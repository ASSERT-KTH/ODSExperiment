{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "For",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "4",
            "dst_parent": "k < 4",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "Literal",
            "operator": "UPD",
            "src": "null",
            "src_parent": "eigenvectors == null",
            "src_parent_type": "BinaryOperator",
            "src_type": "Literal"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "For",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "double",
            "dst_parent": "final double tmp = work[i + k]",
            "dst_parent_type": "LocalVariable",
            "dst_type": "TypeReference",
            "operator": "UPD",
            "src": "int",
            "src_parent": "final int m = eigenvectors.length",
            "src_parent_type": "LocalVariable",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    if (cachedVt == null) {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        final int m = eigenvectors.length;\n        cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n        for (int k = 0; k < m; ++k) {\n            cachedVt.setRowVector(k, eigenvectors[k]);\n        }\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent": "public class EigenDecompositionImpl implements org.apache.commons.math.linear.EigenDecomposition {\n    private static final double TOLERANCE = 100 * org.apache.commons.math.util.MathUtils.EPSILON;\n\n    private static final double TOLERANCE_2 = org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE;\n\n    private double splitTolerance;\n\n    private double[] main;\n\n    private double[] secondary;\n\n    private double[] squaredSecondary;\n\n    private org.apache.commons.math.linear.TriDiagonalTransformer transformer;\n\n    private double lowerSpectra;\n\n    private double upperSpectra;\n\n    private double minPivot;\n\n    private double sigma;\n\n    private double sigmaLow;\n\n    private double tau;\n\n    private double[] work;\n\n    private int pingPong;\n\n    private double qMax;\n\n    private double eMin;\n\n    private int tType;\n\n    private double dMin;\n\n    private double dMin1;\n\n    private double dMin2;\n\n    private double dN;\n\n    private double dN1;\n\n    private double dN2;\n\n    private double g;\n\n    private double[] realEigenvalues;\n\n    private double[] imagEigenvalues;\n\n    private org.apache.commons.math.linear.ArrayRealVector[] eigenvectors;\n\n    private org.apache.commons.math.linear.RealMatrix cachedV;\n\n    private org.apache.commons.math.linear.RealMatrix cachedD;\n\n    private org.apache.commons.math.linear.RealMatrix cachedVt;\n\n    public EigenDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double splitTolerance) throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (isSymmetric(matrix)) {\n            this.splitTolerance = splitTolerance;\n            transformToTridiagonal(matrix);\n            decompose();\n        } else {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\");\n        }\n    }\n\n    public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws org.apache.commons.math.linear.InvalidMatrixException {\n        this.main = main.clone();\n        this.secondary = secondary.clone();\n        transformer = null;\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n        this.splitTolerance = splitTolerance;\n        decompose();\n    }\n\n    private boolean isSymmetric(final org.apache.commons.math.linear.RealMatrix matrix) {\n        final int rows = matrix.getRowDimension();\n        final int columns = matrix.getColumnDimension();\n        final double eps = ((10 * rows) * columns) * org.apache.commons.math.util.MathUtils.EPSILON;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = i + 1; j < columns; ++j) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (java.lang.Math.abs(mij - mji) > (java.lang.Math.max(java.lang.Math.abs(mij), java.lang.Math.abs(mji)) * eps)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private void decompose() {\n        cachedV = null;\n        cachedD = null;\n        cachedVt = null;\n        work = new double[6 * main.length];\n        computeGershgorinCircles();\n        findEigenvalues();\n        eigenvectors = null;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedV == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n        }\n        return cachedV;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedD == null) {\n            cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n        }\n        return cachedD;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedVt == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n        }\n        return cachedVt;\n    }\n\n    public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        return realEigenvalues.clone();\n    }\n\n    public double getRealEigenvalue(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        return realEigenvalues[i];\n    }\n\n    public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        return imagEigenvalues.clone();\n    }\n\n    public double getImagEigenvalue(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        return imagEigenvalues[i];\n    }\n\n    public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        if (cachedVt == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n        }\n        return eigenvectors[i].copy();\n    }\n\n    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }\n\n    public org.apache.commons.math.linear.DecompositionSolver getSolver() {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    }\n\n    private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {\n        private double[] realEigenvalues;\n\n        private double[] imagEigenvalues;\n\n        private final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors;\n\n        private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) {\n            this.realEigenvalues = realEigenvalues;\n            this.imagEigenvalues = imagEigenvalues;\n            this.eigenvectors = eigenvectors;\n        }\n\n        public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.length != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.length, m);\n            }\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n            return bp;\n        }\n\n        public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.getDimension() != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.getDimension(), m);\n            }\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n            return new org.apache.commons.math.linear.ArrayRealVector(bp, false);\n        }\n\n        public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.getRowDimension() != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\", b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n            final int nColB = b.getColumnDimension();\n            final double[][] bp = new double[m][nColB];\n            for (int k = 0; k < nColB; ++k) {\n                for (int i = 0; i < m; ++i) {\n                    final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                    final double[] vData = v.getDataRef();\n                    double s = 0;\n                    for (int j = 0; j < m; ++j) {\n                        s += v.getEntry(j) * b.getEntry(j, k);\n                    }\n                    s /= realEigenvalues[i];\n                    for (int j = 0; j < m; ++j) {\n                        bp[j][k] += s * vData[j];\n                    }\n                }\n            }\n            return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);\n        }\n\n        public boolean isNonSingular() {\n            for (int i = 0; i < realEigenvalues.length; ++i) {\n                if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n            for (int i = 0; i < m; ++i) {\n                final double[] invI = invData[i];\n                for (int j = 0; j < m; ++j) {\n                    double invIJ = 0;\n                    for (int k = 0; k < m; ++k) {\n                        final double[] vK = eigenvectors[k].getDataRef();\n                        invIJ += (vK[i] * vK[j]) / realEigenvalues[k];\n                    }\n                    invI[j] = invIJ;\n                }\n            }\n            return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);\n        }\n    }\n\n    private void transformToTridiagonal(final org.apache.commons.math.linear.RealMatrix matrix) {\n        transformer = new org.apache.commons.math.linear.TriDiagonalTransformer(matrix);\n        main = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n    }\n\n    private void computeGershgorinCircles() {\n        final int m = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = java.lang.Double.POSITIVE_INFINITY;\n        upperSpectra = java.lang.Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n        double eCurrent = 0;\n        for (int i = 0; i < (m - 1); ++i) {\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = java.lang.Math.abs(secondary[i]);\n            eMax = java.lang.Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = java.lang.Math.min(lowerSpectra, lower);\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = java.lang.Math.max(upperSpectra, upper);\n        }\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[(lowerStart + m) - 1] = lower;\n        lowerSpectra = java.lang.Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[(upperStart + m) - 1] = upper;\n        upperSpectra = java.lang.Math.max(upperSpectra, upper);\n        minPivot = org.apache.commons.math.util.MathUtils.SAFE_MIN * java.lang.Math.max(1.0, eMax * eMax);\n    }\n\n    private void findEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        java.util.List<java.lang.Integer> splitIndices = computeSplits();\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n                case 1 :\n                    process1RowBlock(begin);\n                    break;\n                case 2 :\n                    process2RowsBlock(begin);\n                    break;\n                case 3 :\n                    process3RowsBlock(begin);\n                    break;\n                default :\n                    final double[] range = eigenvaluesRange(begin, n);\n                    final double oneFourth = 0.25 * ((3 * range[0]) + range[1]);\n                    final int oneFourthCount = countEigenValues(oneFourth, begin, n);\n                    final double threeFourth = 0.25 * (range[0] + (3 * range[1]));\n                    final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                    final boolean chooseLeft = (oneFourthCount - 1) >= (n - threeFourthCount);\n                    final double lambda = (chooseLeft) ? range[0] : range[1];\n                    tau = (((range[1] - range[0]) * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot);\n                    ldlTDecomposition(lambda, begin, n);\n                    processGeneralBlock(n);\n                    if (chooseLeft) {\n                        for (int i = 0; i < n; ++i) {\n                            realEigenvalues[begin + i] = lambda + work[4 * i];\n                        }\n                    } else {\n                        for (int i = 0; i < n; ++i) {\n                            realEigenvalues[begin + i] = lambda - work[4 * i];\n                        }\n                    }\n            }\n            begin = end;\n        }\n        java.util.Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n    }\n\n    private java.util.List<java.lang.Integer> computeSplits() {\n        final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>();\n        double absDCurrent = java.lang.Math.abs(main[0]);\n        for (int i = 0; i < secondary.length; ++i) {\n            final double absDPrevious = absDCurrent;\n            absDCurrent = java.lang.Math.abs(main[i + 1]);\n            final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent);\n            if (java.lang.Math.abs(secondary[i]) <= max) {\n                list.add(i + 1);\n                secondary[i] = 0;\n                squaredSecondary[i] = 0;\n            }\n        }\n        list.add(secondary.length + 1);\n        return list;\n    }\n\n    private void process1RowBlock(final int index) {\n        realEigenvalues[index] = main[index];\n    }\n\n    private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {\n        final double q0 = main[index];\n        final double q1 = main[index + 1];\n        final double e12 = squaredSecondary[index];\n        final double s = q0 + q1;\n        final double p = (q0 * q1) - e12;\n        final double delta = (s * s) - (4 * p);\n        if (delta < 0) {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"cannot solve degree {0} equation\", 2);\n        }\n        final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta));\n        realEigenvalues[index] = largestRoot;\n        realEigenvalues[index + 1] = p / largestRoot;\n    }\n\n    private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {\n        final double q0 = main[index];\n        final double q1 = main[index + 1];\n        final double q2 = main[index + 2];\n        final double e12 = squaredSecondary[index];\n        final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1];\n        final double b = -((q0 + q1) + q2);\n        final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12;\n        final double d = (q2 * e12) - (q0 * q1q2Me22);\n        final double b2 = b * b;\n        final double q = ((3 * c) - b2) / 9;\n        final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54;\n        final double delta = ((q * q) * q) + (r * r);\n        if (delta >= 0) {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"cannot solve degree {0} equation\", 3);\n        }\n        final double sqrtMq = java.lang.Math.sqrt(-q);\n        final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq));\n        final double alpha = 2 * sqrtMq;\n        final double beta = b / 3;\n        double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta;\n        double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta;\n        double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta;\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        if (z1 < z2) {\n            final double t = z1;\n            z1 = z2;\n            z2 = t;\n        }\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        realEigenvalues[index] = z0;\n        realEigenvalues[index + 1] = z1;\n        realEigenvalues[index + 2] = z2;\n    }\n\n    private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException {\n        double sumOffDiag = 0;\n        for (int i = 0; i < (n - 1); ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n        if (sumOffDiag == 0) {\n            return;\n        }\n        flipIfWarranted(n, 2);\n        initialSplits(n);\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN = 0;\n        dN1 = 0;\n        dN2 = 0;\n        tau = 0;\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n            sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2];\n            sigmaLow = 0;\n            double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6];\n            double offDiagMax = 0;\n            double diagMax = work[(4 * n0) - 4];\n            double diagMin = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + (i / 4);\n                    break;\n                }\n                if (diagMin >= (4 * offDiagMax)) {\n                    diagMin = java.lang.Math.min(diagMin, work[i + 4]);\n                    offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);\n            }\n            work[(4 * n0) - 2] = offDiagMin;\n            dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax)));\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));\n                }\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n                if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) {\n                    int split = i0 - 1;\n                    diagMax = work[4 * i0];\n                    offDiagMin = work[(4 * i0) + 2];\n                    double previousEMin = work[(4 * i0) + 3];\n                    for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {\n                        if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) {\n                            work[i + 2] = -sigma;\n                            split = i / 4;\n                            diagMax = 0;\n                            offDiagMin = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax = java.lang.Math.max(diagMax, work[i + 4]);\n                            offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[(4 * n0) - 2] = offDiagMin;\n                    work[(4 * n0) - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n        } \n    }\n\n    private void initialSplits(final int n) {\n        pingPong = 0;\n        for (int k = 0; k < 2; ++k) {\n            double d = work[(4 * (n - 1)) + pingPong];\n            for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {\n                if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {\n                    work[i + 2] = -0.0;\n                    d = work[i];\n                } else {\n                    d *= work[i] / (d + work[i + 2]);\n                }\n            }\n            d = work[pingPong];\n            for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {\n                final int j = (i - (2 * pingPong)) - 1;\n                work[j] = d + work[i];\n                if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {\n                    work[i] = -0.0;\n                    work[j] = d;\n                    work[j + 2] = 0.0;\n                    d = work[i + 2];\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) {\n                    final double tmp = work[i + 2] / work[j];\n                    work[j + 2] = work[i] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n                    d *= work[i + 2] / work[j];\n                }\n            }\n            work[((4 * n) - 3) - pingPong] = d;\n            pingPong = 1 - pingPong;\n        }\n    }\n\n    private int goodStep(final int start, final int end) {\n        g = 0.0;\n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n            if (start >= deflatedEnd) {\n                return deflatedEnd;\n            }\n            final int k = ((4 * deflatedEnd) + pingPong) - 1;\n            if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) {\n                work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong];\n                deflatedEnd -= 1;\n            } else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) {\n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n                if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));\n                    } else {\n                        s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7] = t;\n                }\n                work[(4 * deflatedEnd) - 8] = sigma + work[k - 7];\n                work[(4 * deflatedEnd) - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n                deflating = false;\n            }\n        }\n        final int l = ((4 * deflatedEnd) + pingPong) - 1;\n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = java.lang.Math.min(dMin2, work[l - 1]);\n                work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong]));\n                qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]));\n                dMin = -0.0;\n            }\n        }\n        if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) {\n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n            for (boolean loop = true; loop;) {\n                dqds(start, deflatedEnd);\n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((((dMin < 0.0) && (dMin1 > 0.0)) && (work[((4 * deflatedEnd) - 5) - pingPong] < (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * (sigma + dN1)))) && (java.lang.Math.abs(dN) < (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * sigma))) {\n                    work[((4 * deflatedEnd) - 3) - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    if (tType < (-22)) {\n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.util.MathUtils.EPSILON));\n                        tType -= 11;\n                    } else {\n                        tau *= 0.25;\n                        tType -= 12;\n                    }\n                } else if (java.lang.Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    loop = false;\n                }\n            }\n        }\n        dqd(start, deflatedEnd);\n        return deflatedEnd;\n    }\n\n    private boolean flipIfWarranted(final int n, final int step) {\n        if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n            tau = 0.0;\n            int j = (4 * n) - 1;\n            for (int i = 0; i < j; i += 4) {\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private double[] eigenvaluesRange(final int index, final int n) {\n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = java.lang.Double.POSITIVE_INFINITY;\n        double upper = java.lang.Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < n; ++i) {\n            lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]);\n            upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);\n        }\n        final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper));\n        final double relativeTolerance = java.lang.Math.sqrt(MathUtils.EPSILON);\n        final double absoluteTolerance = 4 * minPivot;\n        final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0)));\n        final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot));\n        double left = lower - margin;\n        double right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n            final double range = right - left;\n            if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) {\n                break;\n            }\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= 1) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n        }\n        lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left)));\n        left = lower - margin;\n        right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n            final double range = right - left;\n            if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) {\n                break;\n            }\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= n) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n        }\n        upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right)));\n        return new double[]{ lower, upper };\n    }\n\n    private int countEigenValues(final double t, final int index, final int n) {\n        double ratio = main[index] - t;\n        int count = (ratio > 0) ? 0 : 1;\n        for (int i = 1; i < n; ++i) {\n            ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t;\n            if (ratio <= 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n        double di = main[index] - lambda;\n        work[0] = java.lang.Math.abs(di);\n        for (int i = 1; i < n; ++i) {\n            final int fourI = 4 * i;\n            final double eiM1 = secondary[(index + i) - 1];\n            final double ratio = eiM1 / di;\n            work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di);\n            di = (main[index + i] - lambda) - (eiM1 * ratio);\n            work[fourI] = java.lang.Math.abs(di);\n        }\n    }\n\n    private void dqds(final int start, final int end) {\n        eMin = work[((4 * start) + pingPong) + 4];\n        double d = work[(4 * start) + pingPong] - tau;\n        dMin = d;\n        dMin1 = -work[(4 * start) + pingPong];\n        if (pingPong == 0) {\n            for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                final double tmp = work[j4 + 1] / work[j4 - 2];\n                d = (d * tmp) - tau;\n                dMin = java.lang.Math.min(dMin, d);\n                work[j4] = work[j4 - 1] * tmp;\n                eMin = java.lang.Math.min(work[j4], eMin);\n            }\n        } else {\n            for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                final double tmp = work[j4 + 2] / work[j4 - 3];\n                d = (d * tmp) - tau;\n                dMin = java.lang.Math.min(dMin, d);\n                work[j4 - 1] = work[j4] * tmp;\n                eMin = java.lang.Math.min(work[j4 - 1], eMin);\n            }\n        }\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = ((4 * (end - 2)) - pingPong) - 1;\n        int j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau;\n        dMin = java.lang.Math.min(dMin, dN1);\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau;\n        dMin = java.lang.Math.min(dMin, dN);\n        work[j4 + 2] = dN;\n        work[((4 * end) - pingPong) - 1] = eMin;\n    }\n\n    private void dqd(final int start, final int end) {\n        eMin = work[((4 * start) + pingPong) + 4];\n        double d = work[(4 * start) + pingPong];\n        dMin = d;\n        if (pingPong == 0) {\n            for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                if (work[j4 - 2] == 0.0) {\n                    work[j4] = 0.0;\n                    d = work[j4 + 1];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) {\n                    final double tmp = work[j4 + 1] / work[j4 - 2];\n                    work[j4] = work[j4 - 1] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n                    d *= work[j4 + 1] / work[j4 - 2];\n                }\n                dMin = java.lang.Math.min(dMin, d);\n                eMin = java.lang.Math.min(eMin, work[j4]);\n            }\n        } else {\n            for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                if (work[j4 - 3] == 0.0) {\n                    work[j4 - 1] = 0.0;\n                    d = work[j4 + 2];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) {\n                    final double tmp = work[j4 + 2] / work[j4 - 3];\n                    work[j4 - 1] = work[j4] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n                    d *= work[j4 + 2] / work[j4 - 3];\n                }\n                dMin = java.lang.Math.min(dMin, d);\n                eMin = java.lang.Math.min(eMin, work[j4 - 1]);\n            }\n        }\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = ((4 * (end - 2)) - pingPong) - 1;\n        int j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN1 = work[j4p2 + 2];\n            dMin = dN1;\n            eMin = 0.0;\n        } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN1 = dN2 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n        }\n        dMin = java.lang.Math.min(dMin, dN1);\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN = work[j4p2 + 2];\n            dMin = dN;\n        } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN = dN1 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n        }\n        dMin = java.lang.Math.min(dMin, dN);\n        work[j4 + 2] = dN;\n        work[((4 * end) - pingPong) - 1] = eMin;\n    }\n\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.01;\n        final double cnst3 = 1.05;\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n        int nn = ((4 * end) + pingPong) - 1;\n        switch (deflated) {\n            case 0 :\n                if ((dMin == dN) || (dMin == dN1)) {\n                    double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]);\n                    double b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]);\n                    double a2 = work[nn - 7] + work[nn - 5];\n                    if ((dMin == dN) && (dMin1 == dN1)) {\n                        final double gap2 = (dMin2 - a2) - (dMin2 * 0.25);\n                        final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2);\n                        if ((gap1 > 0.0) && (gap1 > b1)) {\n                            tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin);\n                            tType = -2;\n                        } else {\n                            double s = 0.0;\n                            if (dN > b1) {\n                                s = dN - b1;\n                            }\n                            if (a2 > (b1 + b2)) {\n                                s = java.lang.Math.min(s, a2 - (b1 + b2));\n                            }\n                            tau = java.lang.Math.max(s, 0.333 * dMin);\n                            tType = -3;\n                        }\n                    } else {\n                        tType = -4;\n                        double s = 0.25 * dMin;\n                        double gam;\n                        int np;\n                        if (dMin == dN) {\n                            gam = dN;\n                            a2 = 0.0;\n                            if (work[nn - 5] > work[nn - 7]) {\n                                return;\n                            }\n                            b2 = work[nn - 5] / work[nn - 7];\n                            np = nn - 9;\n                        } else {\n                            np = nn - (2 * pingPong);\n                            b2 = work[np - 2];\n                            gam = dN1;\n                            if (work[np - 4] > work[np - 2]) {\n                                return;\n                            }\n                            a2 = work[np - 4] / work[np - 2];\n                            if (work[nn - 9] > work[nn - 11]) {\n                                return;\n                            }\n                            b2 = work[nn - 9] / work[nn - 11];\n                            np = nn - 13;\n                        }\n                        a2 = a2 + b2;\n                        for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (b2 == 0.0) {\n                                break;\n                            }\n                            b1 = b2;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b2 = b2 * (work[i4] / work[i4 - 2]);\n                            a2 = a2 + b2;\n                            if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\n                                break;\n                            }\n                        }\n                        a2 = cnst3 * a2;\n                        if (a2 < cnst1) {\n                            s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);\n                        }\n                        tau = s;\n                    }\n                } else if (dMin == dN2) {\n                    tType = -5;\n                    double s = 0.25 * dMin;\n                    final int np = nn - (2 * pingPong);\n                    double b1 = work[np - 2];\n                    double b2 = work[np - 6];\n                    final double gam = dN2;\n                    if ((work[np - 8] > b2) || (work[np - 4] > b1)) {\n                        return;\n                    }\n                    double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1));\n                    if ((end - start) > 3) {\n                        b2 = work[nn - 13] / work[nn - 15];\n                        a2 = a2 + b2;\n                        for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (b2 == 0.0) {\n                                break;\n                            }\n                            b1 = b2;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b2 = b2 * (work[i4] / work[i4 - 2]);\n                            a2 = a2 + b2;\n                            if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\n                                break;\n                            }\n                        }\n                        a2 = cnst3 * a2;\n                    }\n                    if (a2 < cnst1) {\n                        tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);\n                    } else {\n                        tau = s;\n                    }\n                } else {\n                    if (tType == (-6)) {\n                        g += 0.333 * (1 - g);\n                    } else if (tType == (-18)) {\n                        g = 0.25 * 0.333;\n                    } else {\n                        g = 0.25;\n                    }\n                    tau = g * dMin;\n                    tType = -6;\n                }\n                break;\n            case 1 :\n                if ((dMin1 == dN1) && (dMin2 == dN2)) {\n                    tType = -7;\n                    double s = 0.333 * dMin1;\n                    if (work[nn - 5] > work[nn - 7]) {\n                        return;\n                    }\n                    double b1 = work[nn - 5] / work[nn - 7];\n                    double b2 = b1;\n                    if (b2 != 0.0) {\n                        for (int i4 = ((4 * end) - 10) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            final double oldB1 = b1;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b1 = b1 * (work[i4] / work[i4 - 2]);\n                            b2 = b2 + b1;\n                            if ((100 * java.lang.Math.max(b1, oldB1)) < b2) {\n                                break;\n                            }\n                        }\n                    }\n                    b2 = java.lang.Math.sqrt(cnst3 * b2);\n                    final double a2 = dMin1 / (1 + (b2 * b2));\n                    final double gap2 = (0.5 * dMin2) - a2;\n                    if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\n                        tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));\n                    } else {\n                        tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\n                        tType = -8;\n                    }\n                } else {\n                    tau = 0.25 * dMin1;\n                    if (dMin1 == dN1) {\n                        tau = 0.5 * dMin1;\n                    }\n                    tType = -9;\n                }\n                break;\n            case 2 :\n                if ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) {\n                    tType = -10;\n                    final double s = 0.333 * dMin2;\n                    if (work[nn - 5] > work[nn - 7]) {\n                        return;\n                    }\n                    double b1 = work[nn - 5] / work[nn - 7];\n                    double b2 = b1;\n                    if (b2 != 0.0) {\n                        for (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b1 *= work[i4] / work[i4 - 2];\n                            b2 += b1;\n                            if ((100 * b1) < b2) {\n                                break;\n                            }\n                        }\n                    }\n                    b2 = java.lang.Math.sqrt(cnst3 * b2);\n                    final double a2 = dMin2 / (1 + (b2 * b2));\n                    final double gap2 = ((work[nn - 7] + work[nn - 9]) - (java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2;\n                    if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\n                        tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));\n                    } else {\n                        tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\n                    }\n                } else {\n                    tau = 0.25 * dMin2;\n                    tType = -11;\n                }\n                break;\n            default :\n                tau = 0.0;\n                tType = -12;\n        }\n    }\n\n    private void updateSigma(final double shift) {\n        if (shift < sigma) {\n            sigmaLow += shift;\n            final double t = sigma + sigmaLow;\n            sigmaLow -= t - sigma;\n            sigma = t;\n        } else {\n            final double t = sigma + shift;\n            sigmaLow += sigma - (t - shift);\n            sigma = t;\n        }\n    }\n\n    private void findEigenVectors() {\n        final int m = main.length;\n        eigenvectors = new org.apache.commons.math.linear.ArrayRealVector[m];\n        final double[] d = new double[m];\n        final double[] l = new double[m - 1];\n        final double mu = ((realEigenvalues[m - 1] <= 0) && (realEigenvalues[0] > 0)) ? 0.5 - realEigenvalues[m - 1] : 0;\n        double di = main[0] + mu;\n        d[0] = di;\n        for (int i = 1; i < m; ++i) {\n            final double eiM1 = secondary[i - 1];\n            final double ratio = eiM1 / di;\n            di = (main[i] - (eiM1 * ratio)) + mu;\n            l[i - 1] = ratio;\n            d[i] = di;\n        }\n        for (int i = 0; i < m; ++i) {\n            eigenvectors[i] = findEigenvector(realEigenvalues[i] + mu, d, l);\n        }\n    }\n\n    private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {\n        final int m = main.length;\n        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n        int r = m - 1;\n        double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue);\n        int sixI = 0;\n        for (int i = 0; i < (m - 1); ++i) {\n            final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10]));\n            if (absG < minG) {\n                r = i;\n                minG = absG;\n            }\n            sixI += 6;\n        }\n        double[] eigenvector = new double[m];\n        double n2 = 1;\n        eigenvector[r] = 1;\n        double z = 1;\n        for (int i = r - 1; i >= 0; --i) {\n            z *= -work[(6 * i) + 2];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        z = 1;\n        for (int i = r + 1; i < m; ++i) {\n            z *= -work[(6 * i) - 1];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        final double inv = 1.0 / java.lang.Math.sqrt(n2);\n        for (int i = 0; i < m; ++i) {\n            eigenvector[i] *= inv;\n        }\n        return transformer == null ? new org.apache.commons.math.linear.ArrayRealVector(eigenvector, false) : new org.apache.commons.math.linear.ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n    }\n\n    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double si = -lambda;\n        int sixI = 0;\n        for (int i = 0; i < nM1; ++i) {\n            final double di = d[i];\n            final double li = l[i];\n            final double diP1 = di + si;\n            final double liP1 = (li * di) / diP1;\n            work[sixI] = si;\n            work[sixI + 1] = diP1;\n            work[sixI + 2] = liP1;\n            si = ((li * liP1) * si) - lambda;\n            sixI += 6;\n        }\n        work[(6 * nM1) + 1] = d[nM1] + si;\n        work[6 * nM1] = si;\n    }\n\n    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double pi = d[nM1] - lambda;\n        int sixI = 6 * (nM1 - 1);\n        for (int i = nM1 - 1; i >= 0; --i) {\n            final double di = d[i];\n            final double li = l[i];\n            final double diP1 = ((di * li) * li) + pi;\n            final double t = di / diP1;\n            work[sixI + 9] = pi;\n            work[sixI + 10] = diP1;\n            work[sixI + 5] = li * t;\n            pi = (pi * t) - lambda;\n            sixI -= 6;\n        }\n        work[3] = pi;\n        work[4] = pi;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "cachedVt == null",
            "src_parent": "if (cachedVt == null) {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    final int m = eigenvectors.length;\n    cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n    for (int k = 0; k < m; ++k) {\n        cachedVt.setRowVector(k, eigenvectors[k]);\n    }\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "if (eigenvectors == null) {\n    findEigenVectors();\n}",
            "src_parent": "{\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    final int m = eigenvectors.length;\n    cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n    for (int k = 0; k < m; ++k) {\n        cachedVt.setRowVector(k, eigenvectors[k]);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "final int m = eigenvectors.length",
            "src_parent": "{\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    final int m = eigenvectors.length;\n    cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n    for (int k = 0; k < m; ++k) {\n        cachedVt.setRowVector(k, eigenvectors[k]);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m)",
            "src_parent": "{\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    final int m = eigenvectors.length;\n    cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n    for (int k = 0; k < m; ++k) {\n        cachedVt.setRowVector(k, eigenvectors[k]);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "for (int k = 0; k < m; ++k) {\n    cachedVt.setRowVector(k, eigenvectors[k]);\n}",
            "src_parent": "{\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    final int m = eigenvectors.length;\n    cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n    for (int k = 0; k < m; ++k) {\n        cachedVt.setRowVector(k, eigenvectors[k]);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "For"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "private boolean flipIfWarranted(final int n, final int step) {\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        tau = 0.0;\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "src_parent": "public class EigenDecompositionImpl implements org.apache.commons.math.linear.EigenDecomposition {\n    private static final double TOLERANCE = 100 * org.apache.commons.math.util.MathUtils.EPSILON;\n\n    private static final double TOLERANCE_2 = org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE;\n\n    private double splitTolerance;\n\n    private double[] main;\n\n    private double[] secondary;\n\n    private double[] squaredSecondary;\n\n    private org.apache.commons.math.linear.TriDiagonalTransformer transformer;\n\n    private double lowerSpectra;\n\n    private double upperSpectra;\n\n    private double minPivot;\n\n    private double sigma;\n\n    private double sigmaLow;\n\n    private double tau;\n\n    private double[] work;\n\n    private int pingPong;\n\n    private double qMax;\n\n    private double eMin;\n\n    private int tType;\n\n    private double dMin;\n\n    private double dMin1;\n\n    private double dMin2;\n\n    private double dN;\n\n    private double dN1;\n\n    private double dN2;\n\n    private double g;\n\n    private double[] realEigenvalues;\n\n    private double[] imagEigenvalues;\n\n    private org.apache.commons.math.linear.ArrayRealVector[] eigenvectors;\n\n    private org.apache.commons.math.linear.RealMatrix cachedV;\n\n    private org.apache.commons.math.linear.RealMatrix cachedD;\n\n    private org.apache.commons.math.linear.RealMatrix cachedVt;\n\n    public EigenDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double splitTolerance) throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (isSymmetric(matrix)) {\n            this.splitTolerance = splitTolerance;\n            transformToTridiagonal(matrix);\n            decompose();\n        } else {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\");\n        }\n    }\n\n    public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws org.apache.commons.math.linear.InvalidMatrixException {\n        this.main = main.clone();\n        this.secondary = secondary.clone();\n        transformer = null;\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n        this.splitTolerance = splitTolerance;\n        decompose();\n    }\n\n    private boolean isSymmetric(final org.apache.commons.math.linear.RealMatrix matrix) {\n        final int rows = matrix.getRowDimension();\n        final int columns = matrix.getColumnDimension();\n        final double eps = ((10 * rows) * columns) * org.apache.commons.math.util.MathUtils.EPSILON;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = i + 1; j < columns; ++j) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (java.lang.Math.abs(mij - mji) > (java.lang.Math.max(java.lang.Math.abs(mij), java.lang.Math.abs(mji)) * eps)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private void decompose() {\n        cachedV = null;\n        cachedD = null;\n        cachedVt = null;\n        work = new double[6 * main.length];\n        computeGershgorinCircles();\n        findEigenvalues();\n        eigenvectors = null;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedV == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n        }\n        return cachedV;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedD == null) {\n            cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n        }\n        return cachedD;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedVt == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n        }\n        return cachedVt;\n    }\n\n    public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        return realEigenvalues.clone();\n    }\n\n    public double getRealEigenvalue(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        return realEigenvalues[i];\n    }\n\n    public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        return imagEigenvalues.clone();\n    }\n\n    public double getImagEigenvalue(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        return imagEigenvalues[i];\n    }\n\n    public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        if (cachedVt == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n        }\n        return eigenvectors[i].copy();\n    }\n\n    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }\n\n    public org.apache.commons.math.linear.DecompositionSolver getSolver() {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    }\n\n    private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {\n        private double[] realEigenvalues;\n\n        private double[] imagEigenvalues;\n\n        private final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors;\n\n        private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) {\n            this.realEigenvalues = realEigenvalues;\n            this.imagEigenvalues = imagEigenvalues;\n            this.eigenvectors = eigenvectors;\n        }\n\n        public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.length != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.length, m);\n            }\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n            return bp;\n        }\n\n        public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.getDimension() != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.getDimension(), m);\n            }\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n            return new org.apache.commons.math.linear.ArrayRealVector(bp, false);\n        }\n\n        public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.getRowDimension() != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\", b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n            final int nColB = b.getColumnDimension();\n            final double[][] bp = new double[m][nColB];\n            for (int k = 0; k < nColB; ++k) {\n                for (int i = 0; i < m; ++i) {\n                    final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                    final double[] vData = v.getDataRef();\n                    double s = 0;\n                    for (int j = 0; j < m; ++j) {\n                        s += v.getEntry(j) * b.getEntry(j, k);\n                    }\n                    s /= realEigenvalues[i];\n                    for (int j = 0; j < m; ++j) {\n                        bp[j][k] += s * vData[j];\n                    }\n                }\n            }\n            return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);\n        }\n\n        public boolean isNonSingular() {\n            for (int i = 0; i < realEigenvalues.length; ++i) {\n                if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n            for (int i = 0; i < m; ++i) {\n                final double[] invI = invData[i];\n                for (int j = 0; j < m; ++j) {\n                    double invIJ = 0;\n                    for (int k = 0; k < m; ++k) {\n                        final double[] vK = eigenvectors[k].getDataRef();\n                        invIJ += (vK[i] * vK[j]) / realEigenvalues[k];\n                    }\n                    invI[j] = invIJ;\n                }\n            }\n            return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);\n        }\n    }\n\n    private void transformToTridiagonal(final org.apache.commons.math.linear.RealMatrix matrix) {\n        transformer = new org.apache.commons.math.linear.TriDiagonalTransformer(matrix);\n        main = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n    }\n\n    private void computeGershgorinCircles() {\n        final int m = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = java.lang.Double.POSITIVE_INFINITY;\n        upperSpectra = java.lang.Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n        double eCurrent = 0;\n        for (int i = 0; i < (m - 1); ++i) {\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = java.lang.Math.abs(secondary[i]);\n            eMax = java.lang.Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = java.lang.Math.min(lowerSpectra, lower);\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = java.lang.Math.max(upperSpectra, upper);\n        }\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[(lowerStart + m) - 1] = lower;\n        lowerSpectra = java.lang.Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[(upperStart + m) - 1] = upper;\n        upperSpectra = java.lang.Math.max(upperSpectra, upper);\n        minPivot = org.apache.commons.math.util.MathUtils.SAFE_MIN * java.lang.Math.max(1.0, eMax * eMax);\n    }\n\n    private void findEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        java.util.List<java.lang.Integer> splitIndices = computeSplits();\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n                case 1 :\n                    process1RowBlock(begin);\n                    break;\n                case 2 :\n                    process2RowsBlock(begin);\n                    break;\n                case 3 :\n                    process3RowsBlock(begin);\n                    break;\n                default :\n                    final double[] range = eigenvaluesRange(begin, n);\n                    final double oneFourth = 0.25 * ((3 * range[0]) + range[1]);\n                    final int oneFourthCount = countEigenValues(oneFourth, begin, n);\n                    final double threeFourth = 0.25 * (range[0] + (3 * range[1]));\n                    final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                    final boolean chooseLeft = (oneFourthCount - 1) >= (n - threeFourthCount);\n                    final double lambda = (chooseLeft) ? range[0] : range[1];\n                    tau = (((range[1] - range[0]) * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot);\n                    ldlTDecomposition(lambda, begin, n);\n                    processGeneralBlock(n);\n                    if (chooseLeft) {\n                        for (int i = 0; i < n; ++i) {\n                            realEigenvalues[begin + i] = lambda + work[4 * i];\n                        }\n                    } else {\n                        for (int i = 0; i < n; ++i) {\n                            realEigenvalues[begin + i] = lambda - work[4 * i];\n                        }\n                    }\n            }\n            begin = end;\n        }\n        java.util.Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n    }\n\n    private java.util.List<java.lang.Integer> computeSplits() {\n        final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>();\n        double absDCurrent = java.lang.Math.abs(main[0]);\n        for (int i = 0; i < secondary.length; ++i) {\n            final double absDPrevious = absDCurrent;\n            absDCurrent = java.lang.Math.abs(main[i + 1]);\n            final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent);\n            if (java.lang.Math.abs(secondary[i]) <= max) {\n                list.add(i + 1);\n                secondary[i] = 0;\n                squaredSecondary[i] = 0;\n            }\n        }\n        list.add(secondary.length + 1);\n        return list;\n    }\n\n    private void process1RowBlock(final int index) {\n        realEigenvalues[index] = main[index];\n    }\n\n    private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {\n        final double q0 = main[index];\n        final double q1 = main[index + 1];\n        final double e12 = squaredSecondary[index];\n        final double s = q0 + q1;\n        final double p = (q0 * q1) - e12;\n        final double delta = (s * s) - (4 * p);\n        if (delta < 0) {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"cannot solve degree {0} equation\", 2);\n        }\n        final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta));\n        realEigenvalues[index] = largestRoot;\n        realEigenvalues[index + 1] = p / largestRoot;\n    }\n\n    private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {\n        final double q0 = main[index];\n        final double q1 = main[index + 1];\n        final double q2 = main[index + 2];\n        final double e12 = squaredSecondary[index];\n        final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1];\n        final double b = -((q0 + q1) + q2);\n        final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12;\n        final double d = (q2 * e12) - (q0 * q1q2Me22);\n        final double b2 = b * b;\n        final double q = ((3 * c) - b2) / 9;\n        final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54;\n        final double delta = ((q * q) * q) + (r * r);\n        if (delta >= 0) {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"cannot solve degree {0} equation\", 3);\n        }\n        final double sqrtMq = java.lang.Math.sqrt(-q);\n        final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq));\n        final double alpha = 2 * sqrtMq;\n        final double beta = b / 3;\n        double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta;\n        double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta;\n        double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta;\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        if (z1 < z2) {\n            final double t = z1;\n            z1 = z2;\n            z2 = t;\n        }\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        realEigenvalues[index] = z0;\n        realEigenvalues[index + 1] = z1;\n        realEigenvalues[index + 2] = z2;\n    }\n\n    private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException {\n        double sumOffDiag = 0;\n        for (int i = 0; i < (n - 1); ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n        if (sumOffDiag == 0) {\n            return;\n        }\n        flipIfWarranted(n, 2);\n        initialSplits(n);\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN = 0;\n        dN1 = 0;\n        dN2 = 0;\n        tau = 0;\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n            sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2];\n            sigmaLow = 0;\n            double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6];\n            double offDiagMax = 0;\n            double diagMax = work[(4 * n0) - 4];\n            double diagMin = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + (i / 4);\n                    break;\n                }\n                if (diagMin >= (4 * offDiagMax)) {\n                    diagMin = java.lang.Math.min(diagMin, work[i + 4]);\n                    offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);\n            }\n            work[(4 * n0) - 2] = offDiagMin;\n            dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax)));\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));\n                }\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n                if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) {\n                    int split = i0 - 1;\n                    diagMax = work[4 * i0];\n                    offDiagMin = work[(4 * i0) + 2];\n                    double previousEMin = work[(4 * i0) + 3];\n                    for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {\n                        if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) {\n                            work[i + 2] = -sigma;\n                            split = i / 4;\n                            diagMax = 0;\n                            offDiagMin = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax = java.lang.Math.max(diagMax, work[i + 4]);\n                            offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[(4 * n0) - 2] = offDiagMin;\n                    work[(4 * n0) - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n        } \n    }\n\n    private void initialSplits(final int n) {\n        pingPong = 0;\n        for (int k = 0; k < 2; ++k) {\n            double d = work[(4 * (n - 1)) + pingPong];\n            for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {\n                if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {\n                    work[i + 2] = -0.0;\n                    d = work[i];\n                } else {\n                    d *= work[i] / (d + work[i + 2]);\n                }\n            }\n            d = work[pingPong];\n            for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {\n                final int j = (i - (2 * pingPong)) - 1;\n                work[j] = d + work[i];\n                if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {\n                    work[i] = -0.0;\n                    work[j] = d;\n                    work[j + 2] = 0.0;\n                    d = work[i + 2];\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) {\n                    final double tmp = work[i + 2] / work[j];\n                    work[j + 2] = work[i] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n                    d *= work[i + 2] / work[j];\n                }\n            }\n            work[((4 * n) - 3) - pingPong] = d;\n            pingPong = 1 - pingPong;\n        }\n    }\n\n    private int goodStep(final int start, final int end) {\n        g = 0.0;\n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n            if (start >= deflatedEnd) {\n                return deflatedEnd;\n            }\n            final int k = ((4 * deflatedEnd) + pingPong) - 1;\n            if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) {\n                work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong];\n                deflatedEnd -= 1;\n            } else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) {\n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n                if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));\n                    } else {\n                        s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7] = t;\n                }\n                work[(4 * deflatedEnd) - 8] = sigma + work[k - 7];\n                work[(4 * deflatedEnd) - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n                deflating = false;\n            }\n        }\n        final int l = ((4 * deflatedEnd) + pingPong) - 1;\n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = java.lang.Math.min(dMin2, work[l - 1]);\n                work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong]));\n                qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]));\n                dMin = -0.0;\n            }\n        }\n        if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) {\n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n            for (boolean loop = true; loop;) {\n                dqds(start, deflatedEnd);\n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((((dMin < 0.0) && (dMin1 > 0.0)) && (work[((4 * deflatedEnd) - 5) - pingPong] < (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * (sigma + dN1)))) && (java.lang.Math.abs(dN) < (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * sigma))) {\n                    work[((4 * deflatedEnd) - 3) - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    if (tType < (-22)) {\n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.util.MathUtils.EPSILON));\n                        tType -= 11;\n                    } else {\n                        tau *= 0.25;\n                        tType -= 12;\n                    }\n                } else if (java.lang.Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    loop = false;\n                }\n            }\n        }\n        dqd(start, deflatedEnd);\n        return deflatedEnd;\n    }\n\n    private boolean flipIfWarranted(final int n, final int step) {\n        if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n            tau = 0.0;\n            int j = (4 * n) - 1;\n            for (int i = 0; i < j; i += 4) {\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private double[] eigenvaluesRange(final int index, final int n) {\n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = java.lang.Double.POSITIVE_INFINITY;\n        double upper = java.lang.Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < n; ++i) {\n            lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]);\n            upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);\n        }\n        final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper));\n        final double relativeTolerance = java.lang.Math.sqrt(MathUtils.EPSILON);\n        final double absoluteTolerance = 4 * minPivot;\n        final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0)));\n        final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot));\n        double left = lower - margin;\n        double right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n            final double range = right - left;\n            if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) {\n                break;\n            }\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= 1) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n        }\n        lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left)));\n        left = lower - margin;\n        right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n            final double range = right - left;\n            if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) {\n                break;\n            }\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= n) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n        }\n        upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right)));\n        return new double[]{ lower, upper };\n    }\n\n    private int countEigenValues(final double t, final int index, final int n) {\n        double ratio = main[index] - t;\n        int count = (ratio > 0) ? 0 : 1;\n        for (int i = 1; i < n; ++i) {\n            ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t;\n            if (ratio <= 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n        double di = main[index] - lambda;\n        work[0] = java.lang.Math.abs(di);\n        for (int i = 1; i < n; ++i) {\n            final int fourI = 4 * i;\n            final double eiM1 = secondary[(index + i) - 1];\n            final double ratio = eiM1 / di;\n            work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di);\n            di = (main[index + i] - lambda) - (eiM1 * ratio);\n            work[fourI] = java.lang.Math.abs(di);\n        }\n    }\n\n    private void dqds(final int start, final int end) {\n        eMin = work[((4 * start) + pingPong) + 4];\n        double d = work[(4 * start) + pingPong] - tau;\n        dMin = d;\n        dMin1 = -work[(4 * start) + pingPong];\n        if (pingPong == 0) {\n            for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                final double tmp = work[j4 + 1] / work[j4 - 2];\n                d = (d * tmp) - tau;\n                dMin = java.lang.Math.min(dMin, d);\n                work[j4] = work[j4 - 1] * tmp;\n                eMin = java.lang.Math.min(work[j4], eMin);\n            }\n        } else {\n            for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                final double tmp = work[j4 + 2] / work[j4 - 3];\n                d = (d * tmp) - tau;\n                dMin = java.lang.Math.min(dMin, d);\n                work[j4 - 1] = work[j4] * tmp;\n                eMin = java.lang.Math.min(work[j4 - 1], eMin);\n            }\n        }\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = ((4 * (end - 2)) - pingPong) - 1;\n        int j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau;\n        dMin = java.lang.Math.min(dMin, dN1);\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau;\n        dMin = java.lang.Math.min(dMin, dN);\n        work[j4 + 2] = dN;\n        work[((4 * end) - pingPong) - 1] = eMin;\n    }\n\n    private void dqd(final int start, final int end) {\n        eMin = work[((4 * start) + pingPong) + 4];\n        double d = work[(4 * start) + pingPong];\n        dMin = d;\n        if (pingPong == 0) {\n            for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                if (work[j4 - 2] == 0.0) {\n                    work[j4] = 0.0;\n                    d = work[j4 + 1];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) {\n                    final double tmp = work[j4 + 1] / work[j4 - 2];\n                    work[j4] = work[j4 - 1] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n                    d *= work[j4 + 1] / work[j4 - 2];\n                }\n                dMin = java.lang.Math.min(dMin, d);\n                eMin = java.lang.Math.min(eMin, work[j4]);\n            }\n        } else {\n            for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                if (work[j4 - 3] == 0.0) {\n                    work[j4 - 1] = 0.0;\n                    d = work[j4 + 2];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) {\n                    final double tmp = work[j4 + 2] / work[j4 - 3];\n                    work[j4 - 1] = work[j4] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n                    d *= work[j4 + 2] / work[j4 - 3];\n                }\n                dMin = java.lang.Math.min(dMin, d);\n                eMin = java.lang.Math.min(eMin, work[j4 - 1]);\n            }\n        }\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = ((4 * (end - 2)) - pingPong) - 1;\n        int j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN1 = work[j4p2 + 2];\n            dMin = dN1;\n            eMin = 0.0;\n        } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN1 = dN2 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n        }\n        dMin = java.lang.Math.min(dMin, dN1);\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN = work[j4p2 + 2];\n            dMin = dN;\n        } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN = dN1 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n        }\n        dMin = java.lang.Math.min(dMin, dN);\n        work[j4 + 2] = dN;\n        work[((4 * end) - pingPong) - 1] = eMin;\n    }\n\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.01;\n        final double cnst3 = 1.05;\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n        int nn = ((4 * end) + pingPong) - 1;\n        switch (deflated) {\n            case 0 :\n                if ((dMin == dN) || (dMin == dN1)) {\n                    double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]);\n                    double b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]);\n                    double a2 = work[nn - 7] + work[nn - 5];\n                    if ((dMin == dN) && (dMin1 == dN1)) {\n                        final double gap2 = (dMin2 - a2) - (dMin2 * 0.25);\n                        final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2);\n                        if ((gap1 > 0.0) && (gap1 > b1)) {\n                            tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin);\n                            tType = -2;\n                        } else {\n                            double s = 0.0;\n                            if (dN > b1) {\n                                s = dN - b1;\n                            }\n                            if (a2 > (b1 + b2)) {\n                                s = java.lang.Math.min(s, a2 - (b1 + b2));\n                            }\n                            tau = java.lang.Math.max(s, 0.333 * dMin);\n                            tType = -3;\n                        }\n                    } else {\n                        tType = -4;\n                        double s = 0.25 * dMin;\n                        double gam;\n                        int np;\n                        if (dMin == dN) {\n                            gam = dN;\n                            a2 = 0.0;\n                            if (work[nn - 5] > work[nn - 7]) {\n                                return;\n                            }\n                            b2 = work[nn - 5] / work[nn - 7];\n                            np = nn - 9;\n                        } else {\n                            np = nn - (2 * pingPong);\n                            b2 = work[np - 2];\n                            gam = dN1;\n                            if (work[np - 4] > work[np - 2]) {\n                                return;\n                            }\n                            a2 = work[np - 4] / work[np - 2];\n                            if (work[nn - 9] > work[nn - 11]) {\n                                return;\n                            }\n                            b2 = work[nn - 9] / work[nn - 11];\n                            np = nn - 13;\n                        }\n                        a2 = a2 + b2;\n                        for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (b2 == 0.0) {\n                                break;\n                            }\n                            b1 = b2;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b2 = b2 * (work[i4] / work[i4 - 2]);\n                            a2 = a2 + b2;\n                            if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\n                                break;\n                            }\n                        }\n                        a2 = cnst3 * a2;\n                        if (a2 < cnst1) {\n                            s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);\n                        }\n                        tau = s;\n                    }\n                } else if (dMin == dN2) {\n                    tType = -5;\n                    double s = 0.25 * dMin;\n                    final int np = nn - (2 * pingPong);\n                    double b1 = work[np - 2];\n                    double b2 = work[np - 6];\n                    final double gam = dN2;\n                    if ((work[np - 8] > b2) || (work[np - 4] > b1)) {\n                        return;\n                    }\n                    double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1));\n                    if ((end - start) > 3) {\n                        b2 = work[nn - 13] / work[nn - 15];\n                        a2 = a2 + b2;\n                        for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (b2 == 0.0) {\n                                break;\n                            }\n                            b1 = b2;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b2 = b2 * (work[i4] / work[i4 - 2]);\n                            a2 = a2 + b2;\n                            if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\n                                break;\n                            }\n                        }\n                        a2 = cnst3 * a2;\n                    }\n                    if (a2 < cnst1) {\n                        tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);\n                    } else {\n                        tau = s;\n                    }\n                } else {\n                    if (tType == (-6)) {\n                        g += 0.333 * (1 - g);\n                    } else if (tType == (-18)) {\n                        g = 0.25 * 0.333;\n                    } else {\n                        g = 0.25;\n                    }\n                    tau = g * dMin;\n                    tType = -6;\n                }\n                break;\n            case 1 :\n                if ((dMin1 == dN1) && (dMin2 == dN2)) {\n                    tType = -7;\n                    double s = 0.333 * dMin1;\n                    if (work[nn - 5] > work[nn - 7]) {\n                        return;\n                    }\n                    double b1 = work[nn - 5] / work[nn - 7];\n                    double b2 = b1;\n                    if (b2 != 0.0) {\n                        for (int i4 = ((4 * end) - 10) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            final double oldB1 = b1;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b1 = b1 * (work[i4] / work[i4 - 2]);\n                            b2 = b2 + b1;\n                            if ((100 * java.lang.Math.max(b1, oldB1)) < b2) {\n                                break;\n                            }\n                        }\n                    }\n                    b2 = java.lang.Math.sqrt(cnst3 * b2);\n                    final double a2 = dMin1 / (1 + (b2 * b2));\n                    final double gap2 = (0.5 * dMin2) - a2;\n                    if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\n                        tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));\n                    } else {\n                        tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\n                        tType = -8;\n                    }\n                } else {\n                    tau = 0.25 * dMin1;\n                    if (dMin1 == dN1) {\n                        tau = 0.5 * dMin1;\n                    }\n                    tType = -9;\n                }\n                break;\n            case 2 :\n                if ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) {\n                    tType = -10;\n                    final double s = 0.333 * dMin2;\n                    if (work[nn - 5] > work[nn - 7]) {\n                        return;\n                    }\n                    double b1 = work[nn - 5] / work[nn - 7];\n                    double b2 = b1;\n                    if (b2 != 0.0) {\n                        for (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b1 *= work[i4] / work[i4 - 2];\n                            b2 += b1;\n                            if ((100 * b1) < b2) {\n                                break;\n                            }\n                        }\n                    }\n                    b2 = java.lang.Math.sqrt(cnst3 * b2);\n                    final double a2 = dMin2 / (1 + (b2 * b2));\n                    final double gap2 = ((work[nn - 7] + work[nn - 9]) - (java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2;\n                    if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\n                        tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));\n                    } else {\n                        tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\n                    }\n                } else {\n                    tau = 0.25 * dMin2;\n                    tType = -11;\n                }\n                break;\n            default :\n                tau = 0.0;\n                tType = -12;\n        }\n    }\n\n    private void updateSigma(final double shift) {\n        if (shift < sigma) {\n            sigmaLow += shift;\n            final double t = sigma + sigmaLow;\n            sigmaLow -= t - sigma;\n            sigma = t;\n        } else {\n            final double t = sigma + shift;\n            sigmaLow += sigma - (t - shift);\n            sigma = t;\n        }\n    }\n\n    private void findEigenVectors() {\n        final int m = main.length;\n        eigenvectors = new org.apache.commons.math.linear.ArrayRealVector[m];\n        final double[] d = new double[m];\n        final double[] l = new double[m - 1];\n        final double mu = ((realEigenvalues[m - 1] <= 0) && (realEigenvalues[0] > 0)) ? 0.5 - realEigenvalues[m - 1] : 0;\n        double di = main[0] + mu;\n        d[0] = di;\n        for (int i = 1; i < m; ++i) {\n            final double eiM1 = secondary[i - 1];\n            final double ratio = eiM1 / di;\n            di = (main[i] - (eiM1 * ratio)) + mu;\n            l[i - 1] = ratio;\n            d[i] = di;\n        }\n        for (int i = 0; i < m; ++i) {\n            eigenvectors[i] = findEigenvector(realEigenvalues[i] + mu, d, l);\n        }\n    }\n\n    private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {\n        final int m = main.length;\n        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n        int r = m - 1;\n        double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue);\n        int sixI = 0;\n        for (int i = 0; i < (m - 1); ++i) {\n            final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10]));\n            if (absG < minG) {\n                r = i;\n                minG = absG;\n            }\n            sixI += 6;\n        }\n        double[] eigenvector = new double[m];\n        double n2 = 1;\n        eigenvector[r] = 1;\n        double z = 1;\n        for (int i = r - 1; i >= 0; --i) {\n            z *= -work[(6 * i) + 2];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        z = 1;\n        for (int i = r + 1; i < m; ++i) {\n            z *= -work[(6 * i) - 1];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        final double inv = 1.0 / java.lang.Math.sqrt(n2);\n        for (int i = 0; i < m; ++i) {\n            eigenvector[i] *= inv;\n        }\n        return transformer == null ? new org.apache.commons.math.linear.ArrayRealVector(eigenvector, false) : new org.apache.commons.math.linear.ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n    }\n\n    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double si = -lambda;\n        int sixI = 0;\n        for (int i = 0; i < nM1; ++i) {\n            final double di = d[i];\n            final double li = l[i];\n            final double diP1 = di + si;\n            final double liP1 = (li * di) / diP1;\n            work[sixI] = si;\n            work[sixI + 1] = diP1;\n            work[sixI + 2] = liP1;\n            si = ((li * liP1) * si) - lambda;\n            sixI += 6;\n        }\n        work[(6 * nM1) + 1] = d[nM1] + si;\n        work[6 * nM1] = si;\n    }\n\n    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double pi = d[nM1] - lambda;\n        int sixI = 6 * (nM1 - 1);\n        for (int i = nM1 - 1; i >= 0; --i) {\n            final double di = d[i];\n            final double li = l[i];\n            final double diP1 = ((di * li) * li) + pi;\n            final double t = di / diP1;\n            work[sixI + 9] = pi;\n            work[sixI + 10] = diP1;\n            work[sixI + 5] = li * t;\n            pi = (pi * t) - lambda;\n            sixI -= 6;\n        }\n        work[3] = pi;\n        work[4] = pi;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent": "public class EigenDecompositionImpl implements org.apache.commons.math.linear.EigenDecomposition {\n    private static final double TOLERANCE = 100 * org.apache.commons.math.util.MathUtils.EPSILON;\n\n    private static final double TOLERANCE_2 = org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE;\n\n    private double splitTolerance;\n\n    private double[] main;\n\n    private double[] secondary;\n\n    private double[] squaredSecondary;\n\n    private org.apache.commons.math.linear.TriDiagonalTransformer transformer;\n\n    private double lowerSpectra;\n\n    private double upperSpectra;\n\n    private double minPivot;\n\n    private double sigma;\n\n    private double sigmaLow;\n\n    private double tau;\n\n    private double[] work;\n\n    private int pingPong;\n\n    private double qMax;\n\n    private double eMin;\n\n    private int tType;\n\n    private double dMin;\n\n    private double dMin1;\n\n    private double dMin2;\n\n    private double dN;\n\n    private double dN1;\n\n    private double dN2;\n\n    private double g;\n\n    private double[] realEigenvalues;\n\n    private double[] imagEigenvalues;\n\n    private org.apache.commons.math.linear.ArrayRealVector[] eigenvectors;\n\n    private org.apache.commons.math.linear.RealMatrix cachedV;\n\n    private org.apache.commons.math.linear.RealMatrix cachedD;\n\n    private org.apache.commons.math.linear.RealMatrix cachedVt;\n\n    public EigenDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double splitTolerance) throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (isSymmetric(matrix)) {\n            this.splitTolerance = splitTolerance;\n            transformToTridiagonal(matrix);\n            decompose();\n        } else {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\");\n        }\n    }\n\n    public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws org.apache.commons.math.linear.InvalidMatrixException {\n        this.main = main.clone();\n        this.secondary = secondary.clone();\n        transformer = null;\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n        this.splitTolerance = splitTolerance;\n        decompose();\n    }\n\n    private boolean isSymmetric(final org.apache.commons.math.linear.RealMatrix matrix) {\n        final int rows = matrix.getRowDimension();\n        final int columns = matrix.getColumnDimension();\n        final double eps = ((10 * rows) * columns) * org.apache.commons.math.util.MathUtils.EPSILON;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = i + 1; j < columns; ++j) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (java.lang.Math.abs(mij - mji) > (java.lang.Math.max(java.lang.Math.abs(mij), java.lang.Math.abs(mji)) * eps)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private void decompose() {\n        cachedV = null;\n        cachedD = null;\n        cachedVt = null;\n        work = new double[6 * main.length];\n        computeGershgorinCircles();\n        findEigenvalues();\n        eigenvectors = null;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedV == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n        }\n        return cachedV;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedD == null) {\n            cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n        }\n        return cachedD;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedVt == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n        }\n        return cachedVt;\n    }\n\n    public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        return realEigenvalues.clone();\n    }\n\n    public double getRealEigenvalue(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        return realEigenvalues[i];\n    }\n\n    public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        return imagEigenvalues.clone();\n    }\n\n    public double getImagEigenvalue(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        return imagEigenvalues[i];\n    }\n\n    public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return eigenvectors[i].copy();\n    }\n\n    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }\n\n    public org.apache.commons.math.linear.DecompositionSolver getSolver() {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    }\n\n    private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {\n        private double[] realEigenvalues;\n\n        private double[] imagEigenvalues;\n\n        private final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors;\n\n        private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) {\n            this.realEigenvalues = realEigenvalues;\n            this.imagEigenvalues = imagEigenvalues;\n            this.eigenvectors = eigenvectors;\n        }\n\n        public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.length != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.length, m);\n            }\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n            return bp;\n        }\n\n        public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.getDimension() != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.getDimension(), m);\n            }\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n            return new org.apache.commons.math.linear.ArrayRealVector(bp, false);\n        }\n\n        public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.getRowDimension() != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\", b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n            final int nColB = b.getColumnDimension();\n            final double[][] bp = new double[m][nColB];\n            for (int k = 0; k < nColB; ++k) {\n                for (int i = 0; i < m; ++i) {\n                    final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                    final double[] vData = v.getDataRef();\n                    double s = 0;\n                    for (int j = 0; j < m; ++j) {\n                        s += v.getEntry(j) * b.getEntry(j, k);\n                    }\n                    s /= realEigenvalues[i];\n                    for (int j = 0; j < m; ++j) {\n                        bp[j][k] += s * vData[j];\n                    }\n                }\n            }\n            return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);\n        }\n\n        public boolean isNonSingular() {\n            for (int i = 0; i < realEigenvalues.length; ++i) {\n                if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n            for (int i = 0; i < m; ++i) {\n                final double[] invI = invData[i];\n                for (int j = 0; j < m; ++j) {\n                    double invIJ = 0;\n                    for (int k = 0; k < m; ++k) {\n                        final double[] vK = eigenvectors[k].getDataRef();\n                        invIJ += (vK[i] * vK[j]) / realEigenvalues[k];\n                    }\n                    invI[j] = invIJ;\n                }\n            }\n            return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);\n        }\n    }\n\n    private void transformToTridiagonal(final org.apache.commons.math.linear.RealMatrix matrix) {\n        transformer = new org.apache.commons.math.linear.TriDiagonalTransformer(matrix);\n        main = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n    }\n\n    private void computeGershgorinCircles() {\n        final int m = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = java.lang.Double.POSITIVE_INFINITY;\n        upperSpectra = java.lang.Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n        double eCurrent = 0;\n        for (int i = 0; i < (m - 1); ++i) {\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = java.lang.Math.abs(secondary[i]);\n            eMax = java.lang.Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = java.lang.Math.min(lowerSpectra, lower);\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = java.lang.Math.max(upperSpectra, upper);\n        }\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[(lowerStart + m) - 1] = lower;\n        lowerSpectra = java.lang.Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[(upperStart + m) - 1] = upper;\n        upperSpectra = java.lang.Math.max(upperSpectra, upper);\n        minPivot = org.apache.commons.math.util.MathUtils.SAFE_MIN * java.lang.Math.max(1.0, eMax * eMax);\n    }\n\n    private void findEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        java.util.List<java.lang.Integer> splitIndices = computeSplits();\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n                case 1 :\n                    process1RowBlock(begin);\n                    break;\n                case 2 :\n                    process2RowsBlock(begin);\n                    break;\n                case 3 :\n                    process3RowsBlock(begin);\n                    break;\n                default :\n                    final double[] range = eigenvaluesRange(begin, n);\n                    final double oneFourth = 0.25 * ((3 * range[0]) + range[1]);\n                    final int oneFourthCount = countEigenValues(oneFourth, begin, n);\n                    final double threeFourth = 0.25 * (range[0] + (3 * range[1]));\n                    final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                    final boolean chooseLeft = (oneFourthCount - 1) >= (n - threeFourthCount);\n                    final double lambda = (chooseLeft) ? range[0] : range[1];\n                    tau = (((range[1] - range[0]) * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot);\n                    ldlTDecomposition(lambda, begin, n);\n                    processGeneralBlock(n);\n                    if (chooseLeft) {\n                        for (int i = 0; i < n; ++i) {\n                            realEigenvalues[begin + i] = lambda + work[4 * i];\n                        }\n                    } else {\n                        for (int i = 0; i < n; ++i) {\n                            realEigenvalues[begin + i] = lambda - work[4 * i];\n                        }\n                    }\n            }\n            begin = end;\n        }\n        java.util.Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n    }\n\n    private java.util.List<java.lang.Integer> computeSplits() {\n        final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>();\n        double absDCurrent = java.lang.Math.abs(main[0]);\n        for (int i = 0; i < secondary.length; ++i) {\n            final double absDPrevious = absDCurrent;\n            absDCurrent = java.lang.Math.abs(main[i + 1]);\n            final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent);\n            if (java.lang.Math.abs(secondary[i]) <= max) {\n                list.add(i + 1);\n                secondary[i] = 0;\n                squaredSecondary[i] = 0;\n            }\n        }\n        list.add(secondary.length + 1);\n        return list;\n    }\n\n    private void process1RowBlock(final int index) {\n        realEigenvalues[index] = main[index];\n    }\n\n    private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {\n        final double q0 = main[index];\n        final double q1 = main[index + 1];\n        final double e12 = squaredSecondary[index];\n        final double s = q0 + q1;\n        final double p = (q0 * q1) - e12;\n        final double delta = (s * s) - (4 * p);\n        if (delta < 0) {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"cannot solve degree {0} equation\", 2);\n        }\n        final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta));\n        realEigenvalues[index] = largestRoot;\n        realEigenvalues[index + 1] = p / largestRoot;\n    }\n\n    private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {\n        final double q0 = main[index];\n        final double q1 = main[index + 1];\n        final double q2 = main[index + 2];\n        final double e12 = squaredSecondary[index];\n        final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1];\n        final double b = -((q0 + q1) + q2);\n        final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12;\n        final double d = (q2 * e12) - (q0 * q1q2Me22);\n        final double b2 = b * b;\n        final double q = ((3 * c) - b2) / 9;\n        final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54;\n        final double delta = ((q * q) * q) + (r * r);\n        if (delta >= 0) {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"cannot solve degree {0} equation\", 3);\n        }\n        final double sqrtMq = java.lang.Math.sqrt(-q);\n        final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq));\n        final double alpha = 2 * sqrtMq;\n        final double beta = b / 3;\n        double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta;\n        double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta;\n        double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta;\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        if (z1 < z2) {\n            final double t = z1;\n            z1 = z2;\n            z2 = t;\n        }\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        realEigenvalues[index] = z0;\n        realEigenvalues[index + 1] = z1;\n        realEigenvalues[index + 2] = z2;\n    }\n\n    private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException {\n        double sumOffDiag = 0;\n        for (int i = 0; i < (n - 1); ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n        if (sumOffDiag == 0) {\n            return;\n        }\n        flipIfWarranted(n, 2);\n        initialSplits(n);\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN = 0;\n        dN1 = 0;\n        dN2 = 0;\n        tau = 0;\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n            sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2];\n            sigmaLow = 0;\n            double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6];\n            double offDiagMax = 0;\n            double diagMax = work[(4 * n0) - 4];\n            double diagMin = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + (i / 4);\n                    break;\n                }\n                if (diagMin >= (4 * offDiagMax)) {\n                    diagMin = java.lang.Math.min(diagMin, work[i + 4]);\n                    offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);\n            }\n            work[(4 * n0) - 2] = offDiagMin;\n            dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax)));\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));\n                }\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n                if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) {\n                    int split = i0 - 1;\n                    diagMax = work[4 * i0];\n                    offDiagMin = work[(4 * i0) + 2];\n                    double previousEMin = work[(4 * i0) + 3];\n                    for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {\n                        if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) {\n                            work[i + 2] = -sigma;\n                            split = i / 4;\n                            diagMax = 0;\n                            offDiagMin = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax = java.lang.Math.max(diagMax, work[i + 4]);\n                            offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[(4 * n0) - 2] = offDiagMin;\n                    work[(4 * n0) - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n        } \n    }\n\n    private void initialSplits(final int n) {\n        pingPong = 0;\n        for (int k = 0; k < 2; ++k) {\n            double d = work[(4 * (n - 1)) + pingPong];\n            for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {\n                if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {\n                    work[i + 2] = -0.0;\n                    d = work[i];\n                } else {\n                    d *= work[i] / (d + work[i + 2]);\n                }\n            }\n            d = work[pingPong];\n            for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {\n                final int j = (i - (2 * pingPong)) - 1;\n                work[j] = d + work[i];\n                if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {\n                    work[i] = -0.0;\n                    work[j] = d;\n                    work[j + 2] = 0.0;\n                    d = work[i + 2];\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) {\n                    final double tmp = work[i + 2] / work[j];\n                    work[j + 2] = work[i] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n                    d *= work[i + 2] / work[j];\n                }\n            }\n            work[((4 * n) - 3) - pingPong] = d;\n            pingPong = 1 - pingPong;\n        }\n    }\n\n    private int goodStep(final int start, final int end) {\n        g = 0.0;\n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n            if (start >= deflatedEnd) {\n                return deflatedEnd;\n            }\n            final int k = ((4 * deflatedEnd) + pingPong) - 1;\n            if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) {\n                work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong];\n                deflatedEnd -= 1;\n            } else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) {\n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n                if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));\n                    } else {\n                        s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7] = t;\n                }\n                work[(4 * deflatedEnd) - 8] = sigma + work[k - 7];\n                work[(4 * deflatedEnd) - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n                deflating = false;\n            }\n        }\n        final int l = ((4 * deflatedEnd) + pingPong) - 1;\n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = java.lang.Math.min(dMin2, work[l - 1]);\n                work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong]));\n                qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]));\n                dMin = -0.0;\n            }\n        }\n        if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) {\n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n            for (boolean loop = true; loop;) {\n                dqds(start, deflatedEnd);\n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((((dMin < 0.0) && (dMin1 > 0.0)) && (work[((4 * deflatedEnd) - 5) - pingPong] < (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * (sigma + dN1)))) && (java.lang.Math.abs(dN) < (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * sigma))) {\n                    work[((4 * deflatedEnd) - 3) - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    if (tType < (-22)) {\n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.util.MathUtils.EPSILON));\n                        tType -= 11;\n                    } else {\n                        tau *= 0.25;\n                        tType -= 12;\n                    }\n                } else if (java.lang.Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    loop = false;\n                }\n            }\n        }\n        dqd(start, deflatedEnd);\n        return deflatedEnd;\n    }\n\n    private boolean flipIfWarranted(final int n, final int step) {\n        if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n            int j = (4 * n) - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private double[] eigenvaluesRange(final int index, final int n) {\n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = java.lang.Double.POSITIVE_INFINITY;\n        double upper = java.lang.Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < n; ++i) {\n            lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]);\n            upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);\n        }\n        final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper));\n        final double relativeTolerance = java.lang.Math.sqrt(MathUtils.EPSILON);\n        final double absoluteTolerance = 4 * minPivot;\n        final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0)));\n        final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot));\n        double left = lower - margin;\n        double right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n            final double range = right - left;\n            if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) {\n                break;\n            }\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= 1) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n        }\n        lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left)));\n        left = lower - margin;\n        right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n            final double range = right - left;\n            if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) {\n                break;\n            }\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= n) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n        }\n        upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right)));\n        return new double[]{ lower, upper };\n    }\n\n    private int countEigenValues(final double t, final int index, final int n) {\n        double ratio = main[index] - t;\n        int count = (ratio > 0) ? 0 : 1;\n        for (int i = 1; i < n; ++i) {\n            ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t;\n            if (ratio <= 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n        double di = main[index] - lambda;\n        work[0] = java.lang.Math.abs(di);\n        for (int i = 1; i < n; ++i) {\n            final int fourI = 4 * i;\n            final double eiM1 = secondary[(index + i) - 1];\n            final double ratio = eiM1 / di;\n            work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di);\n            di = (main[index + i] - lambda) - (eiM1 * ratio);\n            work[fourI] = java.lang.Math.abs(di);\n        }\n    }\n\n    private void dqds(final int start, final int end) {\n        eMin = work[((4 * start) + pingPong) + 4];\n        double d = work[(4 * start) + pingPong] - tau;\n        dMin = d;\n        dMin1 = -work[(4 * start) + pingPong];\n        if (pingPong == 0) {\n            for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                final double tmp = work[j4 + 1] / work[j4 - 2];\n                d = (d * tmp) - tau;\n                dMin = java.lang.Math.min(dMin, d);\n                work[j4] = work[j4 - 1] * tmp;\n                eMin = java.lang.Math.min(work[j4], eMin);\n            }\n        } else {\n            for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                final double tmp = work[j4 + 2] / work[j4 - 3];\n                d = (d * tmp) - tau;\n                dMin = java.lang.Math.min(dMin, d);\n                work[j4 - 1] = work[j4] * tmp;\n                eMin = java.lang.Math.min(work[j4 - 1], eMin);\n            }\n        }\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = ((4 * (end - 2)) - pingPong) - 1;\n        int j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau;\n        dMin = java.lang.Math.min(dMin, dN1);\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau;\n        dMin = java.lang.Math.min(dMin, dN);\n        work[j4 + 2] = dN;\n        work[((4 * end) - pingPong) - 1] = eMin;\n    }\n\n    private void dqd(final int start, final int end) {\n        eMin = work[((4 * start) + pingPong) + 4];\n        double d = work[(4 * start) + pingPong];\n        dMin = d;\n        if (pingPong == 0) {\n            for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                if (work[j4 - 2] == 0.0) {\n                    work[j4] = 0.0;\n                    d = work[j4 + 1];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) {\n                    final double tmp = work[j4 + 1] / work[j4 - 2];\n                    work[j4] = work[j4 - 1] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n                    d *= work[j4 + 1] / work[j4 - 2];\n                }\n                dMin = java.lang.Math.min(dMin, d);\n                eMin = java.lang.Math.min(eMin, work[j4]);\n            }\n        } else {\n            for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                if (work[j4 - 3] == 0.0) {\n                    work[j4 - 1] = 0.0;\n                    d = work[j4 + 2];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) {\n                    final double tmp = work[j4 + 2] / work[j4 - 3];\n                    work[j4 - 1] = work[j4] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n                    d *= work[j4 + 2] / work[j4 - 3];\n                }\n                dMin = java.lang.Math.min(dMin, d);\n                eMin = java.lang.Math.min(eMin, work[j4 - 1]);\n            }\n        }\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = ((4 * (end - 2)) - pingPong) - 1;\n        int j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN1 = work[j4p2 + 2];\n            dMin = dN1;\n            eMin = 0.0;\n        } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN1 = dN2 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n        }\n        dMin = java.lang.Math.min(dMin, dN1);\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN = work[j4p2 + 2];\n            dMin = dN;\n            eMin = 0.0;\n        } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN = dN1 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n        }\n        dMin = java.lang.Math.min(dMin, dN);\n        work[j4 + 2] = dN;\n        work[((4 * end) - pingPong) - 1] = eMin;\n    }\n\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.01;\n        final double cnst3 = 1.05;\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n        int nn = ((4 * end) + pingPong) - 1;\n        switch (deflated) {\n            case 0 :\n                if ((dMin == dN) || (dMin == dN1)) {\n                    double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]);\n                    double b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]);\n                    double a2 = work[nn - 7] + work[nn - 5];\n                    if ((dMin == dN) && (dMin1 == dN1)) {\n                        final double gap2 = (dMin2 - a2) - (dMin2 * 0.25);\n                        final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2);\n                        if ((gap1 > 0.0) && (gap1 > b1)) {\n                            tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin);\n                            tType = -2;\n                        } else {\n                            double s = 0.0;\n                            if (dN > b1) {\n                                s = dN - b1;\n                            }\n                            if (a2 > (b1 + b2)) {\n                                s = java.lang.Math.min(s, a2 - (b1 + b2));\n                            }\n                            tau = java.lang.Math.max(s, 0.333 * dMin);\n                            tType = -3;\n                        }\n                    } else {\n                        tType = -4;\n                        double s = 0.25 * dMin;\n                        double gam;\n                        int np;\n                        if (dMin == dN) {\n                            gam = dN;\n                            a2 = 0.0;\n                            if (work[nn - 5] > work[nn - 7]) {\n                                return;\n                            }\n                            b2 = work[nn - 5] / work[nn - 7];\n                            np = nn - 9;\n                        } else {\n                            np = nn - (2 * pingPong);\n                            b2 = work[np - 2];\n                            gam = dN1;\n                            if (work[np - 4] > work[np - 2]) {\n                                return;\n                            }\n                            a2 = work[np - 4] / work[np - 2];\n                            if (work[nn - 9] > work[nn - 11]) {\n                                return;\n                            }\n                            b2 = work[nn - 9] / work[nn - 11];\n                            np = nn - 13;\n                        }\n                        a2 = a2 + b2;\n                        for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (b2 == 0.0) {\n                                break;\n                            }\n                            b1 = b2;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b2 = b2 * (work[i4] / work[i4 - 2]);\n                            a2 = a2 + b2;\n                            if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\n                                break;\n                            }\n                        }\n                        a2 = cnst3 * a2;\n                        if (a2 < cnst1) {\n                            s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);\n                        }\n                        tau = s;\n                    }\n                } else if (dMin == dN2) {\n                    tType = -5;\n                    double s = 0.25 * dMin;\n                    final int np = nn - (2 * pingPong);\n                    double b1 = work[np - 2];\n                    double b2 = work[np - 6];\n                    final double gam = dN2;\n                    if ((work[np - 8] > b2) || (work[np - 4] > b1)) {\n                        return;\n                    }\n                    double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1));\n                    if ((end - start) > 3) {\n                        b2 = work[nn - 13] / work[nn - 15];\n                        a2 = a2 + b2;\n                        for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (b2 == 0.0) {\n                                break;\n                            }\n                            b1 = b2;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b2 = b2 * (work[i4] / work[i4 - 2]);\n                            a2 = a2 + b2;\n                            if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\n                                break;\n                            }\n                        }\n                        a2 = cnst3 * a2;\n                    }\n                    if (a2 < cnst1) {\n                        tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);\n                    } else {\n                        tau = s;\n                    }\n                } else {\n                    if (tType == (-6)) {\n                        g += 0.333 * (1 - g);\n                    } else if (tType == (-18)) {\n                        g = 0.25 * 0.333;\n                    } else {\n                        g = 0.25;\n                    }\n                    tau = g * dMin;\n                    tType = -6;\n                }\n                break;\n            case 1 :\n                if ((dMin1 == dN1) && (dMin2 == dN2)) {\n                    tType = -7;\n                    double s = 0.333 * dMin1;\n                    if (work[nn - 5] > work[nn - 7]) {\n                        return;\n                    }\n                    double b1 = work[nn - 5] / work[nn - 7];\n                    double b2 = b1;\n                    if (b2 != 0.0) {\n                        for (int i4 = ((4 * end) - 10) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            final double oldB1 = b1;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b1 = b1 * (work[i4] / work[i4 - 2]);\n                            b2 = b2 + b1;\n                            if ((100 * java.lang.Math.max(b1, oldB1)) < b2) {\n                                break;\n                            }\n                        }\n                    }\n                    b2 = java.lang.Math.sqrt(cnst3 * b2);\n                    final double a2 = dMin1 / (1 + (b2 * b2));\n                    final double gap2 = (0.5 * dMin2) - a2;\n                    if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\n                        tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));\n                    } else {\n                        tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\n                        tType = -8;\n                    }\n                } else {\n                    tau = 0.25 * dMin1;\n                    if (dMin1 == dN1) {\n                        tau = 0.5 * dMin1;\n                    }\n                    tType = -9;\n                }\n                break;\n            case 2 :\n                if ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) {\n                    tType = -10;\n                    final double s = 0.333 * dMin2;\n                    if (work[nn - 5] > work[nn - 7]) {\n                        return;\n                    }\n                    double b1 = work[nn - 5] / work[nn - 7];\n                    double b2 = b1;\n                    if (b2 != 0.0) {\n                        for (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b1 *= work[i4] / work[i4 - 2];\n                            b2 += b1;\n                            if ((100 * b1) < b2) {\n                                break;\n                            }\n                        }\n                    }\n                    b2 = java.lang.Math.sqrt(cnst3 * b2);\n                    final double a2 = dMin2 / (1 + (b2 * b2));\n                    final double gap2 = ((work[nn - 7] + work[nn - 9]) - (java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2;\n                    if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\n                        tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));\n                    } else {\n                        tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\n                    }\n                } else {\n                    tau = 0.25 * dMin2;\n                    tType = -11;\n                }\n                break;\n            default :\n                tau = 0.0;\n                tType = -12;\n        }\n    }\n\n    private void updateSigma(final double shift) {\n        if (shift < sigma) {\n            sigmaLow += shift;\n            final double t = sigma + sigmaLow;\n            sigmaLow -= t - sigma;\n            sigma = t;\n        } else {\n            final double t = sigma + shift;\n            sigmaLow += sigma - (t - shift);\n            sigma = t;\n        }\n    }\n\n    private void findEigenVectors() {\n        final int m = main.length;\n        eigenvectors = new org.apache.commons.math.linear.ArrayRealVector[m];\n        final double[] d = new double[m];\n        final double[] l = new double[m - 1];\n        final double mu = ((realEigenvalues[m - 1] <= 0) && (realEigenvalues[0] > 0)) ? 0.5 - realEigenvalues[m - 1] : 0;\n        double di = main[0] + mu;\n        d[0] = di;\n        for (int i = 1; i < m; ++i) {\n            final double eiM1 = secondary[i - 1];\n            final double ratio = eiM1 / di;\n            di = (main[i] - (eiM1 * ratio)) + mu;\n            l[i - 1] = ratio;\n            d[i] = di;\n        }\n        for (int i = 0; i < m; ++i) {\n            eigenvectors[i] = findEigenvector(realEigenvalues[i] + mu, d, l);\n        }\n    }\n\n    private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {\n        final int m = main.length;\n        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n        int r = m - 1;\n        double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue);\n        int sixI = 0;\n        for (int i = 0; i < (m - 1); ++i) {\n            final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10]));\n            if (absG < minG) {\n                r = i;\n                minG = absG;\n            }\n            sixI += 6;\n        }\n        double[] eigenvector = new double[m];\n        double n2 = 1;\n        eigenvector[r] = 1;\n        double z = 1;\n        for (int i = r - 1; i >= 0; --i) {\n            z *= -work[(6 * i) + 2];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        z = 1;\n        for (int i = r + 1; i < m; ++i) {\n            z *= -work[(6 * i) - 1];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        final double inv = 1.0 / java.lang.Math.sqrt(n2);\n        for (int i = 0; i < m; ++i) {\n            eigenvector[i] *= inv;\n        }\n        return transformer == null ? new org.apache.commons.math.linear.ArrayRealVector(eigenvector, false) : new org.apache.commons.math.linear.ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n    }\n\n    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double si = -lambda;\n        int sixI = 0;\n        for (int i = 0; i < nM1; ++i) {\n            final double di = d[i];\n            final double li = l[i];\n            final double diP1 = di + si;\n            final double liP1 = (li * di) / diP1;\n            work[sixI] = si;\n            work[sixI + 1] = diP1;\n            work[sixI + 2] = liP1;\n            si = ((li * liP1) * si) - lambda;\n            sixI += 6;\n        }\n        work[(6 * nM1) + 1] = d[nM1] + si;\n        work[6 * nM1] = si;\n    }\n\n    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double pi = d[nM1] - lambda;\n        int sixI = 6 * (nM1 - 1);\n        for (int i = nM1 - 1; i >= 0; --i) {\n            final double di = d[i];\n            final double li = l[i];\n            final double diP1 = ((di * li) * li) + pi;\n            final double t = di / diP1;\n            work[sixI + 9] = pi;\n            work[sixI + 10] = diP1;\n            work[sixI + 5] = li * t;\n            pi = (pi * t) - lambda;\n            sixI -= 6;\n        }\n        work[3] = pi;\n        work[4] = pi;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean flipIfWarranted(final int n, final int step) {\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "src_parent": "public class EigenDecompositionImpl implements org.apache.commons.math.linear.EigenDecomposition {\n    private static final double TOLERANCE = 100 * org.apache.commons.math.util.MathUtils.EPSILON;\n\n    private static final double TOLERANCE_2 = org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE;\n\n    private double splitTolerance;\n\n    private double[] main;\n\n    private double[] secondary;\n\n    private double[] squaredSecondary;\n\n    private org.apache.commons.math.linear.TriDiagonalTransformer transformer;\n\n    private double lowerSpectra;\n\n    private double upperSpectra;\n\n    private double minPivot;\n\n    private double sigma;\n\n    private double sigmaLow;\n\n    private double tau;\n\n    private double[] work;\n\n    private int pingPong;\n\n    private double qMax;\n\n    private double eMin;\n\n    private int tType;\n\n    private double dMin;\n\n    private double dMin1;\n\n    private double dMin2;\n\n    private double dN;\n\n    private double dN1;\n\n    private double dN2;\n\n    private double g;\n\n    private double[] realEigenvalues;\n\n    private double[] imagEigenvalues;\n\n    private org.apache.commons.math.linear.ArrayRealVector[] eigenvectors;\n\n    private org.apache.commons.math.linear.RealMatrix cachedV;\n\n    private org.apache.commons.math.linear.RealMatrix cachedD;\n\n    private org.apache.commons.math.linear.RealMatrix cachedVt;\n\n    public EigenDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double splitTolerance) throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (isSymmetric(matrix)) {\n            this.splitTolerance = splitTolerance;\n            transformToTridiagonal(matrix);\n            decompose();\n        } else {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\");\n        }\n    }\n\n    public EigenDecompositionImpl(final double[] main, double[] secondary, final double splitTolerance) throws org.apache.commons.math.linear.InvalidMatrixException {\n        this.main = main.clone();\n        this.secondary = secondary.clone();\n        transformer = null;\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n        this.splitTolerance = splitTolerance;\n        decompose();\n    }\n\n    private boolean isSymmetric(final org.apache.commons.math.linear.RealMatrix matrix) {\n        final int rows = matrix.getRowDimension();\n        final int columns = matrix.getColumnDimension();\n        final double eps = ((10 * rows) * columns) * org.apache.commons.math.util.MathUtils.EPSILON;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = i + 1; j < columns; ++j) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (java.lang.Math.abs(mij - mji) > (java.lang.Math.max(java.lang.Math.abs(mij), java.lang.Math.abs(mji)) * eps)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private void decompose() {\n        cachedV = null;\n        cachedD = null;\n        cachedVt = null;\n        work = new double[6 * main.length];\n        computeGershgorinCircles();\n        findEigenvalues();\n        eigenvectors = null;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedV == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedV = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n        }\n        return cachedV;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getD() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedD == null) {\n            cachedD = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n        }\n        return cachedD;\n    }\n\n    public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {\n        if (cachedVt == null) {\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n            final int m = eigenvectors.length;\n            cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedVt.setRowVector(k, eigenvectors[k]);\n            }\n        }\n        return cachedVt;\n    }\n\n    public double[] getRealEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        return realEigenvalues.clone();\n    }\n\n    public double getRealEigenvalue(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        return realEigenvalues[i];\n    }\n\n    public double[] getImagEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        return imagEigenvalues.clone();\n    }\n\n    public double getImagEigenvalue(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        return imagEigenvalues[i];\n    }\n\n    public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return eigenvectors[i].copy();\n    }\n\n    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }\n\n    public org.apache.commons.math.linear.DecompositionSolver getSolver() {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return new org.apache.commons.math.linear.EigenDecompositionImpl.Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    }\n\n    private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {\n        private double[] realEigenvalues;\n\n        private double[] imagEigenvalues;\n\n        private final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors;\n\n        private Solver(final double[] realEigenvalues, final double[] imagEigenvalues, final org.apache.commons.math.linear.ArrayRealVector[] eigenvectors) {\n            this.realEigenvalues = realEigenvalues;\n            this.imagEigenvalues = imagEigenvalues;\n            this.eigenvectors = eigenvectors;\n        }\n\n        public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.length != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.length, m);\n            }\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n            return bp;\n        }\n\n        public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.getDimension() != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"vector length mismatch: got {0} but expected {1}\", b.getDimension(), m);\n            }\n            final double[] bp = new double[m];\n            for (int i = 0; i < m; ++i) {\n                final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                final double s = v.dotProduct(b) / realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j] += s * vData[j];\n                }\n            }\n            return new org.apache.commons.math.linear.ArrayRealVector(bp, false);\n        }\n\n        public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            if (b.getRowDimension() != m) {\n                throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\", b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n            final int nColB = b.getColumnDimension();\n            final double[][] bp = new double[m][nColB];\n            for (int k = 0; k < nColB; ++k) {\n                for (int i = 0; i < m; ++i) {\n                    final org.apache.commons.math.linear.ArrayRealVector v = eigenvectors[i];\n                    final double[] vData = v.getDataRef();\n                    double s = 0;\n                    for (int j = 0; j < m; ++j) {\n                        s += v.getEntry(j) * b.getEntry(j, k);\n                    }\n                    s /= realEigenvalues[i];\n                    for (int j = 0; j < m; ++j) {\n                        bp[j][k] += s * vData[j];\n                    }\n                }\n            }\n            return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(bp);\n        }\n\n        public boolean isNonSingular() {\n            for (int i = 0; i < realEigenvalues.length; ++i) {\n                if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {\n            if (!isNonSingular()) {\n                throw new org.apache.commons.math.linear.SingularMatrixException();\n            }\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n            for (int i = 0; i < m; ++i) {\n                final double[] invI = invData[i];\n                for (int j = 0; j < m; ++j) {\n                    double invIJ = 0;\n                    for (int k = 0; k < m; ++k) {\n                        final double[] vK = eigenvectors[k].getDataRef();\n                        invIJ += (vK[i] * vK[j]) / realEigenvalues[k];\n                    }\n                    invI[j] = invIJ;\n                }\n            }\n            return org.apache.commons.math.linear.MatrixUtils.createRealMatrix(invData);\n        }\n    }\n\n    private void transformToTridiagonal(final org.apache.commons.math.linear.RealMatrix matrix) {\n        transformer = new org.apache.commons.math.linear.TriDiagonalTransformer(matrix);\n        main = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n    }\n\n    private void computeGershgorinCircles() {\n        final int m = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = java.lang.Double.POSITIVE_INFINITY;\n        upperSpectra = java.lang.Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n        double eCurrent = 0;\n        for (int i = 0; i < (m - 1); ++i) {\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = java.lang.Math.abs(secondary[i]);\n            eMax = java.lang.Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = java.lang.Math.min(lowerSpectra, lower);\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = java.lang.Math.max(upperSpectra, upper);\n        }\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[(lowerStart + m) - 1] = lower;\n        lowerSpectra = java.lang.Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[(upperStart + m) - 1] = upper;\n        upperSpectra = java.lang.Math.max(upperSpectra, upper);\n        minPivot = org.apache.commons.math.util.MathUtils.SAFE_MIN * java.lang.Math.max(1.0, eMax * eMax);\n    }\n\n    private void findEigenvalues() throws org.apache.commons.math.linear.InvalidMatrixException {\n        java.util.List<java.lang.Integer> splitIndices = computeSplits();\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n                case 1 :\n                    process1RowBlock(begin);\n                    break;\n                case 2 :\n                    process2RowsBlock(begin);\n                    break;\n                case 3 :\n                    process3RowsBlock(begin);\n                    break;\n                default :\n                    final double[] range = eigenvaluesRange(begin, n);\n                    final double oneFourth = 0.25 * ((3 * range[0]) + range[1]);\n                    final int oneFourthCount = countEigenValues(oneFourth, begin, n);\n                    final double threeFourth = 0.25 * (range[0] + (3 * range[1]));\n                    final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                    final boolean chooseLeft = (oneFourthCount - 1) >= (n - threeFourthCount);\n                    final double lambda = (chooseLeft) ? range[0] : range[1];\n                    tau = (((range[1] - range[0]) * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot);\n                    ldlTDecomposition(lambda, begin, n);\n                    processGeneralBlock(n);\n                    if (chooseLeft) {\n                        for (int i = 0; i < n; ++i) {\n                            realEigenvalues[begin + i] = lambda + work[4 * i];\n                        }\n                    } else {\n                        for (int i = 0; i < n; ++i) {\n                            realEigenvalues[begin + i] = lambda - work[4 * i];\n                        }\n                    }\n            }\n            begin = end;\n        }\n        java.util.Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n    }\n\n    private java.util.List<java.lang.Integer> computeSplits() {\n        final java.util.List<java.lang.Integer> list = new java.util.ArrayList<java.lang.Integer>();\n        double absDCurrent = java.lang.Math.abs(main[0]);\n        for (int i = 0; i < secondary.length; ++i) {\n            final double absDPrevious = absDCurrent;\n            absDCurrent = java.lang.Math.abs(main[i + 1]);\n            final double max = splitTolerance * java.lang.Math.sqrt(absDPrevious * absDCurrent);\n            if (java.lang.Math.abs(secondary[i]) <= max) {\n                list.add(i + 1);\n                secondary[i] = 0;\n                squaredSecondary[i] = 0;\n            }\n        }\n        list.add(secondary.length + 1);\n        return list;\n    }\n\n    private void process1RowBlock(final int index) {\n        realEigenvalues[index] = main[index];\n    }\n\n    private void process2RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {\n        final double q0 = main[index];\n        final double q1 = main[index + 1];\n        final double e12 = squaredSecondary[index];\n        final double s = q0 + q1;\n        final double p = (q0 * q1) - e12;\n        final double delta = (s * s) - (4 * p);\n        if (delta < 0) {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"cannot solve degree {0} equation\", 2);\n        }\n        final double largestRoot = 0.5 * (s + java.lang.Math.sqrt(delta));\n        realEigenvalues[index] = largestRoot;\n        realEigenvalues[index + 1] = p / largestRoot;\n    }\n\n    private void process3RowsBlock(final int index) throws org.apache.commons.math.linear.InvalidMatrixException {\n        final double q0 = main[index];\n        final double q1 = main[index + 1];\n        final double q2 = main[index + 2];\n        final double e12 = squaredSecondary[index];\n        final double q1q2Me22 = (q1 * q2) - squaredSecondary[index + 1];\n        final double b = -((q0 + q1) + q2);\n        final double c = (((q0 * q1) + (q0 * q2)) + q1q2Me22) - e12;\n        final double d = (q2 * e12) - (q0 * q1q2Me22);\n        final double b2 = b * b;\n        final double q = ((3 * c) - b2) / 9;\n        final double r = ((((9 * c) - (2 * b2)) * b) - (27 * d)) / 54;\n        final double delta = ((q * q) * q) + (r * r);\n        if (delta >= 0) {\n            throw new org.apache.commons.math.linear.InvalidMatrixException(\"cannot solve degree {0} equation\", 3);\n        }\n        final double sqrtMq = java.lang.Math.sqrt(-q);\n        final double theta = java.lang.Math.acos(r / ((-q) * sqrtMq));\n        final double alpha = 2 * sqrtMq;\n        final double beta = b / 3;\n        double z0 = (alpha * java.lang.Math.cos(theta / 3)) - beta;\n        double z1 = (alpha * java.lang.Math.cos((theta + (2 * java.lang.Math.PI)) / 3)) - beta;\n        double z2 = (alpha * java.lang.Math.cos((theta + (4 * java.lang.Math.PI)) / 3)) - beta;\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        if (z1 < z2) {\n            final double t = z1;\n            z1 = z2;\n            z2 = t;\n        }\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        realEigenvalues[index] = z0;\n        realEigenvalues[index + 1] = z1;\n        realEigenvalues[index + 2] = z2;\n    }\n\n    private void processGeneralBlock(final int n) throws org.apache.commons.math.linear.InvalidMatrixException {\n        double sumOffDiag = 0;\n        for (int i = 0; i < (n - 1); ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n        if (sumOffDiag == 0) {\n            return;\n        }\n        flipIfWarranted(n, 2);\n        initialSplits(n);\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN = 0;\n        dN1 = 0;\n        dN2 = 0;\n        tau = 0;\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n            sigma = (n0 == n) ? 0 : -work[(4 * n0) - 2];\n            sigmaLow = 0;\n            double offDiagMin = (i0 == n0) ? 0 : work[(4 * n0) - 6];\n            double offDiagMax = 0;\n            double diagMax = work[(4 * n0) - 4];\n            double diagMin = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + (i / 4);\n                    break;\n                }\n                if (diagMin >= (4 * offDiagMax)) {\n                    diagMin = java.lang.Math.min(diagMin, work[i + 4]);\n                    offDiagMax = java.lang.Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax = java.lang.Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);\n            }\n            work[(4 * n0) - 2] = offDiagMin;\n            dMin = -java.lang.Math.max(0, diagMin - (2 * java.lang.Math.sqrt(diagMin * offDiagMax)));\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new org.apache.commons.math.linear.InvalidMatrixException(new org.apache.commons.math.MaxIterationsExceededException(maxIter));\n                }\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n                if ((((pingPong == 0) && ((n0 - i0) > 3)) && (work[(4 * n0) - 1] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * diagMax))) && (work[(4 * n0) - 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) {\n                    int split = i0 - 1;\n                    diagMax = work[4 * i0];\n                    offDiagMin = work[(4 * i0) + 2];\n                    double previousEMin = work[(4 * i0) + 3];\n                    for (int i = 4 * i0; i < ((4 * n0) - 16); i += 4) {\n                        if ((work[i + 3] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[i])) || (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) {\n                            work[i + 2] = -sigma;\n                            split = i / 4;\n                            diagMax = 0;\n                            offDiagMin = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax = java.lang.Math.max(diagMax, work[i + 4]);\n                            offDiagMin = java.lang.Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = java.lang.Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[(4 * n0) - 2] = offDiagMin;\n                    work[(4 * n0) - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n        } \n    }\n\n    private void initialSplits(final int n) {\n        pingPong = 0;\n        for (int k = 0; k < 2; ++k) {\n            double d = work[(4 * (n - 1)) + pingPong];\n            for (int i = (4 * (n - 2)) + pingPong; i >= 0; i -= 4) {\n                if (work[i + 2] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {\n                    work[i + 2] = -0.0;\n                    d = work[i];\n                } else {\n                    d *= work[i] / (d + work[i + 2]);\n                }\n            }\n            d = work[pingPong];\n            for (int i = 2 + pingPong; i < ((4 * n) - 2); i += 4) {\n                final int j = (i - (2 * pingPong)) - 1;\n                work[j] = d + work[i];\n                if (work[i] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * d)) {\n                    work[i] = -0.0;\n                    work[j] = d;\n                    work[j + 2] = 0.0;\n                    d = work[i + 2];\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[i + 2]) < work[j]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j]) < work[i + 2])) {\n                    final double tmp = work[i + 2] / work[j];\n                    work[j + 2] = work[i] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n                    d *= work[i + 2] / work[j];\n                }\n            }\n            work[((4 * n) - 3) - pingPong] = d;\n            pingPong = 1 - pingPong;\n        }\n    }\n\n    private int goodStep(final int start, final int end) {\n        g = 0.0;\n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n            if (start >= deflatedEnd) {\n                return deflatedEnd;\n            }\n            final int k = ((4 * deflatedEnd) + pingPong) - 1;\n            if ((start == (deflatedEnd - 1)) || ((start != (deflatedEnd - 2)) && ((work[k - 5] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * (sigma + work[k - 3]))) || (work[(k - (2 * pingPong)) - 4] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 7]))))) {\n                work[(4 * deflatedEnd) - 4] = sigma + work[((4 * deflatedEnd) - 4) + pingPong];\n                deflatedEnd -= 1;\n            } else if (((start == (deflatedEnd - 2)) || (work[k - 9] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * sigma))) || (work[(k - (2 * pingPong)) - 8] <= (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 11]))) {\n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n                if (work[k - 5] > (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE_2 * work[k - 3])) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = (work[k - 3] * work[k - 5]) / (t * (1 + java.lang.Math.sqrt(1 + (s / t))));\n                    } else {\n                        s = (work[k - 3] * work[k - 5]) / (t + java.lang.Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7] = t;\n                }\n                work[(4 * deflatedEnd) - 8] = sigma + work[k - 7];\n                work[(4 * deflatedEnd) - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n                deflating = false;\n            }\n        }\n        final int l = ((4 * deflatedEnd) + pingPong) - 1;\n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = java.lang.Math.min(dMin2, work[l - 1]);\n                work[l - 1] = java.lang.Math.min(work[l - 1], java.lang.Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - (2 * pingPong)] = java.lang.Math.min(work[l - (2 * pingPong)], java.lang.Math.min(work[6 + pingPong], work[6 + pingPong]));\n                qMax = java.lang.Math.max(qMax, java.lang.Math.max(work[3 + pingPong], work[7 + pingPong]));\n                dMin = -0.0;\n            }\n        }\n        if ((dMin < 0) || ((org.apache.commons.math.util.MathUtils.SAFE_MIN * qMax) < java.lang.Math.min(work[l - 1], java.lang.Math.min(work[l - 9], dMin2 + work[l - (2 * pingPong)])))) {\n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n            for (boolean loop = true; loop;) {\n                dqds(start, deflatedEnd);\n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((((dMin < 0.0) && (dMin1 > 0.0)) && (work[((4 * deflatedEnd) - 5) - pingPong] < (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * (sigma + dN1)))) && (java.lang.Math.abs(dN) < (org.apache.commons.math.linear.EigenDecompositionImpl.TOLERANCE * sigma))) {\n                    work[((4 * deflatedEnd) - 3) - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    if (tType < (-22)) {\n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        tau = (tau + dMin) * (1.0 - (2.0 * org.apache.commons.math.util.MathUtils.EPSILON));\n                        tType -= 11;\n                    } else {\n                        tau *= 0.25;\n                        tType -= 12;\n                    }\n                } else if (java.lang.Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    loop = false;\n                }\n            }\n        }\n        dqd(start, deflatedEnd);\n        return deflatedEnd;\n    }\n\n    private boolean flipIfWarranted(final int n, final int step) {\n        if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n            int j = (4 * n) - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private double[] eigenvaluesRange(final int index, final int n) {\n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = java.lang.Double.POSITIVE_INFINITY;\n        double upper = java.lang.Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < n; ++i) {\n            lower = java.lang.Math.min(lower, work[(lowerStart + index) + i]);\n            upper = java.lang.Math.max(upper, work[(upperStart + index) + i]);\n        }\n        final double tNorm = java.lang.Math.max(java.lang.Math.abs(lower), java.lang.Math.abs(upper));\n        final double relativeTolerance = java.lang.Math.sqrt(MathUtils.EPSILON);\n        final double absoluteTolerance = 4 * minPivot;\n        final int maxIter = 2 + ((int) ((java.lang.Math.log(tNorm + minPivot) - java.lang.Math.log(minPivot)) / java.lang.Math.log(2.0)));\n        final double margin = 2 * (((tNorm * org.apache.commons.math.util.MathUtils.EPSILON) * n) + (2 * minPivot));\n        double left = lower - margin;\n        double right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n            final double range = right - left;\n            if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) {\n                break;\n            }\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= 1) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n        }\n        lower = java.lang.Math.max(lower, left - ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(left)));\n        left = lower - margin;\n        right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n            final double range = right - left;\n            if ((range < absoluteTolerance) || (range < (relativeTolerance * java.lang.Math.max(java.lang.Math.abs(left), java.lang.Math.abs(right))))) {\n                break;\n            }\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= n) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n        }\n        upper = java.lang.Math.min(upper, right + ((100 * org.apache.commons.math.util.MathUtils.EPSILON) * java.lang.Math.abs(right)));\n        return new double[]{ lower, upper };\n    }\n\n    private int countEigenValues(final double t, final int index, final int n) {\n        double ratio = main[index] - t;\n        int count = (ratio > 0) ? 0 : 1;\n        for (int i = 1; i < n; ++i) {\n            ratio = (main[index + i] - (squaredSecondary[(index + i) - 1] / ratio)) - t;\n            if (ratio <= 0) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n        double di = main[index] - lambda;\n        work[0] = java.lang.Math.abs(di);\n        for (int i = 1; i < n; ++i) {\n            final int fourI = 4 * i;\n            final double eiM1 = secondary[(index + i) - 1];\n            final double ratio = eiM1 / di;\n            work[fourI - 2] = (ratio * ratio) * java.lang.Math.abs(di);\n            di = (main[index + i] - lambda) - (eiM1 * ratio);\n            work[fourI] = java.lang.Math.abs(di);\n        }\n    }\n\n    private void dqds(final int start, final int end) {\n        eMin = work[((4 * start) + pingPong) + 4];\n        double d = work[(4 * start) + pingPong] - tau;\n        dMin = d;\n        dMin1 = -work[(4 * start) + pingPong];\n        if (pingPong == 0) {\n            for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                final double tmp = work[j4 + 1] / work[j4 - 2];\n                d = (d * tmp) - tau;\n                dMin = java.lang.Math.min(dMin, d);\n                work[j4] = work[j4 - 1] * tmp;\n                eMin = java.lang.Math.min(work[j4], eMin);\n            }\n        } else {\n            for (int j4 = (4 * start) + 3; j4 <= (4 * (end - 3)); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                final double tmp = work[j4 + 2] / work[j4 - 3];\n                d = (d * tmp) - tau;\n                dMin = java.lang.Math.min(dMin, d);\n                work[j4 - 1] = work[j4] * tmp;\n                eMin = java.lang.Math.min(work[j4 - 1], eMin);\n            }\n        }\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = ((4 * (end - 2)) - pingPong) - 1;\n        int j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN1 = (work[j4p2 + 2] * (dN2 / work[j4 - 2])) - tau;\n        dMin = java.lang.Math.min(dMin, dN1);\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN = (work[j4p2 + 2] * (dN1 / work[j4 - 2])) - tau;\n        dMin = java.lang.Math.min(dMin, dN);\n        work[j4 + 2] = dN;\n        work[((4 * end) - pingPong) - 1] = eMin;\n    }\n\n    private void dqd(final int start, final int end) {\n        eMin = work[((4 * start) + pingPong) + 4];\n        double d = work[(4 * start) + pingPong];\n        dMin = d;\n        if (pingPong == 0) {\n            for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                if (work[j4 - 2] == 0.0) {\n                    work[j4] = 0.0;\n                    d = work[j4 + 1];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 1]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4 + 1])) {\n                    final double tmp = work[j4 + 1] / work[j4 - 2];\n                    work[j4] = work[j4 - 1] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n                    d *= work[j4 + 1] / work[j4 - 2];\n                }\n                dMin = java.lang.Math.min(dMin, d);\n                eMin = java.lang.Math.min(eMin, work[j4]);\n            }\n        } else {\n            for (int j4 = (4 * start) + 3; j4 < (4 * (end - 3)); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                if (work[j4 - 3] == 0.0) {\n                    work[j4 - 1] = 0.0;\n                    d = work[j4 + 2];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 + 2]) < work[j4 - 3]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 3]) < work[j4 + 2])) {\n                    final double tmp = work[j4 + 2] / work[j4 - 3];\n                    work[j4 - 1] = work[j4] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n                    d *= work[j4 + 2] / work[j4 - 3];\n                }\n                dMin = java.lang.Math.min(dMin, d);\n                eMin = java.lang.Math.min(eMin, work[j4 - 1]);\n            }\n        }\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = ((4 * (end - 2)) - pingPong) - 1;\n        int j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN1 = work[j4p2 + 2];\n            dMin = dN1;\n            eMin = 0.0;\n        } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN1 = dN2 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n        }\n        dMin = java.lang.Math.min(dMin, dN1);\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = (j4 + (2 * pingPong)) - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN = work[j4p2 + 2];\n            dMin = dN;\n            eMin = 0.0;\n        } else if (((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4p2 + 2]) < work[j4 - 2]) && ((org.apache.commons.math.util.MathUtils.SAFE_MIN * work[j4 - 2]) < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN = dN1 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n        }\n        dMin = java.lang.Math.min(dMin, dN);\n        work[j4 + 2] = dN;\n        work[((4 * end) - pingPong) - 1] = eMin;\n    }\n\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.01;\n        final double cnst3 = 1.05;\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n        int nn = ((4 * end) + pingPong) - 1;\n        switch (deflated) {\n            case 0 :\n                if ((dMin == dN) || (dMin == dN1)) {\n                    double b1 = java.lang.Math.sqrt(work[nn - 3]) * java.lang.Math.sqrt(work[nn - 5]);\n                    double b2 = java.lang.Math.sqrt(work[nn - 7]) * java.lang.Math.sqrt(work[nn - 9]);\n                    double a2 = work[nn - 7] + work[nn - 5];\n                    if ((dMin == dN) && (dMin1 == dN1)) {\n                        final double gap2 = (dMin2 - a2) - (dMin2 * 0.25);\n                        final double gap1 = (a2 - dN) - ((gap2 > 0.0) && (gap2 > b2) ? (b2 / gap2) * b2 : b1 + b2);\n                        if ((gap1 > 0.0) && (gap1 > b1)) {\n                            tau = java.lang.Math.max(dN - ((b1 / gap1) * b1), 0.5 * dMin);\n                            tType = -2;\n                        } else {\n                            double s = 0.0;\n                            if (dN > b1) {\n                                s = dN - b1;\n                            }\n                            if (a2 > (b1 + b2)) {\n                                s = java.lang.Math.min(s, a2 - (b1 + b2));\n                            }\n                            tau = java.lang.Math.max(s, 0.333 * dMin);\n                            tType = -3;\n                        }\n                    } else {\n                        tType = -4;\n                        double s = 0.25 * dMin;\n                        double gam;\n                        int np;\n                        if (dMin == dN) {\n                            gam = dN;\n                            a2 = 0.0;\n                            if (work[nn - 5] > work[nn - 7]) {\n                                return;\n                            }\n                            b2 = work[nn - 5] / work[nn - 7];\n                            np = nn - 9;\n                        } else {\n                            np = nn - (2 * pingPong);\n                            b2 = work[np - 2];\n                            gam = dN1;\n                            if (work[np - 4] > work[np - 2]) {\n                                return;\n                            }\n                            a2 = work[np - 4] / work[np - 2];\n                            if (work[nn - 9] > work[nn - 11]) {\n                                return;\n                            }\n                            b2 = work[nn - 9] / work[nn - 11];\n                            np = nn - 13;\n                        }\n                        a2 = a2 + b2;\n                        for (int i4 = np; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (b2 == 0.0) {\n                                break;\n                            }\n                            b1 = b2;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b2 = b2 * (work[i4] / work[i4 - 2]);\n                            a2 = a2 + b2;\n                            if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\n                                break;\n                            }\n                        }\n                        a2 = cnst3 * a2;\n                        if (a2 < cnst1) {\n                            s = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);\n                        }\n                        tau = s;\n                    }\n                } else if (dMin == dN2) {\n                    tType = -5;\n                    double s = 0.25 * dMin;\n                    final int np = nn - (2 * pingPong);\n                    double b1 = work[np - 2];\n                    double b2 = work[np - 6];\n                    final double gam = dN2;\n                    if ((work[np - 8] > b2) || (work[np - 4] > b1)) {\n                        return;\n                    }\n                    double a2 = (work[np - 8] / b2) * (1 + (work[np - 4] / b1));\n                    if ((end - start) > 3) {\n                        b2 = work[nn - 13] / work[nn - 15];\n                        a2 = a2 + b2;\n                        for (int i4 = nn - 17; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (b2 == 0.0) {\n                                break;\n                            }\n                            b1 = b2;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b2 = b2 * (work[i4] / work[i4 - 2]);\n                            a2 = a2 + b2;\n                            if (((100 * java.lang.Math.max(b2, b1)) < a2) || (cnst1 < a2)) {\n                                break;\n                            }\n                        }\n                        a2 = cnst3 * a2;\n                    }\n                    if (a2 < cnst1) {\n                        tau = (gam * (1 - java.lang.Math.sqrt(a2))) / (1 + a2);\n                    } else {\n                        tau = s;\n                    }\n                } else {\n                    if (tType == (-6)) {\n                        g += 0.333 * (1 - g);\n                    } else if (tType == (-18)) {\n                        g = 0.25 * 0.333;\n                    } else {\n                        g = 0.25;\n                    }\n                    tau = g * dMin;\n                    tType = -6;\n                }\n                break;\n            case 1 :\n                if ((dMin1 == dN1) && (dMin2 == dN2)) {\n                    tType = -7;\n                    double s = 0.333 * dMin1;\n                    if (work[nn - 5] > work[nn - 7]) {\n                        return;\n                    }\n                    double b1 = work[nn - 5] / work[nn - 7];\n                    double b2 = b1;\n                    if (b2 != 0.0) {\n                        for (int i4 = ((4 * end) - 10) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            final double oldB1 = b1;\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b1 = b1 * (work[i4] / work[i4 - 2]);\n                            b2 = b2 + b1;\n                            if ((100 * java.lang.Math.max(b1, oldB1)) < b2) {\n                                break;\n                            }\n                        }\n                    }\n                    b2 = java.lang.Math.sqrt(cnst3 * b2);\n                    final double a2 = dMin1 / (1 + (b2 * b2));\n                    final double gap2 = (0.5 * dMin2) - a2;\n                    if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\n                        tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));\n                    } else {\n                        tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\n                        tType = -8;\n                    }\n                } else {\n                    tau = 0.25 * dMin1;\n                    if (dMin1 == dN1) {\n                        tau = 0.5 * dMin1;\n                    }\n                    tType = -9;\n                }\n                break;\n            case 2 :\n                if ((dMin2 == dN2) && ((2 * work[nn - 5]) < work[nn - 7])) {\n                    tType = -10;\n                    final double s = 0.333 * dMin2;\n                    if (work[nn - 5] > work[nn - 7]) {\n                        return;\n                    }\n                    double b1 = work[nn - 5] / work[nn - 7];\n                    double b2 = b1;\n                    if (b2 != 0.0) {\n                        for (int i4 = ((4 * end) - 9) + pingPong; i4 >= (((4 * start) + 2) + pingPong); i4 -= 4) {\n                            if (work[i4] > work[i4 - 2]) {\n                                return;\n                            }\n                            b1 *= work[i4] / work[i4 - 2];\n                            b2 += b1;\n                            if ((100 * b1) < b2) {\n                                break;\n                            }\n                        }\n                    }\n                    b2 = java.lang.Math.sqrt(cnst3 * b2);\n                    final double a2 = dMin2 / (1 + (b2 * b2));\n                    final double gap2 = ((work[nn - 7] + work[nn - 9]) - (java.lang.Math.sqrt(work[nn - 11]) * java.lang.Math.sqrt(work[nn - 9]))) - a2;\n                    if ((gap2 > 0.0) && (gap2 > (b2 * a2))) {\n                        tau = java.lang.Math.max(s, a2 * (1 - (((cnst2 * a2) * (b2 / gap2)) * b2)));\n                    } else {\n                        tau = java.lang.Math.max(s, a2 * (1 - (cnst2 * b2)));\n                    }\n                } else {\n                    tau = 0.25 * dMin2;\n                    tType = -11;\n                }\n                break;\n            default :\n                tau = 0.0;\n                tType = -12;\n        }\n    }\n\n    private void updateSigma(final double shift) {\n        if (shift < sigma) {\n            sigmaLow += shift;\n            final double t = sigma + sigmaLow;\n            sigmaLow -= t - sigma;\n            sigma = t;\n        } else {\n            final double t = sigma + shift;\n            sigmaLow += sigma - (t - shift);\n            sigma = t;\n        }\n    }\n\n    private void findEigenVectors() {\n        final int m = main.length;\n        eigenvectors = new org.apache.commons.math.linear.ArrayRealVector[m];\n        final double[] d = new double[m];\n        final double[] l = new double[m - 1];\n        final double mu = ((realEigenvalues[m - 1] <= 0) && (realEigenvalues[0] > 0)) ? 0.5 - realEigenvalues[m - 1] : 0;\n        double di = main[0] + mu;\n        d[0] = di;\n        for (int i = 1; i < m; ++i) {\n            final double eiM1 = secondary[i - 1];\n            final double ratio = eiM1 / di;\n            di = (main[i] - (eiM1 * ratio)) + mu;\n            l[i - 1] = ratio;\n            d[i] = di;\n        }\n        for (int i = 0; i < m; ++i) {\n            eigenvectors[i] = findEigenvector(realEigenvalues[i] + mu, d, l);\n        }\n    }\n\n    private org.apache.commons.math.linear.ArrayRealVector findEigenvector(final double eigenvalue, final double[] d, final double[] l) {\n        final int m = main.length;\n        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n        int r = m - 1;\n        double minG = java.lang.Math.abs((work[6 * r] + work[(6 * r) + 3]) + eigenvalue);\n        int sixI = 0;\n        for (int i = 0; i < (m - 1); ++i) {\n            final double absG = java.lang.Math.abs(work[sixI] + ((d[i] * work[sixI + 9]) / work[sixI + 10]));\n            if (absG < minG) {\n                r = i;\n                minG = absG;\n            }\n            sixI += 6;\n        }\n        double[] eigenvector = new double[m];\n        double n2 = 1;\n        eigenvector[r] = 1;\n        double z = 1;\n        for (int i = r - 1; i >= 0; --i) {\n            z *= -work[(6 * i) + 2];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        z = 1;\n        for (int i = r + 1; i < m; ++i) {\n            z *= -work[(6 * i) - 1];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        final double inv = 1.0 / java.lang.Math.sqrt(n2);\n        for (int i = 0; i < m; ++i) {\n            eigenvector[i] *= inv;\n        }\n        return transformer == null ? new org.apache.commons.math.linear.ArrayRealVector(eigenvector, false) : new org.apache.commons.math.linear.ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n    }\n\n    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double si = -lambda;\n        int sixI = 0;\n        for (int i = 0; i < nM1; ++i) {\n            final double di = d[i];\n            final double li = l[i];\n            final double diP1 = di + si;\n            final double liP1 = (li * di) / diP1;\n            work[sixI] = si;\n            work[sixI + 1] = diP1;\n            work[sixI + 2] = liP1;\n            si = ((li * liP1) * si) - lambda;\n            sixI += 6;\n        }\n        work[(6 * nM1) + 1] = d[nM1] + si;\n        work[6 * nM1] = si;\n    }\n\n    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l, final double lambda) {\n        final int nM1 = d.length - 1;\n        double pi = d[nM1] - lambda;\n        int sixI = 6 * (nM1 - 1);\n        for (int i = nM1 - 1; i >= 0; --i) {\n            final double di = d[i];\n            final double li = l[i];\n            final double diP1 = ((di * li) * li) + pi;\n            final double t = di / diP1;\n            work[sixI + 9] = pi;\n            work[sixI + 10] = diP1;\n            work[sixI + 5] = li * t;\n            pi = (pi * t) - lambda;\n            sixI -= 6;\n        }\n        work[3] = pi;\n        work[4] = pi;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "for (int i = 0; i < j; i += 4) {\n    for (int k = 0; k < 4; k += step) {\n        final double tmp = work[i + k];\n        work[i + k] = work[j - k];\n        work[j - k] = tmp;\n    }\n    j -= 4;\n}",
            "src_parent": "{\n    int j = (4 * n) - 1;\n    for (int i = 0; i < j; i += 4) {\n        for (int k = 0; k < 4; k += step) {\n            final double tmp = work[i + k];\n            work[i + k] = work[j - k];\n            work[j - k] = tmp;\n        }\n        j -= 4;\n    }\n    return true;\n}",
            "src_parent_type": "Block",
            "src_type": "For"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "eMin = 0.0",
            "src_parent": "{\n    work[j4] = 0.0;\n    dN = work[j4p2 + 2];\n    dMin = dN;\n    eMin = 0.0;\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "TypeReference",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.math.linear.RealVector",
            "dst_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    return eigenvectors[i].copy();\n}",
            "dst_parent_type": "Method",
            "dst_type": "TypeReference",
            "operator": "MOV",
            "src": "org.apache.commons.math.linear.RealVector",
            "src_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    if (cachedVt == null) {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        final int m = eigenvectors.length;\n        cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n        for (int k = 0; k < m; ++k) {\n            cachedVt.setRowVector(k, eigenvectors[k]);\n        }\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent_type": "Method",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "TypeReference",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "java.lang.ArrayIndexOutOfBoundsException",
            "dst_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    return eigenvectors[i].copy();\n}",
            "dst_parent_type": "Method",
            "dst_type": "TypeReference",
            "operator": "MOV",
            "src": "java.lang.ArrayIndexOutOfBoundsException",
            "src_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    if (cachedVt == null) {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        final int m = eigenvectors.length;\n        cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n        for (int k = 0; k < m; ++k) {\n            cachedVt.setRowVector(k, eigenvectors[k]);\n        }\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent_type": "Method",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "TypeReference",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.math.linear.InvalidMatrixException",
            "dst_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    return eigenvectors[i].copy();\n}",
            "dst_parent_type": "Method",
            "dst_type": "TypeReference",
            "operator": "MOV",
            "src": "org.apache.commons.math.linear.InvalidMatrixException",
            "src_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    if (cachedVt == null) {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        final int m = eigenvectors.length;\n        cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n        for (int k = 0; k < m; ++k) {\n            cachedVt.setRowVector(k, eigenvectors[k]);\n        }\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent_type": "Method",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "VirtualElement",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "VE: Modifiers_Method",
            "dst_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    return eigenvectors[i].copy();\n}",
            "dst_parent_type": "Method",
            "dst_type": "VirtualEle",
            "operator": "MOV",
            "src": "VE: Modifiers_Method",
            "src_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    if (cachedVt == null) {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        final int m = eigenvectors.length;\n        cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n        for (int k = 0; k < m; ++k) {\n            cachedVt.setRowVector(k, eigenvectors[k]);\n        }\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent_type": "Method",
            "src_type": "VirtualEle"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Parameter",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "final int i",
            "dst_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    return eigenvectors[i].copy();\n}",
            "dst_parent_type": "Method",
            "dst_type": "Parameter",
            "operator": "MOV",
            "src": "final int i",
            "src_parent": "public org.apache.commons.math.linear.RealVector getEigenvector(final int i) throws java.lang.ArrayIndexOutOfBoundsException, org.apache.commons.math.linear.InvalidMatrixException {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    if (cachedVt == null) {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        final int m = eigenvectors.length;\n        cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n        for (int k = 0; k < m; ++k) {\n            cachedVt.setRowVector(k, eigenvectors[k]);\n        }\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent_type": "Method",
            "src_type": "Parameter"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if (eigenvectors == null) {\n    findEigenVectors();\n}",
            "dst_parent": "{\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    return eigenvectors[i].copy();\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if (eigenvectors == null) {\n    findEigenVectors();\n}",
            "src_parent": "{\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    if (cachedVt == null) {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        final int m = eigenvectors.length;\n        cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n        for (int k = 0; k < m; ++k) {\n            cachedVt.setRowVector(k, eigenvectors[k]);\n        }\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "return eigenvectors[i].copy()",
            "dst_parent": "{\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    return eigenvectors[i].copy();\n}",
            "dst_parent_type": "Block",
            "dst_type": "Return",
            "operator": "MOV",
            "src": "return eigenvectors[i].copy()",
            "src_parent": "{\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    if (cachedVt == null) {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        final int m = eigenvectors.length;\n        cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n        for (int k = 0; k < m; ++k) {\n            cachedVt.setRowVector(k, eigenvectors[k]);\n        }\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent_type": "Block",
            "src_type": "Return"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "VirtualElement",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "VE: Modifiers_Method",
            "dst_parent": "private boolean flipIfWarranted(final int n, final int step) {\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "dst_parent_type": "Method",
            "dst_type": "VirtualEle",
            "operator": "MOV",
            "src": "VE: Modifiers_Method",
            "src_parent": "private boolean flipIfWarranted(final int n, final int step) {\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        tau = 0.0;\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "src_parent_type": "Method",
            "src_type": "VirtualEle"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Parameter",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "final int n",
            "dst_parent": "private boolean flipIfWarranted(final int n, final int step) {\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "dst_parent_type": "Method",
            "dst_type": "Parameter",
            "operator": "MOV",
            "src": "final int n",
            "src_parent": "private boolean flipIfWarranted(final int n, final int step) {\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        tau = 0.0;\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "src_parent_type": "Method",
            "src_type": "Parameter"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Parameter",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "final int step",
            "dst_parent": "private boolean flipIfWarranted(final int n, final int step) {\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "dst_parent_type": "Method",
            "dst_type": "Parameter",
            "operator": "MOV",
            "src": "final int step",
            "src_parent": "private boolean flipIfWarranted(final int n, final int step) {\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        tau = 0.0;\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "src_parent_type": "Method",
            "src_type": "Parameter"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n    int j = (4 * n) - 1;\n    for (int i = 0; i < j; i += 4) {\n        for (int k = 0; k < 4; k += step) {\n            final double tmp = work[i + k];\n            work[i + k] = work[j - k];\n            work[j - k] = tmp;\n        }\n        j -= 4;\n    }\n    return true;\n}",
            "dst_parent": "{\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if (cachedVt == null) {\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    final int m = eigenvectors.length;\n    cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n    for (int k = 0; k < m; ++k) {\n        cachedVt.setRowVector(k, eigenvectors[k]);\n    }\n}",
            "src_parent": "{\n    if (eigenvectors == null) {\n        findEigenVectors();\n    }\n    if (cachedVt == null) {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        final int m = eigenvectors.length;\n        cachedVt = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(m, m);\n        for (int k = 0; k < m; ++k) {\n            cachedVt.setRowVector(k, eigenvectors[k]);\n        }\n    }\n    return eigenvectors[i].copy();\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "return false",
            "dst_parent": "{\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            for (int k = 0; k < 4; k += step) {\n                final double tmp = work[i + k];\n                work[i + k] = work[j - k];\n                work[j - k] = tmp;\n            }\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "dst_parent_type": "Block",
            "dst_type": "Return",
            "operator": "MOV",
            "src": "return false",
            "src_parent": "{\n    if ((1.5 * work[pingPong]) < work[(4 * (n - 1)) + pingPong]) {\n        tau = 0.0;\n        int j = (4 * n) - 1;\n        for (int i = 0; i < j; i += 4) {\n            j -= 4;\n        }\n        return true;\n    }\n    return false;\n}",
            "src_parent_type": "Block",
            "src_type": "Return"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "int j = (4 * n) - 1",
            "dst_parent": "{\n    int j = (4 * n) - 1;\n    for (int i = 0; i < j; i += 4) {\n        for (int k = 0; k < 4; k += step) {\n            final double tmp = work[i + k];\n            work[i + k] = work[j - k];\n            work[j - k] = tmp;\n        }\n        j -= 4;\n    }\n    return true;\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "int j = (4 * n) - 1",
            "src_parent": "{\n    tau = 0.0;\n    int j = (4 * n) - 1;\n    for (int i = 0; i < j; i += 4) {\n        j -= 4;\n    }\n    return true;\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "return true",
            "dst_parent": "{\n    int j = (4 * n) - 1;\n    for (int i = 0; i < j; i += 4) {\n        for (int k = 0; k < 4; k += step) {\n            final double tmp = work[i + k];\n            work[i + k] = work[j - k];\n            work[j - k] = tmp;\n        }\n        j -= 4;\n    }\n    return true;\n}",
            "dst_parent_type": "Block",
            "dst_type": "Return",
            "operator": "MOV",
            "src": "return true",
            "src_parent": "{\n    tau = 0.0;\n    int j = (4 * n) - 1;\n    for (int i = 0; i < j; i += 4) {\n        j -= 4;\n    }\n    return true;\n}",
            "src_parent_type": "Block",
            "src_type": "Return"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "int i = 0",
            "dst_parent": "for (int i = 0; i < j; i += 4) {\n    for (int k = 0; k < 4; k += step) {\n        final double tmp = work[i + k];\n        work[i + k] = work[j - k];\n        work[j - k] = tmp;\n    }\n    j -= 4;\n}",
            "dst_parent_type": "For",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "int i = 0",
            "src_parent": "for (int i = 0; i < j; i += 4) {\n    j -= 4;\n}",
            "src_parent_type": "For",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "i < j",
            "dst_parent": "for (int i = 0; i < j; i += 4) {\n    for (int k = 0; k < 4; k += step) {\n        final double tmp = work[i + k];\n        work[i + k] = work[j - k];\n        work[j - k] = tmp;\n    }\n    j -= 4;\n}",
            "dst_parent_type": "For",
            "dst_type": "BinaryOperator",
            "operator": "MOV",
            "src": "i < j",
            "src_parent": "for (int i = 0; i < j; i += 4) {\n    j -= 4;\n}",
            "src_parent_type": "For",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "i += 4",
            "dst_parent": "for (int i = 0; i < j; i += 4) {\n    for (int k = 0; k < 4; k += step) {\n        final double tmp = work[i + k];\n        work[i + k] = work[j - k];\n        work[j - k] = tmp;\n    }\n    j -= 4;\n}",
            "dst_parent_type": "For",
            "dst_type": "OperatorAssignment",
            "operator": "MOV",
            "src": "i += 4",
            "src_parent": "for (int i = 0; i < j; i += 4) {\n    j -= 4;\n}",
            "src_parent_type": "For",
            "src_type": "OperatorAssignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "j -= 4",
            "dst_parent": "{\n    for (int k = 0; k < 4; k += step) {\n        final double tmp = work[i + k];\n        work[i + k] = work[j - k];\n        work[j - k] = tmp;\n    }\n    j -= 4;\n}",
            "dst_parent_type": "Block",
            "dst_type": "OperatorAssignment",
            "operator": "MOV",
            "src": "j -= 4",
            "src_parent": "{\n    j -= 4;\n}",
            "src_parent_type": "Block",
            "src_type": "OperatorAssignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "int k = 0",
            "dst_parent": "for (int k = 0; k < 4; k += step) {\n    final double tmp = work[i + k];\n    work[i + k] = work[j - k];\n    work[j - k] = tmp;\n}",
            "dst_parent_type": "For",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "int k = 0",
            "src_parent": "for (int k = 0; k < m; ++k) {\n    cachedVt.setRowVector(k, eigenvectors[k]);\n}",
            "src_parent_type": "For",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "For",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "4",
            "dst_parent": "k < 4",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "Literal",
            "operator": "MOV",
            "src": "null",
            "src_parent": "eigenvectors == null",
            "src_parent_type": "BinaryOperator",
            "src_type": "Literal"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "For",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "double",
            "dst_parent": "final double tmp = work[i + k]",
            "dst_parent_type": "LocalVariable",
            "dst_type": "TypeReference",
            "operator": "MOV",
            "src": "int",
            "src_parent": "final int m = eigenvectors.length",
            "src_parent_type": "LocalVariable",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "For",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "VE: Modifiers_LocalVariable",
            "dst_parent": "final double tmp = work[i + k]",
            "dst_parent_type": "LocalVariable",
            "dst_type": "VirtualEle",
            "operator": "MOV",
            "src": "VE: Modifiers_LocalVariable",
            "src_parent": "final int m = eigenvectors.length",
            "src_parent_type": "LocalVariable",
            "src_type": "VirtualEle"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "For",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.math.linear.EigenDecompositionImpl",
            "dst_parent": "",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "MOV",
            "src": "org.apache.commons.math.linear.EigenDecompositionImpl",
            "src_parent": "",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "k",
            "dst_parent": "i + k",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "k",
            "src_parent": "k < m",
            "src_parent_type": "BinaryOperator",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "For",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.math.linear.EigenDecompositionImpl",
            "dst_parent": "",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "MOV",
            "src": "org.apache.commons.math.linear.EigenDecompositionImpl",
            "src_parent": "",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "For",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.math.linear.EigenDecompositionImpl",
            "dst_parent": "",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "MOV",
            "src": "org.apache.commons.math.linear.EigenDecompositionImpl",
            "src_parent": "",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        }
      ],
      "file_name": "EigenDecompositionImpl"
    }
  ],
  "id": "Arja_patch_Defects4J_Math_80_0_268"
}