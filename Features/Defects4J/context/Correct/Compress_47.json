{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "(org.apache.commons.compress.archivers.zip.ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze)) && supportsCompressedSizeFor(ze)",
            "src_parent": "return (org.apache.commons.compress.archivers.zip.ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze)) && supportsCompressedSizeFor(ze)",
            "src_parent_type": "Return",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "if (!supportsCompressedSizeFor(current.entry)) {\n    throw new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException(org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry);\n}",
            "src_parent": "{\n    if (closed) {\n        throw new java.io.IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    if ((((offset > buffer.length) || (length < 0)) || (offset < 0)) || ((buffer.length - offset) < length)) {\n        throw new java.lang.ArrayIndexOutOfBoundsException();\n    }\n    org.apache.commons.compress.archivers.zip.ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException(org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    if (!supportsCompressedSizeFor(current.entry)) {\n        throw new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException(org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if ((((current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.UNSHRINKING.getCode()) || (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.IMPLODING.getCode())) || (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.ENHANCED_DEFLATED.getCode())) || (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.BZIP2.getCode())) {\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException(org.apache.commons.compress.archivers.zip.ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read >= 0) {\n        current.crc.update(buffer, offset, read);\n    }\n    return read;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "private boolean supportsCompressedSizeFor(final org.apache.commons.compress.archivers.zip.ZipArchiveEntry entry) {\n    return (((entry.getCompressedSize() != org.apache.commons.compress.archivers.ArchiveEntry.SIZE_UNKNOWN) || (entry.getMethod() == java.util.zip.ZipEntry.DEFLATED)) || (entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.ENHANCED_DEFLATED.getCode())) || ((entry.getGeneralPurposeBit().usesDataDescriptor() && allowStoredEntriesWithDataDescriptor) && (entry.getMethod() == java.util.zip.ZipEntry.STORED));\n}",
            "src_parent": "public class ZipArchiveInputStream extends org.apache.commons.compress.archivers.ArchiveInputStream {\n    private final org.apache.commons.compress.archivers.zip.ZipEncoding zipEncoding;\n\n    final java.lang.String encoding;\n\n    private final boolean useUnicodeExtraFields;\n\n    private final java.io.InputStream in;\n\n    private final java.util.zip.Inflater inf = new java.util.zip.Inflater(true);\n\n    private final java.nio.ByteBuffer buf = java.nio.ByteBuffer.allocate(org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.BUFFER_SIZE);\n\n    private org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.CurrentEntry current = null;\n\n    private boolean closed = false;\n\n    private boolean hitCentralDirectory = false;\n\n    private java.io.ByteArrayInputStream lastStoredEntry = null;\n\n    private boolean allowStoredEntriesWithDataDescriptor = false;\n\n    private static final int LFH_LEN = 30;\n\n    private static final int CFH_LEN = 46;\n\n    private static final long TWO_EXP_32 = org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC + 1;\n\n    private final byte[] lfhBuf = new byte[org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.LFH_LEN];\n\n    private final byte[] skipBuf = new byte[1024];\n\n    private final byte[] shortBuf = new byte[org.apache.commons.compress.archivers.zip.ZipConstants.SHORT];\n\n    private final byte[] wordBuf = new byte[org.apache.commons.compress.archivers.zip.ZipConstants.WORD];\n\n    private final byte[] twoDwordBuf = new byte[2 * org.apache.commons.compress.archivers.zip.ZipConstants.DWORD];\n\n    private int entriesRead = 0;\n\n    public ZipArchiveInputStream(final java.io.InputStream inputStream) {\n        this(inputStream, org.apache.commons.compress.archivers.zip.ZipEncodingHelper.UTF8);\n    }\n\n    public ZipArchiveInputStream(final java.io.InputStream inputStream, final java.lang.String encoding) {\n        this(inputStream, encoding, true);\n    }\n\n    public ZipArchiveInputStream(final java.io.InputStream inputStream, final java.lang.String encoding, final boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    public ZipArchiveInputStream(final java.io.InputStream inputStream, final java.lang.String encoding, final boolean useUnicodeExtraFields, final boolean allowStoredEntriesWithDataDescriptor) {\n        this.encoding = encoding;\n        zipEncoding = org.apache.commons.compress.archivers.zip.ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new java.io.PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n        buf.limit(0);\n    }\n\n    public org.apache.commons.compress.archivers.zip.ZipArchiveEntry getNextZipEntry() throws java.io.IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n        long currentHeaderOffset = getBytesRead();\n        try {\n            if (firstEntry) {\n                readFirstLocalFileHeader(lfhBuf);\n            } else {\n                readFully(lfhBuf);\n            }\n        } catch (final java.io.EOFException e) {\n            return null;\n        }\n        final org.apache.commons.compress.archivers.zip.ZipLong sig = new org.apache.commons.compress.archivers.zip.ZipLong(lfhBuf);\n        if (sig.equals(org.apache.commons.compress.archivers.zip.ZipLong.CFH_SIG) || sig.equals(org.apache.commons.compress.archivers.zip.ZipLong.AED_SIG)) {\n            hitCentralDirectory = true;\n            skipRemainderOfArchive();\n            return null;\n        }\n        if (!sig.equals(org.apache.commons.compress.archivers.zip.ZipLong.LFH_SIG)) {\n            throw new java.util.zip.ZipException(java.lang.String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n        }\n        int off = org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n        current = new org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.CurrentEntry();\n        final int versionMadeBy = org.apache.commons.compress.archivers.zip.ZipShort.getValue(lfhBuf, off);\n        off += org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n        current.entry.setPlatform((versionMadeBy >> org.apache.commons.compress.archivers.zip.ZipFile.BYTE_SHIFT) & org.apache.commons.compress.archivers.zip.ZipFile.NIBLET_MASK);\n        final org.apache.commons.compress.archivers.zip.GeneralPurposeBit gpFlag = org.apache.commons.compress.archivers.zip.GeneralPurposeBit.parse(lfhBuf, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final org.apache.commons.compress.archivers.zip.ZipEncoding entryEncoding = (hasUTF8Flag) ? org.apache.commons.compress.archivers.zip.ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n        off += org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n        current.entry.setMethod(org.apache.commons.compress.archivers.zip.ZipShort.getValue(lfhBuf, off));\n        off += org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n        final long time = org.apache.commons.compress.archivers.zip.ZipUtil.dosToJavaTime(org.apache.commons.compress.archivers.zip.ZipLong.getValue(lfhBuf, off));\n        current.entry.setTime(time);\n        off += org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n        org.apache.commons.compress.archivers.zip.ZipLong size = null;\n        org.apache.commons.compress.archivers.zip.ZipLong cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(org.apache.commons.compress.archivers.zip.ZipLong.getValue(lfhBuf, off));\n            off += org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n            cSize = new org.apache.commons.compress.archivers.zip.ZipLong(lfhBuf, off);\n            off += org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n            size = new org.apache.commons.compress.archivers.zip.ZipLong(lfhBuf, off);\n            off += org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n        } else {\n            off += 3 * org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n        }\n        final int fileNameLen = org.apache.commons.compress.archivers.zip.ZipShort.getValue(lfhBuf, off);\n        off += org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n        final int extraLen = org.apache.commons.compress.archivers.zip.ZipShort.getValue(lfhBuf, off);\n        off += org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n        if (hasUTF8Flag) {\n            current.entry.setNameSource(org.apache.commons.compress.archivers.zip.ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n        }\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n        if ((!hasUTF8Flag) && useUnicodeExtraFields) {\n            org.apache.commons.compress.archivers.zip.ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n        processZip64Extra(size, cSize);\n        current.entry.setLocalHeaderOffset(currentHeaderOffset);\n        current.entry.setDataOffset(getBytesRead());\n        current.entry.setStreamContiguous(true);\n        org.apache.commons.compress.archivers.zip.ZipMethod m = org.apache.commons.compress.archivers.zip.ZipMethod.getMethodByCode(current.entry.getMethod());\n        if (current.entry.getCompressedSize() != org.apache.commons.compress.archivers.ArchiveEntry.SIZE_UNKNOWN) {\n            if ((org.apache.commons.compress.archivers.zip.ZipUtil.canHandleEntryData(current.entry) && (m != org.apache.commons.compress.archivers.zip.ZipMethod.STORED)) && (m != org.apache.commons.compress.archivers.zip.ZipMethod.DEFLATED)) {\n                java.io.InputStream bis = new org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.BoundedInputStream(in, current.entry.getCompressedSize());\n                switch (m) {\n                    case UNSHRINKING :\n                        current.in = new org.apache.commons.compress.archivers.zip.UnshrinkingInputStream(bis);\n                        break;\n                    case IMPLODING :\n                        current.in = new org.apache.commons.compress.archivers.zip.ExplodingInputStream(current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis);\n                        break;\n                    case BZIP2 :\n                        current.in = new org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream(bis);\n                        break;\n                    case ENHANCED_DEFLATED :\n                        current.in = new org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream(bis);\n                        break;\n                    default :\n                        break;\n                }\n            }\n        } else if (m == org.apache.commons.compress.archivers.zip.ZipMethod.ENHANCED_DEFLATED) {\n            current.in = new org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream(in);\n        }\n        entriesRead++;\n        return current.entry;\n    }\n\n    private void readFirstLocalFileHeader(final byte[] lfh) throws java.io.IOException {\n        readFully(lfh);\n        final org.apache.commons.compress.archivers.zip.ZipLong sig = new org.apache.commons.compress.archivers.zip.ZipLong(lfh);\n        if (sig.equals(org.apache.commons.compress.archivers.zip.ZipLong.DD_SIG)) {\n            throw new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException(org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n        if (sig.equals(org.apache.commons.compress.archivers.zip.ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n            final byte[] missedLfhBytes = new byte[4];\n            readFully(missedLfhBytes);\n            java.lang.System.arraycopy(lfh, 4, lfh, 0, org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.LFH_LEN - 4);\n            java.lang.System.arraycopy(missedLfhBytes, 0, lfh, org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.LFH_LEN - 4, 4);\n        }\n    }\n\n    private void processZip64Extra(final org.apache.commons.compress.archivers.zip.ZipLong size, final org.apache.commons.compress.archivers.zip.ZipLong cSize) {\n        final org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField z64 = ((org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField) (current.entry.getExtraField(org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField.HEADER_ID)));\n        current.usesZip64 = z64 != null;\n        if (!current.hasDataDescriptor) {\n            if ((z64 != null) && (cSize.equals(org.apache.commons.compress.archivers.zip.ZipLong.ZIP64_MAGIC) || size.equals(org.apache.commons.compress.archivers.zip.ZipLong.ZIP64_MAGIC))) {\n                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\n                current.entry.setSize(z64.getSize().getLongValue());\n            } else {\n                current.entry.setCompressedSize(cSize.getValue());\n                current.entry.setSize(size.getValue());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public org.apache.commons.compress.archivers.ArchiveEntry getNextEntry() throws java.io.IOException {\n        return getNextZipEntry();\n    }\n\n    @java.lang.Override\n    public boolean canReadEntryData(final org.apache.commons.compress.archivers.ArchiveEntry ae) {\n        if (ae instanceof org.apache.commons.compress.archivers.zip.ZipArchiveEntry) {\n            final org.apache.commons.compress.archivers.zip.ZipArchiveEntry ze = ((org.apache.commons.compress.archivers.zip.ZipArchiveEntry) (ae));\n            return (org.apache.commons.compress.archivers.zip.ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze)) && supportsCompressedSizeFor(ze);\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public int read(final byte[] buffer, final int offset, final int length) throws java.io.IOException {\n        if (closed) {\n            throw new java.io.IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return -1;\n        }\n        if ((((offset > buffer.length) || (length < 0)) || (offset < 0)) || ((buffer.length - offset) < length)) {\n            throw new java.lang.ArrayIndexOutOfBoundsException();\n        }\n        org.apache.commons.compress.archivers.zip.ZipUtil.checkRequestedFeatures(current.entry);\n        if (!supportsDataDescriptorFor(current.entry)) {\n            throw new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException(org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n        }\n        if (!supportsCompressedSizeFor(current.entry)) {\n            throw new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException(org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry);\n        }\n        int read;\n        if (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.STORED) {\n            read = readStored(buffer, offset, length);\n        } else if (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.DEFLATED) {\n            read = readDeflated(buffer, offset, length);\n        } else if ((((current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.UNSHRINKING.getCode()) || (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.IMPLODING.getCode())) || (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.ENHANCED_DEFLATED.getCode())) || (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.BZIP2.getCode())) {\n            read = current.in.read(buffer, offset, length);\n        } else {\n            throw new org.apache.commons.compress.archivers.zip.UnsupportedZipFeatureException(org.apache.commons.compress.archivers.zip.ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n        }\n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n        }\n        return read;\n    }\n\n    private int readStored(final byte[] buffer, final int offset, final int length) throws java.io.IOException {\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == (-1)) {\n                return -1;\n            }\n            buf.limit(l);\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n        int toRead = java.lang.Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            toRead = ((int) (csize - current.bytesRead));\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }\n\n    private int readDeflated(final byte[] buffer, final int offset, final int length) throws java.io.IOException {\n        final int read = readFromInflater(buffer, offset, length);\n        if (read <= 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (inf.needsDictionary()) {\n                throw new java.util.zip.ZipException(\"This archive needs a preset dictionary\" + (\" which is not supported by Commons\" + \" Compress.\"));\n            } else if (read == (-1)) {\n                throw new java.io.IOException(\"Truncated ZIP file\");\n            }\n        }\n        return read;\n    }\n\n    private int readFromInflater(final byte[] buffer, final int offset, final int length) throws java.io.IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                final int l = fill();\n                if (l > 0) {\n                    current.bytesReadFromStream += buf.limit();\n                } else if (l == (-1)) {\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (final java.util.zip.DataFormatException e) {\n                throw ((java.io.IOException) (new java.util.zip.ZipException(e.getMessage()).initCause(e)));\n            }\n        } while ((read == 0) && inf.needsInput() );\n        return read;\n    }\n\n    @java.lang.Override\n    public void close() throws java.io.IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                in.close();\n            } finally {\n                inf.end();\n            }\n        }\n    }\n\n    @java.lang.Override\n    public long skip(final long value) throws java.io.IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = read(skipBuf, 0, ((int) (skipBuf.length > rem ? rem : skipBuf.length)));\n                if (x == (-1)) {\n                    return skipped;\n                }\n                skipped += x;\n            } \n            return skipped;\n        }\n        throw new java.lang.IllegalArgumentException();\n    }\n\n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n        return ((org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.checksig(signature, org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.LFH_SIG) || org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.checksig(signature, org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.EOCD_SIG)) || org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.checksig(signature, org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.DD_SIG)) || org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.checksig(signature, org.apache.commons.compress.archivers.zip.ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(final byte[] signature, final byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void closeEntry() throws java.io.IOException {\n        if (closed) {\n            throw new java.io.IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n        if (currentEntryHasOutstandingBytes()) {\n            drainCurrentEntryData();\n        } else {\n            skip(java.lang.Long.MAX_VALUE);\n            final long inB = (current.entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.DEFLATED) ? getBytesInflated() : current.bytesRead;\n            final int diff = ((int) (current.bytesReadFromStream - inB));\n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n                current.bytesReadFromStream -= diff;\n            }\n            if (currentEntryHasOutstandingBytes()) {\n                drainCurrentEntryData();\n            }\n        }\n        if ((lastStoredEntry == null) && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    private boolean currentEntryHasOutstandingBytes() {\n        return (current.bytesReadFromStream <= current.entry.getCompressedSize()) && (!current.hasDataDescriptor);\n    }\n\n    private void drainCurrentEntryData() throws java.io.IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            final long n = in.read(buf.array(), 0, ((int) (java.lang.Math.min(buf.capacity(), remaining))));\n            if (n < 0) {\n                throw new java.io.EOFException(\"Truncated ZIP entry: \" + org.apache.commons.compress.utils.ArchiveUtils.sanitize(current.entry.getName()));\n            }\n            count(n);\n            remaining -= n;\n        } \n    }\n\n    private long getBytesInflated() {\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.TWO_EXP_32) {\n            while ((inB + org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.TWO_EXP_32) <= current.bytesReadFromStream) {\n                inB += org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.TWO_EXP_32;\n            } \n        }\n        return inB;\n    }\n\n    private int fill() throws java.io.IOException {\n        if (closed) {\n            throw new java.io.IOException(\"The stream is closed\");\n        }\n        final int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return length;\n    }\n\n    private void readFully(final byte[] b) throws java.io.IOException {\n        final int count = org.apache.commons.compress.utils.IOUtils.readFully(in, b);\n        count(count);\n        if (count < b.length) {\n            throw new java.io.EOFException();\n        }\n    }\n\n    private void readDataDescriptor() throws java.io.IOException {\n        readFully(wordBuf);\n        org.apache.commons.compress.archivers.zip.ZipLong val = new org.apache.commons.compress.archivers.zip.ZipLong(wordBuf);\n        if (org.apache.commons.compress.archivers.zip.ZipLong.DD_SIG.equals(val)) {\n            readFully(wordBuf);\n            val = new org.apache.commons.compress.archivers.zip.ZipLong(wordBuf);\n        }\n        current.entry.setCrc(val.getValue());\n        readFully(twoDwordBuf);\n        final org.apache.commons.compress.archivers.zip.ZipLong potentialSig = new org.apache.commons.compress.archivers.zip.ZipLong(twoDwordBuf, org.apache.commons.compress.archivers.zip.ZipConstants.DWORD);\n        if (potentialSig.equals(org.apache.commons.compress.archivers.zip.ZipLong.CFH_SIG) || potentialSig.equals(org.apache.commons.compress.archivers.zip.ZipLong.LFH_SIG)) {\n            pushback(twoDwordBuf, org.apache.commons.compress.archivers.zip.ZipConstants.DWORD, org.apache.commons.compress.archivers.zip.ZipConstants.DWORD);\n            current.entry.setCompressedSize(org.apache.commons.compress.archivers.zip.ZipLong.getValue(twoDwordBuf));\n            current.entry.setSize(org.apache.commons.compress.archivers.zip.ZipLong.getValue(twoDwordBuf, org.apache.commons.compress.archivers.zip.ZipConstants.WORD));\n        } else {\n            current.entry.setCompressedSize(org.apache.commons.compress.archivers.zip.ZipEightByteInteger.getLongValue(twoDwordBuf));\n            current.entry.setSize(org.apache.commons.compress.archivers.zip.ZipEightByteInteger.getLongValue(twoDwordBuf, org.apache.commons.compress.archivers.zip.ZipConstants.DWORD));\n        }\n    }\n\n    private boolean supportsDataDescriptorFor(final org.apache.commons.compress.archivers.zip.ZipArchiveEntry entry) {\n        return (((!entry.getGeneralPurposeBit().usesDataDescriptor()) || (allowStoredEntriesWithDataDescriptor && (entry.getMethod() == java.util.zip.ZipEntry.STORED))) || (entry.getMethod() == java.util.zip.ZipEntry.DEFLATED)) || (entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.ENHANCED_DEFLATED.getCode());\n    }\n\n    private boolean supportsCompressedSizeFor(final org.apache.commons.compress.archivers.zip.ZipArchiveEntry entry) {\n        return (((entry.getCompressedSize() != org.apache.commons.compress.archivers.ArchiveEntry.SIZE_UNKNOWN) || (entry.getMethod() == java.util.zip.ZipEntry.DEFLATED)) || (entry.getMethod() == org.apache.commons.compress.archivers.zip.ZipMethod.ENHANCED_DEFLATED.getCode())) || ((entry.getGeneralPurposeBit().usesDataDescriptor() && allowStoredEntriesWithDataDescriptor) && (entry.getMethod() == java.util.zip.ZipEntry.STORED));\n    }\n\n    private void readStoredEntry() throws java.io.IOException {\n        final java.io.ByteArrayOutputStream bos = new java.io.ByteArrayOutputStream();\n        int off = 0;\n        boolean done = false;\n        final int ddLen = (current.usesZip64) ? org.apache.commons.compress.archivers.zip.ZipConstants.WORD + (2 * org.apache.commons.compress.archivers.zip.ZipConstants.DWORD) : 3 * org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\n        while (!done) {\n            final int r = in.read(buf.array(), off, org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.BUFFER_SIZE - off);\n            if (r <= 0) {\n                throw new java.io.IOException(\"Truncated ZIP file\");\n            }\n            if ((r + off) < 4) {\n                off += r;\n                continue;\n            }\n            done = bufferContainsSignature(bos, off, r, ddLen);\n            if (!done) {\n                off = cacheBytesRead(bos, off, r, ddLen);\n            }\n        } \n        final byte[] b = bos.toByteArray();\n        lastStoredEntry = new java.io.ByteArrayInputStream(b);\n    }\n\n    private static final byte[] LFH = org.apache.commons.compress.archivers.zip.ZipLong.LFH_SIG.getBytes();\n\n    private static final byte[] CFH = org.apache.commons.compress.archivers.zip.ZipLong.CFH_SIG.getBytes();\n\n    private static final byte[] DD = org.apache.commons.compress.archivers.zip.ZipLong.DD_SIG.getBytes();\n\n    private boolean bufferContainsSignature(final java.io.ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen) throws java.io.IOException {\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; (!done) && (i < (lastRead - 4)); i++) {\n            if ((buf.array()[i] == org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.LFH[0]) && (buf.array()[i + 1] == org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.LFH[1])) {\n                if (((buf.array()[i + 2] == org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.LFH[2]) && (buf.array()[i + 3] == org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.LFH[3])) || ((buf.array()[i] == org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.CFH[2]) && (buf.array()[i + 3] == org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.CFH[3]))) {\n                    readTooMuch = ((offset + lastRead) - i) - expectedDDLen;\n                    done = true;\n                } else if ((buf.array()[i + 2] == org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.DD[2]) && (buf.array()[i + 3] == org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.DD[3])) {\n                    readTooMuch = (offset + lastRead) - i;\n                    done = true;\n                }\n                if (done) {\n                    pushback(buf.array(), (offset + lastRead) - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    private int cacheBytesRead(final java.io.ByteArrayOutputStream bos, int offset, final int lastRead, final int expecteDDLen) {\n        final int cacheable = ((offset + lastRead) - expecteDDLen) - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            java.lang.System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(final byte[] buf, final int offset, final int length) throws java.io.IOException {\n        ((java.io.PushbackInputStream) (in)).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    private void skipRemainderOfArchive() throws java.io.IOException {\n        realSkip((((long) (entriesRead)) * org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.CFH_LEN) - org.apache.commons.compress.archivers.zip.ZipArchiveInputStream.LFH_LEN);\n        findEocdRecord();\n        realSkip((((long) (org.apache.commons.compress.archivers.zip.ZipFile.MIN_EOCD_SIZE)) - org.apache.commons.compress.archivers.zip.ZipConstants.WORD) - org.apache.commons.compress.archivers.zip.ZipConstants.SHORT);\n        readFully(shortBuf);\n        realSkip(org.apache.commons.compress.archivers.zip.ZipShort.getValue(shortBuf));\n    }\n\n    private void findEocdRecord() throws java.io.IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || ((currentByte = readOneByte()) > (-1))) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == (-1)) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == (-1)) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if ((currentByte == (-1)) || (currentByte == org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.EOCD_SIG[3])) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        } \n    }\n\n    private void realSkip(final long value) throws java.io.IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = in.read(skipBuf, 0, ((int) (skipBuf.length > rem ? rem : skipBuf.length)));\n                if (x == (-1)) {\n                    return;\n                }\n                count(x);\n                skipped += x;\n            } \n            return;\n        }\n        throw new java.lang.IllegalArgumentException();\n    }\n\n    private int readOneByte() throws java.io.IOException {\n        final int b = in.read();\n        if (b != (-1)) {\n            count(1);\n        }\n        return b;\n    }\n\n    private boolean isFirstByteOfEocdSig(final int b) {\n        return b == org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream.EOCD_SIG[0];\n    }\n\n    private static final class CurrentEntry {\n        private final org.apache.commons.compress.archivers.zip.ZipArchiveEntry entry = new org.apache.commons.compress.archivers.zip.ZipArchiveEntry();\n\n        private boolean hasDataDescriptor;\n\n        private boolean usesZip64;\n\n        private long bytesRead;\n\n        private long bytesReadFromStream;\n\n        private final java.util.zip.CRC32 crc = new java.util.zip.CRC32();\n\n        private java.io.InputStream in;\n    }\n\n    private class BoundedInputStream extends java.io.InputStream {\n        private final java.io.InputStream in;\n\n        private final long max;\n\n        private long pos = 0;\n\n        public BoundedInputStream(final java.io.InputStream in, final long size) {\n            this.max = size;\n            this.in = in;\n        }\n\n        @java.lang.Override\n        public int read() throws java.io.IOException {\n            if ((max >= 0) && (pos >= max)) {\n                return -1;\n            }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @java.lang.Override\n        public int read(final byte[] b) throws java.io.IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @java.lang.Override\n        public int read(final byte[] b, final int off, final int len) throws java.io.IOException {\n            if ((max >= 0) && (pos >= max)) {\n                return -1;\n            }\n            final long maxRead = (max >= 0) ? java.lang.Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, ((int) (maxRead)));\n            if (bytesRead == (-1)) {\n                return -1;\n            }\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @java.lang.Override\n        public long skip(final long n) throws java.io.IOException {\n            final long toSkip = (max >= 0) ? java.lang.Math.min(n, max - pos) : n;\n            final long skippedBytes = in.skip(toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n\n        @java.lang.Override\n        public int available() throws java.io.IOException {\n            if ((max >= 0) && (pos >= max)) {\n                return 0;\n            }\n            return in.available();\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.compress.archivers.zip.ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze)",
            "dst_parent": "return org.apache.commons.compress.archivers.zip.ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze)",
            "dst_parent_type": "Return",
            "dst_type": "BinaryOperator",
            "operator": "MOV",
            "src": "(org.apache.commons.compress.archivers.zip.ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze))",
            "src_parent": "(org.apache.commons.compress.archivers.zip.ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze)) && supportsCompressedSizeFor(ze)",
            "src_parent_type": "BinaryOperator",
            "src_type": "BinaryOperator"
          }
        }
      ],
      "file_name": "ZipArchiveInputStream"
    }
  ],
  "id": "Compress_47"
}