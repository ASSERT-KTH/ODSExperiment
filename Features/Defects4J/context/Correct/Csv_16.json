{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.csv.CSVParser.1",
            "dst_parent": "this",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "UPD",
            "src": "org.apache.commons.csv.CSVParser.CSVRecordIterator",
            "src_parent": "this",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.csv.CSVParser.1",
            "dst_parent": "this",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "UPD",
            "src": "org.apache.commons.csv.CSVParser.CSVRecordIterator",
            "src_parent": "this",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.csv.CSVParser.1",
            "dst_parent": "this",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "UPD",
            "src": "org.apache.commons.csv.CSVParser.CSVRecordIterator",
            "src_parent": "this",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.csv.CSVParser.1",
            "dst_parent": "this",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "UPD",
            "src": "org.apache.commons.csv.CSVParser.CSVRecordIterator",
            "src_parent": "this",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.csv.CSVParser.1",
            "dst_parent": "this",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "UPD",
            "src": "org.apache.commons.csv.CSVParser.CSVRecordIterator",
            "src_parent": "this",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.csv.CSVParser.1",
            "dst_parent": "this",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "UPD",
            "src": "org.apache.commons.csv.CSVParser.CSVRecordIterator",
            "src_parent": "this",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.csv.CSVParser.1",
            "dst_parent": "this",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "UPD",
            "src": "org.apache.commons.csv.CSVParser.CSVRecordIterator",
            "src_parent": "this",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "private final org.apache.commons.csv.CSVParser.CSVRecordIterator csvRecordIterator;",
            "src_parent": "public final class CSVParser implements java.io.Closeable , java.lang.Iterable<org.apache.commons.csv.CSVRecord> {\n    @java.lang.SuppressWarnings(\"resource\")\n    public static org.apache.commons.csv.CSVParser parse(final java.io.File file, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(file, \"file\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.InputStreamReader(new java.io.FileInputStream(file), charset), format);\n    }\n\n    @java.lang.SuppressWarnings(\"resource\")\n    public static org.apache.commons.csv.CSVParser parse(final java.io.InputStream inputStream, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(inputStream, \"inputStream\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return org.apache.commons.csv.CSVParser.parse(new java.io.InputStreamReader(inputStream, charset), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.nio.file.Path path, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(path, \"path\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return org.apache.commons.csv.CSVParser.parse(java.nio.file.Files.newBufferedReader(path, charset), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        return new org.apache.commons.csv.CSVParser(reader, format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.lang.String string, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(string, \"string\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.StringReader(string), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.net.URL url, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(url, \"url\");\n        org.apache.commons.csv.Assertions.notNull(charset, \"charset\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private final org.apache.commons.csv.CSVFormat format;\n\n    private final java.util.Map<java.lang.String, java.lang.Integer> headerMap;\n\n    private final org.apache.commons.csv.Lexer lexer;\n\n    private final org.apache.commons.csv.CSVParser.CSVRecordIterator csvRecordIterator;\n\n    private final java.util.List<java.lang.String> recordList = new java.util.ArrayList<>();\n\n    private long recordNumber;\n\n    private final long characterOffset;\n\n    private final org.apache.commons.csv.Token reusableToken = new org.apache.commons.csv.Token();\n\n    public CSVParser(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        this(reader, format, 0, 1);\n    }\n\n    @java.lang.SuppressWarnings(\"resource\")\n    public CSVParser(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format, final long characterOffset, final long recordNumber) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(reader, \"reader\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        this.format = format;\n        this.lexer = new org.apache.commons.csv.Lexer(format, new org.apache.commons.csv.ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new org.apache.commons.csv.CSVParser.CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final java.lang.String input = this.reusableToken.content.toString();\n        final java.lang.String inputClean = (this.format.getTrim()) ? input.trim() : input;\n        if ((lastRecord && inputClean.isEmpty()) && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final java.lang.String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    @java.lang.Override\n    public void close() throws java.io.IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    public java.lang.String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    public java.util.Map<java.lang.String, java.lang.Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new java.util.LinkedHashMap<>(this.headerMap);\n    }\n\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    public java.util.List<org.apache.commons.csv.CSVRecord> getRecords() throws java.io.IOException {\n        org.apache.commons.csv.CSVRecord rec;\n        final java.util.List<org.apache.commons.csv.CSVRecord> records = new java.util.ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        } \n        return records;\n    }\n\n    private java.util.Map<java.lang.String, java.lang.Integer> initializeHeader() throws java.io.IOException {\n        java.util.Map<java.lang.String, java.lang.Integer> hdrMap = null;\n        final java.lang.String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = (this.format.getIgnoreHeaderCase()) ? new java.util.TreeMap<java.lang.String, java.lang.Integer>(java.lang.String.CASE_INSENSITIVE_ORDER) : new java.util.LinkedHashMap<java.lang.String, java.lang.Integer>();\n            java.lang.String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                final org.apache.commons.csv.CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final java.lang.String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = (header == null) || header.trim().isEmpty();\n                    if (containsHeader && ((!emptyHeader) || (!this.format.getAllowMissingColumnNames()))) {\n                        throw new java.lang.IllegalArgumentException(((\"The header contains a duplicate name: \\\"\" + header) + \"\\\" in \") + java.util.Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, java.lang.Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    @java.lang.Override\n    public java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    class CSVRecordIterator implements java.util.Iterator<org.apache.commons.csv.CSVRecord> {\n        private org.apache.commons.csv.CSVRecord current;\n\n        private org.apache.commons.csv.CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final java.io.IOException e) {\n                throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n            }\n        }\n\n        @java.lang.Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n            return this.current != null;\n        }\n\n        @java.lang.Override\n        public org.apache.commons.csv.CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n            }\n            org.apache.commons.csv.CSVRecord next = this.current;\n            this.current = null;\n            if (next == null) {\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new java.util.NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n            return next;\n        }\n\n        @java.lang.Override\n        public void remove() {\n            throw new java.lang.UnsupportedOperationException();\n        }\n    }\n\n    org.apache.commons.csv.CSVRecord nextRecord() throws java.io.IOException {\n        org.apache.commons.csv.CSVRecord result = null;\n        this.recordList.clear();\n        java.lang.StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n                case TOKEN :\n                    this.addRecordValue(false);\n                    break;\n                case EORECORD :\n                    this.addRecordValue(true);\n                    break;\n                case EOF :\n                    if (this.reusableToken.isReady) {\n                        this.addRecordValue(true);\n                    }\n                    break;\n                case INVALID :\n                    throw new java.io.IOException((\"(line \" + this.getCurrentLineNumber()) + \") invalid parse sequence\");\n                case COMMENT :\n                    if (sb == null) {\n                        sb = new java.lang.StringBuilder();\n                    } else {\n                        sb.append(org.apache.commons.csv.Constants.LF);\n                    }\n                    sb.append(this.reusableToken.content);\n                    this.reusableToken.type = org.apache.commons.csv.Token.Type.TOKEN;\n                    break;\n                default :\n                    throw new java.lang.IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == org.apache.commons.csv.Token.Type.TOKEN );\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final java.lang.String comment = (sb == null) ? null : sb.toString();\n            result = new org.apache.commons.csv.CSVRecord(this.recordList.toArray(new java.lang.String[this.recordList.size()]), this.headerMap, comment, this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "this.csvRecordIterator = new org.apache.commons.csv.CSVParser.CSVRecordIterator()",
            "src_parent": "{\n    org.apache.commons.csv.Assertions.notNull(reader, \"reader\");\n    org.apache.commons.csv.Assertions.notNull(format, \"format\");\n    this.format = format;\n    this.lexer = new org.apache.commons.csv.Lexer(format, new org.apache.commons.csv.ExtendedBufferedReader(reader));\n    this.csvRecordIterator = new org.apache.commons.csv.CSVParser.CSVRecordIterator();\n    this.headerMap = this.initializeHeader();\n    this.characterOffset = characterOffset;\n    this.recordNumber = recordNumber - 1;\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "@java.lang.Override\npublic java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n    return csvRecordIterator;\n}",
            "src_parent": "public final class CSVParser implements java.io.Closeable , java.lang.Iterable<org.apache.commons.csv.CSVRecord> {\n    @java.lang.SuppressWarnings(\"resource\")\n    public static org.apache.commons.csv.CSVParser parse(final java.io.File file, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(file, \"file\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.InputStreamReader(new java.io.FileInputStream(file), charset), format);\n    }\n\n    @java.lang.SuppressWarnings(\"resource\")\n    public static org.apache.commons.csv.CSVParser parse(final java.io.InputStream inputStream, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(inputStream, \"inputStream\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return org.apache.commons.csv.CSVParser.parse(new java.io.InputStreamReader(inputStream, charset), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.nio.file.Path path, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(path, \"path\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return org.apache.commons.csv.CSVParser.parse(java.nio.file.Files.newBufferedReader(path, charset), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        return new org.apache.commons.csv.CSVParser(reader, format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.lang.String string, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(string, \"string\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.StringReader(string), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.net.URL url, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(url, \"url\");\n        org.apache.commons.csv.Assertions.notNull(charset, \"charset\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private final org.apache.commons.csv.CSVFormat format;\n\n    private final java.util.Map<java.lang.String, java.lang.Integer> headerMap;\n\n    private final org.apache.commons.csv.Lexer lexer;\n\n    private final org.apache.commons.csv.CSVParser.CSVRecordIterator csvRecordIterator;\n\n    private final java.util.List<java.lang.String> recordList = new java.util.ArrayList<>();\n\n    private long recordNumber;\n\n    private final long characterOffset;\n\n    private final org.apache.commons.csv.Token reusableToken = new org.apache.commons.csv.Token();\n\n    public CSVParser(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        this(reader, format, 0, 1);\n    }\n\n    @java.lang.SuppressWarnings(\"resource\")\n    public CSVParser(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format, final long characterOffset, final long recordNumber) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(reader, \"reader\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        this.format = format;\n        this.lexer = new org.apache.commons.csv.Lexer(format, new org.apache.commons.csv.ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new org.apache.commons.csv.CSVParser.CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final java.lang.String input = this.reusableToken.content.toString();\n        final java.lang.String inputClean = (this.format.getTrim()) ? input.trim() : input;\n        if ((lastRecord && inputClean.isEmpty()) && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final java.lang.String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    @java.lang.Override\n    public void close() throws java.io.IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    public java.lang.String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    public java.util.Map<java.lang.String, java.lang.Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new java.util.LinkedHashMap<>(this.headerMap);\n    }\n\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    public java.util.List<org.apache.commons.csv.CSVRecord> getRecords() throws java.io.IOException {\n        org.apache.commons.csv.CSVRecord rec;\n        final java.util.List<org.apache.commons.csv.CSVRecord> records = new java.util.ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        } \n        return records;\n    }\n\n    private java.util.Map<java.lang.String, java.lang.Integer> initializeHeader() throws java.io.IOException {\n        java.util.Map<java.lang.String, java.lang.Integer> hdrMap = null;\n        final java.lang.String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = (this.format.getIgnoreHeaderCase()) ? new java.util.TreeMap<java.lang.String, java.lang.Integer>(java.lang.String.CASE_INSENSITIVE_ORDER) : new java.util.LinkedHashMap<java.lang.String, java.lang.Integer>();\n            java.lang.String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                final org.apache.commons.csv.CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final java.lang.String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = (header == null) || header.trim().isEmpty();\n                    if (containsHeader && ((!emptyHeader) || (!this.format.getAllowMissingColumnNames()))) {\n                        throw new java.lang.IllegalArgumentException(((\"The header contains a duplicate name: \\\"\" + header) + \"\\\" in \") + java.util.Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, java.lang.Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    @java.lang.Override\n    public java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    class CSVRecordIterator implements java.util.Iterator<org.apache.commons.csv.CSVRecord> {\n        private org.apache.commons.csv.CSVRecord current;\n\n        private org.apache.commons.csv.CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final java.io.IOException e) {\n                throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n            }\n        }\n\n        @java.lang.Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n            return this.current != null;\n        }\n\n        @java.lang.Override\n        public org.apache.commons.csv.CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n            }\n            org.apache.commons.csv.CSVRecord next = this.current;\n            this.current = null;\n            if (next == null) {\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new java.util.NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n            return next;\n        }\n\n        @java.lang.Override\n        public void remove() {\n            throw new java.lang.UnsupportedOperationException();\n        }\n    }\n\n    org.apache.commons.csv.CSVRecord nextRecord() throws java.io.IOException {\n        org.apache.commons.csv.CSVRecord result = null;\n        this.recordList.clear();\n        java.lang.StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n                case TOKEN :\n                    this.addRecordValue(false);\n                    break;\n                case EORECORD :\n                    this.addRecordValue(true);\n                    break;\n                case EOF :\n                    if (this.reusableToken.isReady) {\n                        this.addRecordValue(true);\n                    }\n                    break;\n                case INVALID :\n                    throw new java.io.IOException((\"(line \" + this.getCurrentLineNumber()) + \") invalid parse sequence\");\n                case COMMENT :\n                    if (sb == null) {\n                        sb = new java.lang.StringBuilder();\n                    } else {\n                        sb.append(org.apache.commons.csv.Constants.LF);\n                    }\n                    sb.append(this.reusableToken.content);\n                    this.reusableToken.type = org.apache.commons.csv.Token.Type.TOKEN;\n                    break;\n                default :\n                    throw new java.lang.IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == org.apache.commons.csv.Token.Type.TOKEN );\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final java.lang.String comment = (sb == null) ? null : sb.toString();\n            result = new org.apache.commons.csv.CSVRecord(this.recordList.toArray(new java.lang.String[this.recordList.size()]), this.headerMap, comment, this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "class CSVRecordIterator implements java.util.Iterator<org.apache.commons.csv.CSVRecord> {\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "src_parent": "public final class CSVParser implements java.io.Closeable , java.lang.Iterable<org.apache.commons.csv.CSVRecord> {\n    @java.lang.SuppressWarnings(\"resource\")\n    public static org.apache.commons.csv.CSVParser parse(final java.io.File file, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(file, \"file\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.InputStreamReader(new java.io.FileInputStream(file), charset), format);\n    }\n\n    @java.lang.SuppressWarnings(\"resource\")\n    public static org.apache.commons.csv.CSVParser parse(final java.io.InputStream inputStream, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(inputStream, \"inputStream\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return org.apache.commons.csv.CSVParser.parse(new java.io.InputStreamReader(inputStream, charset), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.nio.file.Path path, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(path, \"path\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return org.apache.commons.csv.CSVParser.parse(java.nio.file.Files.newBufferedReader(path, charset), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        return new org.apache.commons.csv.CSVParser(reader, format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.lang.String string, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(string, \"string\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.StringReader(string), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.net.URL url, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(url, \"url\");\n        org.apache.commons.csv.Assertions.notNull(charset, \"charset\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private final org.apache.commons.csv.CSVFormat format;\n\n    private final java.util.Map<java.lang.String, java.lang.Integer> headerMap;\n\n    private final org.apache.commons.csv.Lexer lexer;\n\n    private final org.apache.commons.csv.CSVParser.CSVRecordIterator csvRecordIterator;\n\n    private final java.util.List<java.lang.String> recordList = new java.util.ArrayList<>();\n\n    private long recordNumber;\n\n    private final long characterOffset;\n\n    private final org.apache.commons.csv.Token reusableToken = new org.apache.commons.csv.Token();\n\n    public CSVParser(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        this(reader, format, 0, 1);\n    }\n\n    @java.lang.SuppressWarnings(\"resource\")\n    public CSVParser(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format, final long characterOffset, final long recordNumber) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(reader, \"reader\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        this.format = format;\n        this.lexer = new org.apache.commons.csv.Lexer(format, new org.apache.commons.csv.ExtendedBufferedReader(reader));\n        this.csvRecordIterator = new org.apache.commons.csv.CSVParser.CSVRecordIterator();\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final java.lang.String input = this.reusableToken.content.toString();\n        final java.lang.String inputClean = (this.format.getTrim()) ? input.trim() : input;\n        if ((lastRecord && inputClean.isEmpty()) && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final java.lang.String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    @java.lang.Override\n    public void close() throws java.io.IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    public java.lang.String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    public java.util.Map<java.lang.String, java.lang.Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new java.util.LinkedHashMap<>(this.headerMap);\n    }\n\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    public java.util.List<org.apache.commons.csv.CSVRecord> getRecords() throws java.io.IOException {\n        org.apache.commons.csv.CSVRecord rec;\n        final java.util.List<org.apache.commons.csv.CSVRecord> records = new java.util.ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        } \n        return records;\n    }\n\n    private java.util.Map<java.lang.String, java.lang.Integer> initializeHeader() throws java.io.IOException {\n        java.util.Map<java.lang.String, java.lang.Integer> hdrMap = null;\n        final java.lang.String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = (this.format.getIgnoreHeaderCase()) ? new java.util.TreeMap<java.lang.String, java.lang.Integer>(java.lang.String.CASE_INSENSITIVE_ORDER) : new java.util.LinkedHashMap<java.lang.String, java.lang.Integer>();\n            java.lang.String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                final org.apache.commons.csv.CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final java.lang.String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = (header == null) || header.trim().isEmpty();\n                    if (containsHeader && ((!emptyHeader) || (!this.format.getAllowMissingColumnNames()))) {\n                        throw new java.lang.IllegalArgumentException(((\"The header contains a duplicate name: \\\"\" + header) + \"\\\" in \") + java.util.Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, java.lang.Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    @java.lang.Override\n    public java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n        return csvRecordIterator;\n    }\n\n    class CSVRecordIterator implements java.util.Iterator<org.apache.commons.csv.CSVRecord> {\n        private org.apache.commons.csv.CSVRecord current;\n\n        private org.apache.commons.csv.CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final java.io.IOException e) {\n                throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n            }\n        }\n\n        @java.lang.Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n            return this.current != null;\n        }\n\n        @java.lang.Override\n        public org.apache.commons.csv.CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n            }\n            org.apache.commons.csv.CSVRecord next = this.current;\n            this.current = null;\n            if (next == null) {\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new java.util.NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n            return next;\n        }\n\n        @java.lang.Override\n        public void remove() {\n            throw new java.lang.UnsupportedOperationException();\n        }\n    }\n\n    org.apache.commons.csv.CSVRecord nextRecord() throws java.io.IOException {\n        org.apache.commons.csv.CSVRecord result = null;\n        this.recordList.clear();\n        java.lang.StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n                case TOKEN :\n                    this.addRecordValue(false);\n                    break;\n                case EORECORD :\n                    this.addRecordValue(true);\n                    break;\n                case EOF :\n                    if (this.reusableToken.isReady) {\n                        this.addRecordValue(true);\n                    }\n                    break;\n                case INVALID :\n                    throw new java.io.IOException((\"(line \" + this.getCurrentLineNumber()) + \") invalid parse sequence\");\n                case COMMENT :\n                    if (sb == null) {\n                        sb = new java.lang.StringBuilder();\n                    } else {\n                        sb.append(org.apache.commons.csv.Constants.LF);\n                    }\n                    sb.append(this.reusableToken.content);\n                    this.reusableToken.type = org.apache.commons.csv.Token.Type.TOKEN;\n                    break;\n                default :\n                    throw new java.lang.IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == org.apache.commons.csv.Token.Type.TOKEN );\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final java.lang.String comment = (sb == null) ? null : sb.toString();\n            result = new org.apache.commons.csv.CSVRecord(this.recordList.toArray(new java.lang.String[this.recordList.size()]), this.headerMap, comment, this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Class"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "@java.lang.Override\npublic java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n    return new java.util.Iterator<org.apache.commons.csv.CSVRecord>() {\n        private org.apache.commons.csv.CSVRecord current;\n\n        private org.apache.commons.csv.CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final java.io.IOException e) {\n                throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n            }\n        }\n\n        @java.lang.Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n            return this.current != null;\n        }\n\n        @java.lang.Override\n        public org.apache.commons.csv.CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n            }\n            org.apache.commons.csv.CSVRecord next = this.current;\n            this.current = null;\n            if (next == null) {\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new java.util.NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n            return next;\n        }\n\n        @java.lang.Override\n        public void remove() {\n            throw new java.lang.UnsupportedOperationException();\n        }\n    };\n}",
            "src_parent": "public final class CSVParser implements java.io.Closeable , java.lang.Iterable<org.apache.commons.csv.CSVRecord> {\n    @java.lang.SuppressWarnings(\"resource\")\n    public static org.apache.commons.csv.CSVParser parse(final java.io.File file, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(file, \"file\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.InputStreamReader(new java.io.FileInputStream(file), charset), format);\n    }\n\n    @java.lang.SuppressWarnings(\"resource\")\n    public static org.apache.commons.csv.CSVParser parse(final java.io.InputStream inputStream, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(inputStream, \"inputStream\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return org.apache.commons.csv.CSVParser.parse(new java.io.InputStreamReader(inputStream, charset), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.nio.file.Path path, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(path, \"path\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return org.apache.commons.csv.CSVParser.parse(java.nio.file.Files.newBufferedReader(path, charset), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        return new org.apache.commons.csv.CSVParser(reader, format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.lang.String string, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(string, \"string\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.StringReader(string), format);\n    }\n\n    public static org.apache.commons.csv.CSVParser parse(final java.net.URL url, final java.nio.charset.Charset charset, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(url, \"url\");\n        org.apache.commons.csv.Assertions.notNull(charset, \"charset\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        return new org.apache.commons.csv.CSVParser(new java.io.InputStreamReader(url.openStream(), charset), format);\n    }\n\n    private final org.apache.commons.csv.CSVFormat format;\n\n    private final java.util.Map<java.lang.String, java.lang.Integer> headerMap;\n\n    private final org.apache.commons.csv.Lexer lexer;\n\n    private final java.util.List<java.lang.String> recordList = new java.util.ArrayList<>();\n\n    private long recordNumber;\n\n    private final long characterOffset;\n\n    private final org.apache.commons.csv.Token reusableToken = new org.apache.commons.csv.Token();\n\n    public CSVParser(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format) throws java.io.IOException {\n        this(reader, format, 0, 1);\n    }\n\n    @java.lang.SuppressWarnings(\"resource\")\n    public CSVParser(final java.io.Reader reader, final org.apache.commons.csv.CSVFormat format, final long characterOffset, final long recordNumber) throws java.io.IOException {\n        org.apache.commons.csv.Assertions.notNull(reader, \"reader\");\n        org.apache.commons.csv.Assertions.notNull(format, \"format\");\n        this.format = format;\n        this.lexer = new org.apache.commons.csv.Lexer(format, new org.apache.commons.csv.ExtendedBufferedReader(reader));\n        this.headerMap = this.initializeHeader();\n        this.characterOffset = characterOffset;\n        this.recordNumber = recordNumber - 1;\n    }\n\n    private void addRecordValue(final boolean lastRecord) {\n        final java.lang.String input = this.reusableToken.content.toString();\n        final java.lang.String inputClean = (this.format.getTrim()) ? input.trim() : input;\n        if ((lastRecord && inputClean.isEmpty()) && this.format.getTrailingDelimiter()) {\n            return;\n        }\n        final java.lang.String nullString = this.format.getNullString();\n        this.recordList.add(inputClean.equals(nullString) ? null : inputClean);\n    }\n\n    @java.lang.Override\n    public void close() throws java.io.IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    public java.lang.String getFirstEndOfLine() {\n        return lexer.getFirstEol();\n    }\n\n    public java.util.Map<java.lang.String, java.lang.Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new java.util.LinkedHashMap<>(this.headerMap);\n    }\n\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    public java.util.List<org.apache.commons.csv.CSVRecord> getRecords() throws java.io.IOException {\n        org.apache.commons.csv.CSVRecord rec;\n        final java.util.List<org.apache.commons.csv.CSVRecord> records = new java.util.ArrayList<>();\n        while ((rec = this.nextRecord()) != null) {\n            records.add(rec);\n        } \n        return records;\n    }\n\n    private java.util.Map<java.lang.String, java.lang.Integer> initializeHeader() throws java.io.IOException {\n        java.util.Map<java.lang.String, java.lang.Integer> hdrMap = null;\n        final java.lang.String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = (this.format.getIgnoreHeaderCase()) ? new java.util.TreeMap<java.lang.String, java.lang.Integer>(java.lang.String.CASE_INSENSITIVE_ORDER) : new java.util.LinkedHashMap<java.lang.String, java.lang.Integer>();\n            java.lang.String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                final org.apache.commons.csv.CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final java.lang.String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = (header == null) || header.trim().isEmpty();\n                    if (containsHeader && ((!emptyHeader) || (!this.format.getAllowMissingColumnNames()))) {\n                        throw new java.lang.IllegalArgumentException(((\"The header contains a duplicate name: \\\"\" + header) + \"\\\" in \") + java.util.Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, java.lang.Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    @java.lang.Override\n    public java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n        return new java.util.Iterator<org.apache.commons.csv.CSVRecord>() {\n            private org.apache.commons.csv.CSVRecord current;\n\n            private org.apache.commons.csv.CSVRecord getNextRecord() {\n                try {\n                    return CSVParser.this.nextRecord();\n                } catch (final java.io.IOException e) {\n                    throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n                }\n            }\n\n            @java.lang.Override\n            public boolean hasNext() {\n                if (CSVParser.this.isClosed()) {\n                    return false;\n                }\n                if (this.current == null) {\n                    this.current = this.getNextRecord();\n                }\n                return this.current != null;\n            }\n\n            @java.lang.Override\n            public org.apache.commons.csv.CSVRecord next() {\n                if (CSVParser.this.isClosed()) {\n                    throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n                }\n                org.apache.commons.csv.CSVRecord next = this.current;\n                this.current = null;\n                if (next == null) {\n                    next = this.getNextRecord();\n                    if (next == null) {\n                        throw new java.util.NoSuchElementException(\"No more CSV records available\");\n                    }\n                }\n                return next;\n            }\n\n            @java.lang.Override\n            public void remove() {\n                throw new java.lang.UnsupportedOperationException();\n            }\n        };\n    }\n\n    org.apache.commons.csv.CSVRecord nextRecord() throws java.io.IOException {\n        org.apache.commons.csv.CSVRecord result = null;\n        this.recordList.clear();\n        java.lang.StringBuilder sb = null;\n        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n        do {\n            this.reusableToken.reset();\n            this.lexer.nextToken(this.reusableToken);\n            switch (this.reusableToken.type) {\n                case TOKEN :\n                    this.addRecordValue(false);\n                    break;\n                case EORECORD :\n                    this.addRecordValue(true);\n                    break;\n                case EOF :\n                    if (this.reusableToken.isReady) {\n                        this.addRecordValue(true);\n                    }\n                    break;\n                case INVALID :\n                    throw new java.io.IOException((\"(line \" + this.getCurrentLineNumber()) + \") invalid parse sequence\");\n                case COMMENT :\n                    if (sb == null) {\n                        sb = new java.lang.StringBuilder();\n                    } else {\n                        sb.append(org.apache.commons.csv.Constants.LF);\n                    }\n                    sb.append(this.reusableToken.content);\n                    this.reusableToken.type = org.apache.commons.csv.Token.Type.TOKEN;\n                    break;\n                default :\n                    throw new java.lang.IllegalStateException(\"Unexpected Token type: \" + this.reusableToken.type);\n            }\n        } while (this.reusableToken.type == org.apache.commons.csv.Token.Type.TOKEN );\n        if (!this.recordList.isEmpty()) {\n            this.recordNumber++;\n            final java.lang.String comment = (sb == null) ? null : sb.toString();\n            result = new org.apache.commons.csv.CSVRecord(this.recordList.toArray(new java.lang.String[this.recordList.size()]), this.headerMap, comment, this.recordNumber, startCharPosition);\n        }\n        return result;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "TypeReference",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "java.util.Iterator<org.apache.commons.csv.CSVRecord>",
            "dst_parent": "@java.lang.Override\npublic java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n    return new java.util.Iterator<org.apache.commons.csv.CSVRecord>() {\n        private org.apache.commons.csv.CSVRecord current;\n\n        private org.apache.commons.csv.CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final java.io.IOException e) {\n                throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n            }\n        }\n\n        @java.lang.Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n            return this.current != null;\n        }\n\n        @java.lang.Override\n        public org.apache.commons.csv.CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n            }\n            org.apache.commons.csv.CSVRecord next = this.current;\n            this.current = null;\n            if (next == null) {\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new java.util.NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n            return next;\n        }\n\n        @java.lang.Override\n        public void remove() {\n            throw new java.lang.UnsupportedOperationException();\n        }\n    };\n}",
            "dst_parent_type": "Method",
            "dst_type": "TypeReference",
            "operator": "MOV",
            "src": "java.util.Iterator<org.apache.commons.csv.CSVRecord>",
            "src_parent": "@java.lang.Override\npublic java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n    return csvRecordIterator;\n}",
            "src_parent_type": "Method",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "VirtualElement",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "VE: Modifiers_Method",
            "dst_parent": "@java.lang.Override\npublic java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n    return new java.util.Iterator<org.apache.commons.csv.CSVRecord>() {\n        private org.apache.commons.csv.CSVRecord current;\n\n        private org.apache.commons.csv.CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final java.io.IOException e) {\n                throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n            }\n        }\n\n        @java.lang.Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n            return this.current != null;\n        }\n\n        @java.lang.Override\n        public org.apache.commons.csv.CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n            }\n            org.apache.commons.csv.CSVRecord next = this.current;\n            this.current = null;\n            if (next == null) {\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new java.util.NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n            return next;\n        }\n\n        @java.lang.Override\n        public void remove() {\n            throw new java.lang.UnsupportedOperationException();\n        }\n    };\n}",
            "dst_parent_type": "Method",
            "dst_type": "VirtualEle",
            "operator": "MOV",
            "src": "VE: Modifiers_Method",
            "src_parent": "@java.lang.Override\npublic java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n    return csvRecordIterator;\n}",
            "src_parent_type": "Method",
            "src_type": "VirtualEle"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Annotation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@java.lang.Override",
            "dst_parent": "@java.lang.Override\npublic java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n    return new java.util.Iterator<org.apache.commons.csv.CSVRecord>() {\n        private org.apache.commons.csv.CSVRecord current;\n\n        private org.apache.commons.csv.CSVRecord getNextRecord() {\n            try {\n                return CSVParser.this.nextRecord();\n            } catch (final java.io.IOException e) {\n                throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n            }\n        }\n\n        @java.lang.Override\n        public boolean hasNext() {\n            if (CSVParser.this.isClosed()) {\n                return false;\n            }\n            if (this.current == null) {\n                this.current = this.getNextRecord();\n            }\n            return this.current != null;\n        }\n\n        @java.lang.Override\n        public org.apache.commons.csv.CSVRecord next() {\n            if (CSVParser.this.isClosed()) {\n                throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n            }\n            org.apache.commons.csv.CSVRecord next = this.current;\n            this.current = null;\n            if (next == null) {\n                next = this.getNextRecord();\n                if (next == null) {\n                    throw new java.util.NoSuchElementException(\"No more CSV records available\");\n                }\n            }\n            return next;\n        }\n\n        @java.lang.Override\n        public void remove() {\n            throw new java.lang.UnsupportedOperationException();\n        }\n    };\n}",
            "dst_parent_type": "Method",
            "dst_type": "Annotation",
            "operator": "MOV",
            "src": "@java.lang.Override",
            "src_parent": "@java.lang.Override\npublic java.util.Iterator<org.apache.commons.csv.CSVRecord> iterator() {\n    return csvRecordIterator;\n}",
            "src_parent_type": "Method",
            "src_type": "Annotation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private org.apache.commons.csv.CSVRecord current;",
            "dst_parent": "{\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Field",
            "operator": "MOV",
            "src": "private org.apache.commons.csv.CSVRecord current;",
            "src_parent": "class CSVRecordIterator implements java.util.Iterator<org.apache.commons.csv.CSVRecord> {\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private org.apache.commons.csv.CSVRecord getNextRecord() {\n    try {\n        return this.nextRecord();\n    } catch (final java.io.IOException e) {\n        throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n    }\n}",
            "dst_parent": "{\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "MOV",
            "src": "private org.apache.commons.csv.CSVRecord getNextRecord() {\n    try {\n        return this.nextRecord();\n    } catch (final java.io.IOException e) {\n        throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n    }\n}",
            "src_parent": "class CSVRecordIterator implements java.util.Iterator<org.apache.commons.csv.CSVRecord> {\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@java.lang.Override\npublic boolean hasNext() {\n    if (this.isClosed()) {\n        return false;\n    }\n    if (this.current == null) {\n        this.current = this.getNextRecord();\n    }\n    return this.current != null;\n}",
            "dst_parent": "{\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "MOV",
            "src": "@java.lang.Override\npublic boolean hasNext() {\n    if (this.isClosed()) {\n        return false;\n    }\n    if (this.current == null) {\n        this.current = this.getNextRecord();\n    }\n    return this.current != null;\n}",
            "src_parent": "class CSVRecordIterator implements java.util.Iterator<org.apache.commons.csv.CSVRecord> {\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@java.lang.Override\npublic org.apache.commons.csv.CSVRecord next() {\n    if (this.isClosed()) {\n        throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n    }\n    org.apache.commons.csv.CSVRecord next = this.current;\n    this.current = null;\n    if (next == null) {\n        next = this.getNextRecord();\n        if (next == null) {\n            throw new java.util.NoSuchElementException(\"No more CSV records available\");\n        }\n    }\n    return next;\n}",
            "dst_parent": "{\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "MOV",
            "src": "@java.lang.Override\npublic org.apache.commons.csv.CSVRecord next() {\n    if (this.isClosed()) {\n        throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n    }\n    org.apache.commons.csv.CSVRecord next = this.current;\n    this.current = null;\n    if (next == null) {\n        next = this.getNextRecord();\n        if (next == null) {\n            throw new java.util.NoSuchElementException(\"No more CSV records available\");\n        }\n    }\n    return next;\n}",
            "src_parent": "class CSVRecordIterator implements java.util.Iterator<org.apache.commons.csv.CSVRecord> {\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@java.lang.Override\npublic void remove() {\n    throw new java.lang.UnsupportedOperationException();\n}",
            "dst_parent": "{\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "MOV",
            "src": "@java.lang.Override\npublic void remove() {\n    throw new java.lang.UnsupportedOperationException();\n}",
            "src_parent": "class CSVRecordIterator implements java.util.Iterator<org.apache.commons.csv.CSVRecord> {\n    private org.apache.commons.csv.CSVRecord current;\n\n    private org.apache.commons.csv.CSVRecord getNextRecord() {\n        try {\n            return CSVParser.this.nextRecord();\n        } catch (final java.io.IOException e) {\n            throw new java.lang.IllegalStateException((e.getClass().getSimpleName() + \" reading next record: \") + e.toString(), e);\n        }\n    }\n\n    @java.lang.Override\n    public boolean hasNext() {\n        if (CSVParser.this.isClosed()) {\n            return false;\n        }\n        if (this.current == null) {\n            this.current = this.getNextRecord();\n        }\n        return this.current != null;\n    }\n\n    @java.lang.Override\n    public org.apache.commons.csv.CSVRecord next() {\n        if (CSVParser.this.isClosed()) {\n            throw new java.util.NoSuchElementException(\"CSVParser has been closed\");\n        }\n        org.apache.commons.csv.CSVRecord next = this.current;\n        this.current = null;\n        if (next == null) {\n            next = this.getNextRecord();\n            if (next == null) {\n                throw new java.util.NoSuchElementException(\"No more CSV records available\");\n            }\n        }\n        return next;\n    }\n\n    @java.lang.Override\n    public void remove() {\n        throw new java.lang.UnsupportedOperationException();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        }
      ],
      "file_name": "CSVParser"
    }
  ],
  "id": "Csv_16"
}