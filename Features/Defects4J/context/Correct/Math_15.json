{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.math3.util.FastMath.TWO_POWER_52",
            "dst_parent": "(y >= org.apache.commons.math3.util.FastMath.TWO_POWER_52)",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "FieldRead",
            "operator": "UPD",
            "src": "org.apache.commons.math3.util.FastMath.TWO_POWER_53",
            "src_parent": "(y >= org.apache.commons.math3.util.FastMath.TWO_POWER_53)",
            "src_parent_type": "BinaryOperator",
            "src_type": "FieldRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.commons.math3.util.FastMath.TWO_POWER_52",
            "dst_parent": "(-org.apache.commons.math3.util.FastMath.TWO_POWER_52)",
            "dst_parent_type": "UnaryOperator",
            "dst_type": "FieldRead",
            "operator": "UPD",
            "src": "org.apache.commons.math3.util.FastMath.TWO_POWER_53",
            "src_parent": "(-org.apache.commons.math3.util.FastMath.TWO_POWER_53)",
            "src_parent_type": "UnaryOperator",
            "src_type": "FieldRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "private static final double TWO_POWER_53 = 2 * org.apache.commons.math3.util.FastMath.TWO_POWER_52;",
            "src_parent": "public class FastMath {\n    private static final double LOG_MAX_VALUE = java.lang.StrictMath.log(java.lang.Double.MAX_VALUE);\n\n    public static final double PI = (1.05414357E8 / 3.3554432E7) + 1.984187159361081E-9;\n\n    public static final double E = (2850325.0 / 1048576.0) + 8.254840070411029E-8;\n\n    static final int EXP_INT_TABLE_MAX_INDEX = 750;\n\n    static final int EXP_INT_TABLE_LEN = org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX * 2;\n\n    static final int LN_MANT_LEN = 1024;\n\n    static final int EXP_FRAC_TABLE_LEN = 1025;\n\n    private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false;\n\n    private static final double LN_2_A = 0.6931470632553101;\n\n    private static final double LN_2_B = 1.1730463525082348E-7;\n\n    private static final double[][] LN_QUICK_COEF = new double[][]{ new double[]{ 1.0, 5.669184079525E-24 }, new double[]{ -0.25, -0.25 }, new double[]{ 0.3333333134651184, 1.986821492305628E-8 }, new double[]{ -0.25, -6.663542893624021E-14 }, new double[]{ 0.19999998807907104, 1.1921056801463227E-8 }, new double[]{ -0.1666666567325592, -7.800414592973399E-9 }, new double[]{ 0.1428571343421936, 5.650007086920087E-9 }, new double[]{ -0.12502530217170715, -7.44321345601866E-11 }, new double[]{ 0.11113807559013367, 9.219544613762692E-9 } };\n\n    private static final double[][] LN_HI_PREC_COEF = new double[][]{ new double[]{ 1.0, -6.032174644509064E-23 }, new double[]{ -0.25, -0.25 }, new double[]{ 0.3333333134651184, 1.9868161777724352E-8 }, new double[]{ -0.2499999701976776, -2.957007209750105E-8 }, new double[]{ 0.19999954104423523, 1.5830993332061267E-10 }, new double[]{ -0.16624879837036133, -2.6033824355191673E-8 } };\n\n    private static final int SINE_TABLE_LEN = 14;\n\n    private static final double[] SINE_TABLE_A = new double[]{ +0.0, +0.1246747374534607, +0.24740394949913025, +0.366272509098053, +0.4794255495071411, +0.5850973129272461, +0.6816387176513672, +0.7675435543060303, +0.8414709568023682, +0.902267575263977, +0.9489846229553223, +0.9808930158615112, +0.9974949359893799, +0.9985313415527344 };\n\n    private static final double[] SINE_TABLE_B = new double[]{ +0.0, -4.068233003401932E-9, +9.755392680573412E-9, +1.9987994582857286E-8, -1.0902938113007961E-8, -3.9986783938944604E-8, +4.23719669792332E-8, -5.207000323380292E-8, +2.800552834259E-8, +1.883511811213715E-8, -3.5997360512765566E-9, +4.116164446561962E-8, +5.0614674548127384E-8, -1.0129027912496858E-9 };\n\n    private static final double[] COSINE_TABLE_A = new double[]{ +1.0, +0.9921976327896118, +0.9689123630523682, +0.9305076599121094, +0.8775825500488281, +0.8109631538391113, +0.7316888570785522, +0.6409968137741089, +0.5403022766113281, +0.4311765432357788, +0.3153223395347595, +0.19454771280288696, +0.07073719799518585, -0.05417713522911072 };\n\n    private static final double[] COSINE_TABLE_B = new double[]{ +0.0, +3.4439717236742845E-8, +5.865827662008209E-8, -3.7999795083850525E-8, +1.184154459111628E-8, -3.43338934259355E-8, +1.1795268640216787E-8, +4.438921624363781E-8, +2.925681159240093E-8, -2.6437112632041807E-8, +2.2860509143963117E-8, -4.813899778443457E-9, +3.6725170580355583E-9, +2.0217439756338078E-10 };\n\n    private static final double[] TANGENT_TABLE_A = new double[]{ +0.0, +0.1256551444530487, +0.25534194707870483, +0.3936265707015991, +0.5463024377822876, +0.7214844226837158, +0.9315965175628662, +1.1974215507507324, +1.5574076175689697, +2.092571258544922, +3.0095696449279785, +5.041914939880371, +14.101419448852539, -18.430862426757812 };\n\n    private static final double[] TANGENT_TABLE_B = new double[]{ +0.0, -7.877917738262007E-9, -2.5857668567479893E-8, +5.2240336371356666E-9, +5.206150291559893E-8, +1.8307188599677033E-8, -5.7618793749770706E-8, +7.848361555046424E-8, +1.0708593250394448E-7, +1.7827257129423813E-8, +2.893485277253286E-8, +3.1660099222737955E-7, +4.983191803254889E-7, -3.356118100840571E-7 };\n\n    private static final long[] RECIP_2PI = new long[]{ (0x28be60dbL << 32) | 0x9391054aL, (0x7f09d5f4L << 32) | 0x7d4d3770L, (0x36d8a566L << 32) | 0x4f10e410L, (0x7f9458eaL << 32) | 0xf7aef158L, (0x6dc91b8eL << 32) | 0x909374b8L, (0x1924bbaL << 32) | 0x82746487L, (0x3f877ac7L << 32) | 0x2c4a69cfL, (0xba208d7dL << 32) | 0x4baed121L, (0x3a671c09L << 32) | 0xad17df90L, (0x4e64758eL << 32) | 0x60d4ce7dL, (0x272117e2L << 32) | 0xef7e4a0eL, (0xc7fe25ffL << 32) | 0xf7816603L, (0xfbcbc462L << 32) | 0xd6829b47L, (0xdb4d9fb3L << 32) | 0xc9f2c26dL, (0xd3d18fd9L << 32) | 0xa797fa8bL, (0x5d49eeb1L << 32) | 0xfaf97c5eL, (0xcf41ce7dL << 32) | 0xe294a4baL, 0x9afed7ecL << 32 };\n\n    private static final long[] PI_O_4_BITS = new long[]{ (0xc90fdaa2L << 32) | 0x2168c234L, (0xc4c6628bL << 32) | 0x80dc1cd1L };\n\n    private static final double[] EIGHTHS = new double[]{ 0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625 };\n\n    private static final double[] CBRTTWO = new double[]{ 0.6299605249474366, 0.7937005259840998, 1.0, 1.2599210498948732, 1.5874010519681994 };\n\n    private static final long HEX_40000000 = 0x40000000L;\n\n    private static final long MASK_30BITS = (-1L) - (org.apache.commons.math3.util.FastMath.HEX_40000000 - 1);\n\n    private static final double TWO_POWER_52 = 4.503599627370496E15;\n\n    private static final double TWO_POWER_53 = 2 * org.apache.commons.math3.util.FastMath.TWO_POWER_52;\n\n    private static final double F_1_3 = 1.0 / 3.0;\n\n    private static final double F_1_5 = 1.0 / 5.0;\n\n    private static final double F_1_7 = 1.0 / 7.0;\n\n    private static final double F_1_9 = 1.0 / 9.0;\n\n    private static final double F_1_11 = 1.0 / 11.0;\n\n    private static final double F_1_13 = 1.0 / 13.0;\n\n    private static final double F_1_15 = 1.0 / 15.0;\n\n    private static final double F_1_17 = 1.0 / 17.0;\n\n    private static final double F_3_4 = 3.0 / 4.0;\n\n    private static final double F_15_16 = 15.0 / 16.0;\n\n    private static final double F_13_14 = 13.0 / 14.0;\n\n    private static final double F_11_12 = 11.0 / 12.0;\n\n    private static final double F_9_10 = 9.0 / 10.0;\n\n    private static final double F_7_8 = 7.0 / 8.0;\n\n    private static final double F_5_6 = 5.0 / 6.0;\n\n    private static final double F_1_2 = 1.0 / 2.0;\n\n    private static final double F_1_4 = 1.0 / 4.0;\n\n    private FastMath() {\n    }\n\n    private static double doubleHighPart(double d) {\n        if ((d > (-Precision.SAFE_MIN)) && (d < Precision.SAFE_MIN)) {\n            return d;\n        }\n        long xl = java.lang.Double.doubleToLongBits(d);\n        xl = xl & org.apache.commons.math3.util.FastMath.MASK_30BITS;\n        return java.lang.Double.longBitsToDouble(xl);\n    }\n\n    public static double sqrt(final double a) {\n        return java.lang.Math.sqrt(a);\n    }\n\n    public static double cosh(double x) {\n        if (x != x) {\n            return x;\n        }\n        if (x > 20) {\n            if (x >= org.apache.commons.math3.util.FastMath.LOG_MAX_VALUE) {\n                final double t = org.apache.commons.math3.util.FastMath.exp(0.5 * x);\n                return (0.5 * t) * t;\n            } else {\n                return 0.5 * org.apache.commons.math3.util.FastMath.exp(x);\n            }\n        } else if (x < (-20)) {\n            if (x <= (-org.apache.commons.math3.util.FastMath.LOG_MAX_VALUE)) {\n                final double t = org.apache.commons.math3.util.FastMath.exp((-0.5) * x);\n                return (0.5 * t) * t;\n            } else {\n                return 0.5 * org.apache.commons.math3.util.FastMath.exp(-x);\n            }\n        }\n        final double[] hiPrec = new double[2];\n        if (x < 0.0) {\n            x = -x;\n        }\n        org.apache.commons.math3.util.FastMath.exp(x, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -((ya - hiPrec[0]) - hiPrec[1]);\n        double temp = ya * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double yaa = (ya + temp) - temp;\n        double yab = ya - yaa;\n        double recip = 1.0 / ya;\n        temp = recip * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double recipa = (recip + temp) - temp;\n        double recipb = recip - recipa;\n        recipb += ((((1.0 - (yaa * recipa)) - (yaa * recipb)) - (yab * recipa)) - (yab * recipb)) * recip;\n        recipb += ((-yb) * recip) * recip;\n        temp = ya + recipa;\n        yb += -((temp - ya) - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -((temp - ya) - recipb);\n        ya = temp;\n        double result = ya + yb;\n        result *= 0.5;\n        return result;\n    }\n\n    public static double sinh(double x) {\n        boolean negate = false;\n        if (x != x) {\n            return x;\n        }\n        if (x > 20) {\n            if (x >= org.apache.commons.math3.util.FastMath.LOG_MAX_VALUE) {\n                final double t = org.apache.commons.math3.util.FastMath.exp(0.5 * x);\n                return (0.5 * t) * t;\n            } else {\n                return 0.5 * org.apache.commons.math3.util.FastMath.exp(x);\n            }\n        } else if (x < (-20)) {\n            if (x <= (-org.apache.commons.math3.util.FastMath.LOG_MAX_VALUE)) {\n                final double t = org.apache.commons.math3.util.FastMath.exp((-0.5) * x);\n                return ((-0.5) * t) * t;\n            } else {\n                return (-0.5) * org.apache.commons.math3.util.FastMath.exp(-x);\n            }\n        }\n        if (x == 0) {\n            return x;\n        }\n        if (x < 0.0) {\n            x = -x;\n            negate = true;\n        }\n        double result;\n        if (x > 0.25) {\n            double[] hiPrec = new double[2];\n            org.apache.commons.math3.util.FastMath.exp(x, 0.0, hiPrec);\n            double ya = hiPrec[0] + hiPrec[1];\n            double yb = -((ya - hiPrec[0]) - hiPrec[1]);\n            double temp = ya * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            double yaa = (ya + temp) - temp;\n            double yab = ya - yaa;\n            double recip = 1.0 / ya;\n            temp = recip * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            double recipa = (recip + temp) - temp;\n            double recipb = recip - recipa;\n            recipb += ((((1.0 - (yaa * recipa)) - (yaa * recipb)) - (yab * recipa)) - (yab * recipb)) * recip;\n            recipb += ((-yb) * recip) * recip;\n            recipa = -recipa;\n            recipb = -recipb;\n            temp = ya + recipa;\n            yb += -((temp - ya) - recipa);\n            ya = temp;\n            temp = ya + recipb;\n            yb += -((temp - ya) - recipb);\n            ya = temp;\n            result = ya + yb;\n            result *= 0.5;\n        } else {\n            double[] hiPrec = new double[2];\n            org.apache.commons.math3.util.FastMath.expm1(x, hiPrec);\n            double ya = hiPrec[0] + hiPrec[1];\n            double yb = -((ya - hiPrec[0]) - hiPrec[1]);\n            double denom = 1.0 + ya;\n            double denomr = 1.0 / denom;\n            double denomb = (-((denom - 1.0) - ya)) + yb;\n            double ratio = ya * denomr;\n            double temp = ratio * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            double ra = (ratio + temp) - temp;\n            double rb = ratio - ra;\n            temp = denom * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            double za = (denom + temp) - temp;\n            double zb = denom - za;\n            rb += ((((ya - (za * ra)) - (za * rb)) - (zb * ra)) - (zb * rb)) * denomr;\n            rb += yb * denomr;\n            rb += (((-ya) * denomb) * denomr) * denomr;\n            temp = ya + ra;\n            yb += -((temp - ya) - ra);\n            ya = temp;\n            temp = ya + rb;\n            yb += -((temp - ya) - rb);\n            ya = temp;\n            result = ya + yb;\n            result *= 0.5;\n        }\n        if (negate) {\n            result = -result;\n        }\n        return result;\n    }\n\n    public static double tanh(double x) {\n        boolean negate = false;\n        if (x != x) {\n            return x;\n        }\n        if (x > 20.0) {\n            return 1.0;\n        }\n        if (x < (-20)) {\n            return -1.0;\n        }\n        if (x == 0) {\n            return x;\n        }\n        if (x < 0.0) {\n            x = -x;\n            negate = true;\n        }\n        double result;\n        if (x >= 0.5) {\n            double[] hiPrec = new double[2];\n            org.apache.commons.math3.util.FastMath.exp(x * 2.0, 0.0, hiPrec);\n            double ya = hiPrec[0] + hiPrec[1];\n            double yb = -((ya - hiPrec[0]) - hiPrec[1]);\n            double na = (-1.0) + ya;\n            double nb = -((na + 1.0) - ya);\n            double temp = na + yb;\n            nb += -((temp - na) - yb);\n            na = temp;\n            double da = 1.0 + ya;\n            double db = -((da - 1.0) - ya);\n            temp = da + yb;\n            db += -((temp - da) - yb);\n            da = temp;\n            temp = da * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            double daa = (da + temp) - temp;\n            double dab = da - daa;\n            double ratio = na / da;\n            temp = ratio * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            double ratioa = (ratio + temp) - temp;\n            double ratiob = ratio - ratioa;\n            ratiob += ((((na - (daa * ratioa)) - (daa * ratiob)) - (dab * ratioa)) - (dab * ratiob)) / da;\n            ratiob += nb / da;\n            ratiob += (((-db) * na) / da) / da;\n            result = ratioa + ratiob;\n        } else {\n            double[] hiPrec = new double[2];\n            org.apache.commons.math3.util.FastMath.expm1(x * 2.0, hiPrec);\n            double ya = hiPrec[0] + hiPrec[1];\n            double yb = -((ya - hiPrec[0]) - hiPrec[1]);\n            double na = ya;\n            double nb = yb;\n            double da = 2.0 + ya;\n            double db = -((da - 2.0) - ya);\n            double temp = da + yb;\n            db += -((temp - da) - yb);\n            da = temp;\n            temp = da * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            double daa = (da + temp) - temp;\n            double dab = da - daa;\n            double ratio = na / da;\n            temp = ratio * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            double ratioa = (ratio + temp) - temp;\n            double ratiob = ratio - ratioa;\n            ratiob += ((((na - (daa * ratioa)) - (daa * ratiob)) - (dab * ratioa)) - (dab * ratiob)) / da;\n            ratiob += nb / da;\n            ratiob += (((-db) * na) / da) / da;\n            result = ratioa + ratiob;\n        }\n        if (negate) {\n            result = -result;\n        }\n        return result;\n    }\n\n    public static double acosh(final double a) {\n        return org.apache.commons.math3.util.FastMath.log(a + org.apache.commons.math3.util.FastMath.sqrt((a * a) - 1));\n    }\n\n    public static double asinh(double a) {\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n        double absAsinh;\n        if (a > 0.167) {\n            absAsinh = org.apache.commons.math3.util.FastMath.log(org.apache.commons.math3.util.FastMath.sqrt((a * a) + 1) + a);\n        } else {\n            final double a2 = a * a;\n            if (a > 0.097) {\n                absAsinh = a * (1 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_3 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_5 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_7 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_9 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_11 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_13 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_15 - ((a2 * org.apache.commons.math3.util.FastMath.F_1_17) * org.apache.commons.math3.util.FastMath.F_15_16))) * org.apache.commons.math3.util.FastMath.F_13_14))) * org.apache.commons.math3.util.FastMath.F_11_12))) * org.apache.commons.math3.util.FastMath.F_9_10))) * org.apache.commons.math3.util.FastMath.F_7_8))) * org.apache.commons.math3.util.FastMath.F_5_6))) * org.apache.commons.math3.util.FastMath.F_3_4))) * org.apache.commons.math3.util.FastMath.F_1_2));\n            } else if (a > 0.036) {\n                absAsinh = a * (1 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_3 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_5 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_7 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_9 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_11 - ((a2 * org.apache.commons.math3.util.FastMath.F_1_13) * org.apache.commons.math3.util.FastMath.F_11_12))) * org.apache.commons.math3.util.FastMath.F_9_10))) * org.apache.commons.math3.util.FastMath.F_7_8))) * org.apache.commons.math3.util.FastMath.F_5_6))) * org.apache.commons.math3.util.FastMath.F_3_4))) * org.apache.commons.math3.util.FastMath.F_1_2));\n            } else if (a > 0.0036) {\n                absAsinh = a * (1 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_3 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_5 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_7 - ((a2 * org.apache.commons.math3.util.FastMath.F_1_9) * org.apache.commons.math3.util.FastMath.F_7_8))) * org.apache.commons.math3.util.FastMath.F_5_6))) * org.apache.commons.math3.util.FastMath.F_3_4))) * org.apache.commons.math3.util.FastMath.F_1_2));\n            } else {\n                absAsinh = a * (1 - ((a2 * (org.apache.commons.math3.util.FastMath.F_1_3 - ((a2 * org.apache.commons.math3.util.FastMath.F_1_5) * org.apache.commons.math3.util.FastMath.F_3_4))) * org.apache.commons.math3.util.FastMath.F_1_2));\n            }\n        }\n        return negative ? -absAsinh : absAsinh;\n    }\n\n    public static double atanh(double a) {\n        boolean negative = false;\n        if (a < 0) {\n            negative = true;\n            a = -a;\n        }\n        double absAtanh;\n        if (a > 0.15) {\n            absAtanh = 0.5 * org.apache.commons.math3.util.FastMath.log((1 + a) / (1 - a));\n        } else {\n            final double a2 = a * a;\n            if (a > 0.087) {\n                absAtanh = a * (1 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_3 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_5 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_7 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_9 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_11 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_13 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_15 + (a2 * org.apache.commons.math3.util.FastMath.F_1_17))))))))))))))));\n            } else if (a > 0.031) {\n                absAtanh = a * (1 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_3 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_5 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_7 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_9 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_11 + (a2 * org.apache.commons.math3.util.FastMath.F_1_13))))))))))));\n            } else if (a > 0.003) {\n                absAtanh = a * (1 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_3 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_5 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_7 + (a2 * org.apache.commons.math3.util.FastMath.F_1_9))))))));\n            } else {\n                absAtanh = a * (1 + (a2 * (org.apache.commons.math3.util.FastMath.F_1_3 + (a2 * org.apache.commons.math3.util.FastMath.F_1_5))));\n            }\n        }\n        return negative ? -absAtanh : absAtanh;\n    }\n\n    public static double signum(final double a) {\n        return a < 0.0 ? -1.0 : a > 0.0 ? 1.0 : a;\n    }\n\n    public static float signum(final float a) {\n        return a < 0.0F ? -1.0F : a > 0.0F ? 1.0F : a;\n    }\n\n    public static double nextUp(final double a) {\n        return org.apache.commons.math3.util.FastMath.nextAfter(a, java.lang.Double.POSITIVE_INFINITY);\n    }\n\n    public static float nextUp(final float a) {\n        return org.apache.commons.math3.util.FastMath.nextAfter(a, java.lang.Float.POSITIVE_INFINITY);\n    }\n\n    public static double random() {\n        return java.lang.Math.random();\n    }\n\n    public static double exp(double x) {\n        return org.apache.commons.math3.util.FastMath.exp(x, 0.0, null);\n    }\n\n    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n        if (x < 0.0) {\n            intVal = ((int) (-x));\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n            if (intVal > 709) {\n                final double result = org.apache.commons.math3.util.FastMath.exp(x + 40.19140625, extra, hiPrec) / 2.85040095144011776E17;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 2.85040095144011776E17;\n                    hiPrec[1] /= 2.85040095144011776E17;\n                }\n                return result;\n            }\n            if (intVal == 709) {\n                final double result = org.apache.commons.math3.util.FastMath.exp(x + 1.494140625, extra, hiPrec) / 4.455505956692757;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692757;\n                    hiPrec[1] /= 4.455505956692757;\n                }\n                return result;\n            }\n            intVal++;\n            intPartA = org.apache.commons.math3.util.FastMath.ExpIntTable.EXP_INT_TABLE_A[org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX - intVal];\n            intPartB = org.apache.commons.math3.util.FastMath.ExpIntTable.EXP_INT_TABLE_B[org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX - intVal];\n            intVal = -intVal;\n        } else {\n            intVal = ((int) (x));\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = java.lang.Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return java.lang.Double.POSITIVE_INFINITY;\n            }\n            intPartA = org.apache.commons.math3.util.FastMath.ExpIntTable.EXP_INT_TABLE_A[org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX + intVal];\n            intPartB = org.apache.commons.math3.util.FastMath.ExpIntTable.EXP_INT_TABLE_B[org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX + intVal];\n        }\n        final int intFrac = ((int) ((x - intVal) * 1024.0));\n        final double fracPartA = org.apache.commons.math3.util.FastMath.ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = org.apache.commons.math3.util.FastMath.ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n        final double epsilon = x - (intVal + (intFrac / 1024.0));\n        double z = 0.04168701738764507;\n        z = (z * epsilon) + 0.1666666505023083;\n        z = (z * epsilon) + 0.5000000000042687;\n        z = (z * epsilon) + 1.0;\n        z = (z * epsilon) + (-3.940510424527919E-20);\n        double tempA = intPartA * fracPartA;\n        double tempB = ((intPartA * fracPartB) + (intPartB * fracPartA)) + (intPartB * fracPartB);\n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = (((((tempC * extra) * z) + (tempC * extra)) + (tempC * z)) + tempB) + tempA;\n        } else {\n            result = ((tempC * z) + tempB) + tempA;\n        }\n        if (hiPrec != null) {\n            hiPrec[0] = tempA;\n            hiPrec[1] = ((((tempC * extra) * z) + (tempC * extra)) + (tempC * z)) + tempB;\n        }\n        return result;\n    }\n\n    public static double expm1(double x) {\n        return org.apache.commons.math3.util.FastMath.expm1(x, null);\n    }\n\n    private static double expm1(double x, double[] hiPrecOut) {\n        if ((x != x) || (x == 0.0)) {\n            return x;\n        }\n        if ((x <= (-1.0)) || (x >= 1.0)) {\n            double[] hiPrec = new double[2];\n            org.apache.commons.math3.util.FastMath.exp(x, 0.0, hiPrec);\n            if (x > 0.0) {\n                return ((-1.0) + hiPrec[0]) + hiPrec[1];\n            } else {\n                final double ra = (-1.0) + hiPrec[0];\n                double rb = -((ra + 1.0) - hiPrec[0]);\n                rb += hiPrec[1];\n                return ra + rb;\n            }\n        }\n        double baseA;\n        double baseB;\n        double epsilon;\n        boolean negative = false;\n        if (x < 0.0) {\n            x = -x;\n            negative = true;\n        }\n        {\n            int intFrac = ((int) (x * 1024.0));\n            double tempA = org.apache.commons.math3.util.FastMath.ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;\n            double tempB = org.apache.commons.math3.util.FastMath.ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n            double temp = tempA + tempB;\n            tempB = -((temp - tempA) - tempB);\n            tempA = temp;\n            temp = tempA * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            baseA = (tempA + temp) - temp;\n            baseB = tempB + (tempA - baseA);\n            epsilon = x - (intFrac / 1024.0);\n        }\n        double zb = 0.008336750013465571;\n        zb = (zb * epsilon) + 0.041666663879186654;\n        zb = (zb * epsilon) + 0.16666666666745392;\n        zb = (zb * epsilon) + 0.49999999999999994;\n        zb = zb * epsilon;\n        zb = zb * epsilon;\n        double za = epsilon;\n        double temp = za + zb;\n        zb = -((temp - za) - zb);\n        za = temp;\n        temp = za * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        temp = (za + temp) - temp;\n        zb += za - temp;\n        za = temp;\n        double ya = za * baseA;\n        temp = ya + (za * baseB);\n        double yb = -((temp - ya) - (za * baseB));\n        ya = temp;\n        temp = ya + (zb * baseA);\n        yb += -((temp - ya) - (zb * baseA));\n        ya = temp;\n        temp = ya + (zb * baseB);\n        yb += -((temp - ya) - (zb * baseB));\n        ya = temp;\n        temp = ya + baseA;\n        yb += -((temp - baseA) - ya);\n        ya = temp;\n        temp = ya + za;\n        yb += -((temp - ya) - za);\n        ya = temp;\n        temp = ya + baseB;\n        yb += -((temp - ya) - baseB);\n        ya = temp;\n        temp = ya + zb;\n        yb += -((temp - ya) - zb);\n        ya = temp;\n        if (negative) {\n            double denom = 1.0 + ya;\n            double denomr = 1.0 / denom;\n            double denomb = (-((denom - 1.0) - ya)) + yb;\n            double ratio = ya * denomr;\n            temp = ratio * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            final double ra = (ratio + temp) - temp;\n            double rb = ratio - ra;\n            temp = denom * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            za = (denom + temp) - temp;\n            zb = denom - za;\n            rb += ((((ya - (za * ra)) - (za * rb)) - (zb * ra)) - (zb * rb)) * denomr;\n            rb += yb * denomr;\n            rb += (((-ya) * denomb) * denomr) * denomr;\n            ya = -ra;\n            yb = -rb;\n        }\n        if (hiPrecOut != null) {\n            hiPrecOut[0] = ya;\n            hiPrecOut[1] = yb;\n        }\n        return ya + yb;\n    }\n\n    public static double log(final double x) {\n        return org.apache.commons.math3.util.FastMath.log(x, null);\n    }\n\n    private static double log(final double x, final double[] hiPrec) {\n        if (x == 0) {\n            return java.lang.Double.NEGATIVE_INFINITY;\n        }\n        long bits = java.lang.Double.doubleToLongBits(x);\n        if (((bits & 0x8000000000000000L) != 0) || (x != x)) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = java.lang.Double.NaN;\n                }\n                return java.lang.Double.NaN;\n            }\n        }\n        if (x == java.lang.Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = java.lang.Double.POSITIVE_INFINITY;\n            }\n            return java.lang.Double.POSITIVE_INFINITY;\n        }\n        int exp = ((int) (bits >> 52)) - 1023;\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            if (x == 0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = java.lang.Double.NEGATIVE_INFINITY;\n                }\n                return java.lang.Double.NEGATIVE_INFINITY;\n            }\n            bits <<= 1;\n            while ((bits & 0x10000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            } \n        }\n        if ((exp == (-1)) || (exp == 0)) {\n            if (((x < 1.01) && (x > 0.99)) && (hiPrec == null)) {\n                double xa = x - 1.0;\n                double xb = (xa - x) + 1.0;\n                double tmp = xa * org.apache.commons.math3.util.FastMath.HEX_40000000;\n                double aa = (xa + tmp) - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n                final double[] lnCoef_last = org.apache.commons.math3.util.FastMath.LN_QUICK_COEF[org.apache.commons.math3.util.FastMath.LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n                for (int i = org.apache.commons.math3.util.FastMath.LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    aa = ya * xa;\n                    ab = ((ya * xb) + (yb * xa)) + (yb * xb);\n                    tmp = aa * org.apache.commons.math3.util.FastMath.HEX_40000000;\n                    ya = (aa + tmp) - tmp;\n                    yb = (aa - ya) + ab;\n                    final double[] lnCoef_i = org.apache.commons.math3.util.FastMath.LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    tmp = aa * org.apache.commons.math3.util.FastMath.HEX_40000000;\n                    ya = (aa + tmp) - tmp;\n                    yb = (aa - ya) + ab;\n                }\n                aa = ya * xa;\n                ab = ((ya * xb) + (yb * xa)) + (yb * xb);\n                tmp = aa * org.apache.commons.math3.util.FastMath.HEX_40000000;\n                ya = (aa + tmp) - tmp;\n                yb = (aa - ya) + ab;\n                return ya + yb;\n            }\n        }\n        final double[] lnm = org.apache.commons.math3.util.FastMath.lnMant.LN_MANT[((int) ((bits & 0xffc0000000000L) >> 42))];\n        final double epsilon = (bits & 0x3ffffffffffL) / (org.apache.commons.math3.util.FastMath.TWO_POWER_52 + (bits & 0xffc0000000000L));\n        double lnza = 0.0;\n        double lnzb = 0.0;\n        if (hiPrec != null) {\n            double tmp = epsilon * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            double aa = (epsilon + tmp) - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = org.apache.commons.math3.util.FastMath.TWO_POWER_52 + (bits & 0xffc0000000000L);\n            aa = (numer - (xa * denom)) - (xb * denom);\n            xb += aa / denom;\n            final double[] lnCoef_last = org.apache.commons.math3.util.FastMath.LN_HI_PREC_COEF[org.apache.commons.math3.util.FastMath.LN_HI_PREC_COEF.length - 1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n            for (int i = org.apache.commons.math3.util.FastMath.LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                aa = ya * xa;\n                ab = ((ya * xb) + (yb * xa)) + (yb * xb);\n                tmp = aa * org.apache.commons.math3.util.FastMath.HEX_40000000;\n                ya = (aa + tmp) - tmp;\n                yb = (aa - ya) + ab;\n                final double[] lnCoef_i = org.apache.commons.math3.util.FastMath.LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                tmp = aa * org.apache.commons.math3.util.FastMath.HEX_40000000;\n                ya = (aa + tmp) - tmp;\n                yb = (aa - ya) + ab;\n            }\n            aa = ya * xa;\n            ab = ((ya * xb) + (yb * xa)) + (yb * xb);\n            lnza = aa + ab;\n            lnzb = -((lnza - aa) - ab);\n        } else {\n            lnza = -0.16624882440418567;\n            lnza = (lnza * epsilon) + 0.19999954120254515;\n            lnza = (lnza * epsilon) + (-0.2499999997677497);\n            lnza = (lnza * epsilon) + 0.3333333333332802;\n            lnza = (lnza * epsilon) + (-0.5);\n            lnza = (lnza * epsilon) + 1.0;\n            lnza = lnza * epsilon;\n        }\n        double a = org.apache.commons.math3.util.FastMath.LN_2_A * exp;\n        double b = 0.0;\n        double c = a + lnm[0];\n        double d = -((c - a) - lnm[0]);\n        a = c;\n        b = b + d;\n        c = a + lnza;\n        d = -((c - a) - lnza);\n        a = c;\n        b = b + d;\n        c = a + (org.apache.commons.math3.util.FastMath.LN_2_B * exp);\n        d = -((c - a) - (org.apache.commons.math3.util.FastMath.LN_2_B * exp));\n        a = c;\n        b = b + d;\n        c = a + lnm[1];\n        d = -((c - a) - lnm[1]);\n        a = c;\n        b = b + d;\n        c = a + lnzb;\n        d = -((c - a) - lnzb);\n        a = c;\n        b = b + d;\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n        return a + b;\n    }\n\n    public static double log1p(final double x) {\n        if (x == (-1)) {\n            return java.lang.Double.NEGATIVE_INFINITY;\n        }\n        if (x == java.lang.Double.POSITIVE_INFINITY) {\n            return java.lang.Double.POSITIVE_INFINITY;\n        }\n        if ((x > 1.0E-6) || (x < (-1.0E-6))) {\n            final double xpa = 1 + x;\n            final double xpb = -((xpa - 1) - x);\n            final double[] hiPrec = new double[2];\n            final double lores = org.apache.commons.math3.util.FastMath.log(xpa, hiPrec);\n            if (java.lang.Double.isInfinite(lores)) {\n                return lores;\n            }\n            final double fx1 = xpb / xpa;\n            final double epsilon = (0.5 * fx1) + 1;\n            return ((epsilon * fx1) + hiPrec[1]) + hiPrec[0];\n        } else {\n            final double y = (((x * org.apache.commons.math3.util.FastMath.F_1_3) - org.apache.commons.math3.util.FastMath.F_1_2) * x) + 1;\n            return y * x;\n        }\n    }\n\n    public static double log10(final double x) {\n        final double[] hiPrec = new double[2];\n        final double lores = org.apache.commons.math3.util.FastMath.log(x, hiPrec);\n        if (java.lang.Double.isInfinite(lores)) {\n            return lores;\n        }\n        final double tmp = hiPrec[0] * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        final double lna = (hiPrec[0] + tmp) - tmp;\n        final double lnb = (hiPrec[0] - lna) + hiPrec[1];\n        final double rln10a = 0.4342944622039795;\n        final double rln10b = 1.9699272335463627E-8;\n        return (((rln10b * lnb) + (rln10b * lna)) + (rln10a * lnb)) + (rln10a * lna);\n    }\n\n    public static double log(double base, double x) {\n        return org.apache.commons.math3.util.FastMath.log(x) / org.apache.commons.math3.util.FastMath.log(base);\n    }\n\n    public static double pow(double x, double y) {\n        final double[] lns = new double[2];\n        if (y == 0.0) {\n            return 1.0;\n        }\n        if (x != x) {\n            return x;\n        }\n        if (x == 0) {\n            long bits = java.lang.Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                long yi = ((long) (y));\n                if (((y < 0) && (y == yi)) && ((yi & 1) == 1)) {\n                    return java.lang.Double.NEGATIVE_INFINITY;\n                }\n                if (((y > 0) && (y == yi)) && ((yi & 1) == 1)) {\n                    return -0.0;\n                }\n            }\n            if (y < 0) {\n                return java.lang.Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n            return java.lang.Double.NaN;\n        }\n        if (x == java.lang.Double.POSITIVE_INFINITY) {\n            if (y != y) {\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return java.lang.Double.POSITIVE_INFINITY;\n            }\n        }\n        if (y == java.lang.Double.POSITIVE_INFINITY) {\n            if ((x * x) == 1.0) {\n                return java.lang.Double.NaN;\n            }\n            if ((x * x) > 1.0) {\n                return java.lang.Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n        if (x == java.lang.Double.NEGATIVE_INFINITY) {\n            if (y != y) {\n                return y;\n            }\n            if (y < 0) {\n                long yi = ((long) (y));\n                if ((y == yi) && ((yi & 1) == 1)) {\n                    return -0.0;\n                }\n                return 0.0;\n            }\n            if (y > 0) {\n                long yi = ((long) (y));\n                if ((y == yi) && ((yi & 1) == 1)) {\n                    return java.lang.Double.NEGATIVE_INFINITY;\n                }\n                return java.lang.Double.POSITIVE_INFINITY;\n            }\n        }\n        if (y == java.lang.Double.NEGATIVE_INFINITY) {\n            if ((x * x) == 1.0) {\n                return java.lang.Double.NaN;\n            }\n            if ((x * x) < 1.0) {\n                return java.lang.Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n        if (x < 0) {\n            if ((y >= org.apache.commons.math3.util.FastMath.TWO_POWER_53) || (y <= (-org.apache.commons.math3.util.FastMath.TWO_POWER_53))) {\n                return org.apache.commons.math3.util.FastMath.pow(-x, y);\n            }\n            if (y == ((long) (y))) {\n                return (((long) (y)) & 1) == 0 ? org.apache.commons.math3.util.FastMath.pow(-x, y) : -org.apache.commons.math3.util.FastMath.pow(-x, y);\n            } else {\n                return java.lang.Double.NaN;\n            }\n        }\n        double ya;\n        double yb;\n        if ((y < 8.0E298) && (y > (-8.0E298))) {\n            double tmp1 = y * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            ya = (y + tmp1) - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.313225746154785E-10;\n            double tmp2 = tmp1 * 9.313225746154785E-10;\n            ya = (((tmp1 + tmp2) - tmp1) * org.apache.commons.math3.util.FastMath.HEX_40000000) * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            yb = y - ya;\n        }\n        final double lores = org.apache.commons.math3.util.FastMath.log(x, lns);\n        if (java.lang.Double.isInfinite(lores)) {\n            return lores;\n        }\n        double lna = lns[0];\n        double lnb = lns[1];\n        double tmp1 = lna * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double tmp2 = (lna + tmp1) - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n        final double aa = lna * ya;\n        final double ab = ((lna * yb) + (lnb * ya)) + (lnb * yb);\n        lna = aa + ab;\n        lnb = -((lna - aa) - ab);\n        double z = 1.0 / 120.0;\n        z = (z * lnb) + (1.0 / 24.0);\n        z = (z * lnb) + (1.0 / 6.0);\n        z = (z * lnb) + 0.5;\n        z = (z * lnb) + 1.0;\n        z = z * lnb;\n        final double result = org.apache.commons.math3.util.FastMath.exp(lna, z, null);\n        return result;\n    }\n\n    public static double pow(double d, int e) {\n        if (e == 0) {\n            return 1.0;\n        } else if (e < 0) {\n            e = -e;\n            d = 1.0 / d;\n        }\n        final int splitFactor = 0x8000001;\n        final double cd = splitFactor * d;\n        final double d1High = cd - (cd - d);\n        final double d1Low = d - d1High;\n        double resultHigh = 1;\n        double resultLow = 0;\n        double d2p = d;\n        double d2pHigh = d1High;\n        double d2pLow = d1Low;\n        while (e != 0) {\n            if ((e & 0x1) != 0) {\n                final double tmpHigh = resultHigh * d2p;\n                final double cRH = splitFactor * resultHigh;\n                final double rHH = cRH - (cRH - resultHigh);\n                final double rHL = resultHigh - rHH;\n                final double tmpLow = (rHL * d2pLow) - (((tmpHigh - (rHH * d2pHigh)) - (rHL * d2pHigh)) - (rHH * d2pLow));\n                resultHigh = tmpHigh;\n                resultLow = (resultLow * d2p) + tmpLow;\n            }\n            final double tmpHigh = d2pHigh * d2p;\n            final double cD2pH = splitFactor * d2pHigh;\n            final double d2pHH = cD2pH - (cD2pH - d2pHigh);\n            final double d2pHL = d2pHigh - d2pHH;\n            final double tmpLow = (d2pHL * d2pLow) - (((tmpHigh - (d2pHH * d2pHigh)) - (d2pHL * d2pHigh)) - (d2pHH * d2pLow));\n            final double cTmpH = splitFactor * tmpHigh;\n            d2pHigh = cTmpH - (cTmpH - tmpHigh);\n            d2pLow = ((d2pLow * d2p) + tmpLow) + (tmpHigh - d2pHigh);\n            d2p = d2pHigh + d2pLow;\n            e = e >> 1;\n        } \n        return resultHigh + resultLow;\n    }\n\n    private static double polySine(final double x) {\n        double x2 = x * x;\n        double p = 2.7553817452272217E-6;\n        p = (p * x2) + (-1.9841269659586505E-4);\n        p = (p * x2) + 0.008333333333329196;\n        p = (p * x2) + (-0.16666666666666666);\n        p = (p * x2) * x;\n        return p;\n    }\n\n    private static double polyCosine(double x) {\n        double x2 = x * x;\n        double p = 2.479773539153719E-5;\n        p = (p * x2) + (-0.0013888888689039883);\n        p = (p * x2) + 0.041666666666621166;\n        p = (p * x2) + (-0.49999999999999994);\n        p *= x2;\n        return p;\n    }\n\n    private static double sinQ(double xa, double xb) {\n        int idx = ((int) ((xa * 8.0) + 0.5));\n        final double epsilon = xa - org.apache.commons.math3.util.FastMath.EIGHTHS[idx];\n        final double sintA = org.apache.commons.math3.util.FastMath.SINE_TABLE_A[idx];\n        final double sintB = org.apache.commons.math3.util.FastMath.SINE_TABLE_B[idx];\n        final double costA = org.apache.commons.math3.util.FastMath.COSINE_TABLE_A[idx];\n        final double costB = org.apache.commons.math3.util.FastMath.COSINE_TABLE_B[idx];\n        double sinEpsA = epsilon;\n        double sinEpsB = org.apache.commons.math3.util.FastMath.polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = org.apache.commons.math3.util.FastMath.polyCosine(epsilon);\n        final double temp = sinEpsA * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB += sinEpsA - temp2;\n        sinEpsA = temp2;\n        double result;\n        double a = 0;\n        double b = 0;\n        double t = sintA;\n        double c = a + t;\n        double d = -((c - a) - t);\n        a = c;\n        b = b + d;\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -((c - a) - t);\n        a = c;\n        b = b + d;\n        b = (b + (sintA * cosEpsB)) + (costA * sinEpsB);\n        b = (((b + sintB) + (costB * sinEpsA)) + (sintB * cosEpsB)) + (costB * sinEpsB);\n        if (xb != 0.0) {\n            t = (((costA + costB) * (cosEpsA + cosEpsB)) - ((sintA + sintB) * (sinEpsA + sinEpsB))) * xb;\n            c = a + t;\n            d = -((c - a) - t);\n            a = c;\n            b = b + d;\n        }\n        result = a + b;\n        return result;\n    }\n\n    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n        final double a = pi2a - xa;\n        double b = -((a - pi2a) + xa);\n        b += pi2b - xb;\n        return org.apache.commons.math3.util.FastMath.sinQ(a, b);\n    }\n\n    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n        int idx = ((int) ((xa * 8.0) + 0.5));\n        final double epsilon = xa - org.apache.commons.math3.util.FastMath.EIGHTHS[idx];\n        final double sintA = org.apache.commons.math3.util.FastMath.SINE_TABLE_A[idx];\n        final double sintB = org.apache.commons.math3.util.FastMath.SINE_TABLE_B[idx];\n        final double costA = org.apache.commons.math3.util.FastMath.COSINE_TABLE_A[idx];\n        final double costB = org.apache.commons.math3.util.FastMath.COSINE_TABLE_B[idx];\n        double sinEpsA = epsilon;\n        double sinEpsB = org.apache.commons.math3.util.FastMath.polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = org.apache.commons.math3.util.FastMath.polyCosine(epsilon);\n        double temp = sinEpsA * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB += sinEpsA - temp2;\n        sinEpsA = temp2;\n        double a = 0;\n        double b = 0;\n        double t = sintA;\n        double c = a + t;\n        double d = -((c - a) - t);\n        a = c;\n        b = b + d;\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -((c - a) - t);\n        a = c;\n        b = b + d;\n        b = (b + (sintA * cosEpsB)) + (costA * sinEpsB);\n        b = (((b + sintB) + (costB * sinEpsA)) + (sintB * cosEpsB)) + (costB * sinEpsB);\n        double sina = a + b;\n        double sinb = -((sina - a) - b);\n        a = b = c = d = 0.0;\n        t = costA * cosEpsA;\n        c = a + t;\n        d = -((c - a) - t);\n        a = c;\n        b = b + d;\n        t = (-sintA) * sinEpsA;\n        c = a + t;\n        d = -((c - a) - t);\n        a = c;\n        b = b + d;\n        b = ((b + (costB * cosEpsA)) + (costA * cosEpsB)) + (costB * cosEpsB);\n        b = b - (((sintB * sinEpsA) + (sintA * sinEpsB)) + (sintB * sinEpsB));\n        double cosa = a + b;\n        double cosb = -((cosa - a) - b);\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa;\n            cosa = sina;\n            sina = tmp;\n            tmp = cosb;\n            cosb = sinb;\n            sinb = tmp;\n        }\n        double est = sina / cosa;\n        temp = est * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb = est - esta;\n        temp = cosa * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab = cosa - cosaa;\n        double err = ((((sina - (esta * cosaa)) - (esta * cosab)) - (estb * cosaa)) - (estb * cosab)) / cosa;\n        err += sinb / cosa;\n        err += (((-sina) * cosb) / cosa) / cosa;\n        if (xb != 0.0) {\n            double xbadj = xb + ((est * est) * xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n            err += xbadj;\n        }\n        return est + err;\n    }\n\n    private static void reducePayneHanek(double x, double[] result) {\n        long inbits = java.lang.Double.doubleToLongBits(x);\n        int exponent = ((int) ((inbits >> 52) & 0x7ff)) - 1023;\n        inbits &= 0xfffffffffffffL;\n        inbits |= 0x10000000000000L;\n        exponent++;\n        inbits <<= 11;\n        long shpi0;\n        long shpiA;\n        long shpiB;\n        int idx = exponent >> 6;\n        int shift = exponent - (idx << 6);\n        if (shift != 0) {\n            shpi0 = (idx == 0) ? 0 : org.apache.commons.math3.util.FastMath.RECIP_2PI[idx - 1] << shift;\n            shpi0 |= org.apache.commons.math3.util.FastMath.RECIP_2PI[idx] >>> (64 - shift);\n            shpiA = (org.apache.commons.math3.util.FastMath.RECIP_2PI[idx] << shift) | (org.apache.commons.math3.util.FastMath.RECIP_2PI[idx + 1] >>> (64 - shift));\n            shpiB = (org.apache.commons.math3.util.FastMath.RECIP_2PI[idx + 1] << shift) | (org.apache.commons.math3.util.FastMath.RECIP_2PI[idx + 2] >>> (64 - shift));\n        } else {\n            shpi0 = (idx == 0) ? 0 : org.apache.commons.math3.util.FastMath.RECIP_2PI[idx - 1];\n            shpiA = org.apache.commons.math3.util.FastMath.RECIP_2PI[idx];\n            shpiB = org.apache.commons.math3.util.FastMath.RECIP_2PI[idx + 1];\n        }\n        long a = inbits >>> 32;\n        long b = inbits & 0xffffffffL;\n        long c = shpiA >>> 32;\n        long d = shpiA & 0xffffffffL;\n        long ac = a * c;\n        long bd = b * d;\n        long bc = b * c;\n        long ad = a * d;\n        long prodB = bd + (ad << 32);\n        long prodA = ac + (ad >>> 32);\n        boolean bita = (bd & 0x8000000000000000L) != 0;\n        boolean bitb = (ad & 0x80000000L) != 0;\n        boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n        if ((bita && bitb) || ((bita || bitb) && (!bitsum))) {\n            prodA++;\n        }\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L) != 0;\n        prodB = prodB + (bc << 32);\n        prodA = prodA + (bc >>> 32);\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        if ((bita && bitb) || ((bita || bitb) && (!bitsum))) {\n            prodA++;\n        }\n        c = shpiB >>> 32;\n        d = shpiB & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n        ac = ac + ((bc + ad) >>> 32);\n        bita = (prodB & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L) != 0;\n        prodB += ac;\n        bitsum = (prodB & 0x8000000000000000L) != 0;\n        if ((bita && bitb) || ((bita || bitb) && (!bitsum))) {\n            prodA++;\n        }\n        c = shpi0 >>> 32;\n        d = shpi0 & 0xffffffffL;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n        prodA += bd + ((bc + ad) << 32);\n        int intPart = ((int) (prodA >>> 62));\n        prodA <<= 2;\n        prodA |= prodB >>> 62;\n        prodB <<= 2;\n        a = prodA >>> 32;\n        b = prodA & 0xffffffffL;\n        c = org.apache.commons.math3.util.FastMath.PI_O_4_BITS[0] >>> 32;\n        d = org.apache.commons.math3.util.FastMath.PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bd = b * d;\n        bc = b * c;\n        ad = a * d;\n        long prod2B = bd + (ad << 32);\n        long prod2A = ac + (ad >>> 32);\n        bita = (bd & 0x8000000000000000L) != 0;\n        bitb = (ad & 0x80000000L) != 0;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        if ((bita && bitb) || ((bita || bitb) && (!bitsum))) {\n            prod2A++;\n        }\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (bc & 0x80000000L) != 0;\n        prod2B = prod2B + (bc << 32);\n        prod2A = prod2A + (bc >>> 32);\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        if ((bita && bitb) || ((bita || bitb) && (!bitsum))) {\n            prod2A++;\n        }\n        c = org.apache.commons.math3.util.FastMath.PI_O_4_BITS[1] >>> 32;\n        d = org.apache.commons.math3.util.FastMath.PI_O_4_BITS[1] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n        ac = ac + ((bc + ad) >>> 32);\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        if ((bita && bitb) || ((bita || bitb) && (!bitsum))) {\n            prod2A++;\n        }\n        a = prodB >>> 32;\n        b = prodB & 0xffffffffL;\n        c = org.apache.commons.math3.util.FastMath.PI_O_4_BITS[0] >>> 32;\n        d = org.apache.commons.math3.util.FastMath.PI_O_4_BITS[0] & 0xffffffffL;\n        ac = a * c;\n        bc = b * c;\n        ad = a * d;\n        ac = ac + ((bc + ad) >>> 32);\n        bita = (prod2B & 0x8000000000000000L) != 0;\n        bitb = (ac & 0x8000000000000000L) != 0;\n        prod2B += ac;\n        bitsum = (prod2B & 0x8000000000000000L) != 0;\n        if ((bita && bitb) || ((bita || bitb) && (!bitsum))) {\n            prod2A++;\n        }\n        double tmpA = (prod2A >>> 12) / org.apache.commons.math3.util.FastMath.TWO_POWER_52;\n        double tmpB = ((((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / org.apache.commons.math3.util.FastMath.TWO_POWER_52) / org.apache.commons.math3.util.FastMath.TWO_POWER_52;\n        double sumA = tmpA + tmpB;\n        double sumB = -((sumA - tmpA) - tmpB);\n        result[0] = intPart;\n        result[1] = sumA * 2.0;\n        result[2] = sumB * 2.0;\n    }\n\n    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n        if (xa == 0.0) {\n            long bits = java.lang.Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n        if ((xa != xa) || (xa == java.lang.Double.POSITIVE_INFINITY)) {\n            return java.lang.Double.NaN;\n        }\n        if (xa > 3294198.0) {\n            double[] reduceResults = new double[3];\n            org.apache.commons.math3.util.FastMath.reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) (reduceResults[0])) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final org.apache.commons.math3.util.FastMath.CodyWaite cw = new org.apache.commons.math3.util.FastMath.CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n        if (negative) {\n            quadrant ^= 2;\n        }\n        switch (quadrant) {\n            case 0 :\n                return org.apache.commons.math3.util.FastMath.sinQ(xa, xb);\n            case 1 :\n                return org.apache.commons.math3.util.FastMath.cosQ(xa, xb);\n            case 2 :\n                return -org.apache.commons.math3.util.FastMath.sinQ(xa, xb);\n            case 3 :\n                return -org.apache.commons.math3.util.FastMath.cosQ(xa, xb);\n            default :\n                return java.lang.Double.NaN;\n        }\n    }\n\n    public static double cos(double x) {\n        int quadrant = 0;\n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n        if ((xa != xa) || (xa == java.lang.Double.POSITIVE_INFINITY)) {\n            return java.lang.Double.NaN;\n        }\n        double xb = 0;\n        if (xa > 3294198.0) {\n            double[] reduceResults = new double[3];\n            org.apache.commons.math3.util.FastMath.reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) (reduceResults[0])) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final org.apache.commons.math3.util.FastMath.CodyWaite cw = new org.apache.commons.math3.util.FastMath.CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n        switch (quadrant) {\n            case 0 :\n                return org.apache.commons.math3.util.FastMath.cosQ(xa, xb);\n            case 1 :\n                return -org.apache.commons.math3.util.FastMath.sinQ(xa, xb);\n            case 2 :\n                return -org.apache.commons.math3.util.FastMath.cosQ(xa, xb);\n            case 3 :\n                return org.apache.commons.math3.util.FastMath.sinQ(xa, xb);\n            default :\n                return java.lang.Double.NaN;\n        }\n    }\n\n    public static double tan(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n        if (xa == 0.0) {\n            long bits = java.lang.Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n        if ((xa != xa) || (xa == java.lang.Double.POSITIVE_INFINITY)) {\n            return java.lang.Double.NaN;\n        }\n        double xb = 0;\n        if (xa > 3294198.0) {\n            double[] reduceResults = new double[3];\n            org.apache.commons.math3.util.FastMath.reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) (reduceResults[0])) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final org.apache.commons.math3.util.FastMath.CodyWaite cw = new org.apache.commons.math3.util.FastMath.CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n        if (xa > 1.5) {\n            final double pi2a = 1.5707963267948966;\n            final double pi2b = 6.123233995736766E-17;\n            final double a = pi2a - xa;\n            double b = -((a - pi2a) + xa);\n            b += pi2b - xb;\n            xa = a + b;\n            xb = -((xa - a) - b);\n            quadrant ^= 1;\n            negative ^= true;\n        }\n        double result;\n        if ((quadrant & 1) == 0) {\n            result = org.apache.commons.math3.util.FastMath.tanQ(xa, xb, false);\n        } else {\n            result = -org.apache.commons.math3.util.FastMath.tanQ(xa, xb, true);\n        }\n        if (negative) {\n            result = -result;\n        }\n        return result;\n    }\n\n    public static double atan(double x) {\n        return org.apache.commons.math3.util.FastMath.atan(x, 0.0, false);\n    }\n\n    private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate = false;\n        int idx;\n        if (xa == 0.0) {\n            return leftPlane ? org.apache.commons.math3.util.FastMath.copySign(java.lang.Math.PI, xa) : xa;\n        }\n        if (xa < 0) {\n            xa = -xa;\n            xb = -xb;\n            negate = true;\n        }\n        if (xa > 1.633123935319537E16) {\n            return negate ^ leftPlane ? (-java.lang.Math.PI) * org.apache.commons.math3.util.FastMath.F_1_2 : java.lang.Math.PI * org.apache.commons.math3.util.FastMath.F_1_2;\n        }\n        if (xa < 1) {\n            idx = ((int) ((((((-1.7168146928204135) * xa) * xa) + 8.0) * xa) + 0.5));\n        } else {\n            final double oneOverXa = 1 / xa;\n            idx = ((int) ((-(((((-1.7168146928204135) * oneOverXa) * oneOverXa) + 8.0) * oneOverXa)) + 13.07));\n        }\n        double epsA = xa - org.apache.commons.math3.util.FastMath.TANGENT_TABLE_A[idx];\n        double epsB = -((epsA - xa) + org.apache.commons.math3.util.FastMath.TANGENT_TABLE_A[idx]);\n        epsB += xb - org.apache.commons.math3.util.FastMath.TANGENT_TABLE_B[idx];\n        double temp = epsA + epsB;\n        epsB = -((temp - epsA) - epsB);\n        epsA = temp;\n        temp = xa * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double ya = (xa + temp) - temp;\n        double yb = (xb + xa) - ya;\n        xa = ya;\n        xb += yb;\n        if (idx == 0) {\n            final double denom = 1.0 / (1.0 + ((xa + xb) * (org.apache.commons.math3.util.FastMath.TANGENT_TABLE_A[idx] + org.apache.commons.math3.util.FastMath.TANGENT_TABLE_B[idx])));\n            ya = epsA * denom;\n            yb = epsB * denom;\n        } else {\n            double temp2 = xa * org.apache.commons.math3.util.FastMath.TANGENT_TABLE_A[idx];\n            double za = 1.0 + temp2;\n            double zb = -((za - 1.0) - temp2);\n            temp2 = (xb * org.apache.commons.math3.util.FastMath.TANGENT_TABLE_A[idx]) + (xa * org.apache.commons.math3.util.FastMath.TANGENT_TABLE_B[idx]);\n            temp = za + temp2;\n            zb += -((temp - za) - temp2);\n            za = temp;\n            zb += xb * org.apache.commons.math3.util.FastMath.TANGENT_TABLE_B[idx];\n            ya = epsA / za;\n            temp = ya * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            final double yaa = (ya + temp) - temp;\n            final double yab = ya - yaa;\n            temp = za * org.apache.commons.math3.util.FastMath.HEX_40000000;\n            final double zaa = (za + temp) - temp;\n            final double zab = za - zaa;\n            yb = ((((epsA - (yaa * zaa)) - (yaa * zab)) - (yab * zaa)) - (yab * zab)) / za;\n            yb += (((-epsA) * zb) / za) / za;\n            yb += epsB / za;\n        }\n        epsA = ya;\n        epsB = yb;\n        final double epsA2 = epsA * epsA;\n        yb = 0.07490822288864472;\n        yb = (yb * epsA2) + (-0.09088450866185192);\n        yb = (yb * epsA2) + 0.11111095942313305;\n        yb = (yb * epsA2) + (-0.1428571423679182);\n        yb = (yb * epsA2) + 0.19999999999923582;\n        yb = (yb * epsA2) + (-0.33333333333333287);\n        yb = (yb * epsA2) * epsA;\n        ya = epsA;\n        temp = ya + yb;\n        yb = -((temp - ya) - yb);\n        ya = temp;\n        yb += epsB / (1.0 + (epsA * epsA));\n        double za = org.apache.commons.math3.util.FastMath.EIGHTHS[idx] + ya;\n        double zb = -((za - org.apache.commons.math3.util.FastMath.EIGHTHS[idx]) - ya);\n        temp = za + yb;\n        zb += -((temp - za) - yb);\n        za = temp;\n        double result = za + zb;\n        double resultb = -((result - za) - zb);\n        if (leftPlane) {\n            final double pia = 1.5707963267948966 * 2;\n            final double pib = 6.123233995736766E-17 * 2;\n            za = pia - result;\n            zb = -((za - pia) + result);\n            zb += pib - resultb;\n            result = za + zb;\n            resultb = -((result - za) - zb);\n        }\n        if (negate ^ leftPlane) {\n            result = -result;\n        }\n        return result;\n    }\n\n    public static double atan2(double y, double x) {\n        if ((x != x) || (y != y)) {\n            return java.lang.Double.NaN;\n        }\n        if (y == 0) {\n            final double result = x * y;\n            final double invx = 1.0 / x;\n            final double invy = 1.0 / y;\n            if (invx == 0) {\n                if (x > 0) {\n                    return y;\n                } else {\n                    return org.apache.commons.math3.util.FastMath.copySign(java.lang.Math.PI, y);\n                }\n            }\n            if ((x < 0) || (invx < 0)) {\n                if ((y < 0) || (invy < 0)) {\n                    return -java.lang.Math.PI;\n                } else {\n                    return java.lang.Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n        if (y == java.lang.Double.POSITIVE_INFINITY) {\n            if (x == java.lang.Double.POSITIVE_INFINITY) {\n                return java.lang.Math.PI * org.apache.commons.math3.util.FastMath.F_1_4;\n            }\n            if (x == java.lang.Double.NEGATIVE_INFINITY) {\n                return java.lang.Math.PI * org.apache.commons.math3.util.FastMath.F_3_4;\n            }\n            return java.lang.Math.PI * org.apache.commons.math3.util.FastMath.F_1_2;\n        }\n        if (y == java.lang.Double.NEGATIVE_INFINITY) {\n            if (x == java.lang.Double.POSITIVE_INFINITY) {\n                return (-java.lang.Math.PI) * org.apache.commons.math3.util.FastMath.F_1_4;\n            }\n            if (x == java.lang.Double.NEGATIVE_INFINITY) {\n                return (-java.lang.Math.PI) * org.apache.commons.math3.util.FastMath.F_3_4;\n            }\n            return (-java.lang.Math.PI) * org.apache.commons.math3.util.FastMath.F_1_2;\n        }\n        if (x == java.lang.Double.POSITIVE_INFINITY) {\n            if ((y > 0) || ((1 / y) > 0)) {\n                return 0.0;\n            }\n            if ((y < 0) || ((1 / y) < 0)) {\n                return -0.0;\n            }\n        }\n        if (x == java.lang.Double.NEGATIVE_INFINITY) {\n            if ((y > 0.0) || ((1 / y) > 0.0)) {\n                return java.lang.Math.PI;\n            }\n            if ((y < 0) || ((1 / y) < 0)) {\n                return -java.lang.Math.PI;\n            }\n        }\n        if (x == 0) {\n            if ((y > 0) || ((1 / y) > 0)) {\n                return java.lang.Math.PI * org.apache.commons.math3.util.FastMath.F_1_2;\n            }\n            if ((y < 0) || ((1 / y) < 0)) {\n                return (-java.lang.Math.PI) * org.apache.commons.math3.util.FastMath.F_1_2;\n            }\n        }\n        final double r = y / x;\n        if (java.lang.Double.isInfinite(r)) {\n            return org.apache.commons.math3.util.FastMath.atan(r, 0, x < 0);\n        }\n        double ra = org.apache.commons.math3.util.FastMath.doubleHighPart(r);\n        double rb = r - ra;\n        final double xa = org.apache.commons.math3.util.FastMath.doubleHighPart(x);\n        final double xb = x - xa;\n        rb += ((((y - (ra * xa)) - (ra * xb)) - (rb * xa)) - (rb * xb)) / x;\n        final double temp = ra + rb;\n        rb = -((temp - ra) - rb);\n        ra = temp;\n        if (ra == 0) {\n            ra = org.apache.commons.math3.util.FastMath.copySign(0.0, y);\n        }\n        final double result = org.apache.commons.math3.util.FastMath.atan(ra, rb, x < 0);\n        return result;\n    }\n\n    public static double asin(double x) {\n        if (x != x) {\n            return java.lang.Double.NaN;\n        }\n        if ((x > 1.0) || (x < (-1.0))) {\n            return java.lang.Double.NaN;\n        }\n        if (x == 1.0) {\n            return java.lang.Math.PI / 2.0;\n        }\n        if (x == (-1.0)) {\n            return (-java.lang.Math.PI) / 2.0;\n        }\n        if (x == 0.0) {\n            return x;\n        }\n        double temp = x * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        final double xa = (x + temp) - temp;\n        final double xb = x - xa;\n        double ya = xa * xa;\n        double yb = ((xa * xb) * 2.0) + (xb * xb);\n        ya = -ya;\n        yb = -yb;\n        double za = 1.0 + ya;\n        double zb = -((za - 1.0) - ya);\n        temp = za + yb;\n        zb += -((temp - za) - yb);\n        za = temp;\n        double y;\n        y = org.apache.commons.math3.util.FastMath.sqrt(za);\n        temp = y * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        ya = (y + temp) - temp;\n        yb = y - ya;\n        yb += (((za - (ya * ya)) - ((2 * ya) * yb)) - (yb * yb)) / (2.0 * y);\n        double dx = zb / (2.0 * y);\n        double r = x / y;\n        temp = r * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double ra = (r + temp) - temp;\n        double rb = r - ra;\n        rb += ((((x - (ra * ya)) - (ra * yb)) - (rb * ya)) - (rb * yb)) / y;\n        rb += (((-x) * dx) / y) / y;\n        temp = ra + rb;\n        rb = -((temp - ra) - rb);\n        ra = temp;\n        return org.apache.commons.math3.util.FastMath.atan(ra, rb, false);\n    }\n\n    public static double acos(double x) {\n        if (x != x) {\n            return java.lang.Double.NaN;\n        }\n        if ((x > 1.0) || (x < (-1.0))) {\n            return java.lang.Double.NaN;\n        }\n        if (x == (-1.0)) {\n            return java.lang.Math.PI;\n        }\n        if (x == 1.0) {\n            return 0.0;\n        }\n        if (x == 0) {\n            return java.lang.Math.PI / 2.0;\n        }\n        double temp = x * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        final double xa = (x + temp) - temp;\n        final double xb = x - xa;\n        double ya = xa * xa;\n        double yb = ((xa * xb) * 2.0) + (xb * xb);\n        ya = -ya;\n        yb = -yb;\n        double za = 1.0 + ya;\n        double zb = -((za - 1.0) - ya);\n        temp = za + yb;\n        zb += -((temp - za) - yb);\n        za = temp;\n        double y = org.apache.commons.math3.util.FastMath.sqrt(za);\n        temp = y * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        ya = (y + temp) - temp;\n        yb = y - ya;\n        yb += (((za - (ya * ya)) - ((2 * ya) * yb)) - (yb * yb)) / (2.0 * y);\n        yb += zb / (2.0 * y);\n        y = ya + yb;\n        yb = -((y - ya) - yb);\n        double r = y / x;\n        if (java.lang.Double.isInfinite(r)) {\n            return java.lang.Math.PI / 2;\n        }\n        double ra = org.apache.commons.math3.util.FastMath.doubleHighPart(r);\n        double rb = r - ra;\n        rb += ((((y - (ra * xa)) - (ra * xb)) - (rb * xa)) - (rb * xb)) / x;\n        rb += yb / x;\n        temp = ra + rb;\n        rb = -((temp - ra) - rb);\n        ra = temp;\n        return org.apache.commons.math3.util.FastMath.atan(ra, rb, x < 0);\n    }\n\n    public static double cbrt(double x) {\n        long inbits = java.lang.Double.doubleToLongBits(x);\n        int exponent = ((int) ((inbits >> 52) & 0x7ff)) - 1023;\n        boolean subnormal = false;\n        if (exponent == (-1023)) {\n            if (x == 0) {\n                return x;\n            }\n            subnormal = true;\n            x *= 1.8014398509481984E16;\n            inbits = java.lang.Double.doubleToLongBits(x);\n            exponent = ((int) ((inbits >> 52) & 0x7ff)) - 1023;\n        }\n        if (exponent == 1024) {\n            return x;\n        }\n        int exp3 = exponent / 3;\n        double p2 = java.lang.Double.longBitsToDouble((inbits & 0x8000000000000000L) | (((long) ((exp3 + 1023) & 0x7ff)) << 52));\n        final double mant = java.lang.Double.longBitsToDouble((inbits & 0xfffffffffffffL) | 0x3ff0000000000000L);\n        double est = -0.010714690733195933;\n        est = (est * mant) + 0.0875862700108075;\n        est = (est * mant) + (-0.3058015757857271);\n        est = (est * mant) + 0.7249995199969751;\n        est = (est * mant) + 0.5039018405998233;\n        est *= org.apache.commons.math3.util.FastMath.CBRTTWO[(exponent % 3) + 2];\n        final double xs = x / ((p2 * p2) * p2);\n        est += (xs - ((est * est) * est)) / ((3 * est) * est);\n        est += (xs - ((est * est) * est)) / ((3 * est) * est);\n        double temp = est * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double ya = (est + temp) - temp;\n        double yb = est - ya;\n        double za = ya * ya;\n        double zb = ((ya * yb) * 2.0) + (yb * yb);\n        temp = za * org.apache.commons.math3.util.FastMath.HEX_40000000;\n        double temp2 = (za + temp) - temp;\n        zb += za - temp2;\n        za = temp2;\n        zb = ((za * yb) + (ya * zb)) + (zb * yb);\n        za = za * ya;\n        double na = xs - za;\n        double nb = -((na - xs) + za);\n        nb -= zb;\n        est += (na + nb) / ((3 * est) * est);\n        est *= p2;\n        if (subnormal) {\n            est *= 3.814697265625E-6;\n        }\n        return est;\n    }\n\n    public static double toRadians(double x) {\n        if (java.lang.Double.isInfinite(x) || (x == 0.0)) {\n            return x;\n        }\n        final double facta = 0.01745329052209854;\n        final double factb = 1.997844754509471E-9;\n        double xa = org.apache.commons.math3.util.FastMath.doubleHighPart(x);\n        double xb = x - xa;\n        double result = (((xb * factb) + (xb * facta)) + (xa * factb)) + (xa * facta);\n        if (result == 0) {\n            result = result * x;\n        }\n        return result;\n    }\n\n    public static double toDegrees(double x) {\n        if (java.lang.Double.isInfinite(x) || (x == 0.0)) {\n            return x;\n        }\n        final double facta = 57.2957763671875;\n        final double factb = 3.145894820876798E-6;\n        double xa = org.apache.commons.math3.util.FastMath.doubleHighPart(x);\n        double xb = x - xa;\n        return (((xb * factb) + (xb * facta)) + (xa * factb)) + (xa * facta);\n    }\n\n    public static int abs(final int x) {\n        return x < 0 ? -x : x;\n    }\n\n    public static long abs(final long x) {\n        return x < 0L ? -x : x;\n    }\n\n    public static float abs(final float x) {\n        return x < 0.0F ? -x : x == 0.0F ? 0.0F : x;\n    }\n\n    public static double abs(double x) {\n        return x < 0.0 ? -x : x == 0.0 ? 0.0 : x;\n    }\n\n    public static double ulp(double x) {\n        if (java.lang.Double.isInfinite(x)) {\n            return java.lang.Double.POSITIVE_INFINITY;\n        }\n        return org.apache.commons.math3.util.FastMath.abs(x - java.lang.Double.longBitsToDouble(java.lang.Double.doubleToLongBits(x) ^ 1));\n    }\n\n    public static float ulp(float x) {\n        if (java.lang.Float.isInfinite(x)) {\n            return java.lang.Float.POSITIVE_INFINITY;\n        }\n        return org.apache.commons.math3.util.FastMath.abs(x - java.lang.Float.intBitsToFloat(java.lang.Float.floatToIntBits(x) ^ 1));\n    }\n\n    public static double scalb(final double d, final int n) {\n        if ((n > (-1023)) && (n < 1024)) {\n            return d * java.lang.Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n        if ((java.lang.Double.isNaN(d) || java.lang.Double.isInfinite(d)) || (d == 0)) {\n            return d;\n        }\n        if (n < (-2098)) {\n            return d > 0 ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return d > 0 ? java.lang.Double.POSITIVE_INFINITY : java.lang.Double.NEGATIVE_INFINITY;\n        }\n        final long bits = java.lang.Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int exponent = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa = bits & 0xfffffffffffffL;\n        int scaledExponent = exponent + n;\n        if (n < 0) {\n            if (scaledExponent > 0) {\n                return java.lang.Double.longBitsToDouble((sign | (((long) (scaledExponent)) << 52)) | mantissa);\n            } else if (scaledExponent > (-53)) {\n                mantissa = mantissa | (1L << 52);\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    mantissa++;\n                }\n                return java.lang.Double.longBitsToDouble(sign | mantissa);\n            } else {\n                return sign == 0L ? 0.0 : -0.0;\n            }\n        } else if (exponent == 0) {\n            while ((mantissa >>> 52) != 1) {\n                mantissa = mantissa << 1;\n                --scaledExponent;\n            } \n            ++scaledExponent;\n            mantissa = mantissa & 0xfffffffffffffL;\n            if (scaledExponent < 2047) {\n                return java.lang.Double.longBitsToDouble((sign | (((long) (scaledExponent)) << 52)) | mantissa);\n            } else {\n                return sign == 0L ? java.lang.Double.POSITIVE_INFINITY : java.lang.Double.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 2047) {\n            return java.lang.Double.longBitsToDouble((sign | (((long) (scaledExponent)) << 52)) | mantissa);\n        } else {\n            return sign == 0L ? java.lang.Double.POSITIVE_INFINITY : java.lang.Double.NEGATIVE_INFINITY;\n        }\n    }\n\n    public static float scalb(final float f, final int n) {\n        if ((n > (-127)) && (n < 128)) {\n            return f * java.lang.Float.intBitsToFloat((n + 127) << 23);\n        }\n        if ((java.lang.Float.isNaN(f) || java.lang.Float.isInfinite(f)) || (f == 0.0F)) {\n            return f;\n        }\n        if (n < (-277)) {\n            return f > 0 ? 0.0F : -0.0F;\n        }\n        if (n > 276) {\n            return f > 0 ? java.lang.Float.POSITIVE_INFINITY : java.lang.Float.NEGATIVE_INFINITY;\n        }\n        final int bits = java.lang.Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        int exponent = (bits >>> 23) & 0xff;\n        int mantissa = bits & 0x7fffff;\n        int scaledExponent = exponent + n;\n        if (n < 0) {\n            if (scaledExponent > 0) {\n                return java.lang.Float.intBitsToFloat((sign | (scaledExponent << 23)) | mantissa);\n            } else if (scaledExponent > (-24)) {\n                mantissa = mantissa | (1 << 23);\n                final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    mantissa++;\n                }\n                return java.lang.Float.intBitsToFloat(sign | mantissa);\n            } else {\n                return sign == 0 ? 0.0F : -0.0F;\n            }\n        } else if (exponent == 0) {\n            while ((mantissa >>> 23) != 1) {\n                mantissa = mantissa << 1;\n                --scaledExponent;\n            } \n            ++scaledExponent;\n            mantissa = mantissa & 0x7fffff;\n            if (scaledExponent < 255) {\n                return java.lang.Float.intBitsToFloat((sign | (scaledExponent << 23)) | mantissa);\n            } else {\n                return sign == 0 ? java.lang.Float.POSITIVE_INFINITY : java.lang.Float.NEGATIVE_INFINITY;\n            }\n        } else if (scaledExponent < 255) {\n            return java.lang.Float.intBitsToFloat((sign | (scaledExponent << 23)) | mantissa);\n        } else {\n            return sign == 0 ? java.lang.Float.POSITIVE_INFINITY : java.lang.Float.NEGATIVE_INFINITY;\n        }\n    }\n\n    public static double nextAfter(double d, double direction) {\n        if (java.lang.Double.isNaN(d) || java.lang.Double.isNaN(direction)) {\n            return java.lang.Double.NaN;\n        } else if (d == direction) {\n            return direction;\n        } else if (java.lang.Double.isInfinite(d)) {\n            return d < 0 ? -java.lang.Double.MAX_VALUE : java.lang.Double.MAX_VALUE;\n        } else if (d == 0) {\n            return direction < 0 ? -java.lang.Double.MIN_VALUE : java.lang.Double.MIN_VALUE;\n        }\n        final long bits = java.lang.Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        if ((direction < d) ^ (sign == 0L)) {\n            return java.lang.Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n        } else {\n            return java.lang.Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n        }\n    }\n\n    public static float nextAfter(final float f, final double direction) {\n        if (java.lang.Double.isNaN(f) || java.lang.Double.isNaN(direction)) {\n            return java.lang.Float.NaN;\n        } else if (f == direction) {\n            return ((float) (direction));\n        } else if (java.lang.Float.isInfinite(f)) {\n            return f < 0.0F ? -java.lang.Float.MAX_VALUE : java.lang.Float.MAX_VALUE;\n        } else if (f == 0.0F) {\n            return direction < 0 ? -java.lang.Float.MIN_VALUE : java.lang.Float.MIN_VALUE;\n        }\n        final int bits = java.lang.Float.floatToIntBits(f);\n        final int sign = bits & 0x80000000;\n        if ((direction < f) ^ (sign == 0)) {\n            return java.lang.Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n        } else {\n            return java.lang.Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));\n        }\n    }\n\n    public static double floor(double x) {\n        long y;\n        if (x != x) {\n            return x;\n        }\n        if ((x >= org.apache.commons.math3.util.FastMath.TWO_POWER_52) || (x <= (-org.apache.commons.math3.util.FastMath.TWO_POWER_52))) {\n            return x;\n        }\n        y = ((long) (x));\n        if ((x < 0) && (y != x)) {\n            y--;\n        }\n        if (y == 0) {\n            return x * y;\n        }\n        return y;\n    }\n\n    public static double ceil(double x) {\n        double y;\n        if (x != x) {\n            return x;\n        }\n        y = org.apache.commons.math3.util.FastMath.floor(x);\n        if (y == x) {\n            return y;\n        }\n        y += 1.0;\n        if (y == 0) {\n            return x * y;\n        }\n        return y;\n    }\n\n    public static double rint(double x) {\n        double y = org.apache.commons.math3.util.FastMath.floor(x);\n        double d = x - y;\n        if (d > 0.5) {\n            if (y == (-1.0)) {\n                return -0.0;\n            }\n            return y + 1.0;\n        }\n        if (d < 0.5) {\n            return y;\n        }\n        long z = ((long) (y));\n        return (z & 1) == 0 ? y : y + 1.0;\n    }\n\n    public static long round(double x) {\n        return ((long) (org.apache.commons.math3.util.FastMath.floor(x + 0.5)));\n    }\n\n    public static int round(final float x) {\n        return ((int) (org.apache.commons.math3.util.FastMath.floor(x + 0.5F)));\n    }\n\n    public static int min(final int a, final int b) {\n        return a <= b ? a : b;\n    }\n\n    public static long min(final long a, final long b) {\n        return a <= b ? a : b;\n    }\n\n    public static float min(final float a, final float b) {\n        if (a > b) {\n            return b;\n        }\n        if (a < b) {\n            return a;\n        }\n        if (a != b) {\n            return java.lang.Float.NaN;\n        }\n        int bits = java.lang.Float.floatToRawIntBits(a);\n        if (bits == 0x80000000) {\n            return a;\n        }\n        return b;\n    }\n\n    public static double min(final double a, final double b) {\n        if (a > b) {\n            return b;\n        }\n        if (a < b) {\n            return a;\n        }\n        if (a != b) {\n            return java.lang.Double.NaN;\n        }\n        long bits = java.lang.Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return a;\n        }\n        return b;\n    }\n\n    public static int max(final int a, final int b) {\n        return a <= b ? b : a;\n    }\n\n    public static long max(final long a, final long b) {\n        return a <= b ? b : a;\n    }\n\n    public static float max(final float a, final float b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        if (a != b) {\n            return java.lang.Float.NaN;\n        }\n        int bits = java.lang.Float.floatToRawIntBits(a);\n        if (bits == 0x80000000) {\n            return b;\n        }\n        return a;\n    }\n\n    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        if (a != b) {\n            return java.lang.Double.NaN;\n        }\n        long bits = java.lang.Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }\n\n    public static double hypot(final double x, final double y) {\n        if (java.lang.Double.isInfinite(x) || java.lang.Double.isInfinite(y)) {\n            return java.lang.Double.POSITIVE_INFINITY;\n        } else if (java.lang.Double.isNaN(x) || java.lang.Double.isNaN(y)) {\n            return java.lang.Double.NaN;\n        } else {\n            final int expX = org.apache.commons.math3.util.FastMath.getExponent(x);\n            final int expY = org.apache.commons.math3.util.FastMath.getExponent(y);\n            if (expX > (expY + 27)) {\n                return org.apache.commons.math3.util.FastMath.abs(x);\n            } else if (expY > (expX + 27)) {\n                return org.apache.commons.math3.util.FastMath.abs(y);\n            } else {\n                final int middleExp = (expX + expY) / 2;\n                final double scaledX = org.apache.commons.math3.util.FastMath.scalb(x, -middleExp);\n                final double scaledY = org.apache.commons.math3.util.FastMath.scalb(y, -middleExp);\n                final double scaledH = org.apache.commons.math3.util.FastMath.sqrt((scaledX * scaledX) + (scaledY * scaledY));\n                return org.apache.commons.math3.util.FastMath.scalb(scaledH, middleExp);\n            }\n        }\n    }\n\n    public static double IEEEremainder(double dividend, double divisor) {\n        return java.lang.StrictMath.IEEEremainder(dividend, divisor);\n    }\n\n    public static double copySign(double magnitude, double sign) {\n        long m = java.lang.Double.doubleToLongBits(magnitude);\n        long s = java.lang.Double.doubleToLongBits(sign);\n        if (((m >= 0) && (s >= 0)) || ((m < 0) && (s < 0))) {\n            return magnitude;\n        }\n        return -magnitude;\n    }\n\n    public static float copySign(float magnitude, float sign) {\n        int m = java.lang.Float.floatToIntBits(magnitude);\n        int s = java.lang.Float.floatToIntBits(sign);\n        if (((m >= 0) && (s >= 0)) || ((m < 0) && (s < 0))) {\n            return magnitude;\n        }\n        return -magnitude;\n    }\n\n    public static int getExponent(final double d) {\n        return ((int) ((java.lang.Double.doubleToLongBits(d) >>> 52) & 0x7ff)) - 1023;\n    }\n\n    public static int getExponent(final float f) {\n        return ((java.lang.Float.floatToIntBits(f) >>> 23) & 0xff) - 127;\n    }\n\n    public static void main(java.lang.String[] a) {\n        java.io.PrintStream out = java.lang.System.out;\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_LEN, org.apache.commons.math3.util.FastMath.ExpIntTable.EXP_INT_TABLE_A);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_LEN, org.apache.commons.math3.util.FastMath.ExpIntTable.EXP_INT_TABLE_B);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", org.apache.commons.math3.util.FastMath.EXP_FRAC_TABLE_LEN, org.apache.commons.math3.util.FastMath.ExpFracTable.EXP_FRAC_TABLE_A);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", org.apache.commons.math3.util.FastMath.EXP_FRAC_TABLE_LEN, org.apache.commons.math3.util.FastMath.ExpFracTable.EXP_FRAC_TABLE_B);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"LN_MANT\", org.apache.commons.math3.util.FastMath.LN_MANT_LEN, org.apache.commons.math3.util.FastMath.lnMant.LN_MANT);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"SINE_TABLE_A\", org.apache.commons.math3.util.FastMath.SINE_TABLE_LEN, org.apache.commons.math3.util.FastMath.SINE_TABLE_A);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"SINE_TABLE_B\", org.apache.commons.math3.util.FastMath.SINE_TABLE_LEN, org.apache.commons.math3.util.FastMath.SINE_TABLE_B);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"COSINE_TABLE_A\", org.apache.commons.math3.util.FastMath.SINE_TABLE_LEN, org.apache.commons.math3.util.FastMath.COSINE_TABLE_A);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"COSINE_TABLE_B\", org.apache.commons.math3.util.FastMath.SINE_TABLE_LEN, org.apache.commons.math3.util.FastMath.COSINE_TABLE_B);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", org.apache.commons.math3.util.FastMath.SINE_TABLE_LEN, org.apache.commons.math3.util.FastMath.TANGENT_TABLE_A);\n        org.apache.commons.math3.util.FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", org.apache.commons.math3.util.FastMath.SINE_TABLE_LEN, org.apache.commons.math3.util.FastMath.TANGENT_TABLE_B);\n    }\n\n    private static class ExpIntTable {\n        private static final double[] EXP_INT_TABLE_A;\n\n        private static final double[] EXP_INT_TABLE_B;\n\n        static {\n            if (org.apache.commons.math3.util.FastMath.RECOMPUTE_TABLES_AT_RUNTIME) {\n                EXP_INT_TABLE_A = new double[org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_LEN];\n                EXP_INT_TABLE_B = new double[org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_LEN];\n                final double[] tmp = new double[2];\n                final double[] recip = new double[2];\n                for (int i = 0; i < org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {\n                    org.apache.commons.math3.util.FastMathCalc.expint(i, tmp);\n                    EXP_INT_TABLE_A[i + org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n                    EXP_INT_TABLE_B[i + org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n                    if (i != 0) {\n                        org.apache.commons.math3.util.FastMathCalc.splitReciprocal(tmp, recip);\n                        EXP_INT_TABLE_A[org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];\n                        EXP_INT_TABLE_B[org.apache.commons.math3.util.FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\n                    }\n                }\n            } else {\n                EXP_INT_TABLE_A = org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntA();\n                EXP_INT_TABLE_B = org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntB();\n            }\n        }\n    }\n\n    private static class ExpFracTable {\n        private static final double[] EXP_FRAC_TABLE_A;\n\n        private static final double[] EXP_FRAC_TABLE_B;\n\n        static {\n            if (org.apache.commons.math3.util.FastMath.RECOMPUTE_TABLES_AT_RUNTIME) {\n                EXP_FRAC_TABLE_A = new double[org.apache.commons.math3.util.FastMath.EXP_FRAC_TABLE_LEN];\n                EXP_FRAC_TABLE_B = new double[org.apache.commons.math3.util.FastMath.EXP_FRAC_TABLE_LEN];\n                final double[] tmp = new double[2];\n                final double factor = 1.0 / (org.apache.commons.math3.util.FastMath.EXP_FRAC_TABLE_LEN - 1);\n                for (int i = 0; i < org.apache.commons.math3.util.FastMath.ExpFracTable.EXP_FRAC_TABLE_A.length; i++) {\n                    org.apache.commons.math3.util.FastMathCalc.slowexp(i * factor, tmp);\n                    EXP_FRAC_TABLE_A[i] = tmp[0];\n                    EXP_FRAC_TABLE_B[i] = tmp[1];\n                }\n            } else {\n                EXP_FRAC_TABLE_A = org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracA();\n                EXP_FRAC_TABLE_B = org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracB();\n            }\n        }\n    }\n\n    private static class lnMant {\n        private static final double[][] LN_MANT;\n\n        static {\n            if (org.apache.commons.math3.util.FastMath.RECOMPUTE_TABLES_AT_RUNTIME) {\n                LN_MANT = new double[org.apache.commons.math3.util.FastMath.LN_MANT_LEN][];\n                for (int i = 0; i < org.apache.commons.math3.util.FastMath.lnMant.LN_MANT.length; i++) {\n                    final double d = java.lang.Double.longBitsToDouble((((long) (i)) << 42) | 0x3ff0000000000000L);\n                    LN_MANT[i] = org.apache.commons.math3.util.FastMathCalc.slowLog(d);\n                }\n            } else {\n                LN_MANT = org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant();\n            }\n        }\n    }\n\n    private static class CodyWaite {\n        private final int finalK;\n\n        private final double finalRemA;\n\n        private final double finalRemB;\n\n        CodyWaite(double xa, double xb) {\n            int k = ((int) (xa * 0.6366197723675814));\n            double remA;\n            double remB;\n            while (true) {\n                double a = (-k) * 1.570796251296997;\n                remA = xa + a;\n                remB = -((remA - xa) - a);\n                a = (-k) * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -((remA - b) - a);\n                a = (-k) * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -((remA - b) - a);\n                if (remA > 0) {\n                    break;\n                }\n                --k;\n            } \n            this.finalK = k;\n            this.finalRemA = remA;\n            this.finalRemB = remB;\n        }\n\n        int getK() {\n            return finalK;\n        }\n\n        double getRemA() {\n            return finalRemA;\n        }\n\n        double getRemB() {\n            return finalRemB;\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        }
      ],
      "file_name": "FastMath"
    }
  ],
  "id": "Math_15"
}