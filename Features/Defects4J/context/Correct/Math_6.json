{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "While",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "incrementIterationCount()",
            "src_parent": "{\n    incrementIterationCount();\n    final org.apache.commons.math3.optim.PointVectorValuePair previous = current;\n    qrDecomposition(computeWeightedJacobian(currentPoint));\n    weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n    for (int i = 0; i < nR; i++) {\n        qtf[i] = weightedResidual[i];\n    }\n    qTy(qtf);\n    for (int k = 0; k < solvedCols; ++k) {\n        int pk = permutation[k];\n        weightedJacobian[k][pk] = diagR[pk];\n    }\n    if (firstIteration) {\n        xNorm = 0;\n        for (int k = 0; k < nC; ++k) {\n            double dk = jacNorm[k];\n            if (dk == 0) {\n                dk = 1.0;\n            }\n            double xk = dk * currentPoint[k];\n            xNorm += xk * xk;\n            diag[k] = dk;\n        }\n        xNorm = org.apache.commons.math3.util.FastMath.sqrt(xNorm);\n        delta = (xNorm == 0) ? initialStepBoundFactor : initialStepBoundFactor * xNorm;\n    }\n    double maxCosine = 0;\n    if (currentCost != 0) {\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = jacNorm[pj];\n            if (s != 0) {\n                double sum = 0;\n                for (int i = 0; i <= j; ++i) {\n                    sum += weightedJacobian[i][pj] * qtf[i];\n                }\n                maxCosine = org.apache.commons.math3.util.FastMath.max(maxCosine, org.apache.commons.math3.util.FastMath.abs(sum) / (s * currentCost));\n            }\n        }\n    }\n    if (maxCosine <= orthoTolerance) {\n        setCost(currentCost);\n        return current;\n    }\n    for (int j = 0; j < nC; ++j) {\n        diag[j] = org.apache.commons.math3.util.FastMath.max(diag[j], jacNorm[j]);\n    }\n    for (double ratio = 0; ratio < 1.0E-4;) {\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            oldX[pj] = currentPoint[pj];\n        }\n        final double previousCost = currentCost;\n        double[] tmpVec = weightedResidual;\n        weightedResidual = oldRes;\n        oldRes = tmpVec;\n        tmpVec = currentObjective;\n        currentObjective = oldObj;\n        oldObj = tmpVec;\n        determineLMParameter(qtf, delta, diag, work1, work2, work3);\n        double lmNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            lmDir[pj] = -lmDir[pj];\n            currentPoint[pj] = oldX[pj] + lmDir[pj];\n            double s = diag[pj] * lmDir[pj];\n            lmNorm += s * s;\n        }\n        lmNorm = org.apache.commons.math3.util.FastMath.sqrt(lmNorm);\n        if (firstIteration) {\n            delta = org.apache.commons.math3.util.FastMath.min(delta, lmNorm);\n        }\n        currentObjective = computeObjectiveValue(currentPoint);\n        currentResiduals = computeResiduals(currentObjective);\n        current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n        currentCost = computeCost(currentResiduals);\n        double actRed = -1.0;\n        if ((0.1 * currentCost) < previousCost) {\n            double r = currentCost / previousCost;\n            actRed = 1.0 - (r * r);\n        }\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double dirJ = lmDir[pj];\n            work1[j] = 0;\n            for (int i = 0; i <= j; ++i) {\n                work1[i] += weightedJacobian[i][pj] * dirJ;\n            }\n        }\n        double coeff1 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            coeff1 += work1[j] * work1[j];\n        }\n        double pc2 = previousCost * previousCost;\n        coeff1 = coeff1 / pc2;\n        double coeff2 = ((lmPar * lmNorm) * lmNorm) / pc2;\n        double preRed = coeff1 + (2 * coeff2);\n        double dirDer = -(coeff1 + coeff2);\n        ratio = (preRed == 0) ? 0 : actRed / preRed;\n        if (ratio <= 0.25) {\n            double tmp = (actRed < 0) ? (0.5 * dirDer) / (dirDer + (0.5 * actRed)) : 0.5;\n            if (((0.1 * currentCost) >= previousCost) || (tmp < 0.1)) {\n                tmp = 0.1;\n            }\n            delta = tmp * org.apache.commons.math3.util.FastMath.min(delta, 10.0 * lmNorm);\n            lmPar /= tmp;\n        } else if ((lmPar == 0) || (ratio >= 0.75)) {\n            delta = 2 * lmNorm;\n            lmPar *= 0.5;\n        }\n        if (ratio >= 1.0E-4) {\n            firstIteration = false;\n            xNorm = 0;\n            for (int k = 0; k < nC; ++k) {\n                double xK = diag[k] * currentPoint[k];\n                xNorm += xK * xK;\n            }\n            xNorm = org.apache.commons.math3.util.FastMath.sqrt(xNorm);\n            if (checker != null) {\n                if (checker.converged(getIterations(), previous, current)) {\n                    setCost(currentCost);\n                    return current;\n                }\n            }\n        } else {\n            currentCost = previousCost;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                currentPoint[pj] = oldX[pj];\n            }\n            tmpVec = weightedResidual;\n            weightedResidual = oldRes;\n            oldRes = tmpVec;\n            tmpVec = currentObjective;\n            currentObjective = oldObj;\n            oldObj = tmpVec;\n            current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n        }\n        if ((((org.apache.commons.math3.util.FastMath.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * xNorm))) {\n            setCost(currentCost);\n            return current;\n        }\n        if (((org.apache.commons.math3.util.FastMath.abs(actRed) <= 2.2204E-16) && (preRed <= 2.2204E-16)) && (ratio <= 2.0)) {\n            throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n        } else if (delta <= (2.2204E-16 * xNorm)) {\n            throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n        } else if (maxCosine <= 2.2204E-16) {\n            throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "getIterations()",
            "src_parent": "checker.converged(getIterations(), previous, current)",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "int iter = 0",
            "src_parent": "{\n    checkParameters();\n    final int nR = getTarget().length;\n    final double[] currentPoint = getStartPoint();\n    final int nC = currentPoint.length;\n    solvedCols = org.apache.commons.math3.util.FastMath.min(nR, nC);\n    diagR = new double[nC];\n    jacNorm = new double[nC];\n    beta = new double[nC];\n    permutation = new int[nC];\n    lmDir = new double[nC];\n    double delta = 0;\n    double xNorm = 0;\n    double[] diag = new double[nC];\n    double[] oldX = new double[nC];\n    double[] oldRes = new double[nR];\n    double[] oldObj = new double[nR];\n    double[] qtf = new double[nR];\n    double[] work1 = new double[nC];\n    double[] work2 = new double[nC];\n    double[] work3 = new double[nC];\n    final org.apache.commons.math3.linear.RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n    double[] currentObjective = computeObjectiveValue(currentPoint);\n    double[] currentResiduals = computeResiduals(currentObjective);\n    org.apache.commons.math3.optim.PointVectorValuePair current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n    double currentCost = computeCost(currentResiduals);\n    lmPar = 0;\n    boolean firstIteration = true;\n    int iter = 0;\n    final org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointVectorValuePair> checker = getConvergenceChecker();\n    while (true) {\n        ++iter;\n        final org.apache.commons.math3.optim.PointVectorValuePair previous = current;\n        qrDecomposition(computeWeightedJacobian(currentPoint));\n        weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n        for (int i = 0; i < nR; i++) {\n            qtf[i] = weightedResidual[i];\n        }\n        qTy(qtf);\n        for (int k = 0; k < solvedCols; ++k) {\n            int pk = permutation[k];\n            weightedJacobian[k][pk] = diagR[pk];\n        }\n        if (firstIteration) {\n            xNorm = 0;\n            for (int k = 0; k < nC; ++k) {\n                double dk = jacNorm[k];\n                if (dk == 0) {\n                    dk = 1.0;\n                }\n                double xk = dk * currentPoint[k];\n                xNorm += xk * xk;\n                diag[k] = dk;\n            }\n            xNorm = org.apache.commons.math3.util.FastMath.sqrt(xNorm);\n            delta = (xNorm == 0) ? initialStepBoundFactor : initialStepBoundFactor * xNorm;\n        }\n        double maxCosine = 0;\n        if (currentCost != 0) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = jacNorm[pj];\n                if (s != 0) {\n                    double sum = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        sum += weightedJacobian[i][pj] * qtf[i];\n                    }\n                    maxCosine = org.apache.commons.math3.util.FastMath.max(maxCosine, org.apache.commons.math3.util.FastMath.abs(sum) / (s * currentCost));\n                }\n            }\n        }\n        if (maxCosine <= orthoTolerance) {\n            setCost(currentCost);\n            return current;\n        }\n        for (int j = 0; j < nC; ++j) {\n            diag[j] = org.apache.commons.math3.util.FastMath.max(diag[j], jacNorm[j]);\n        }\n        for (double ratio = 0; ratio < 1.0E-4;) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                oldX[pj] = currentPoint[pj];\n            }\n            final double previousCost = currentCost;\n            double[] tmpVec = weightedResidual;\n            weightedResidual = oldRes;\n            oldRes = tmpVec;\n            tmpVec = currentObjective;\n            currentObjective = oldObj;\n            oldObj = tmpVec;\n            determineLMParameter(qtf, delta, diag, work1, work2, work3);\n            double lmNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                lmDir[pj] = -lmDir[pj];\n                currentPoint[pj] = oldX[pj] + lmDir[pj];\n                double s = diag[pj] * lmDir[pj];\n                lmNorm += s * s;\n            }\n            lmNorm = org.apache.commons.math3.util.FastMath.sqrt(lmNorm);\n            if (firstIteration) {\n                delta = org.apache.commons.math3.util.FastMath.min(delta, lmNorm);\n            }\n            currentObjective = computeObjectiveValue(currentPoint);\n            currentResiduals = computeResiduals(currentObjective);\n            current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n            currentCost = computeCost(currentResiduals);\n            double actRed = -1.0;\n            if ((0.1 * currentCost) < previousCost) {\n                double r = currentCost / previousCost;\n                actRed = 1.0 - (r * r);\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double dirJ = lmDir[pj];\n                work1[j] = 0;\n                for (int i = 0; i <= j; ++i) {\n                    work1[i] += weightedJacobian[i][pj] * dirJ;\n                }\n            }\n            double coeff1 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                coeff1 += work1[j] * work1[j];\n            }\n            double pc2 = previousCost * previousCost;\n            coeff1 = coeff1 / pc2;\n            double coeff2 = ((lmPar * lmNorm) * lmNorm) / pc2;\n            double preRed = coeff1 + (2 * coeff2);\n            double dirDer = -(coeff1 + coeff2);\n            ratio = (preRed == 0) ? 0 : actRed / preRed;\n            if (ratio <= 0.25) {\n                double tmp = (actRed < 0) ? (0.5 * dirDer) / (dirDer + (0.5 * actRed)) : 0.5;\n                if (((0.1 * currentCost) >= previousCost) || (tmp < 0.1)) {\n                    tmp = 0.1;\n                }\n                delta = tmp * org.apache.commons.math3.util.FastMath.min(delta, 10.0 * lmNorm);\n                lmPar /= tmp;\n            } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                delta = 2 * lmNorm;\n                lmPar *= 0.5;\n            }\n            if (ratio >= 1.0E-4) {\n                firstIteration = false;\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double xK = diag[k] * currentPoint[k];\n                    xNorm += xK * xK;\n                }\n                xNorm = org.apache.commons.math3.util.FastMath.sqrt(xNorm);\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        setCost(currentCost);\n                        return current;\n                    }\n                }\n            } else {\n                currentCost = previousCost;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    currentPoint[pj] = oldX[pj];\n                }\n                tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes = tmpVec;\n                tmpVec = currentObjective;\n                currentObjective = oldObj;\n                oldObj = tmpVec;\n                current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n            }\n            if ((((org.apache.commons.math3.util.FastMath.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * xNorm))) {\n                setCost(currentCost);\n                return current;\n            }\n            if (((org.apache.commons.math3.util.FastMath.abs(actRed) <= 2.2204E-16) && (preRed <= 2.2204E-16)) && (ratio <= 2.0)) {\n                throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n            } else if (delta <= (2.2204E-16 * xNorm)) {\n                throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n            } else if (maxCosine <= 2.2204E-16) {\n                throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n            }\n        }\n    } \n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "While",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "++iter",
            "src_parent": "{\n    ++iter;\n    final org.apache.commons.math3.optim.PointVectorValuePair previous = current;\n    qrDecomposition(computeWeightedJacobian(currentPoint));\n    weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n    for (int i = 0; i < nR; i++) {\n        qtf[i] = weightedResidual[i];\n    }\n    qTy(qtf);\n    for (int k = 0; k < solvedCols; ++k) {\n        int pk = permutation[k];\n        weightedJacobian[k][pk] = diagR[pk];\n    }\n    if (firstIteration) {\n        xNorm = 0;\n        for (int k = 0; k < nC; ++k) {\n            double dk = jacNorm[k];\n            if (dk == 0) {\n                dk = 1.0;\n            }\n            double xk = dk * currentPoint[k];\n            xNorm += xk * xk;\n            diag[k] = dk;\n        }\n        xNorm = org.apache.commons.math3.util.FastMath.sqrt(xNorm);\n        delta = (xNorm == 0) ? initialStepBoundFactor : initialStepBoundFactor * xNorm;\n    }\n    double maxCosine = 0;\n    if (currentCost != 0) {\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = jacNorm[pj];\n            if (s != 0) {\n                double sum = 0;\n                for (int i = 0; i <= j; ++i) {\n                    sum += weightedJacobian[i][pj] * qtf[i];\n                }\n                maxCosine = org.apache.commons.math3.util.FastMath.max(maxCosine, org.apache.commons.math3.util.FastMath.abs(sum) / (s * currentCost));\n            }\n        }\n    }\n    if (maxCosine <= orthoTolerance) {\n        setCost(currentCost);\n        return current;\n    }\n    for (int j = 0; j < nC; ++j) {\n        diag[j] = org.apache.commons.math3.util.FastMath.max(diag[j], jacNorm[j]);\n    }\n    for (double ratio = 0; ratio < 1.0E-4;) {\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            oldX[pj] = currentPoint[pj];\n        }\n        final double previousCost = currentCost;\n        double[] tmpVec = weightedResidual;\n        weightedResidual = oldRes;\n        oldRes = tmpVec;\n        tmpVec = currentObjective;\n        currentObjective = oldObj;\n        oldObj = tmpVec;\n        determineLMParameter(qtf, delta, diag, work1, work2, work3);\n        double lmNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            lmDir[pj] = -lmDir[pj];\n            currentPoint[pj] = oldX[pj] + lmDir[pj];\n            double s = diag[pj] * lmDir[pj];\n            lmNorm += s * s;\n        }\n        lmNorm = org.apache.commons.math3.util.FastMath.sqrt(lmNorm);\n        if (firstIteration) {\n            delta = org.apache.commons.math3.util.FastMath.min(delta, lmNorm);\n        }\n        currentObjective = computeObjectiveValue(currentPoint);\n        currentResiduals = computeResiduals(currentObjective);\n        current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n        currentCost = computeCost(currentResiduals);\n        double actRed = -1.0;\n        if ((0.1 * currentCost) < previousCost) {\n            double r = currentCost / previousCost;\n            actRed = 1.0 - (r * r);\n        }\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double dirJ = lmDir[pj];\n            work1[j] = 0;\n            for (int i = 0; i <= j; ++i) {\n                work1[i] += weightedJacobian[i][pj] * dirJ;\n            }\n        }\n        double coeff1 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            coeff1 += work1[j] * work1[j];\n        }\n        double pc2 = previousCost * previousCost;\n        coeff1 = coeff1 / pc2;\n        double coeff2 = ((lmPar * lmNorm) * lmNorm) / pc2;\n        double preRed = coeff1 + (2 * coeff2);\n        double dirDer = -(coeff1 + coeff2);\n        ratio = (preRed == 0) ? 0 : actRed / preRed;\n        if (ratio <= 0.25) {\n            double tmp = (actRed < 0) ? (0.5 * dirDer) / (dirDer + (0.5 * actRed)) : 0.5;\n            if (((0.1 * currentCost) >= previousCost) || (tmp < 0.1)) {\n                tmp = 0.1;\n            }\n            delta = tmp * org.apache.commons.math3.util.FastMath.min(delta, 10.0 * lmNorm);\n            lmPar /= tmp;\n        } else if ((lmPar == 0) || (ratio >= 0.75)) {\n            delta = 2 * lmNorm;\n            lmPar *= 0.5;\n        }\n        if (ratio >= 1.0E-4) {\n            firstIteration = false;\n            xNorm = 0;\n            for (int k = 0; k < nC; ++k) {\n                double xK = diag[k] * currentPoint[k];\n                xNorm += xK * xK;\n            }\n            xNorm = org.apache.commons.math3.util.FastMath.sqrt(xNorm);\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    setCost(currentCost);\n                    return current;\n                }\n            }\n        } else {\n            currentCost = previousCost;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                currentPoint[pj] = oldX[pj];\n            }\n            tmpVec = weightedResidual;\n            weightedResidual = oldRes;\n            oldRes = tmpVec;\n            tmpVec = currentObjective;\n            currentObjective = oldObj;\n            oldObj = tmpVec;\n            current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n        }\n        if ((((org.apache.commons.math3.util.FastMath.abs(actRed) <= costRelativeTolerance) && (preRed <= costRelativeTolerance)) && (ratio <= 2.0)) || (delta <= (parRelativeTolerance * xNorm))) {\n            setCost(currentCost);\n            return current;\n        }\n        if (((org.apache.commons.math3.util.FastMath.abs(actRed) <= 2.2204E-16) && (preRed <= 2.2204E-16)) && (ratio <= 2.0)) {\n            throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE, costRelativeTolerance);\n        } else if (delta <= (2.2204E-16 * xNorm)) {\n            throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE, parRelativeTolerance);\n        } else if (maxCosine <= 2.2204E-16) {\n            throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE, orthoTolerance);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "iter",
            "src_parent": "checker.converged(iter, previous, current)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        }
      ],
      "file_name": "LevenbergMarquardtOptimizer"
    },
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "java.lang.Integer.MAX_VALUE",
            "src_parent": "new org.apache.commons.math3.util.Incrementor(java.lang.Integer.MAX_VALUE, new org.apache.commons.math3.optim.BaseOptimizer.MaxIterCallback())",
            "src_parent_type": "ConstructorCall",
            "src_type": "FieldRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "0",
            "src_parent": "new org.apache.commons.math3.util.Incrementor(0, new org.apache.commons.math3.optim.BaseOptimizer.MaxIterCallback())",
            "src_parent_type": "ConstructorCall",
            "src_type": "Literal"
          }
        }
      ],
      "file_name": "BaseOptimizer"
    },
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "incrementIterationCount()",
            "src_parent": "{\n    incrementIterationCount();\n    final org.apache.commons.math3.linear.RealMatrix arz = randn1(dimension, lambda);\n    final org.apache.commons.math3.linear.RealMatrix arx = org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.zeros(dimension, lambda);\n    final double[] fitness = new double[lambda];\n    for (int k = 0; k < lambda; k++) {\n        org.apache.commons.math3.linear.RealMatrix arxk = null;\n        for (int i = 0; i < (checkFeasableCount + 1); i++) {\n            if (diagonalOnly <= 0) {\n                arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k)).scalarMultiply(sigma));\n            } else {\n                arxk = xmean.add(org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.times(diagD, arz.getColumnMatrix(k)).scalarMultiply(sigma));\n            }\n            if ((i >= checkFeasableCount) || fitfun.isFeasible(arxk.getColumn(0))) {\n                break;\n            }\n            arz.setColumn(k, randn(dimension));\n        }\n        org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.copyColumn(arxk, 0, arx, k);\n        try {\n            fitness[k] = fitfun.value(arx.getColumn(k));\n        } catch (org.apache.commons.math3.exception.TooManyEvaluationsException e) {\n            break generationLoop;\n        }\n    }\n    final int[] arindex = sortedIndices(fitness);\n    final org.apache.commons.math3.linear.RealMatrix xold = xmean;\n    final org.apache.commons.math3.linear.RealMatrix bestArx = org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.selectColumns(arx, org.apache.commons.math3.util.MathArrays.copyOf(arindex, mu));\n    xmean = bestArx.multiply(weights);\n    final org.apache.commons.math3.linear.RealMatrix bestArz = org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.selectColumns(arz, org.apache.commons.math3.util.MathArrays.copyOf(arindex, mu));\n    final org.apache.commons.math3.linear.RealMatrix zmean = bestArz.multiply(weights);\n    final boolean hsig = updateEvolutionPaths(zmean, xold);\n    if (diagonalOnly <= 0) {\n        updateCovariance(hsig, bestArx, arz, arindex, xold);\n    } else {\n        updateCovarianceDiagonalOnly(hsig, bestArz);\n    }\n    sigma *= java.lang.Math.exp(java.lang.Math.min(1, (((normps / chiN) - 1) * cs) / damps));\n    final double bestFitness = fitness[arindex[0]];\n    final double worstFitness = fitness[arindex[arindex.length - 1]];\n    if (bestValue > bestFitness) {\n        bestValue = bestFitness;\n        lastResult = optimum;\n        optimum = new org.apache.commons.math3.optim.PointValuePair(fitfun.repair(bestArx.getColumn(0)), isMinimize ? bestFitness : -bestFitness);\n        if ((getConvergenceChecker() != null) && (lastResult != null)) {\n            if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                break generationLoop;\n            }\n        }\n    }\n    if (stopFitness != 0) {\n        if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n            break generationLoop;\n        }\n    }\n    final double[] sqrtDiagC = org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sqrt(diagC).getColumn(0);\n    final double[] pcCol = pc.getColumn(0);\n    for (int i = 0; i < dimension; i++) {\n        if ((sigma * java.lang.Math.max(java.lang.Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n            break;\n        }\n        if (i >= (dimension - 1)) {\n            break generationLoop;\n        }\n    }\n    for (int i = 0; i < dimension; i++) {\n        if ((sigma * sqrtDiagC[i]) > stopTolUpX) {\n            break generationLoop;\n        }\n    }\n    final double historyBest = org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.min(fitnessHistory);\n    final double historyWorst = org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.max(fitnessHistory);\n    if ((iterations > 2) && ((java.lang.Math.max(historyWorst, worstFitness) - java.lang.Math.min(historyBest, bestFitness)) < stopTolFun)) {\n        break generationLoop;\n    }\n    if ((iterations > fitnessHistory.length) && ((historyWorst - historyBest) < stopTolHistFun)) {\n        break generationLoop;\n    }\n    if ((org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.max(diagD) / org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.min(diagD)) > 1.0E7) {\n        break generationLoop;\n    }\n    if (getConvergenceChecker() != null) {\n        final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair(bestArx.getColumn(0), isMinimize ? bestFitness : -bestFitness);\n        if ((lastResult != null) && getConvergenceChecker().converged(iterations, current, lastResult)) {\n            break generationLoop;\n        }\n        lastResult = current;\n    }\n    if (bestValue == fitness[arindex[((int) (0.1 + (lambda / 4.0)))]]) {\n        sigma = sigma * java.lang.Math.exp(0.2 + (cs / damps));\n    }\n    if ((iterations > 2) && ((java.lang.Math.max(historyWorst, bestFitness) - java.lang.Math.min(historyBest, bestFitness)) == 0)) {\n        sigma = sigma * java.lang.Math.exp(0.2 + (cs / damps));\n    }\n    org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.push(fitnessHistory, bestFitness);\n    fitfun.setValueRange(worstFitness - bestFitness);\n    if (generateStatistics) {\n        statisticsSigmaHistory.add(sigma);\n        statisticsFitnessHistory.add(bestFitness);\n        statisticsMeanHistory.add(xmean.transpose());\n        statisticsDHistory.add(diagD.transpose().scalarMultiply(100000.0));\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        }
      ],
      "file_name": "CMAESOptimizer"
    },
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Throw",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "incrementIterationCount()",
            "src_parent": "{\n    incrementIterationCount();\n    org.apache.commons.math3.optim.PointVectorValuePair previous = current;\n    final double[] currentObjective = computeObjectiveValue(currentPoint);\n    final double[] currentResiduals = computeResiduals(currentObjective);\n    final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n    current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n    final double[] b = new double[nC];\n    final double[][] a = new double[nC][nC];\n    for (int i = 0; i < nR; ++i) {\n        final double[] grad = weightedJacobian.getRow(i);\n        final double weight = residualsWeights[i];\n        final double residual = currentResiduals[i];\n        final double wr = weight * residual;\n        for (int j = 0; j < nC; ++j) {\n            b[j] += wr * grad[j];\n        }\n        for (int k = 0; k < nC; ++k) {\n            double[] ak = a[k];\n            double wgk = weight * grad[k];\n            for (int l = 0; l < nC; ++l) {\n                ak[l] += wgk * grad[l];\n            }\n        }\n    }\n    try {\n        org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix(a);\n        org.apache.commons.math3.linear.DecompositionSolver solver = (useLU) ? new org.apache.commons.math3.linear.LUDecomposition(mA).getSolver() : new org.apache.commons.math3.linear.QRDecomposition(mA).getSolver();\n        final double[] dX = solver.solve(new org.apache.commons.math3.linear.ArrayRealVector(b, false)).toArray();\n        for (int i = 0; i < nC; ++i) {\n            currentPoint[i] += dX[i];\n        }\n    } catch (org.apache.commons.math3.linear.SingularMatrixException e) {\n        throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n    }\n    if (previous != null) {\n        converged = checker.converged(getIterations(), previous, current);\n        if (converged) {\n            setCost(computeCost(currentResiduals));\n            return current;\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "getIterations()",
            "src_parent": "checker.converged(getIterations(), previous, current)",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "int iter = 0",
            "src_parent": "{\n    checkParameters();\n    final org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointVectorValuePair> checker = getConvergenceChecker();\n    if (checker == null) {\n        throw new org.apache.commons.math3.exception.NullArgumentException();\n    }\n    final double[] targetValues = getTarget();\n    final int nR = targetValues.length;\n    final org.apache.commons.math3.linear.RealMatrix weightMatrix = getWeight();\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n    final double[] currentPoint = getStartPoint();\n    final int nC = currentPoint.length;\n    org.apache.commons.math3.optim.PointVectorValuePair current = null;\n    int iter = 0;\n    for (boolean converged = false; !converged;) {\n        ++iter;\n        org.apache.commons.math3.optim.PointVectorValuePair previous = current;\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n        final double[] b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n            final double[] grad = weightedJacobian.getRow(i);\n            final double weight = residualsWeights[i];\n            final double residual = currentResiduals[i];\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n            for (int k = 0; k < nC; ++k) {\n                double[] ak = a[k];\n                double wgk = weight * grad[k];\n                for (int l = 0; l < nC; ++l) {\n                    ak[l] += wgk * grad[l];\n                }\n            }\n        }\n        try {\n            org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix(a);\n            org.apache.commons.math3.linear.DecompositionSolver solver = (useLU) ? new org.apache.commons.math3.linear.LUDecomposition(mA).getSolver() : new org.apache.commons.math3.linear.QRDecomposition(mA).getSolver();\n            final double[] dX = solver.solve(new org.apache.commons.math3.linear.ArrayRealVector(b, false)).toArray();\n            for (int i = 0; i < nC; ++i) {\n                currentPoint[i] += dX[i];\n            }\n        } catch (org.apache.commons.math3.linear.SingularMatrixException e) {\n            throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n        }\n        if (previous != null) {\n            converged = checker.converged(iter, previous, current);\n            if (converged) {\n                setCost(computeCost(currentResiduals));\n                return current;\n            }\n        }\n    }\n    throw new org.apache.commons.math3.exception.MathInternalError();\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Throw",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "++iter",
            "src_parent": "{\n    ++iter;\n    org.apache.commons.math3.optim.PointVectorValuePair previous = current;\n    final double[] currentObjective = computeObjectiveValue(currentPoint);\n    final double[] currentResiduals = computeResiduals(currentObjective);\n    final org.apache.commons.math3.linear.RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n    current = new org.apache.commons.math3.optim.PointVectorValuePair(currentPoint, currentObjective);\n    final double[] b = new double[nC];\n    final double[][] a = new double[nC][nC];\n    for (int i = 0; i < nR; ++i) {\n        final double[] grad = weightedJacobian.getRow(i);\n        final double weight = residualsWeights[i];\n        final double residual = currentResiduals[i];\n        final double wr = weight * residual;\n        for (int j = 0; j < nC; ++j) {\n            b[j] += wr * grad[j];\n        }\n        for (int k = 0; k < nC; ++k) {\n            double[] ak = a[k];\n            double wgk = weight * grad[k];\n            for (int l = 0; l < nC; ++l) {\n                ak[l] += wgk * grad[l];\n            }\n        }\n    }\n    try {\n        org.apache.commons.math3.linear.RealMatrix mA = new org.apache.commons.math3.linear.BlockRealMatrix(a);\n        org.apache.commons.math3.linear.DecompositionSolver solver = (useLU) ? new org.apache.commons.math3.linear.LUDecomposition(mA).getSolver() : new org.apache.commons.math3.linear.QRDecomposition(mA).getSolver();\n        final double[] dX = solver.solve(new org.apache.commons.math3.linear.ArrayRealVector(b, false)).toArray();\n        for (int i = 0; i < nC; ++i) {\n            currentPoint[i] += dX[i];\n        }\n    } catch (org.apache.commons.math3.linear.SingularMatrixException e) {\n        throw new org.apache.commons.math3.exception.ConvergenceException(org.apache.commons.math3.exception.util.LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n    }\n    if (previous != null) {\n        converged = checker.converged(iter, previous, current);\n        if (converged) {\n            setCost(computeCost(currentResiduals));\n            return current;\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "iter",
            "src_parent": "checker.converged(iter, previous, current)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        }
      ],
      "file_name": "GaussNewtonOptimizer"
    },
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "While",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "getIterations()",
            "src_parent": "getIterations() > 0",
            "src_parent_type": "BinaryOperator",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "While",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "incrementIterationCount()",
            "src_parent": "{\n    if (getIterations() > 0) {\n        boolean converged = true;\n        for (int i = 0; i < simplex.getSize(); i++) {\n            org.apache.commons.math3.optim.PointValuePair prev = previous[i];\n            converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\n        }\n        if (converged) {\n            return simplex.getPoint(0);\n        }\n    }\n    previous = simplex.getPoints();\n    simplex.iterate(evalFunc, comparator);\n    incrementIterationCount();\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "While",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "++iteration",
            "src_parent": "{\n    if (iteration > 0) {\n        boolean converged = true;\n        for (int i = 0; i < simplex.getSize(); i++) {\n            org.apache.commons.math3.optim.PointValuePair prev = previous[i];\n            converged = converged && checker.converged(iteration, prev, simplex.getPoint(i));\n        }\n        if (converged) {\n            return simplex.getPoint(0);\n        }\n    }\n    previous = simplex.getPoints();\n    simplex.iterate(evalFunc, comparator);\n    ++iteration;\n}",
            "src_parent_type": "Block",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "While",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "iteration",
            "src_parent": "iteration > 0",
            "src_parent_type": "BinaryOperator",
            "src_type": "VariableRead"
          }
        }
      ],
      "file_name": "SimplexOptimizer"
    },
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "For",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "While",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "incrementIterationCount()",
            "src_parent": "{\n    incrementIterationCount();\n    final double objective = computeObjectiveValue(point);\n    org.apache.commons.math3.optim.PointValuePair previous = current;\n    current = new org.apache.commons.math3.optim.PointValuePair(point, objective);\n    if (previous != null) {\n        if (checker.converged(getIterations(), previous, current)) {\n            return current;\n        }\n    }\n    final org.apache.commons.math3.analysis.UnivariateFunction lsf = new org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.LineSearchFunction(point, searchDirection);\n    final double uB = findUpperBound(lsf, 0, initialStep);\n    final double step = solver.solve(maxEval, lsf, 0, uB, 1.0E-15);\n    maxEval -= solver.getEvaluations();\n    for (int i = 0; i < point.length; ++i) {\n        point[i] += step * searchDirection[i];\n    }\n    r = computeObjectiveGradient(point);\n    if (goal == org.apache.commons.math3.optim.nonlinear.scalar.GoalType.MINIMIZE) {\n        for (int i = 0; i < n; ++i) {\n            r[i] = -r[i];\n        }\n    }\n    final double deltaOld = delta;\n    final double[] newSteepestDescent = preconditioner.precondition(point, r);\n    delta = 0;\n    for (int i = 0; i < n; ++i) {\n        delta += r[i] * newSteepestDescent[i];\n    }\n    final double beta;\n    switch (updateFormula) {\n        case FLETCHER_REEVES :\n            beta = delta / deltaOld;\n            break;\n        case POLAK_RIBIERE :\n            double deltaMid = 0;\n            for (int i = 0; i < r.length; ++i) {\n                deltaMid += r[i] * steepestDescent[i];\n            }\n            beta = (delta - deltaMid) / deltaOld;\n            break;\n        default :\n            throw new org.apache.commons.math3.exception.MathInternalError();\n    }\n    steepestDescent = newSteepestDescent;\n    if (((getIterations() % n) == 0) || (beta < 0)) {\n        searchDirection = steepestDescent.clone();\n    } else {\n        for (int i = 0; i < n; ++i) {\n            searchDirection[i] = steepestDescent[i] + (beta * searchDirection[i]);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "getIterations()",
            "src_parent": "checker.converged(getIterations(), previous, current)",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Switch",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "While",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "getIterations()",
            "src_parent": "(getIterations() % n)",
            "src_parent_type": "BinaryOperator",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "int iter = 0",
            "src_parent": "{\n    final org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair> checker = getConvergenceChecker();\n    final double[] point = getStartPoint();\n    final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = getGoalType();\n    final int n = point.length;\n    double[] r = computeObjectiveGradient(point);\n    if (goal == org.apache.commons.math3.optim.nonlinear.scalar.GoalType.MINIMIZE) {\n        for (int i = 0; i < n; i++) {\n            r[i] = -r[i];\n        }\n    }\n    double[] steepestDescent = preconditioner.precondition(point, r);\n    double[] searchDirection = steepestDescent.clone();\n    double delta = 0;\n    for (int i = 0; i < n; ++i) {\n        delta += r[i] * searchDirection[i];\n    }\n    org.apache.commons.math3.optim.PointValuePair current = null;\n    int iter = 0;\n    int maxEval = getMaxEvaluations();\n    while (true) {\n        ++iter;\n        final double objective = computeObjectiveValue(point);\n        org.apache.commons.math3.optim.PointValuePair previous = current;\n        current = new org.apache.commons.math3.optim.PointValuePair(point, objective);\n        if (previous != null) {\n            if (checker.converged(iter, previous, current)) {\n                return current;\n            }\n        }\n        final org.apache.commons.math3.analysis.UnivariateFunction lsf = new org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.LineSearchFunction(point, searchDirection);\n        final double uB = findUpperBound(lsf, 0, initialStep);\n        final double step = solver.solve(maxEval, lsf, 0, uB, 1.0E-15);\n        maxEval -= solver.getEvaluations();\n        for (int i = 0; i < point.length; ++i) {\n            point[i] += step * searchDirection[i];\n        }\n        r = computeObjectiveGradient(point);\n        if (goal == org.apache.commons.math3.optim.nonlinear.scalar.GoalType.MINIMIZE) {\n            for (int i = 0; i < n; ++i) {\n                r[i] = -r[i];\n            }\n        }\n        final double deltaOld = delta;\n        final double[] newSteepestDescent = preconditioner.precondition(point, r);\n        delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * newSteepestDescent[i];\n        }\n        final double beta;\n        switch (updateFormula) {\n            case FLETCHER_REEVES :\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE :\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default :\n                throw new org.apache.commons.math3.exception.MathInternalError();\n        }\n        steepestDescent = newSteepestDescent;\n        if (((iter % n) == 0) || (beta < 0)) {\n            searchDirection = steepestDescent.clone();\n        } else {\n            for (int i = 0; i < n; ++i) {\n                searchDirection[i] = steepestDescent[i] + (beta * searchDirection[i]);\n            }\n        }\n    } \n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "For",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "While",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "++iter",
            "src_parent": "{\n    ++iter;\n    final double objective = computeObjectiveValue(point);\n    org.apache.commons.math3.optim.PointValuePair previous = current;\n    current = new org.apache.commons.math3.optim.PointValuePair(point, objective);\n    if (previous != null) {\n        if (checker.converged(iter, previous, current)) {\n            return current;\n        }\n    }\n    final org.apache.commons.math3.analysis.UnivariateFunction lsf = new org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.LineSearchFunction(point, searchDirection);\n    final double uB = findUpperBound(lsf, 0, initialStep);\n    final double step = solver.solve(maxEval, lsf, 0, uB, 1.0E-15);\n    maxEval -= solver.getEvaluations();\n    for (int i = 0; i < point.length; ++i) {\n        point[i] += step * searchDirection[i];\n    }\n    r = computeObjectiveGradient(point);\n    if (goal == org.apache.commons.math3.optim.nonlinear.scalar.GoalType.MINIMIZE) {\n        for (int i = 0; i < n; ++i) {\n            r[i] = -r[i];\n        }\n    }\n    final double deltaOld = delta;\n    final double[] newSteepestDescent = preconditioner.precondition(point, r);\n    delta = 0;\n    for (int i = 0; i < n; ++i) {\n        delta += r[i] * newSteepestDescent[i];\n    }\n    final double beta;\n    switch (updateFormula) {\n        case FLETCHER_REEVES :\n            beta = delta / deltaOld;\n            break;\n        case POLAK_RIBIERE :\n            double deltaMid = 0;\n            for (int i = 0; i < r.length; ++i) {\n                deltaMid += r[i] * steepestDescent[i];\n            }\n            beta = (delta - deltaMid) / deltaOld;\n            break;\n        default :\n            throw new org.apache.commons.math3.exception.MathInternalError();\n    }\n    steepestDescent = newSteepestDescent;\n    if (((iter % n) == 0) || (beta < 0)) {\n        searchDirection = steepestDescent.clone();\n    } else {\n        for (int i = 0; i < n; ++i) {\n            searchDirection[i] = steepestDescent[i] + (beta * searchDirection[i]);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "iter",
            "src_parent": "checker.converged(iter, previous, current)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Switch",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "While",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "iter",
            "src_parent": "(iter % n)",
            "src_parent_type": "BinaryOperator",
            "src_type": "VariableRead"
          }
        }
      ],
      "file_name": "NonLinearConjugateGradientOptimizer"
    },
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "While",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "incrementIterationCount()",
            "src_parent": "{\n    incrementIterationCount();\n    double fX = fVal;\n    double fX2 = 0;\n    double delta = 0;\n    int bigInd = 0;\n    double alphaMin = 0;\n    for (int i = 0; i < n; i++) {\n        final double[] d = org.apache.commons.math3.util.MathArrays.copyOf(direc[i]);\n        fX2 = fVal;\n        final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search(x, d);\n        fVal = optimum.getValue();\n        alphaMin = optimum.getPoint();\n        final double[][] result = newPointAndDirection(x, d, alphaMin);\n        x = result[0];\n        if ((fX2 - fVal) > delta) {\n            delta = fX2 - fVal;\n            bigInd = i;\n        }\n    }\n    boolean stop = (2 * (fX - fVal)) <= ((relativeThreshold * (org.apache.commons.math3.util.FastMath.abs(fX) + org.apache.commons.math3.util.FastMath.abs(fVal))) + absoluteThreshold);\n    final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair(x1, fX);\n    final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair(x, fVal);\n    if (!stop) {\n        if (checker != null) {\n            stop = checker.converged(getIterations(), previous, current);\n        }\n    }\n    if (stop) {\n        if (goal == org.apache.commons.math3.optim.nonlinear.scalar.GoalType.MINIMIZE) {\n            return fVal < fX ? current : previous;\n        } else {\n            return fVal > fX ? current : previous;\n        }\n    }\n    final double[] d = new double[n];\n    final double[] x2 = new double[n];\n    for (int i = 0; i < n; i++) {\n        d[i] = x[i] - x1[i];\n        x2[i] = (2 * x[i]) - x1[i];\n    }\n    x1 = x.clone();\n    fX2 = computeObjectiveValue(x2);\n    if (fX > fX2) {\n        double t = 2 * ((fX + fX2) - (2 * fVal));\n        double temp = (fX - fVal) - delta;\n        t *= temp * temp;\n        temp = fX - fX2;\n        t -= (delta * temp) * temp;\n        if (t < 0.0) {\n            final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search(x, d);\n            fVal = optimum.getValue();\n            alphaMin = optimum.getPoint();\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\n            x = result[0];\n            final int lastInd = n - 1;\n            direc[bigInd] = direc[lastInd];\n            direc[lastInd] = result[1];\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "getIterations()",
            "src_parent": "checker.converged(getIterations(), previous, current)",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "int iter = 0",
            "src_parent": "{\n    checkParameters();\n    final org.apache.commons.math3.optim.nonlinear.scalar.GoalType goal = getGoalType();\n    final double[] guess = getStartPoint();\n    final int n = guess.length;\n    final double[][] direc = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        direc[i][i] = 1;\n    }\n    final org.apache.commons.math3.optim.ConvergenceChecker<org.apache.commons.math3.optim.PointValuePair> checker = getConvergenceChecker();\n    double[] x = guess;\n    double fVal = computeObjectiveValue(x);\n    double[] x1 = x.clone();\n    int iter = 0;\n    while (true) {\n        ++iter;\n        double fX = fVal;\n        double fX2 = 0;\n        double delta = 0;\n        int bigInd = 0;\n        double alphaMin = 0;\n        for (int i = 0; i < n; i++) {\n            final double[] d = org.apache.commons.math3.util.MathArrays.copyOf(direc[i]);\n            fX2 = fVal;\n            final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search(x, d);\n            fVal = optimum.getValue();\n            alphaMin = optimum.getPoint();\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\n            x = result[0];\n            if ((fX2 - fVal) > delta) {\n                delta = fX2 - fVal;\n                bigInd = i;\n            }\n        }\n        boolean stop = (2 * (fX - fVal)) <= ((relativeThreshold * (org.apache.commons.math3.util.FastMath.abs(fX) + org.apache.commons.math3.util.FastMath.abs(fVal))) + absoluteThreshold);\n        final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair(x1, fX);\n        final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair(x, fVal);\n        if (!stop) {\n            if (checker != null) {\n                stop = checker.converged(iter, previous, current);\n            }\n        }\n        if (stop) {\n            if (goal == org.apache.commons.math3.optim.nonlinear.scalar.GoalType.MINIMIZE) {\n                return fVal < fX ? current : previous;\n            } else {\n                return fVal > fX ? current : previous;\n            }\n        }\n        final double[] d = new double[n];\n        final double[] x2 = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = x[i] - x1[i];\n            x2[i] = (2 * x[i]) - x1[i];\n        }\n        x1 = x.clone();\n        fX2 = computeObjectiveValue(x2);\n        if (fX > fX2) {\n            double t = 2 * ((fX + fX2) - (2 * fVal));\n            double temp = (fX - fVal) - delta;\n            t *= temp * temp;\n            temp = fX - fX2;\n            t -= (delta * temp) * temp;\n            if (t < 0.0) {\n                final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n                final int lastInd = n - 1;\n                direc[bigInd] = direc[lastInd];\n                direc[lastInd] = result[1];\n            }\n        }\n    } \n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "While",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "++iter",
            "src_parent": "{\n    ++iter;\n    double fX = fVal;\n    double fX2 = 0;\n    double delta = 0;\n    int bigInd = 0;\n    double alphaMin = 0;\n    for (int i = 0; i < n; i++) {\n        final double[] d = org.apache.commons.math3.util.MathArrays.copyOf(direc[i]);\n        fX2 = fVal;\n        final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search(x, d);\n        fVal = optimum.getValue();\n        alphaMin = optimum.getPoint();\n        final double[][] result = newPointAndDirection(x, d, alphaMin);\n        x = result[0];\n        if ((fX2 - fVal) > delta) {\n            delta = fX2 - fVal;\n            bigInd = i;\n        }\n    }\n    boolean stop = (2 * (fX - fVal)) <= ((relativeThreshold * (org.apache.commons.math3.util.FastMath.abs(fX) + org.apache.commons.math3.util.FastMath.abs(fVal))) + absoluteThreshold);\n    final org.apache.commons.math3.optim.PointValuePair previous = new org.apache.commons.math3.optim.PointValuePair(x1, fX);\n    final org.apache.commons.math3.optim.PointValuePair current = new org.apache.commons.math3.optim.PointValuePair(x, fVal);\n    if (!stop) {\n        if (checker != null) {\n            stop = checker.converged(iter, previous, current);\n        }\n    }\n    if (stop) {\n        if (goal == org.apache.commons.math3.optim.nonlinear.scalar.GoalType.MINIMIZE) {\n            return fVal < fX ? current : previous;\n        } else {\n            return fVal > fX ? current : previous;\n        }\n    }\n    final double[] d = new double[n];\n    final double[] x2 = new double[n];\n    for (int i = 0; i < n; i++) {\n        d[i] = x[i] - x1[i];\n        x2[i] = (2 * x[i]) - x1[i];\n    }\n    x1 = x.clone();\n    fX2 = computeObjectiveValue(x2);\n    if (fX > fX2) {\n        double t = 2 * ((fX + fX2) - (2 * fVal));\n        double temp = (fX - fVal) - delta;\n        t *= temp * temp;\n        temp = fX - fX2;\n        t -= (delta * temp) * temp;\n        if (t < 0.0) {\n            final org.apache.commons.math3.optim.univariate.UnivariatePointValuePair optimum = line.search(x, d);\n            fVal = optimum.getValue();\n            alphaMin = optimum.getPoint();\n            final double[][] result = newPointAndDirection(x, d, alphaMin);\n            x = result[0];\n            final int lastInd = n - 1;\n            direc[bigInd] = direc[lastInd];\n            direc[lastInd] = result[1];\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "iter",
            "src_parent": "checker.converged(iter, previous, current)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        }
      ],
      "file_name": "PowellOptimizer"
    }
  ],
  "id": "Math_6"
}