{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Try",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "fillEmptyModules(modules)",
            "src_parent": "{\n    initOptions(options);\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n    this.externs = makeCompilerInput(externs, true);\n    this.modules = modules;\n    try {\n        this.moduleGraph = new com.google.javascript.jscomp.JSModuleGraph(modules);\n    } catch (com.google.javascript.jscomp.JSModuleGraph e) {\n        report(com.google.javascript.jscomp.JSError.make(com.google.javascript.jscomp.Compiler.MODULE_DEPENDENCY_ERROR, e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n    }\n    this.inputs = getAllInputsFromModules();\n    initBasedOnOptions();\n    initInputsByNameMap();\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "private void fillEmptyModules(com.google.javascript.jscomp.JSModule[] modules) {\n    for (int i = 1; i < modules.length; i++) {\n        com.google.javascript.jscomp.JSModule module = modules[i];\n        if (module.getInputs().isEmpty()) {\n            module.add(com.google.javascript.jscomp.JSSourceFile.fromCode((\"[\" + module.getName()) + \"]\", \"\"));\n        }\n    }\n}",
            "src_parent": "public class Compiler extends com.google.javascript.jscomp.AbstractCompiler {\n    com.google.javascript.jscomp.CompilerOptions options = null;\n\n    private com.google.javascript.jscomp.PassConfig passes = null;\n\n    private com.google.javascript.jscomp.CompilerInput[] externs;\n\n    private com.google.javascript.jscomp.JSModule[] modules;\n\n    private com.google.javascript.jscomp.JSModuleGraph moduleGraph;\n\n    private com.google.javascript.jscomp.CompilerInput[] inputs;\n\n    private com.google.javascript.jscomp.ErrorManager errorManager;\n\n    private com.google.javascript.jscomp.SymbolTable symbolTable = null;\n\n    com.google.javascript.rhino.Node externsRoot;\n\n    com.google.javascript.rhino.Node jsRoot;\n\n    com.google.javascript.rhino.Node externAndJsRoot;\n\n    private java.util.Map<java.lang.String, com.google.javascript.jscomp.CompilerInput> inputsByName;\n\n    private com.google.javascript.jscomp.SourceMap sourceMap;\n\n    private java.lang.String externExports = null;\n\n    private int uniqueNameId = 0;\n\n    private boolean normalized = false;\n\n    private boolean useThreads = true;\n\n    private com.google.javascript.jscomp.FunctionInformationMap functionInformationMap;\n\n    private final java.lang.StringBuilder debugLog = new java.lang.StringBuilder();\n\n    com.google.javascript.jscomp.CodingConvention defaultCodingConvention = new com.google.javascript.jscomp.GoogleCodingConvention();\n\n    private com.google.javascript.rhino.jstype.JSTypeRegistry typeRegistry;\n\n    private com.google.javascript.jscomp.parsing.Config parserConfig = null;\n\n    private com.google.javascript.jscomp.ReverseAbstractInterpreter abstractInterpreter;\n\n    private final com.google.javascript.jscomp.TypeValidator typeValidator;\n\n    public com.google.javascript.jscomp.PerformanceTracker tracker;\n\n    private final com.google.javascript.jscomp.mozilla.rhino.ErrorReporter oldErrorReporter = com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(this);\n\n    private final com.google.javascript.jscomp.mozilla.rhino.ErrorReporter defaultErrorReporter = com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(this);\n\n    public static final com.google.javascript.jscomp.DiagnosticType OPTIMIZE_LOOP_ERROR = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\", \"Exceeded max number of optimization iterations: {0}\");\n\n    public static final com.google.javascript.jscomp.DiagnosticType MOTION_ITERATIONS_ERROR = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\", \"Exceeded max number of code motion iterations: {0}\");\n\n    private static final long COMPILER_STACK_SIZE = 1048576L;\n\n    private static final java.util.logging.Logger logger = java.util.logging.Logger.getLogger(\"com.google.javascript.jscomp\");\n\n    private final java.io.PrintStream outStream;\n\n    public Compiler() {\n        this(((java.io.PrintStream) (null)));\n    }\n\n    public Compiler(java.io.PrintStream stream) {\n        addChangeHandler(recentChange);\n        this.typeValidator = new com.google.javascript.jscomp.TypeValidator(this);\n        outStream = stream;\n    }\n\n    public Compiler(com.google.javascript.jscomp.ErrorManager errorManager) {\n        this();\n        setErrorManager(errorManager);\n    }\n\n    @java.lang.Override\n    com.google.javascript.jscomp.SymbolTable acquireSymbolTable() {\n        if (symbolTable == null) {\n            symbolTable = new com.google.javascript.jscomp.SymbolTable(this);\n        }\n        symbolTable.acquire();\n        return symbolTable;\n    }\n\n    public void setErrorManager(com.google.javascript.jscomp.ErrorManager errorManager) {\n        com.google.common.base.Preconditions.checkNotNull(errorManager, \"the error manager cannot be null\");\n        this.errorManager = errorManager;\n    }\n\n    private com.google.javascript.jscomp.MessageFormatter createMessageFormatter() {\n        boolean colorize = options.shouldColorizeErrorOutput();\n        return options.errorFormat.toFormatter(this, colorize);\n    }\n\n    public void initOptions(com.google.javascript.jscomp.CompilerOptions options) {\n        this.options = options;\n        if (errorManager == null) {\n            if (outStream == null) {\n                setErrorManager(new com.google.javascript.jscomp.LoggerErrorManager(createMessageFormatter(), com.google.javascript.jscomp.Compiler.logger));\n            } else {\n                com.google.javascript.jscomp.PrintStreamErrorManager printer = new com.google.javascript.jscomp.PrintStreamErrorManager(createMessageFormatter(), outStream);\n                printer.setSummaryDetailLevel(options.summaryDetailLevel);\n                setErrorManager(printer);\n            }\n        }\n    }\n\n    public void init(com.google.javascript.jscomp.JSSourceFile[] externs, com.google.javascript.jscomp.JSSourceFile[] inputs, com.google.javascript.jscomp.CompilerOptions options) {\n        initOptions(options);\n        this.externs = makeCompilerInput(externs, true);\n        this.modules = null;\n        this.moduleGraph = null;\n        this.inputs = makeCompilerInput(inputs, false);\n        initBasedOnOptions();\n        initInputsByNameMap();\n    }\n\n    static final com.google.javascript.jscomp.DiagnosticType MODULE_DEPENDENCY_ERROR = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\", \"Bad dependency: {0} -> {1}. \" + \"Modules must be listed in dependency order.\");\n\n    public void init(com.google.javascript.jscomp.JSSourceFile[] externs, com.google.javascript.jscomp.JSModule[] modules, com.google.javascript.jscomp.CompilerOptions options) {\n        initOptions(options);\n        checkFirstModule(modules);\n        fillEmptyModules(modules);\n        this.externs = makeCompilerInput(externs, true);\n        this.modules = modules;\n        try {\n            this.moduleGraph = new com.google.javascript.jscomp.JSModuleGraph(modules);\n        } catch (com.google.javascript.jscomp.JSModuleGraph e) {\n            report(com.google.javascript.jscomp.JSError.make(com.google.javascript.jscomp.Compiler.MODULE_DEPENDENCY_ERROR, e.getModule().getName(), e.getDependentModule().getName()));\n            return;\n        }\n        this.inputs = getAllInputsFromModules();\n        initBasedOnOptions();\n        initInputsByNameMap();\n    }\n\n    private void initBasedOnOptions() {\n        if (options.sourceMapOutputPath != null) {\n            sourceMap = new com.google.javascript.jscomp.SourceMap();\n        }\n    }\n\n    private com.google.javascript.jscomp.CompilerInput[] makeCompilerInput(com.google.javascript.jscomp.JSSourceFile[] files, boolean isExtern) {\n        com.google.javascript.jscomp.CompilerInput[] inputs = new com.google.javascript.jscomp.CompilerInput[files.length];\n        for (int i = 0; i < files.length; ++i) {\n            inputs[i] = new com.google.javascript.jscomp.CompilerInput(files[i], isExtern);\n        }\n        return inputs;\n    }\n\n    private static final com.google.javascript.jscomp.DiagnosticType EMPTY_MODULE_LIST_ERROR = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\", \"At least one module must be provided\");\n\n    private static final com.google.javascript.jscomp.DiagnosticType EMPTY_ROOT_MODULE_ERROR = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\", \"Root module '{0}' must contain at least one source code input\");\n\n    private void checkFirstModule(com.google.javascript.jscomp.JSModule[] modules) {\n        if (modules.length == 0) {\n            report(com.google.javascript.jscomp.JSError.make(com.google.javascript.jscomp.Compiler.EMPTY_MODULE_LIST_ERROR));\n        } else if (modules[0].getInputs().isEmpty()) {\n            report(com.google.javascript.jscomp.JSError.make(com.google.javascript.jscomp.Compiler.EMPTY_ROOT_MODULE_ERROR, modules[0].getName()));\n        }\n    }\n\n    private void fillEmptyModules(com.google.javascript.jscomp.JSModule[] modules) {\n        for (int i = 1; i < modules.length; i++) {\n            com.google.javascript.jscomp.JSModule module = modules[i];\n            if (module.getInputs().isEmpty()) {\n                module.add(com.google.javascript.jscomp.JSSourceFile.fromCode((\"[\" + module.getName()) + \"]\", \"\"));\n            }\n        }\n    }\n\n    static final com.google.javascript.jscomp.DiagnosticType DUPLICATE_INPUT_IN_MODULES = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_DUPLICATE_INPUT_IN_MODULES_ERROR\", \"Two modules cannot contain the same input, but module {0} and {1} \" + \"both include \\\"{2}\\\"\");\n\n    public void rebuildInputsFromModules() {\n        inputs = getAllInputsFromModules();\n        initInputsByNameMap();\n    }\n\n    private com.google.javascript.jscomp.CompilerInput[] getAllInputsFromModules() {\n        java.util.List<com.google.javascript.jscomp.CompilerInput> inputs = new java.util.ArrayList<com.google.javascript.jscomp.CompilerInput>();\n        java.util.Map<java.lang.String, com.google.javascript.jscomp.JSModule> inputMap = new java.util.HashMap<java.lang.String, com.google.javascript.jscomp.JSModule>();\n        for (com.google.javascript.jscomp.JSModule module : modules) {\n            for (com.google.javascript.jscomp.CompilerInput input : module.getInputs()) {\n                java.lang.String inputName = input.getName();\n                com.google.javascript.jscomp.JSModule firstModule = inputMap.get(inputName);\n                if (firstModule == null) {\n                    inputs.add(input);\n                    inputMap.put(inputName, module);\n                } else {\n                    report(com.google.javascript.jscomp.JSError.make(com.google.javascript.jscomp.Compiler.DUPLICATE_INPUT_IN_MODULES, firstModule.getName(), module.getName(), inputName));\n                }\n            }\n        }\n        if (hasErrors()) {\n            return new com.google.javascript.jscomp.CompilerInput[0];\n        }\n        return inputs.toArray(new com.google.javascript.jscomp.CompilerInput[inputs.size()]);\n    }\n\n    static final com.google.javascript.jscomp.DiagnosticType DUPLICATE_INPUT = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType DUPLICATE_EXTERN_INPUT = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\", \"Duplicate extern input: {0}\");\n\n    void initInputsByNameMap() {\n        inputsByName = new java.util.HashMap<java.lang.String, com.google.javascript.jscomp.CompilerInput>();\n        for (com.google.javascript.jscomp.CompilerInput input : externs) {\n            java.lang.String name = input.getName();\n            if (!inputsByName.containsKey(name)) {\n                inputsByName.put(name, input);\n            } else {\n                report(com.google.javascript.jscomp.JSError.make(com.google.javascript.jscomp.Compiler.DUPLICATE_EXTERN_INPUT, name));\n            }\n        }\n        for (com.google.javascript.jscomp.CompilerInput input : inputs) {\n            java.lang.String name = input.getName();\n            if (!inputsByName.containsKey(name)) {\n                inputsByName.put(name, input);\n            } else {\n                report(com.google.javascript.jscomp.JSError.make(com.google.javascript.jscomp.Compiler.DUPLICATE_INPUT, name));\n            }\n        }\n    }\n\n    public com.google.javascript.jscomp.Result compile(com.google.javascript.jscomp.JSSourceFile extern, com.google.javascript.jscomp.JSSourceFile input, com.google.javascript.jscomp.CompilerOptions options) {\n        return compile(extern, new com.google.javascript.jscomp.JSSourceFile[]{ input }, options);\n    }\n\n    public com.google.javascript.jscomp.Result compile(com.google.javascript.jscomp.JSSourceFile extern, com.google.javascript.jscomp.JSSourceFile[] input, com.google.javascript.jscomp.CompilerOptions options) {\n        return compile(new com.google.javascript.jscomp.JSSourceFile[]{ extern }, input, options);\n    }\n\n    public com.google.javascript.jscomp.Result compile(com.google.javascript.jscomp.JSSourceFile extern, com.google.javascript.jscomp.JSModule[] modules, com.google.javascript.jscomp.CompilerOptions options) {\n        return compile(new com.google.javascript.jscomp.JSSourceFile[]{ extern }, modules, options);\n    }\n\n    public com.google.javascript.jscomp.Result compile(com.google.javascript.jscomp.JSSourceFile[] externs, com.google.javascript.jscomp.JSSourceFile[] inputs, com.google.javascript.jscomp.CompilerOptions options) {\n        com.google.common.base.Preconditions.checkState(jsRoot == null);\n        try {\n            init(externs, inputs, options);\n            if (hasErrors()) {\n                return getResult();\n            }\n            return compile();\n        } finally {\n            com.google.javascript.jscomp.Tracer t = newTracer(\"generateReport\");\n            errorManager.generateReport();\n            stopTracer(t, \"generateReport\");\n        }\n    }\n\n    public com.google.javascript.jscomp.Result compile(com.google.javascript.jscomp.JSSourceFile[] externs, com.google.javascript.jscomp.JSModule[] modules, com.google.javascript.jscomp.CompilerOptions options) {\n        com.google.common.base.Preconditions.checkState(jsRoot == null);\n        try {\n            init(externs, modules, options);\n            if (hasErrors()) {\n                return getResult();\n            }\n            return compile();\n        } finally {\n            com.google.javascript.jscomp.Tracer t = newTracer(\"generateReport\");\n            errorManager.generateReport();\n            stopTracer(t, \"generateReport\");\n        }\n    }\n\n    private com.google.javascript.jscomp.Result compile() {\n        return runInCompilerThread(new java.util.concurrent.Callable<com.google.javascript.jscomp.Result>() {\n            public com.google.javascript.jscomp.Result call() throws java.lang.Exception {\n                compileInternal();\n                return getResult();\n            }\n        });\n    }\n\n    public void disableThreads() {\n        useThreads = false;\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <T> T runInCompilerThread(final java.util.concurrent.Callable<T> callable) {\n        final boolean dumpTraceReport = options.tracer.isOn();\n        final java.lang.Object[] result = new java.lang.Object[1];\n        final java.lang.Throwable[] exception = new java.lang.Throwable[1];\n        java.lang.Runnable runnable = new java.lang.Runnable() {\n            public void run() {\n                try {\n                    if (dumpTraceReport) {\n                        com.google.javascript.jscomp.Tracer.initCurrentThreadTrace();\n                    }\n                    result[0] = callable.call();\n                } catch (java.lang.Throwable e) {\n                    exception[0] = e;\n                } finally {\n                    if (dumpTraceReport) {\n                        com.google.javascript.jscomp.Tracer.logAndClearCurrentThreadTrace();\n                    }\n                }\n            }\n        };\n        if (useThreads) {\n            java.lang.Thread th = new java.lang.Thread(null, runnable, \"jscompiler\", com.google.javascript.jscomp.Compiler.COMPILER_STACK_SIZE);\n            th.start();\n            while (true) {\n                try {\n                    th.join();\n                    break;\n                } catch (java.lang.InterruptedException ignore) {\n                }\n            } \n        } else {\n            runnable.run();\n        }\n        if (exception[0] != null) {\n            throw new java.lang.RuntimeException(exception[0]);\n        }\n        return ((T) (result[0]));\n    }\n\n    private void compileInternal() {\n        parse();\n        if (hasErrors()) {\n            return;\n        }\n        if (!precheck()) {\n            return;\n        }\n        if (options.nameAnonymousFunctionsOnly) {\n            check();\n            return;\n        }\n        if (!options.skipAllPasses) {\n            check();\n            if (hasErrors()) {\n                return;\n            }\n            if (options.externExportsPath != null) {\n                externExports();\n            }\n            if (!options.ideMode) {\n                optimize();\n            }\n        }\n        if (options.recordFunctionInformation) {\n            recordFunctionInformation();\n        }\n        if (options.devMode == com.google.javascript.jscomp.CompilerOptions.DevMode.START_AND_END) {\n            runSanityCheck();\n        }\n    }\n\n    public void parse() {\n        parseInputs();\n    }\n\n    com.google.javascript.jscomp.PassConfig getPassConfig() {\n        if (passes == null) {\n            passes = createPassConfigInternal();\n        }\n        return passes;\n    }\n\n    com.google.javascript.jscomp.PassConfig createPassConfigInternal() {\n        return new com.google.javascript.jscomp.DefaultPassConfig(options);\n    }\n\n    public void setPassConfig(com.google.javascript.jscomp.PassConfig passes) {\n        com.google.common.base.Preconditions.checkNotNull(passes);\n        if (this.passes != null) {\n            throw new java.lang.IllegalStateException(\"this.passes has already been assigned\");\n        }\n        this.passes = passes;\n    }\n\n    boolean precheck() {\n        return true;\n    }\n\n    public void check() {\n        runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n        com.google.javascript.jscomp.PhaseOptimizer phaseOptimizer = new com.google.javascript.jscomp.PhaseOptimizer(this, tracker);\n        if (options.devMode == com.google.javascript.jscomp.CompilerOptions.DevMode.EVERY_PASS) {\n            phaseOptimizer.setSanityCheck(sanityCheck);\n        }\n        phaseOptimizer.consume(getPassConfig().getChecks());\n        phaseOptimizer.process(externsRoot, jsRoot);\n        if (hasErrors()) {\n            return;\n        }\n        if (options.nameAnonymousFunctionsOnly) {\n            return;\n        }\n        if (options.removeTryCatchFinally) {\n            removeTryCatchFinally();\n        }\n        if ((((!options.stripTypes.isEmpty()) || (!options.stripNameSuffixes.isEmpty())) || (!options.stripTypePrefixes.isEmpty())) || (!options.stripNamePrefixes.isEmpty())) {\n            stripCode(options.stripTypes, options.stripNameSuffixes, options.stripTypePrefixes, options.stripNamePrefixes);\n        }\n        runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n        normalize();\n    }\n\n    private void externExports() {\n        com.google.javascript.jscomp.Compiler.logger.info(\"Creating extern file for exports\");\n        startPass(\"externExports\");\n        com.google.javascript.jscomp.ExternExportsPass pass = new com.google.javascript.jscomp.ExternExportsPass(this);\n        process(pass);\n        externExports = pass.getGeneratedExterns();\n        endPass();\n    }\n\n    void process(com.google.javascript.jscomp.CompilerPass p) {\n        p.process(externsRoot, jsRoot);\n    }\n\n    private final com.google.javascript.jscomp.PassFactory sanityCheck = new com.google.javascript.jscomp.PassFactory(\"sanityCheck\", false) {\n        @java.lang.Override\n        protected com.google.javascript.jscomp.CompilerPass createInternal(com.google.javascript.jscomp.AbstractCompiler compiler) {\n            return new com.google.javascript.jscomp.SanityCheck(compiler);\n        }\n    };\n\n    private void maybeSanityCheck() {\n        if (options.devMode == com.google.javascript.jscomp.CompilerOptions.DevMode.EVERY_PASS) {\n            runSanityCheck();\n        }\n    }\n\n    private void runSanityCheck() {\n        sanityCheck.create(this).process(externsRoot, jsRoot);\n    }\n\n    void removeTryCatchFinally() {\n        com.google.javascript.jscomp.Compiler.logger.info(\"Remove try/catch/finally\");\n        startPass(\"removeTryCatchFinally\");\n        com.google.javascript.jscomp.RemoveTryCatch r = new com.google.javascript.jscomp.RemoveTryCatch(this);\n        process(r);\n        endPass();\n    }\n\n    void stripCode(java.util.Set<java.lang.String> stripTypes, java.util.Set<java.lang.String> stripNameSuffixes, java.util.Set<java.lang.String> stripTypePrefixes, java.util.Set<java.lang.String> stripNamePrefixes) {\n        com.google.javascript.jscomp.Compiler.logger.info(\"Strip code\");\n        startPass(\"stripCode\");\n        com.google.javascript.jscomp.StripCode r = new com.google.javascript.jscomp.StripCode(this, stripTypes, stripNameSuffixes, stripTypePrefixes, stripNamePrefixes);\n        process(r);\n        endPass();\n    }\n\n    private void runCustomPasses(com.google.javascript.jscomp.CustomPassExecutionTime executionTime) {\n        if (options.customPasses != null) {\n            com.google.javascript.jscomp.Tracer t = newTracer(\"runCustomPasses\");\n            try {\n                for (com.google.javascript.jscomp.CompilerPass p : options.customPasses.get(executionTime)) {\n                    process(p);\n                }\n            } finally {\n                stopTracer(t, \"runCustomPasses\");\n            }\n        }\n    }\n\n    private com.google.javascript.jscomp.Tracer currentTracer = null;\n\n    private java.lang.String currentPassName = null;\n\n    void startPass(java.lang.String passName) {\n        com.google.common.base.Preconditions.checkState(currentTracer == null);\n        currentPassName = passName;\n        currentTracer = newTracer(passName);\n    }\n\n    void endPass() {\n        com.google.common.base.Preconditions.checkState(currentTracer != null, \"Tracer should not be null at the end of a pass.\");\n        stopTracer(currentTracer, currentPassName);\n        java.lang.String passToCheck = currentPassName;\n        currentPassName = null;\n        currentTracer = null;\n        maybeSanityCheck();\n    }\n\n    com.google.javascript.jscomp.Tracer newTracer(java.lang.String passName) {\n        java.lang.String comment = passName + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n        if (options.tracer.isOn()) {\n            tracker.recordPassStart(passName);\n        }\n        return new com.google.javascript.jscomp.Tracer(\"Compiler\", comment);\n    }\n\n    void stopTracer(com.google.javascript.jscomp.Tracer t, java.lang.String passName) {\n        long result = t.stop();\n        if (options.tracer.isOn()) {\n            tracker.recordPassStop(passName, result);\n        }\n    }\n\n    public com.google.javascript.jscomp.Result getResult() {\n        com.google.javascript.jscomp.PassConfig.State state = getPassConfig().getIntermediateState();\n        return new com.google.javascript.jscomp.Result(getErrors(), getWarnings(), debugLog.toString(), state.variableMap, state.propertyMap, state.anonymousFunctionNameMap, functionInformationMap, sourceMap, externExports, state.cssNames);\n    }\n\n    public com.google.javascript.jscomp.JSError[] getMessages() {\n        return getErrors();\n    }\n\n    public com.google.javascript.jscomp.JSError[] getErrors() {\n        return errorManager.getErrors();\n    }\n\n    public com.google.javascript.jscomp.JSError[] getWarnings() {\n        return errorManager.getWarnings();\n    }\n\n    public com.google.javascript.rhino.Node getRoot() {\n        return externAndJsRoot;\n    }\n\n    private int nextUniqueNameId() {\n        return uniqueNameId++;\n    }\n\n    @com.google.common.annotations.VisibleForTesting\n    void resetUniqueNameId() {\n        uniqueNameId = 0;\n    }\n\n    @java.lang.Override\n    com.google.common.base.Supplier<java.lang.String> getUniqueNameIdSupplier() {\n        final com.google.javascript.jscomp.Compiler self = this;\n        return new com.google.common.base.Supplier<java.lang.String>() {\n            public java.lang.String get() {\n                return java.lang.String.valueOf(self.nextUniqueNameId());\n            }\n        };\n    }\n\n    @java.lang.Override\n    void setNormalized() {\n        normalized = true;\n    }\n\n    @java.lang.Override\n    void setUnnormalized() {\n        normalized = false;\n    }\n\n    @java.lang.Override\n    boolean isNormalized() {\n        return normalized;\n    }\n\n    @java.lang.Override\n    boolean areNodesEqualForInlining(com.google.javascript.rhino.Node n1, com.google.javascript.rhino.Node n2) {\n        if (options.ambiguateProperties || options.disambiguateProperties) {\n            return n1.checkTreeTypeAwareEqualsSilent(n2);\n        } else {\n            return n1.checkTreeEqualsSilent(n2);\n        }\n    }\n\n    @java.lang.Override\n    public com.google.javascript.jscomp.CompilerInput getInput(java.lang.String name) {\n        return inputsByName.get(name);\n    }\n\n    @java.lang.Override\n    public com.google.javascript.jscomp.CompilerInput newExternInput(java.lang.String name) {\n        if (inputsByName.containsKey(name)) {\n            throw new java.lang.IllegalArgumentException(\"Conflicting externs name: \" + name);\n        }\n        com.google.javascript.jscomp.SourceAst ast = new com.google.javascript.jscomp.SyntheticAst(name);\n        com.google.javascript.jscomp.CompilerInput input = new com.google.javascript.jscomp.CompilerInput(ast, name, true);\n        inputsByName.put(name, input);\n        externsRoot.addChildToFront(ast.getAstRoot(this));\n        return input;\n    }\n\n    void addIncrementalSourceAst(com.google.javascript.jscomp.JsAst ast) {\n        java.lang.String sourceName = ast.getSourceFile().getName();\n        com.google.common.base.Preconditions.checkState(getInput(sourceName) == null, \"Duplicate input of name \" + sourceName);\n        inputsByName.put(sourceName, new com.google.javascript.jscomp.CompilerInput(ast));\n    }\n\n    @java.lang.Override\n    com.google.javascript.jscomp.JSModuleGraph getModuleGraph() {\n        return moduleGraph;\n    }\n\n    @java.lang.Override\n    public com.google.javascript.rhino.jstype.JSTypeRegistry getTypeRegistry() {\n        if (typeRegistry == null) {\n            typeRegistry = new com.google.javascript.rhino.jstype.JSTypeRegistry(oldErrorReporter);\n        }\n        return typeRegistry;\n    }\n\n    @java.lang.Override\n    com.google.javascript.jscomp.ScopeCreator getScopeCreator() {\n        return getPassConfig().getScopeCreator();\n    }\n\n    @java.lang.Override\n    public com.google.javascript.jscomp.Scope getTopScope() {\n        return getPassConfig().getTopScope();\n    }\n\n    @java.lang.Override\n    public com.google.javascript.jscomp.ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n        if (abstractInterpreter == null) {\n            com.google.javascript.jscomp.ChainableReverseAbstractInterpreter interpreter = new com.google.javascript.jscomp.SemanticReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry());\n            if (options.closurePass) {\n                interpreter = new com.google.javascript.jscomp.ClosureReverseAbstractInterpreter(getCodingConvention(), getTypeRegistry()).append(interpreter).getFirst();\n            }\n            abstractInterpreter = interpreter;\n        }\n        return abstractInterpreter;\n    }\n\n    @java.lang.Override\n    com.google.javascript.jscomp.TypeValidator getTypeValidator() {\n        return typeValidator;\n    }\n\n    com.google.javascript.rhino.Node parseInputs() {\n        boolean devMode = options.devMode != com.google.javascript.jscomp.CompilerOptions.DevMode.OFF;\n        if (externsRoot != null) {\n            externsRoot.detachChildren();\n        }\n        if (jsRoot != null) {\n            jsRoot.detachChildren();\n        }\n        jsRoot = new com.google.javascript.rhino.Node(com.google.javascript.rhino.Token.BLOCK);\n        jsRoot.setIsSyntheticBlock(true);\n        if (options.tracer.isOn()) {\n            tracker = new com.google.javascript.jscomp.PerformanceTracker(jsRoot, options.tracer == com.google.javascript.jscomp.CompilerOptions.TracerMode.ALL);\n            addChangeHandler(tracker.getCodeChangeHandler());\n        }\n        com.google.javascript.jscomp.Tracer tracer = newTracer(\"parseInputs\");\n        try {\n            externsRoot = new com.google.javascript.rhino.Node(com.google.javascript.rhino.Token.BLOCK);\n            externsRoot.setIsSyntheticBlock(true);\n            for (com.google.javascript.jscomp.CompilerInput input : externs) {\n                com.google.javascript.rhino.Node n = input.getAstRoot(this);\n                if (hasErrors()) {\n                    return null;\n                }\n                externsRoot.addChildToBack(n);\n            }\n            for (com.google.javascript.jscomp.CompilerInput input : inputs) {\n                com.google.javascript.rhino.Node n = input.getAstRoot(this);\n                if (hasErrors()) {\n                    return null;\n                }\n                if (n == null) {\n                    continue;\n                }\n                if (devMode) {\n                    runSanityCheck();\n                    if (hasErrors()) {\n                        return null;\n                    }\n                }\n                if ((options.sourceMapOutputPath != null) || (options.nameReferenceReportPath != null)) {\n                    com.google.javascript.jscomp.SourceInformationAnnotator sia = new com.google.javascript.jscomp.SourceInformationAnnotator(input.getName());\n                    com.google.javascript.jscomp.NodeTraversal.traverse(this, n, sia);\n                }\n                jsRoot.addChildToBack(n);\n            }\n            externAndJsRoot = new com.google.javascript.rhino.Node(com.google.javascript.rhino.Token.BLOCK, externsRoot, jsRoot);\n            externAndJsRoot.setIsSyntheticBlock(true);\n            return externAndJsRoot;\n        } finally {\n            stopTracer(tracer, \"parseInputs\");\n        }\n    }\n\n    public com.google.javascript.rhino.Node parse(com.google.javascript.jscomp.JSSourceFile file) {\n        initCompilerOptionsIfTesting();\n        addToDebugLog(\"Parsing: \" + file.getName());\n        return new com.google.javascript.jscomp.JsAst(file).getAstRoot(this);\n    }\n\n    @java.lang.Override\n    com.google.javascript.rhino.Node parseSyntheticCode(java.lang.String js) {\n        com.google.javascript.jscomp.CompilerInput input = new com.google.javascript.jscomp.CompilerInput(com.google.javascript.jscomp.JSSourceFile.fromCode(\" [synthetic] \", js));\n        inputsByName.put(input.getName(), input);\n        return input.getAstRoot(this);\n    }\n\n    void initCompilerOptionsIfTesting() {\n        if (options == null) {\n            initOptions(new com.google.javascript.jscomp.CompilerOptions());\n        }\n    }\n\n    @java.lang.Override\n    com.google.javascript.rhino.Node parseSyntheticCode(java.lang.String fileName, java.lang.String js) {\n        initCompilerOptionsIfTesting();\n        return parse(com.google.javascript.jscomp.JSSourceFile.fromCode(fileName, js));\n    }\n\n    com.google.javascript.rhino.Node parseTestCode(java.lang.String js) {\n        initCompilerOptionsIfTesting();\n        com.google.javascript.jscomp.CompilerInput input = new com.google.javascript.jscomp.CompilerInput(com.google.javascript.jscomp.JSSourceFile.fromCode(\" [testcode] \", js));\n        if (inputsByName == null) {\n            inputsByName = com.google.common.collect.Maps.newHashMap();\n        }\n        inputsByName.put(input.getName(), input);\n        return input.getAstRoot(this);\n    }\n\n    @java.lang.Override\n    com.google.javascript.jscomp.mozilla.rhino.ErrorReporter getDefaultErrorReporter() {\n        return defaultErrorReporter;\n    }\n\n    public java.lang.String toSource() {\n        return runInCompilerThread(new java.util.concurrent.Callable<java.lang.String>() {\n            public java.lang.String call() throws java.lang.Exception {\n                com.google.javascript.jscomp.Tracer tracer = newTracer(\"toSource\");\n                try {\n                    com.google.javascript.jscomp.Compiler.CodeBuilder cb = new com.google.javascript.jscomp.Compiler.CodeBuilder();\n                    if (jsRoot != null) {\n                        int i = 0;\n                        for (com.google.javascript.rhino.Node scriptNode = jsRoot.getFirstChild(); scriptNode != null; scriptNode = scriptNode.getNext()) {\n                            toSource(cb, i++, scriptNode);\n                        }\n                    }\n                    return cb.toString();\n                } finally {\n                    stopTracer(tracer, \"toSource\");\n                }\n            }\n        });\n    }\n\n    public java.lang.String[] toSourceArray() {\n        return runInCompilerThread(new java.util.concurrent.Callable<java.lang.String[]>() {\n            public java.lang.String[] call() throws java.lang.Exception {\n                com.google.javascript.jscomp.Tracer tracer = newTracer(\"toSourceArray\");\n                try {\n                    int numInputs = inputs.length;\n                    java.lang.String[] sources = new java.lang.String[numInputs];\n                    com.google.javascript.jscomp.Compiler.CodeBuilder cb = new com.google.javascript.jscomp.Compiler.CodeBuilder();\n                    for (int i = 0; i < numInputs; i++) {\n                        com.google.javascript.rhino.Node scriptNode = inputs[i].getAstRoot(Compiler.this);\n                        cb.reset();\n                        toSource(cb, i, scriptNode);\n                        sources[i] = cb.toString();\n                    }\n                    return sources;\n                } finally {\n                    stopTracer(tracer, \"toSourceArray\");\n                }\n            }\n        });\n    }\n\n    public java.lang.String toSource(final com.google.javascript.jscomp.JSModule module) {\n        return runInCompilerThread(new java.util.concurrent.Callable<java.lang.String>() {\n            public java.lang.String call() throws java.lang.Exception {\n                java.util.List<com.google.javascript.jscomp.CompilerInput> inputs = module.getInputs();\n                int numInputs = inputs.size();\n                if (numInputs == 0) {\n                    return \"\";\n                }\n                com.google.javascript.jscomp.Compiler.CodeBuilder cb = new com.google.javascript.jscomp.Compiler.CodeBuilder();\n                for (int i = 0; i < numInputs; i++) {\n                    com.google.javascript.rhino.Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n                    if (scriptNode == null) {\n                        throw new java.lang.IllegalArgumentException(\"Bad module: \" + module.getName());\n                    }\n                    toSource(cb, i, scriptNode);\n                }\n                return cb.toString();\n            }\n        });\n    }\n\n    public java.lang.String[] toSourceArray(final com.google.javascript.jscomp.JSModule module) {\n        return runInCompilerThread(new java.util.concurrent.Callable<java.lang.String[]>() {\n            public java.lang.String[] call() throws java.lang.Exception {\n                java.util.List<com.google.javascript.jscomp.CompilerInput> inputs = module.getInputs();\n                int numInputs = inputs.size();\n                if (numInputs == 0) {\n                    return new java.lang.String[0];\n                }\n                java.lang.String[] sources = new java.lang.String[numInputs];\n                com.google.javascript.jscomp.Compiler.CodeBuilder cb = new com.google.javascript.jscomp.Compiler.CodeBuilder();\n                for (int i = 0; i < numInputs; i++) {\n                    com.google.javascript.rhino.Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n                    if (scriptNode == null) {\n                        throw new java.lang.IllegalArgumentException(\"Bad module input: \" + inputs.get(i).getName());\n                    }\n                    cb.reset();\n                    toSource(cb, i, scriptNode);\n                    sources[i] = cb.toString();\n                }\n                return sources;\n            }\n        });\n    }\n\n    public void toSource(final com.google.javascript.jscomp.Compiler.CodeBuilder cb, final int inputSeqNum, final com.google.javascript.rhino.Node root) {\n        runInCompilerThread(new java.util.concurrent.Callable<java.lang.Void>() {\n            public java.lang.Void call() throws java.lang.Exception {\n                if (options.printInputDelimiter) {\n                    if ((cb.getLength() > 0) && (!cb.endsWith(\"\\n\"))) {\n                        cb.append(\"\\n\");\n                    }\n                    com.google.common.base.Preconditions.checkState(root.getType() == com.google.javascript.rhino.Token.SCRIPT);\n                    java.lang.String delimiter = options.inputDelimiter;\n                    java.lang.String sourceName = ((java.lang.String) (root.getProp(Node.SOURCENAME_PROP)));\n                    com.google.common.base.Preconditions.checkState(sourceName != null);\n                    com.google.common.base.Preconditions.checkState(!sourceName.isEmpty());\n                    delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", java.lang.String.valueOf(inputSeqNum));\n                    cb.append(delimiter).append(\"\\n\");\n                }\n                if ((root.getJSDocInfo() != null) && (root.getJSDocInfo().getLicense() != null)) {\n                    cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n                }\n                if (options.sourceMapOutputPath != null) {\n                    sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n                }\n                java.lang.String code = toSource(root);\n                if (!code.isEmpty()) {\n                    cb.append(code);\n                    if (!code.endsWith(\";\")) {\n                        cb.append(\";\");\n                    }\n                }\n                return null;\n            }\n        });\n    }\n\n    @java.lang.Override\n    java.lang.String toSource(com.google.javascript.rhino.Node n) {\n        initCompilerOptionsIfTesting();\n        com.google.javascript.jscomp.CodePrinter.Builder builder = new com.google.javascript.jscomp.CodePrinter.Builder(n);\n        builder.setPrettyPrint(options.prettyPrint);\n        builder.setLineBreak(options.lineBreak);\n        builder.setSourceMap(sourceMap);\n        builder.setOutputCharset(options.outputCharset);\n        return builder.build();\n    }\n\n    public static class CodeBuilder {\n        private final java.lang.StringBuilder sb = new java.lang.StringBuilder();\n\n        private int lineCount = 0;\n\n        void reset() {\n            sb.setLength(0);\n        }\n\n        com.google.javascript.jscomp.Compiler.CodeBuilder append(java.lang.String str) {\n            sb.append(str);\n            int index = -1;\n            while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n                ++lineCount;\n            } \n            return this;\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            return sb.toString();\n        }\n\n        public int getLength() {\n            return sb.length();\n        }\n\n        int getLineIndex() {\n            return lineCount;\n        }\n\n        int getColumnIndex() {\n            int index = sb.lastIndexOf(\"\\n\");\n            return index >= 0 ? sb.length() - (index + 1) : sb.length();\n        }\n\n        boolean endsWith(java.lang.String suffix) {\n            return (sb.length() > suffix.length()) && suffix.equals(sb.substring(sb.length() - suffix.length()));\n        }\n    }\n\n    public void optimize() {\n        com.google.javascript.jscomp.PhaseOptimizer phaseOptimizer = new com.google.javascript.jscomp.PhaseOptimizer(this, tracker);\n        if (options.devMode == com.google.javascript.jscomp.CompilerOptions.DevMode.EVERY_PASS) {\n            phaseOptimizer.setSanityCheck(sanityCheck);\n        }\n        phaseOptimizer.consume(getPassConfig().getOptimizations());\n        phaseOptimizer.process(externsRoot, jsRoot);\n        if (hasErrors()) {\n            return;\n        }\n    }\n\n    @java.lang.Override\n    void setCssRenamingMap(com.google.javascript.jscomp.CssRenamingMap map) {\n        options.cssRenamingMap = map;\n    }\n\n    @java.lang.Override\n    com.google.javascript.jscomp.CssRenamingMap getCssRenamingMap() {\n        return options.cssRenamingMap;\n    }\n\n    public void processDefines() {\n        new com.google.javascript.jscomp.DefaultPassConfig(options).processDefines.create(this).process(externsRoot, jsRoot);\n    }\n\n    boolean isInliningForbidden() {\n        return (options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC) || (options.propertyRenaming == PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC);\n    }\n\n    com.google.javascript.jscomp.ControlFlowGraph<com.google.javascript.rhino.Node> computeCFG() {\n        com.google.javascript.jscomp.Compiler.logger.info(\"Computing Control Flow Graph\");\n        com.google.javascript.jscomp.Tracer tracer = newTracer(\"computeCFG\");\n        com.google.javascript.jscomp.ControlFlowAnalysis cfa = new com.google.javascript.jscomp.ControlFlowAnalysis(this, true);\n        process(cfa);\n        stopTracer(tracer, \"computeCFG\");\n        return cfa.getCfg();\n    }\n\n    public void normalize() {\n        com.google.javascript.jscomp.Compiler.logger.info(\"Normalizing\");\n        startPass(\"normalize\");\n        process(new com.google.javascript.jscomp.Normalize(this, false));\n        setNormalized();\n        endPass();\n    }\n\n    @java.lang.Override\n    void prepareAst(com.google.javascript.rhino.Node root) {\n        com.google.javascript.jscomp.Tracer tracer = newTracer(\"prepareAst\");\n        com.google.javascript.jscomp.CompilerPass pass = new com.google.javascript.jscomp.PrepareAst(this);\n        pass.process(null, root);\n        stopTracer(tracer, \"prepareAst\");\n    }\n\n    void recordFunctionInformation() {\n        com.google.javascript.jscomp.Compiler.logger.info(\"Recording function information\");\n        startPass(\"recordFunctionInformation\");\n        com.google.javascript.jscomp.RecordFunctionInformation recordFunctionInfoPass = new com.google.javascript.jscomp.RecordFunctionInformation(this, getPassConfig().getIntermediateState().functionNames);\n        process(recordFunctionInfoPass);\n        functionInformationMap = recordFunctionInfoPass.getMap();\n        endPass();\n    }\n\n    protected final CodeChangeHandler.RecentChange recentChange = new com.google.javascript.jscomp.CodeChangeHandler.RecentChange();\n\n    private final java.util.List<com.google.javascript.jscomp.CodeChangeHandler> codeChangeHandlers = com.google.common.collect.Lists.<com.google.javascript.jscomp.CodeChangeHandler>newArrayList();\n\n    @java.lang.Override\n    void addChangeHandler(com.google.javascript.jscomp.CodeChangeHandler handler) {\n        codeChangeHandlers.add(handler);\n    }\n\n    @java.lang.Override\n    void removeChangeHandler(com.google.javascript.jscomp.CodeChangeHandler handler) {\n        codeChangeHandlers.remove(handler);\n    }\n\n    @java.lang.Override\n    public void reportCodeChange() {\n        for (com.google.javascript.jscomp.CodeChangeHandler handler : codeChangeHandlers) {\n            handler.reportChange();\n        }\n    }\n\n    @java.lang.Override\n    public com.google.javascript.jscomp.CodingConvention getCodingConvention() {\n        com.google.javascript.jscomp.CodingConvention convention = options.getCodingConvention();\n        convention = (convention != null) ? convention : defaultCodingConvention;\n        return convention;\n    }\n\n    @java.lang.Override\n    public boolean isIdeMode() {\n        return options.ideMode;\n    }\n\n    @java.lang.Override\n    com.google.javascript.jscomp.parsing.Config getParserConfig() {\n        if (parserConfig == null) {\n            parserConfig = com.google.javascript.jscomp.parsing.ParserRunner.createConfig(getTypeRegistry(), isIdeMode());\n        }\n        return parserConfig;\n    }\n\n    @java.lang.Override\n    public boolean isTypeCheckingEnabled() {\n        return options.checkTypes;\n    }\n\n    @java.lang.Override\n    public void report(com.google.javascript.jscomp.JSError error) {\n        com.google.javascript.jscomp.CheckLevel level = error.level;\n        com.google.javascript.jscomp.WarningsGuard guard = options.getWarningsGuard();\n        if (guard != null) {\n            com.google.javascript.jscomp.CheckLevel newLevel = guard.level(error);\n            if (newLevel != null) {\n                level = newLevel;\n            }\n        }\n        if (level.isOn()) {\n            errorManager.report(level, error);\n        }\n    }\n\n    @java.lang.Override\n    void throwInternalError(java.lang.String message, java.lang.Exception cause) {\n        java.lang.String finalMessage = (\"INTERNAL COMPILER ERROR.\\n\" + \"Please report this problem.\\n\") + message;\n        java.lang.RuntimeException e = new java.lang.RuntimeException(finalMessage, cause);\n        if (cause != null) {\n            e.setStackTrace(cause.getStackTrace());\n        }\n        throw e;\n    }\n\n    public int getErrorCount() {\n        return errorManager.getErrorCount();\n    }\n\n    public int getWarningCount() {\n        return errorManager.getWarningCount();\n    }\n\n    @java.lang.Override\n    boolean hasHaltingErrors() {\n        return (!isIdeMode()) && (getErrorCount() > 0);\n    }\n\n    public boolean hasErrors() {\n        return hasHaltingErrors();\n    }\n\n    @java.lang.Override\n    void addToDebugLog(java.lang.String str) {\n        debugLog.append(str);\n        debugLog.append('\\n');\n        com.google.javascript.jscomp.Compiler.logger.fine(str);\n    }\n\n    private com.google.javascript.jscomp.SourceFile getSourceFileByName(java.lang.String sourceName) {\n        if (inputsByName.containsKey(sourceName)) {\n            return inputsByName.get(sourceName).getSourceFile();\n        }\n        return null;\n    }\n\n    public java.lang.String getSourceLine(java.lang.String sourceName, int lineNumber) {\n        if (lineNumber < 1) {\n            return null;\n        }\n        com.google.javascript.jscomp.SourceFile input = getSourceFileByName(sourceName);\n        if (input != null) {\n            return input.getLine(lineNumber);\n        }\n        return null;\n    }\n\n    public com.google.javascript.jscomp.Region getSourceRegion(java.lang.String sourceName, int lineNumber) {\n        if (lineNumber < 1) {\n            return null;\n        }\n        com.google.javascript.jscomp.SourceFile input = getSourceFileByName(sourceName);\n        if (input != null) {\n            return input.getRegion(lineNumber);\n        }\n        return null;\n    }\n\n    @java.lang.Override\n    com.google.javascript.rhino.Node getNodeForCodeInsertion(com.google.javascript.jscomp.JSModule module) {\n        if (module == null) {\n            if (inputs.length == 0) {\n                throw new java.lang.IllegalStateException(\"No inputs\");\n            }\n            return inputs[0].getAstRoot(this);\n        }\n        java.util.List<com.google.javascript.jscomp.CompilerInput> inputs = module.getInputs();\n        if (inputs.size() > 0) {\n            return inputs.get(0).getAstRoot(this);\n        }\n        throw new java.lang.IllegalStateException(\"Root module has no inputs\");\n    }\n\n    public com.google.javascript.jscomp.SourceMap getSourceMap() {\n        return sourceMap;\n    }\n\n    com.google.javascript.jscomp.VariableMap getVariableMap() {\n        return getPassConfig().getIntermediateState().variableMap;\n    }\n\n    com.google.javascript.jscomp.VariableMap getPropertyMap() {\n        return getPassConfig().getIntermediateState().propertyMap;\n    }\n\n    com.google.javascript.jscomp.CompilerOptions getOptions() {\n        return options;\n    }\n\n    com.google.javascript.jscomp.FunctionInformationMap getFunctionalInformationMap() {\n        return functionInformationMap;\n    }\n\n    public static void setLoggingLevel(java.util.logging.Level level) {\n        com.google.javascript.jscomp.Compiler.logger.setLevel(level);\n    }\n\n    public java.lang.String getAstDotGraph() throws java.io.IOException {\n        if (jsRoot != null) {\n            com.google.javascript.jscomp.ControlFlowAnalysis cfa = new com.google.javascript.jscomp.ControlFlowAnalysis(this, true);\n            cfa.process(null, jsRoot);\n            return com.google.javascript.jscomp.DotFormatter.toDot(jsRoot, cfa.getCfg());\n        } else {\n            return \"\";\n        }\n    }\n\n    @java.lang.Override\n    public com.google.javascript.jscomp.ErrorManager getErrorManager() {\n        if (options == null) {\n            initOptions(new com.google.javascript.jscomp.CompilerOptions());\n        }\n        return errorManager;\n    }\n\n    public static class IntermediateState implements java.io.Serializable {\n        private static final long serialVersionUID = 1L;\n\n        com.google.javascript.rhino.Node externsRoot;\n\n        private com.google.javascript.rhino.Node jsRoot;\n\n        private com.google.javascript.jscomp.CompilerInput[] externs;\n\n        private com.google.javascript.jscomp.CompilerInput[] inputs;\n\n        private com.google.javascript.jscomp.JSModule[] modules;\n\n        private PassConfig.State passConfigState;\n\n        private com.google.javascript.rhino.jstype.JSTypeRegistry typeRegistry;\n\n        private boolean normalized;\n\n        private IntermediateState() {\n        }\n    }\n\n    public com.google.javascript.jscomp.Compiler.IntermediateState getState() {\n        com.google.javascript.jscomp.Compiler.IntermediateState state = new com.google.javascript.jscomp.Compiler.IntermediateState();\n        state.externsRoot = externsRoot;\n        state.jsRoot = jsRoot;\n        state.externs = externs;\n        state.inputs = inputs;\n        state.modules = modules;\n        state.passConfigState = getPassConfig().getIntermediateState();\n        state.typeRegistry = typeRegistry;\n        state.normalized = normalized;\n        return state;\n    }\n\n    public void setState(com.google.javascript.jscomp.Compiler.IntermediateState state) {\n        externsRoot = state.externsRoot;\n        jsRoot = state.jsRoot;\n        externs = state.externs;\n        inputs = state.inputs;\n        modules = state.modules;\n        passes = createPassConfigInternal();\n        getPassConfig().setIntermediateState(state.passConfigState);\n        typeRegistry = state.typeRegistry;\n        normalized = state.normalized;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "for (com.google.javascript.jscomp.JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {\n    inputs = m.getInputs();\n    if (inputs.size() > 0) {\n        return inputs.get(0).getAstRoot(this);\n    }\n}",
            "src_parent": "{\n    if (module == null) {\n        if (inputs.length == 0) {\n            throw new java.lang.IllegalStateException(\"No inputs\");\n        }\n        return inputs[0].getAstRoot(this);\n    }\n    java.util.List<com.google.javascript.jscomp.CompilerInput> inputs = module.getInputs();\n    if (inputs.size() > 0) {\n        return inputs.get(0).getAstRoot(this);\n    }\n    for (com.google.javascript.jscomp.JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {\n        inputs = m.getInputs();\n        if (inputs.size() > 0) {\n            return inputs.get(0).getAstRoot(this);\n        }\n    }\n    throw new java.lang.IllegalStateException(\"Root module has no inputs\");\n}",
            "src_parent_type": "Block",
            "src_type": "ForEach"
          }
        }
      ],
      "file_name": "Compiler"
    }
  ],
  "id": "Closure_140"
}