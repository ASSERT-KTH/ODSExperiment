{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "private static final int HASH_SEED = 31;",
            "src_parent": "public class ExtendedMessageFormat extends java.text.MessageFormat {\n    private static final long serialVersionUID = -2362048321261811743L;\n\n    private static final int HASH_SEED = 31;\n\n    private static final java.lang.String DUMMY_PATTERN = \"\";\n\n    private static final java.lang.String ESCAPED_QUOTE = \"''\";\n\n    private static final char START_FMT = ',';\n\n    private static final char END_FE = '}';\n\n    private static final char START_FE = '{';\n\n    private static final char QUOTE = '\\'';\n\n    private java.lang.String toPattern;\n\n    private final java.util.Map<java.lang.String, ? extends org.apache.commons.lang3.text.FormatFactory> registry;\n\n    public ExtendedMessageFormat(java.lang.String pattern) {\n        this(pattern, java.util.Locale.getDefault());\n    }\n\n    public ExtendedMessageFormat(java.lang.String pattern, java.util.Locale locale) {\n        this(pattern, locale, null);\n    }\n\n    public ExtendedMessageFormat(java.lang.String pattern, java.util.Map<java.lang.String, ? extends org.apache.commons.lang3.text.FormatFactory> registry) {\n        this(pattern, java.util.Locale.getDefault(), registry);\n    }\n\n    public ExtendedMessageFormat(java.lang.String pattern, java.util.Locale locale, java.util.Map<java.lang.String, ? extends org.apache.commons.lang3.text.FormatFactory> registry) {\n        super(org.apache.commons.lang3.text.ExtendedMessageFormat.DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n    @java.lang.Override\n    public java.lang.String toPattern() {\n        return toPattern;\n    }\n\n    @java.lang.Override\n    public final void applyPattern(java.lang.String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        java.util.ArrayList<java.text.Format> foundFormats = new java.util.ArrayList<java.text.Format>();\n        java.util.ArrayList<java.lang.String> foundDescriptions = new java.util.ArrayList<java.lang.String>();\n        java.lang.StringBuilder stripCustom = new java.lang.StringBuilder(pattern.length());\n        java.text.ParsePosition pos = new java.text.ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    appendQuotedString(pattern, pos, stripCustom, true);\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE :\n                    fmtCount++;\n                    seekNonWs(pattern, pos);\n                    int start = pos.getIndex();\n                    int index = readArgumentIndex(pattern, next(pos));\n                    stripCustom.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE).append(index);\n                    seekNonWs(pattern, pos);\n                    java.text.Format format = null;\n                    java.lang.String formatDescription = null;\n                    if (c[pos.getIndex()] == org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT) {\n                        formatDescription = parseFormatDescription(pattern, next(pos));\n                        format = getFormat(formatDescription);\n                        if (format == null) {\n                            stripCustom.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT).append(formatDescription);\n                        }\n                    }\n                    foundFormats.add(format);\n                    foundDescriptions.add(format == null ? null : formatDescription);\n                    org.apache.commons.lang3.Validate.isTrue(foundFormats.size() == fmtCount);\n                    org.apache.commons.lang3.Validate.isTrue(foundDescriptions.size() == fmtCount);\n                    if (c[pos.getIndex()] != org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE) {\n                        throw new java.lang.IllegalArgumentException(\"Unreadable format element at position \" + start);\n                    }\n                default :\n                    stripCustom.append(c[pos.getIndex()]);\n                    next(pos);\n            }\n        } \n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            java.text.Format[] origFormats = getFormats();\n            int i = 0;\n            for (java.util.Iterator<java.text.Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n                java.text.Format f = it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n    @java.lang.Override\n    public void setFormat(int formatElementIndex, java.text.Format newFormat) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public void setFormatByArgumentIndex(int argumentIndex, java.text.Format newFormat) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public void setFormats(java.text.Format[] newFormats) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public void setFormatsByArgumentIndex(java.text.Format[] newFormats) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public boolean equals(java.lang.Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (org.apache.commons.lang3.ObjectUtils.notEqual(getClass(), obj.getClass())) {\n            return false;\n        }\n        org.apache.commons.lang3.text.ExtendedMessageFormat rhs = ((org.apache.commons.lang3.text.ExtendedMessageFormat) (obj));\n        if (org.apache.commons.lang3.ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n            return false;\n        }\n        if (org.apache.commons.lang3.ObjectUtils.notEqual(registry, rhs.registry)) {\n            return false;\n        }\n        return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = (org.apache.commons.lang3.text.ExtendedMessageFormat.HASH_SEED * result) + org.apache.commons.lang3.ObjectUtils.hashCode(registry);\n        result = (org.apache.commons.lang3.text.ExtendedMessageFormat.HASH_SEED * result) + org.apache.commons.lang3.ObjectUtils.hashCode(toPattern);\n        return result;\n    }\n\n    private java.text.Format getFormat(java.lang.String desc) {\n        if (registry != null) {\n            java.lang.String name = desc;\n            java.lang.String args = null;\n            int i = desc.indexOf(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            org.apache.commons.lang3.text.FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    private int readArgumentIndex(java.lang.String pattern, java.text.ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        java.lang.StringBuffer result = new java.lang.StringBuffer();\n        boolean error = false;\n        for (; (!error) && (pos.getIndex() < pattern.length()); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (java.lang.Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if ((c != org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT) && (c != org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE)) {\n                    error = true;\n                    continue;\n                }\n            }\n            if (((c == org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT) || (c == org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE)) && (result.length() > 0)) {\n                try {\n                    return java.lang.Integer.parseInt(result.toString());\n                } catch (java.lang.NumberFormatException e) {\n                }\n            }\n            error = !java.lang.Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new java.lang.IllegalArgumentException(((\"Invalid format argument index at position \" + start) + \": \") + pattern.substring(start, pos.getIndex()));\n        }\n        throw new java.lang.IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n\n    private java.lang.String parseFormatDescription(java.lang.String pattern, java.text.ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE :\n                    depth++;\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE :\n                    depth--;\n                    if (depth == 0) {\n                        return pattern.substring(text, pos.getIndex());\n                    }\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    getQuotedString(pattern, pos, false);\n                    break;\n            }\n        }\n        throw new java.lang.IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n\n    private java.lang.String insertFormats(java.lang.String pattern, java.util.ArrayList<java.lang.String> customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        java.lang.StringBuilder sb = new java.lang.StringBuilder(pattern.length() * 2);\n        java.text.ParsePosition pos = new java.text.ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    appendQuotedString(pattern, pos, sb, false);\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE :\n                    depth++;\n                    if (depth == 1) {\n                        fe++;\n                        sb.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE).append(readArgumentIndex(pattern, next(pos)));\n                        java.lang.String customPattern = customPatterns.get(fe);\n                        if (customPattern != null) {\n                            sb.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT).append(customPattern);\n                        }\n                    }\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE :\n                    depth--;\n                default :\n                    sb.append(c);\n                    next(pos);\n            }\n        } \n        return sb.toString();\n    }\n\n    private void seekNonWs(java.lang.String pattern, java.text.ParsePosition pos) {\n        int len = 0;\n        char[] buffer = pattern.toCharArray();\n        do {\n            len = org.apache.commons.lang3.text.StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n            pos.setIndex(pos.getIndex() + len);\n        } while ((len > 0) && (pos.getIndex() < pattern.length()) );\n    }\n\n    private java.text.ParsePosition next(java.text.ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n\n    private java.lang.StringBuilder appendQuotedString(java.lang.String pattern, java.text.ParsePosition pos, java.lang.StringBuilder appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && (c[start] == org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE)) {\n            next(pos);\n            return appendTo == null ? null : appendTo.append(org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(org.apache.commons.lang3.text.ExtendedMessageFormat.ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE);\n                pos.setIndex(i + org.apache.commons.lang3.text.ExtendedMessageFormat.ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    next(pos);\n                    return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                default :\n                    next(pos);\n            }\n        }\n        throw new java.lang.IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n    }\n\n    private void getQuotedString(java.lang.String pattern, java.text.ParsePosition pos, boolean escapingOn) {\n        appendQuotedString(pattern, pos, null, escapingOn);\n    }\n\n    private boolean containsElements(java.util.Collection<?> coll) {\n        if ((coll == null) || (coll.size() == 0)) {\n            return false;\n        }\n        for (java.util.Iterator<?> iter = coll.iterator(); iter.hasNext();) {\n            if (iter.next() != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "@java.lang.Override\npublic boolean equals(java.lang.Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (!super.equals(obj)) {\n        return false;\n    }\n    if (org.apache.commons.lang3.ObjectUtils.notEqual(getClass(), obj.getClass())) {\n        return false;\n    }\n    org.apache.commons.lang3.text.ExtendedMessageFormat rhs = ((org.apache.commons.lang3.text.ExtendedMessageFormat) (obj));\n    if (org.apache.commons.lang3.ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n        return false;\n    }\n    if (org.apache.commons.lang3.ObjectUtils.notEqual(registry, rhs.registry)) {\n        return false;\n    }\n    return true;\n}",
            "src_parent": "public class ExtendedMessageFormat extends java.text.MessageFormat {\n    private static final long serialVersionUID = -2362048321261811743L;\n\n    private static final int HASH_SEED = 31;\n\n    private static final java.lang.String DUMMY_PATTERN = \"\";\n\n    private static final java.lang.String ESCAPED_QUOTE = \"''\";\n\n    private static final char START_FMT = ',';\n\n    private static final char END_FE = '}';\n\n    private static final char START_FE = '{';\n\n    private static final char QUOTE = '\\'';\n\n    private java.lang.String toPattern;\n\n    private final java.util.Map<java.lang.String, ? extends org.apache.commons.lang3.text.FormatFactory> registry;\n\n    public ExtendedMessageFormat(java.lang.String pattern) {\n        this(pattern, java.util.Locale.getDefault());\n    }\n\n    public ExtendedMessageFormat(java.lang.String pattern, java.util.Locale locale) {\n        this(pattern, locale, null);\n    }\n\n    public ExtendedMessageFormat(java.lang.String pattern, java.util.Map<java.lang.String, ? extends org.apache.commons.lang3.text.FormatFactory> registry) {\n        this(pattern, java.util.Locale.getDefault(), registry);\n    }\n\n    public ExtendedMessageFormat(java.lang.String pattern, java.util.Locale locale, java.util.Map<java.lang.String, ? extends org.apache.commons.lang3.text.FormatFactory> registry) {\n        super(org.apache.commons.lang3.text.ExtendedMessageFormat.DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n    @java.lang.Override\n    public java.lang.String toPattern() {\n        return toPattern;\n    }\n\n    @java.lang.Override\n    public final void applyPattern(java.lang.String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        java.util.ArrayList<java.text.Format> foundFormats = new java.util.ArrayList<java.text.Format>();\n        java.util.ArrayList<java.lang.String> foundDescriptions = new java.util.ArrayList<java.lang.String>();\n        java.lang.StringBuilder stripCustom = new java.lang.StringBuilder(pattern.length());\n        java.text.ParsePosition pos = new java.text.ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    appendQuotedString(pattern, pos, stripCustom, true);\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE :\n                    fmtCount++;\n                    seekNonWs(pattern, pos);\n                    int start = pos.getIndex();\n                    int index = readArgumentIndex(pattern, next(pos));\n                    stripCustom.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE).append(index);\n                    seekNonWs(pattern, pos);\n                    java.text.Format format = null;\n                    java.lang.String formatDescription = null;\n                    if (c[pos.getIndex()] == org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT) {\n                        formatDescription = parseFormatDescription(pattern, next(pos));\n                        format = getFormat(formatDescription);\n                        if (format == null) {\n                            stripCustom.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT).append(formatDescription);\n                        }\n                    }\n                    foundFormats.add(format);\n                    foundDescriptions.add(format == null ? null : formatDescription);\n                    org.apache.commons.lang3.Validate.isTrue(foundFormats.size() == fmtCount);\n                    org.apache.commons.lang3.Validate.isTrue(foundDescriptions.size() == fmtCount);\n                    if (c[pos.getIndex()] != org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE) {\n                        throw new java.lang.IllegalArgumentException(\"Unreadable format element at position \" + start);\n                    }\n                default :\n                    stripCustom.append(c[pos.getIndex()]);\n                    next(pos);\n            }\n        } \n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            java.text.Format[] origFormats = getFormats();\n            int i = 0;\n            for (java.util.Iterator<java.text.Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n                java.text.Format f = it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n    @java.lang.Override\n    public void setFormat(int formatElementIndex, java.text.Format newFormat) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public void setFormatByArgumentIndex(int argumentIndex, java.text.Format newFormat) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public void setFormats(java.text.Format[] newFormats) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public void setFormatsByArgumentIndex(java.text.Format[] newFormats) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public boolean equals(java.lang.Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (org.apache.commons.lang3.ObjectUtils.notEqual(getClass(), obj.getClass())) {\n            return false;\n        }\n        org.apache.commons.lang3.text.ExtendedMessageFormat rhs = ((org.apache.commons.lang3.text.ExtendedMessageFormat) (obj));\n        if (org.apache.commons.lang3.ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n            return false;\n        }\n        if (org.apache.commons.lang3.ObjectUtils.notEqual(registry, rhs.registry)) {\n            return false;\n        }\n        return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = (org.apache.commons.lang3.text.ExtendedMessageFormat.HASH_SEED * result) + org.apache.commons.lang3.ObjectUtils.hashCode(registry);\n        result = (org.apache.commons.lang3.text.ExtendedMessageFormat.HASH_SEED * result) + org.apache.commons.lang3.ObjectUtils.hashCode(toPattern);\n        return result;\n    }\n\n    private java.text.Format getFormat(java.lang.String desc) {\n        if (registry != null) {\n            java.lang.String name = desc;\n            java.lang.String args = null;\n            int i = desc.indexOf(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            org.apache.commons.lang3.text.FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    private int readArgumentIndex(java.lang.String pattern, java.text.ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        java.lang.StringBuffer result = new java.lang.StringBuffer();\n        boolean error = false;\n        for (; (!error) && (pos.getIndex() < pattern.length()); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (java.lang.Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if ((c != org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT) && (c != org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE)) {\n                    error = true;\n                    continue;\n                }\n            }\n            if (((c == org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT) || (c == org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE)) && (result.length() > 0)) {\n                try {\n                    return java.lang.Integer.parseInt(result.toString());\n                } catch (java.lang.NumberFormatException e) {\n                }\n            }\n            error = !java.lang.Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new java.lang.IllegalArgumentException(((\"Invalid format argument index at position \" + start) + \": \") + pattern.substring(start, pos.getIndex()));\n        }\n        throw new java.lang.IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n\n    private java.lang.String parseFormatDescription(java.lang.String pattern, java.text.ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE :\n                    depth++;\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE :\n                    depth--;\n                    if (depth == 0) {\n                        return pattern.substring(text, pos.getIndex());\n                    }\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    getQuotedString(pattern, pos, false);\n                    break;\n            }\n        }\n        throw new java.lang.IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n\n    private java.lang.String insertFormats(java.lang.String pattern, java.util.ArrayList<java.lang.String> customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        java.lang.StringBuilder sb = new java.lang.StringBuilder(pattern.length() * 2);\n        java.text.ParsePosition pos = new java.text.ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    appendQuotedString(pattern, pos, sb, false);\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE :\n                    depth++;\n                    if (depth == 1) {\n                        fe++;\n                        sb.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE).append(readArgumentIndex(pattern, next(pos)));\n                        java.lang.String customPattern = customPatterns.get(fe);\n                        if (customPattern != null) {\n                            sb.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT).append(customPattern);\n                        }\n                    }\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE :\n                    depth--;\n                default :\n                    sb.append(c);\n                    next(pos);\n            }\n        } \n        return sb.toString();\n    }\n\n    private void seekNonWs(java.lang.String pattern, java.text.ParsePosition pos) {\n        int len = 0;\n        char[] buffer = pattern.toCharArray();\n        do {\n            len = org.apache.commons.lang3.text.StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n            pos.setIndex(pos.getIndex() + len);\n        } while ((len > 0) && (pos.getIndex() < pattern.length()) );\n    }\n\n    private java.text.ParsePosition next(java.text.ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n\n    private java.lang.StringBuilder appendQuotedString(java.lang.String pattern, java.text.ParsePosition pos, java.lang.StringBuilder appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && (c[start] == org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE)) {\n            next(pos);\n            return appendTo == null ? null : appendTo.append(org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(org.apache.commons.lang3.text.ExtendedMessageFormat.ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE);\n                pos.setIndex(i + org.apache.commons.lang3.text.ExtendedMessageFormat.ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    next(pos);\n                    return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                default :\n                    next(pos);\n            }\n        }\n        throw new java.lang.IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n    }\n\n    private void getQuotedString(java.lang.String pattern, java.text.ParsePosition pos, boolean escapingOn) {\n        appendQuotedString(pattern, pos, null, escapingOn);\n    }\n\n    private boolean containsElements(java.util.Collection<?> coll) {\n        if ((coll == null) || (coll.size() == 0)) {\n            return false;\n        }\n        for (java.util.Iterator<?> iter = coll.iterator(); iter.hasNext();) {\n            if (iter.next() != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "@java.lang.Override\npublic int hashCode() {\n    int result = super.hashCode();\n    result = (org.apache.commons.lang3.text.ExtendedMessageFormat.HASH_SEED * result) + org.apache.commons.lang3.ObjectUtils.hashCode(registry);\n    result = (org.apache.commons.lang3.text.ExtendedMessageFormat.HASH_SEED * result) + org.apache.commons.lang3.ObjectUtils.hashCode(toPattern);\n    return result;\n}",
            "src_parent": "public class ExtendedMessageFormat extends java.text.MessageFormat {\n    private static final long serialVersionUID = -2362048321261811743L;\n\n    private static final int HASH_SEED = 31;\n\n    private static final java.lang.String DUMMY_PATTERN = \"\";\n\n    private static final java.lang.String ESCAPED_QUOTE = \"''\";\n\n    private static final char START_FMT = ',';\n\n    private static final char END_FE = '}';\n\n    private static final char START_FE = '{';\n\n    private static final char QUOTE = '\\'';\n\n    private java.lang.String toPattern;\n\n    private final java.util.Map<java.lang.String, ? extends org.apache.commons.lang3.text.FormatFactory> registry;\n\n    public ExtendedMessageFormat(java.lang.String pattern) {\n        this(pattern, java.util.Locale.getDefault());\n    }\n\n    public ExtendedMessageFormat(java.lang.String pattern, java.util.Locale locale) {\n        this(pattern, locale, null);\n    }\n\n    public ExtendedMessageFormat(java.lang.String pattern, java.util.Map<java.lang.String, ? extends org.apache.commons.lang3.text.FormatFactory> registry) {\n        this(pattern, java.util.Locale.getDefault(), registry);\n    }\n\n    public ExtendedMessageFormat(java.lang.String pattern, java.util.Locale locale, java.util.Map<java.lang.String, ? extends org.apache.commons.lang3.text.FormatFactory> registry) {\n        super(org.apache.commons.lang3.text.ExtendedMessageFormat.DUMMY_PATTERN);\n        setLocale(locale);\n        this.registry = registry;\n        applyPattern(pattern);\n    }\n\n    @java.lang.Override\n    public java.lang.String toPattern() {\n        return toPattern;\n    }\n\n    @java.lang.Override\n    public final void applyPattern(java.lang.String pattern) {\n        if (registry == null) {\n            super.applyPattern(pattern);\n            toPattern = super.toPattern();\n            return;\n        }\n        java.util.ArrayList<java.text.Format> foundFormats = new java.util.ArrayList<java.text.Format>();\n        java.util.ArrayList<java.lang.String> foundDescriptions = new java.util.ArrayList<java.lang.String>();\n        java.lang.StringBuilder stripCustom = new java.lang.StringBuilder(pattern.length());\n        java.text.ParsePosition pos = new java.text.ParsePosition(0);\n        char[] c = pattern.toCharArray();\n        int fmtCount = 0;\n        while (pos.getIndex() < pattern.length()) {\n            switch (c[pos.getIndex()]) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    appendQuotedString(pattern, pos, stripCustom, true);\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE :\n                    fmtCount++;\n                    seekNonWs(pattern, pos);\n                    int start = pos.getIndex();\n                    int index = readArgumentIndex(pattern, next(pos));\n                    stripCustom.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE).append(index);\n                    seekNonWs(pattern, pos);\n                    java.text.Format format = null;\n                    java.lang.String formatDescription = null;\n                    if (c[pos.getIndex()] == org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT) {\n                        formatDescription = parseFormatDescription(pattern, next(pos));\n                        format = getFormat(formatDescription);\n                        if (format == null) {\n                            stripCustom.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT).append(formatDescription);\n                        }\n                    }\n                    foundFormats.add(format);\n                    foundDescriptions.add(format == null ? null : formatDescription);\n                    org.apache.commons.lang3.Validate.isTrue(foundFormats.size() == fmtCount);\n                    org.apache.commons.lang3.Validate.isTrue(foundDescriptions.size() == fmtCount);\n                    if (c[pos.getIndex()] != org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE) {\n                        throw new java.lang.IllegalArgumentException(\"Unreadable format element at position \" + start);\n                    }\n                default :\n                    stripCustom.append(c[pos.getIndex()]);\n                    next(pos);\n            }\n        } \n        super.applyPattern(stripCustom.toString());\n        toPattern = insertFormats(super.toPattern(), foundDescriptions);\n        if (containsElements(foundFormats)) {\n            java.text.Format[] origFormats = getFormats();\n            int i = 0;\n            for (java.util.Iterator<java.text.Format> it = foundFormats.iterator(); it.hasNext(); i++) {\n                java.text.Format f = it.next();\n                if (f != null) {\n                    origFormats[i] = f;\n                }\n            }\n            super.setFormats(origFormats);\n        }\n    }\n\n    @java.lang.Override\n    public void setFormat(int formatElementIndex, java.text.Format newFormat) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public void setFormatByArgumentIndex(int argumentIndex, java.text.Format newFormat) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public void setFormats(java.text.Format[] newFormats) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public void setFormatsByArgumentIndex(java.text.Format[] newFormats) {\n        throw new java.lang.UnsupportedOperationException();\n    }\n\n    @java.lang.Override\n    public boolean equals(java.lang.Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj == null) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        if (org.apache.commons.lang3.ObjectUtils.notEqual(getClass(), obj.getClass())) {\n            return false;\n        }\n        org.apache.commons.lang3.text.ExtendedMessageFormat rhs = ((org.apache.commons.lang3.text.ExtendedMessageFormat) (obj));\n        if (org.apache.commons.lang3.ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n            return false;\n        }\n        if (org.apache.commons.lang3.ObjectUtils.notEqual(registry, rhs.registry)) {\n            return false;\n        }\n        return true;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = (org.apache.commons.lang3.text.ExtendedMessageFormat.HASH_SEED * result) + org.apache.commons.lang3.ObjectUtils.hashCode(registry);\n        result = (org.apache.commons.lang3.text.ExtendedMessageFormat.HASH_SEED * result) + org.apache.commons.lang3.ObjectUtils.hashCode(toPattern);\n        return result;\n    }\n\n    private java.text.Format getFormat(java.lang.String desc) {\n        if (registry != null) {\n            java.lang.String name = desc;\n            java.lang.String args = null;\n            int i = desc.indexOf(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT);\n            if (i > 0) {\n                name = desc.substring(0, i).trim();\n                args = desc.substring(i + 1).trim();\n            }\n            org.apache.commons.lang3.text.FormatFactory factory = registry.get(name);\n            if (factory != null) {\n                return factory.getFormat(name, args, getLocale());\n            }\n        }\n        return null;\n    }\n\n    private int readArgumentIndex(java.lang.String pattern, java.text.ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        java.lang.StringBuffer result = new java.lang.StringBuffer();\n        boolean error = false;\n        for (; (!error) && (pos.getIndex() < pattern.length()); next(pos)) {\n            char c = pattern.charAt(pos.getIndex());\n            if (java.lang.Character.isWhitespace(c)) {\n                seekNonWs(pattern, pos);\n                c = pattern.charAt(pos.getIndex());\n                if ((c != org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT) && (c != org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE)) {\n                    error = true;\n                    continue;\n                }\n            }\n            if (((c == org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT) || (c == org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE)) && (result.length() > 0)) {\n                try {\n                    return java.lang.Integer.parseInt(result.toString());\n                } catch (java.lang.NumberFormatException e) {\n                }\n            }\n            error = !java.lang.Character.isDigit(c);\n            result.append(c);\n        }\n        if (error) {\n            throw new java.lang.IllegalArgumentException(((\"Invalid format argument index at position \" + start) + \": \") + pattern.substring(start, pos.getIndex()));\n        }\n        throw new java.lang.IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n\n    private java.lang.String parseFormatDescription(java.lang.String pattern, java.text.ParsePosition pos) {\n        int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        int text = pos.getIndex();\n        int depth = 1;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE :\n                    depth++;\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE :\n                    depth--;\n                    if (depth == 0) {\n                        return pattern.substring(text, pos.getIndex());\n                    }\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    getQuotedString(pattern, pos, false);\n                    break;\n            }\n        }\n        throw new java.lang.IllegalArgumentException(\"Unterminated format element at position \" + start);\n    }\n\n    private java.lang.String insertFormats(java.lang.String pattern, java.util.ArrayList<java.lang.String> customPatterns) {\n        if (!containsElements(customPatterns)) {\n            return pattern;\n        }\n        java.lang.StringBuilder sb = new java.lang.StringBuilder(pattern.length() * 2);\n        java.text.ParsePosition pos = new java.text.ParsePosition(0);\n        int fe = -1;\n        int depth = 0;\n        while (pos.getIndex() < pattern.length()) {\n            char c = pattern.charAt(pos.getIndex());\n            switch (c) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    appendQuotedString(pattern, pos, sb, false);\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE :\n                    depth++;\n                    if (depth == 1) {\n                        fe++;\n                        sb.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FE).append(readArgumentIndex(pattern, next(pos)));\n                        java.lang.String customPattern = customPatterns.get(fe);\n                        if (customPattern != null) {\n                            sb.append(org.apache.commons.lang3.text.ExtendedMessageFormat.START_FMT).append(customPattern);\n                        }\n                    }\n                    break;\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.END_FE :\n                    depth--;\n                default :\n                    sb.append(c);\n                    next(pos);\n            }\n        } \n        return sb.toString();\n    }\n\n    private void seekNonWs(java.lang.String pattern, java.text.ParsePosition pos) {\n        int len = 0;\n        char[] buffer = pattern.toCharArray();\n        do {\n            len = org.apache.commons.lang3.text.StrMatcher.splitMatcher().isMatch(buffer, pos.getIndex());\n            pos.setIndex(pos.getIndex() + len);\n        } while ((len > 0) && (pos.getIndex() < pattern.length()) );\n    }\n\n    private java.text.ParsePosition next(java.text.ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n        return pos;\n    }\n\n    private java.lang.StringBuilder appendQuotedString(java.lang.String pattern, java.text.ParsePosition pos, java.lang.StringBuilder appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && (c[start] == org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE)) {\n            next(pos);\n            return appendTo == null ? null : appendTo.append(org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(org.apache.commons.lang3.text.ExtendedMessageFormat.ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE);\n                pos.setIndex(i + org.apache.commons.lang3.text.ExtendedMessageFormat.ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n                case org.apache.commons.lang3.text.ExtendedMessageFormat.QUOTE :\n                    next(pos);\n                    return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold);\n                default :\n                    next(pos);\n            }\n        }\n        throw new java.lang.IllegalArgumentException(\"Unterminated quoted string at position \" + start);\n    }\n\n    private void getQuotedString(java.lang.String pattern, java.text.ParsePosition pos, boolean escapingOn) {\n        appendQuotedString(pattern, pos, null, escapingOn);\n    }\n\n    private boolean containsElements(java.util.Collection<?> coll) {\n        if ((coll == null) || (coll.size() == 0)) {\n            return false;\n        }\n        for (java.util.Iterator<?> iter = coll.iterator(); iter.hasNext();) {\n            if (iter.next() != null) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        }
      ],
      "file_name": "ExtendedMessageFormat"
    }
  ],
  "id": "Lang_23"
}