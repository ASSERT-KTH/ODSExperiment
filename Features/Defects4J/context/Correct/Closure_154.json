{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "static final com.google.javascript.jscomp.DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + ((\"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\") + \"override: {3}\"));",
            "src_parent": "class TypeValidator {\n    private final com.google.javascript.jscomp.AbstractCompiler compiler;\n\n    private final com.google.javascript.rhino.jstype.JSTypeRegistry typeRegistry;\n\n    private final com.google.javascript.rhino.jstype.JSType allValueTypes;\n\n    private boolean shouldReport = true;\n\n    private final com.google.javascript.rhino.jstype.JSType nullOrUndefined;\n\n    private final java.util.List<com.google.javascript.jscomp.TypeValidator.TypeMismatch> mismatches = com.google.common.collect.Lists.newArrayList();\n\n    private static final java.lang.String FOUND_REQUIRED = \"{0}\\n\" + (\"found   : {1}\\n\" + \"required: {2}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType INVALID_CAST = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_INVALID_CAST\", \"invalid cast - must be a subtype or supertype\\n\" + (\"from: {0}\\n\" + \"to  : {1}\"));\n\n    static final com.google.javascript.jscomp.DiagnosticType TYPE_MISMATCH_WARNING = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_TYPE_MISMATCH\", \"{0}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType MISSING_EXTENDS_TAG_WARNING = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_MISSING_EXTENDS_TAG\", \"Missing @extends tag on type {0}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType DUP_VAR_DECLARATION = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_DUP_VAR_DECLARATION\", \"variable {0} redefined with type {1}, \" + \"original definition at {2}:{3} with type {4}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType HIDDEN_PROPERTY_MISMATCH = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_HIDDEN_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + ((\"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\") + \"override: {3}\"));\n\n    static final com.google.javascript.jscomp.DiagnosticType INTERFACE_METHOD_NOT_IMPLEMENTED = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_INTERFACE_METHOD_NOT_IMPLEMENTED\", \"property {0} on interface {1} is not implemented by type {2}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + ((\"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\") + \"override: {3}\"));\n\n    static final com.google.javascript.jscomp.DiagnosticGroup ALL_DIAGNOSTICS = new com.google.javascript.jscomp.DiagnosticGroup(com.google.javascript.jscomp.TypeValidator.INVALID_CAST, com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING, com.google.javascript.jscomp.TypeValidator.MISSING_EXTENDS_TAG_WARNING, com.google.javascript.jscomp.TypeValidator.DUP_VAR_DECLARATION, com.google.javascript.jscomp.TypeValidator.HIDDEN_PROPERTY_MISMATCH, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, com.google.javascript.jscomp.TypeValidator.HIDDEN_INTERFACE_PROPERTY_MISMATCH);\n\n    TypeValidator(com.google.javascript.jscomp.AbstractCompiler compiler) {\n        this.compiler = compiler;\n        this.typeRegistry = compiler.getTypeRegistry();\n        this.allValueTypes = typeRegistry.createUnionType(com.google.javascript.jscomp.STRING_TYPE, com.google.javascript.jscomp.NUMBER_TYPE, com.google.javascript.jscomp.BOOLEAN_TYPE, com.google.javascript.jscomp.NULL_TYPE, com.google.javascript.jscomp.VOID_TYPE);\n        this.nullOrUndefined = typeRegistry.createUnionType(com.google.javascript.jscomp.NULL_TYPE, com.google.javascript.jscomp.VOID_TYPE);\n    }\n\n    java.lang.Iterable<com.google.javascript.jscomp.TypeValidator.TypeMismatch> getMismatches() {\n        return mismatches;\n    }\n\n    void setShouldReport(boolean report) {\n        this.shouldReport = report;\n    }\n\n    boolean expectObject(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type, java.lang.String msg) {\n        if (!type.matchesObjectContext()) {\n            mismatch(t, n, msg, type, com.google.javascript.jscomp.OBJECT_TYPE);\n            return false;\n        }\n        return true;\n    }\n\n    void expectActualObject(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type, java.lang.String msg) {\n        if (!type.isObject()) {\n            mismatch(t, n, msg, type, com.google.javascript.jscomp.OBJECT_TYPE);\n        }\n    }\n\n    void expectAnyObject(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type, java.lang.String msg) {\n        com.google.javascript.rhino.jstype.JSType anyObjectType = getNativeType(com.google.javascript.jscomp.NO_OBJECT_TYPE);\n        if ((!anyObjectType.isSubtype(type)) && (!type.isEmptyType())) {\n            mismatch(t, n, msg, type, anyObjectType);\n        }\n    }\n\n    void expectString(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type, java.lang.String msg) {\n        if (!type.matchesStringContext()) {\n            mismatch(t, n, msg, type, com.google.javascript.jscomp.STRING_TYPE);\n        }\n    }\n\n    void expectNumber(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type, java.lang.String msg) {\n        if (!type.matchesNumberContext()) {\n            mismatch(t, n, msg, type, com.google.javascript.jscomp.NUMBER_TYPE);\n        }\n    }\n\n    void expectBitwiseable(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type, java.lang.String msg) {\n        if ((!type.matchesNumberContext()) && (!type.isSubtype(allValueTypes))) {\n            mismatch(t, n, msg, type, allValueTypes);\n        }\n    }\n\n    void expectStringOrNumber(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type, java.lang.String msg) {\n        if ((!type.matchesNumberContext()) && (!type.matchesStringContext())) {\n            mismatch(t, n, msg, type, com.google.javascript.jscomp.NUMBER_STRING);\n        }\n    }\n\n    boolean expectNotNullOrUndefined(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type, java.lang.String msg, com.google.javascript.rhino.jstype.JSType expectedType) {\n        if ((((!type.isNoType()) && (!type.isUnknownType())) && type.isSubtype(nullOrUndefined)) && (!containsForwardDeclaredUnresolvedName(type))) {\n            if (((n.getType() == com.google.javascript.rhino.Token.GETPROP) && (!t.inGlobalScope())) && type.isNullType()) {\n                return true;\n            }\n            mismatch(t, n, msg, type, expectedType);\n            return false;\n        }\n        return true;\n    }\n\n    private boolean containsForwardDeclaredUnresolvedName(com.google.javascript.rhino.jstype.JSType type) {\n        if (type instanceof com.google.javascript.rhino.jstype.UnionType) {\n            for (com.google.javascript.rhino.jstype.JSType alt : ((com.google.javascript.rhino.jstype.UnionType) (type)).getAlternates()) {\n                if (containsForwardDeclaredUnresolvedName(alt)) {\n                    return true;\n                }\n            }\n        }\n        return type.isNoResolvedType();\n    }\n\n    void expectSwitchMatchesCase(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType switchType, com.google.javascript.rhino.jstype.JSType caseType) {\n        if ((!switchType.canTestForShallowEqualityWith(caseType)) && ((caseType.autoboxesTo() == null) || (!caseType.autoboxesTo().isSubtype(switchType)))) {\n            mismatch(t, n.getFirstChild(), \"case expression doesn't match switch\", caseType, switchType);\n        }\n    }\n\n    void expectIndexMatch(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType objType, com.google.javascript.rhino.jstype.JSType indexType) {\n        if (objType.isUnknownType()) {\n            expectStringOrNumber(t, n, indexType, \"property access\");\n        } else if ((objType.toObjectType() != null) && (objType.toObjectType().getIndexType() != null)) {\n            expectCanAssignTo(t, n, indexType, objType.toObjectType().getIndexType(), \"restricted index type\");\n        } else if (objType.isArrayType()) {\n            expectNumber(t, n, indexType, \"array access\");\n        } else if (objType.matchesObjectContext()) {\n            expectString(t, n, indexType, \"property access\");\n        } else {\n            mismatch(t, n, \"only arrays or objects can be accessed\", objType, typeRegistry.createUnionType(com.google.javascript.jscomp.ARRAY_TYPE, com.google.javascript.jscomp.OBJECT_TYPE));\n        }\n    }\n\n    boolean expectCanAssignToPropertyOf(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType rightType, com.google.javascript.rhino.jstype.JSType leftType, com.google.javascript.rhino.Node owner, java.lang.String propName) {\n        if ((!leftType.isNoType()) && (!rightType.canAssignTo(leftType))) {\n            if (bothIntrinsics(rightType, leftType)) {\n                registerMismatch(rightType, leftType);\n            } else {\n                mismatch(t, n, ((\"assignment to property \" + propName) + \" of \") + getReadableJSTypeName(owner, true), rightType, leftType);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    boolean expectCanAssignTo(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType rightType, com.google.javascript.rhino.jstype.JSType leftType, java.lang.String msg) {\n        if (!rightType.canAssignTo(leftType)) {\n            if (bothIntrinsics(rightType, leftType)) {\n                registerMismatch(rightType, leftType);\n            } else {\n                mismatch(t, n, msg, rightType, leftType);\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private boolean bothIntrinsics(com.google.javascript.rhino.jstype.JSType rightType, com.google.javascript.rhino.jstype.JSType leftType) {\n        return (leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType());\n    }\n\n    void expectArgumentMatchesParameter(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType argType, com.google.javascript.rhino.jstype.JSType paramType, com.google.javascript.rhino.Node callNode, int ordinal) {\n        if (!argType.canAssignTo(paramType)) {\n            mismatch(t, n, java.lang.String.format(\"actual parameter %d of %s does not match \" + \"formal parameter\", ordinal, getReadableJSTypeName(callNode.getFirstChild(), false)), argType, paramType);\n        }\n    }\n\n    void expectCanOverride(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType overridingType, com.google.javascript.rhino.jstype.JSType hiddenType, java.lang.String propertyName, com.google.javascript.rhino.jstype.JSType ownerType) {\n        if (!overridingType.canAssignTo(hiddenType)) {\n            registerMismatch(overridingType, hiddenType);\n            if (shouldReport) {\n                compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeValidator.HIDDEN_PROPERTY_MISMATCH, propertyName, ownerType.toString(), hiddenType.toString(), overridingType.toString()));\n            }\n        }\n    }\n\n    void expectSuperType(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.ObjectType superObject, com.google.javascript.rhino.jstype.ObjectType subObject) {\n        com.google.javascript.rhino.jstype.FunctionType subCtor = subObject.getConstructor();\n        com.google.javascript.rhino.jstype.ObjectType declaredSuper = subObject.getImplicitPrototype().getImplicitPrototype();\n        if (!declaredSuper.equals(superObject)) {\n            if (declaredSuper.equals(getNativeType(com.google.javascript.jscomp.OBJECT_TYPE))) {\n                if (shouldReport) {\n                    compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeValidator.MISSING_EXTENDS_TAG_WARNING, subObject.toString()));\n                }\n                registerMismatch(superObject, declaredSuper);\n            } else {\n                mismatch(t.getSourceName(), n, \"mismatch in declaration of superclass type\", superObject, declaredSuper);\n            }\n            if (!subCtor.hasCachedValues()) {\n                subCtor.setPrototypeBasedOn(superObject);\n            }\n        }\n    }\n\n    void expectCanCast(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type, com.google.javascript.rhino.jstype.JSType castType) {\n        castType = castType.restrictByNotNullOrUndefined();\n        type = type.restrictByNotNullOrUndefined();\n        if ((!type.canAssignTo(castType)) && (!castType.canAssignTo(type))) {\n            if (shouldReport) {\n                compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeValidator.INVALID_CAST, castType.toString(), type.toString()));\n            }\n            registerMismatch(type, castType);\n        }\n    }\n\n    void expectUndeclaredVariable(java.lang.String sourceName, com.google.javascript.rhino.Node n, com.google.javascript.rhino.Node parent, com.google.javascript.jscomp.Scope.Var var, java.lang.String variableName, com.google.javascript.rhino.jstype.JSType newType) {\n        boolean allowDupe = false;\n        if (n.getType() == com.google.javascript.rhino.Token.GETPROP) {\n            com.google.javascript.rhino.JSDocInfo info = n.getJSDocInfo();\n            if (info == null) {\n                info = parent.getJSDocInfo();\n            }\n            allowDupe = (info != null) && info.getSuppressions().contains(\"duplicate\");\n        }\n        com.google.javascript.rhino.jstype.JSType varType = var.getType();\n        if ((((varType != null) && (varType != typeRegistry.getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE))) && (newType != null)) && (newType != typeRegistry.getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE))) {\n            if (var.input == null) {\n                n.setJSType(varType);\n                if (parent.getType() == com.google.javascript.rhino.Token.VAR) {\n                    if (n.getFirstChild() != null) {\n                        n.getFirstChild().setJSType(varType);\n                    }\n                } else {\n                    com.google.common.base.Preconditions.checkState(parent.getType() == com.google.javascript.rhino.Token.FUNCTION);\n                    parent.setJSType(varType);\n                }\n            } else if ((!(allowDupe || (var.getParentNode().getType() == com.google.javascript.rhino.Token.EXPR_RESULT))) || (!newType.equals(varType))) {\n                if (shouldReport) {\n                    compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.DUP_VAR_DECLARATION, variableName, newType.toString(), var.getInputName(), java.lang.String.valueOf(var.nameNode.getLineno()), varType.toString()));\n                }\n            }\n        }\n    }\n\n    void expectAllInterfaceProperties(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.FunctionType type) {\n        com.google.javascript.rhino.jstype.ObjectType instance = type.getInstanceType();\n        for (com.google.javascript.rhino.jstype.ObjectType implemented : type.getAllImplementedInterfaces()) {\n            if (implemented.getImplicitPrototype() != null) {\n                for (java.lang.String prop : implemented.getImplicitPrototype().getOwnPropertyNames()) {\n                    expectInterfaceProperty(t, n, instance, implemented, prop);\n                }\n            }\n        }\n    }\n\n    private void expectInterfaceProperty(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.ObjectType instance, com.google.javascript.rhino.jstype.ObjectType implementedInterface, java.lang.String prop) {\n        if (!instance.hasProperty(prop)) {\n            java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n            sourceName = (sourceName == null) ? \"\" : sourceName;\n            if (shouldReport) {\n                compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n            }\n            registerMismatch(instance, implementedInterface);\n        } else {\n            com.google.javascript.rhino.jstype.JSType found = instance.getPropertyType(prop);\n            com.google.javascript.rhino.jstype.JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n            found = found.restrictByNotNullOrUndefined();\n            required = required.restrictByNotNullOrUndefined();\n            if (!found.canAssignTo(required)) {\n                if (shouldReport) {\n                    com.google.javascript.rhino.jstype.FunctionType constructor = implementedInterface.toObjectType().getConstructor();\n                    compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeValidator.HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()));\n                }\n                registerMismatch(found, required);\n            }\n        }\n    }\n\n    private void mismatch(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, java.lang.String msg, com.google.javascript.rhino.jstype.JSType found, com.google.javascript.rhino.jstype.JSType required) {\n        mismatch(t.getSourceName(), n, msg, found, required);\n    }\n\n    private void mismatch(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, java.lang.String msg, com.google.javascript.rhino.jstype.JSType found, com.google.javascript.rhino.jstype.JSTypeNative required) {\n        mismatch(t, n, msg, found, getNativeType(required));\n    }\n\n    private void mismatch(java.lang.String sourceName, com.google.javascript.rhino.Node n, java.lang.String msg, com.google.javascript.rhino.jstype.JSType found, com.google.javascript.rhino.jstype.JSType required) {\n        registerMismatch(found, required);\n        if (shouldReport) {\n            compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING, formatFoundRequired(msg, found, required)));\n        }\n    }\n\n    private void registerMismatch(com.google.javascript.rhino.jstype.JSType found, com.google.javascript.rhino.jstype.JSType required) {\n        found = found.restrictByNotNullOrUndefined();\n        required = required.restrictByNotNullOrUndefined();\n        if (found.canAssignTo(required) || required.canAssignTo(found)) {\n            return;\n        }\n        mismatches.add(new com.google.javascript.jscomp.TypeValidator.TypeMismatch(found, required));\n        if ((found instanceof com.google.javascript.rhino.jstype.FunctionType) && (required instanceof com.google.javascript.rhino.jstype.FunctionType)) {\n            com.google.javascript.rhino.jstype.FunctionType fnTypeA = ((com.google.javascript.rhino.jstype.FunctionType) (found));\n            com.google.javascript.rhino.jstype.FunctionType fnTypeB = ((com.google.javascript.rhino.jstype.FunctionType) (required));\n            java.util.Iterator<com.google.javascript.rhino.Node> paramItA = fnTypeA.getParameters().iterator();\n            java.util.Iterator<com.google.javascript.rhino.Node> paramItB = fnTypeB.getParameters().iterator();\n            while (paramItA.hasNext() && paramItB.hasNext()) {\n                registerIfMismatch(paramItA.next().getJSType(), paramItB.next().getJSType());\n            } \n            registerIfMismatch(fnTypeA.getReturnType(), fnTypeB.getReturnType());\n        }\n    }\n\n    private void registerIfMismatch(com.google.javascript.rhino.jstype.JSType found, com.google.javascript.rhino.jstype.JSType required) {\n        if (((found != null) && (required != null)) && (!found.canAssignTo(required))) {\n            registerMismatch(found, required);\n        }\n    }\n\n    private java.lang.String formatFoundRequired(java.lang.String description, com.google.javascript.rhino.jstype.JSType found, com.google.javascript.rhino.jstype.JSType required) {\n        return java.text.MessageFormat.format(com.google.javascript.jscomp.TypeValidator.FOUND_REQUIRED, description, found, required);\n    }\n\n    java.lang.String getReadableJSTypeName(com.google.javascript.rhino.Node n, boolean dereference) {\n        if (n.getType() == com.google.javascript.rhino.Token.GETPROP) {\n            com.google.javascript.rhino.jstype.ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n            if (objectType != null) {\n                java.lang.String propName = n.getLastChild().getString();\n                while ((objectType != null) && (!objectType.hasOwnProperty(propName))) {\n                    objectType = objectType.getImplicitPrototype();\n                } \n                if ((objectType != null) && ((objectType.getConstructor() != null) || objectType.isFunctionPrototypeType())) {\n                    return (objectType.toString() + \".\") + propName;\n                }\n            }\n        }\n        com.google.javascript.rhino.jstype.JSType type = getJSType(n);\n        if (dereference) {\n            com.google.javascript.rhino.jstype.ObjectType dereferenced = type.dereference();\n            if (dereferenced != null) {\n                type = dereferenced;\n            }\n        }\n        java.lang.String qualifiedName = n.getQualifiedName();\n        if (type.isFunctionPrototypeType() || ((type.toObjectType() != null) && (type.toObjectType().getConstructor() != null))) {\n            return type.toString();\n        } else if (qualifiedName != null) {\n            return qualifiedName;\n        } else if (type instanceof com.google.javascript.rhino.jstype.FunctionType) {\n            return \"function\";\n        } else {\n            return type.toString();\n        }\n    }\n\n    private com.google.javascript.rhino.jstype.JSType getJSType(com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.jstype.JSType jsType = n.getJSType();\n        if (jsType == null) {\n            return getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE);\n        } else {\n            return jsType;\n        }\n    }\n\n    private com.google.javascript.rhino.jstype.JSType getNativeType(com.google.javascript.rhino.jstype.JSTypeNative typeId) {\n        return typeRegistry.getNativeType(typeId);\n    }\n\n    static class TypeMismatch {\n        final com.google.javascript.rhino.jstype.JSType typeA;\n\n        final com.google.javascript.rhino.jstype.JSType typeB;\n\n        TypeMismatch(com.google.javascript.rhino.jstype.JSType a, com.google.javascript.rhino.jstype.JSType b) {\n            this.typeA = a;\n            this.typeB = b;\n        }\n\n        @java.lang.Override\n        public boolean equals(java.lang.Object object) {\n            if (object instanceof com.google.javascript.jscomp.TypeValidator.TypeMismatch) {\n                com.google.javascript.jscomp.TypeValidator.TypeMismatch that = ((com.google.javascript.jscomp.TypeValidator.TypeMismatch) (object));\n                return (that.typeA.equals(this.typeA) && that.typeB.equals(this.typeB)) || (that.typeB.equals(this.typeA) && that.typeA.equals(this.typeB));\n            }\n            return false;\n        }\n\n        @java.lang.Override\n        public int hashCode() {\n            return com.google.common.base.Objects.hashCode(typeA, typeB);\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            return (((\"(\" + typeA) + \", \") + typeB) + \")\";\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Field",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "VirtualElement",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "VE: Modifiers_Field",
            "src_parent": "static final com.google.javascript.jscomp.DiagnosticGroup ALL_DIAGNOSTICS = new com.google.javascript.jscomp.DiagnosticGroup(com.google.javascript.jscomp.TypeValidator.INVALID_CAST, com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING, com.google.javascript.jscomp.TypeValidator.MISSING_EXTENDS_TAG_WARNING, com.google.javascript.jscomp.TypeValidator.DUP_VAR_DECLARATION, com.google.javascript.jscomp.TypeValidator.HIDDEN_PROPERTY_MISMATCH, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, com.google.javascript.jscomp.TypeValidator.HIDDEN_INTERFACE_PROPERTY_MISMATCH);",
            "src_parent_type": "Field",
            "src_type": "VirtualEle"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ConstructorCall",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "FieldRead",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "com.google.javascript.jscomp.TypeValidator.HIDDEN_INTERFACE_PROPERTY_MISMATCH",
            "src_parent": "new com.google.javascript.jscomp.DiagnosticGroup(com.google.javascript.jscomp.TypeValidator.INVALID_CAST, com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING, com.google.javascript.jscomp.TypeValidator.MISSING_EXTENDS_TAG_WARNING, com.google.javascript.jscomp.TypeValidator.DUP_VAR_DECLARATION, com.google.javascript.jscomp.TypeValidator.HIDDEN_PROPERTY_MISMATCH, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, com.google.javascript.jscomp.TypeValidator.HIDDEN_INTERFACE_PROPERTY_MISMATCH)",
            "src_parent_type": "ConstructorCall",
            "src_type": "FieldRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "if (!instance.hasProperty(prop)) {\n    java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n    sourceName = (sourceName == null) ? \"\" : sourceName;\n    if (shouldReport) {\n        compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n    }\n    registerMismatch(instance, implementedInterface);\n} else {\n    com.google.javascript.rhino.jstype.JSType found = instance.getPropertyType(prop);\n    com.google.javascript.rhino.jstype.JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n    found = found.restrictByNotNullOrUndefined();\n    required = required.restrictByNotNullOrUndefined();\n    if (!found.canAssignTo(required)) {\n        if (shouldReport) {\n            com.google.javascript.rhino.jstype.FunctionType constructor = implementedInterface.toObjectType().getConstructor();\n            compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeValidator.HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()));\n        }\n        registerMismatch(found, required);\n    }\n}",
            "src_parent": "{\n    if (!instance.hasProperty(prop)) {\n        java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n        sourceName = (sourceName == null) ? \"\" : sourceName;\n        if (shouldReport) {\n            compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n        }\n        registerMismatch(instance, implementedInterface);\n    } else {\n        com.google.javascript.rhino.jstype.JSType found = instance.getPropertyType(prop);\n        com.google.javascript.rhino.jstype.JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n        found = found.restrictByNotNullOrUndefined();\n        required = required.restrictByNotNullOrUndefined();\n        if (!found.canAssignTo(required)) {\n            if (shouldReport) {\n                com.google.javascript.rhino.jstype.FunctionType constructor = implementedInterface.toObjectType().getConstructor();\n                compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeValidator.HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()));\n            }\n            registerMismatch(found, required);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (!instance.hasProperty(prop)) {\n    java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n    sourceName = (sourceName == null) ? \"\" : sourceName;\n    if (shouldReport) {\n        compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n    }\n    registerMismatch(instance, implementedInterface);\n}",
            "src_parent": "{\n    if (!instance.hasProperty(prop)) {\n        java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n        sourceName = (sourceName == null) ? \"\" : sourceName;\n        if (shouldReport) {\n            compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n        }\n        registerMismatch(instance, implementedInterface);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Field",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "VirtualElement",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "VE: Modifiers_Field",
            "dst_parent": "static final com.google.javascript.jscomp.DiagnosticGroup ALL_DIAGNOSTICS = new com.google.javascript.jscomp.DiagnosticGroup(com.google.javascript.jscomp.TypeValidator.INVALID_CAST, com.google.javascript.jscomp.TypeValidator.TYPE_MISMATCH_WARNING, com.google.javascript.jscomp.TypeValidator.MISSING_EXTENDS_TAG_WARNING, com.google.javascript.jscomp.TypeValidator.DUP_VAR_DECLARATION, com.google.javascript.jscomp.TypeValidator.HIDDEN_PROPERTY_MISMATCH, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED);",
            "dst_parent_type": "Field",
            "dst_type": "VirtualEle",
            "operator": "MOV",
            "src": "VE: Modifiers_Field",
            "src_parent": "static final com.google.javascript.jscomp.DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + ((\"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\") + \"override: {3}\"));",
            "src_parent_type": "Field",
            "src_type": "VirtualEle"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "!instance.hasProperty(prop)",
            "dst_parent": "if (!instance.hasProperty(prop)) {\n    java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n    sourceName = (sourceName == null) ? \"\" : sourceName;\n    if (shouldReport) {\n        compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n    }\n    registerMismatch(instance, implementedInterface);\n}",
            "dst_parent_type": "If",
            "dst_type": "UnaryOperator",
            "operator": "MOV",
            "src": "!instance.hasProperty(prop)",
            "src_parent": "if (!instance.hasProperty(prop)) {\n    java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n    sourceName = (sourceName == null) ? \"\" : sourceName;\n    if (shouldReport) {\n        compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n    }\n    registerMismatch(instance, implementedInterface);\n} else {\n    com.google.javascript.rhino.jstype.JSType found = instance.getPropertyType(prop);\n    com.google.javascript.rhino.jstype.JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n    found = found.restrictByNotNullOrUndefined();\n    required = required.restrictByNotNullOrUndefined();\n    if (!found.canAssignTo(required)) {\n        if (shouldReport) {\n            com.google.javascript.rhino.jstype.FunctionType constructor = implementedInterface.toObjectType().getConstructor();\n            compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeValidator.HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()));\n        }\n        registerMismatch(found, required);\n    }\n}",
            "src_parent_type": "If",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n    sourceName = (sourceName == null) ? \"\" : sourceName;\n    if (shouldReport) {\n        compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n    }\n    registerMismatch(instance, implementedInterface);\n}",
            "dst_parent": "if (!instance.hasProperty(prop)) {\n    java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n    sourceName = (sourceName == null) ? \"\" : sourceName;\n    if (shouldReport) {\n        compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n    }\n    registerMismatch(instance, implementedInterface);\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n    sourceName = (sourceName == null) ? \"\" : sourceName;\n    if (shouldReport) {\n        compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n    }\n    registerMismatch(instance, implementedInterface);\n}",
            "src_parent": "if (!instance.hasProperty(prop)) {\n    java.lang.String sourceName = ((java.lang.String) (n.getProp(Node.SOURCENAME_PROP)));\n    sourceName = (sourceName == null) ? \"\" : sourceName;\n    if (shouldReport) {\n        compiler.report(com.google.javascript.jscomp.JSError.make(sourceName, n, com.google.javascript.jscomp.TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED, prop, implementedInterface.toString(), instance.toString()));\n    }\n    registerMismatch(instance, implementedInterface);\n} else {\n    com.google.javascript.rhino.jstype.JSType found = instance.getPropertyType(prop);\n    com.google.javascript.rhino.jstype.JSType required = implementedInterface.getImplicitPrototype().getPropertyType(prop);\n    found = found.restrictByNotNullOrUndefined();\n    required = required.restrictByNotNullOrUndefined();\n    if (!found.canAssignTo(required)) {\n        if (shouldReport) {\n            com.google.javascript.rhino.jstype.FunctionType constructor = implementedInterface.toObjectType().getConstructor();\n            compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeValidator.HIDDEN_INTERFACE_PROPERTY_MISMATCH, prop, constructor.getTopMostDefiningType(prop).toString(), required.toString(), found.toString()));\n        }\n        registerMismatch(found, required);\n    }\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        }
      ],
      "file_name": "TypeValidator"
    },
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "static final com.google.javascript.jscomp.DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + ((\"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\") + \"override: {3}\"));",
            "src_parent": "public class TypeCheck implements com.google.javascript.jscomp.CompilerPass , com.google.javascript.jscomp.NodeTraversal.Callback {\n    static final com.google.javascript.jscomp.DiagnosticType UNEXPECTED_TOKEN = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_INTERNAL_ERROR_UNEXPECTED_TOKEN\", \"Internal Error: Don't know how to handle {0}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType BAD_DELETE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_BAD_DELETE_OPERAND\", \"delete operator needs a reference operand\");\n\n    protected static final java.lang.String OVERRIDING_PROTOTYPE_WITH_NON_OBJECT = \"overriding prototype with non-object\";\n\n    static final com.google.javascript.jscomp.DiagnosticType DETERMINISTIC_TEST = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_DETERMINISTIC_TEST\", \"condition always evaluates to {2}\\n\" + (\"left : {0}\\n\" + \"right: {1}\"));\n\n    static final com.google.javascript.jscomp.DiagnosticType DETERMINISTIC_TEST_NO_RESULT = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_DETERMINISTIC_TEST_NO_RESULT\", \"condition always evaluates to the same value\\n\" + (\"left : {0}\\n\" + \"right: {1}\"));\n\n    static final com.google.javascript.jscomp.DiagnosticType INEXISTENT_ENUM_ELEMENT = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_INEXISTENT_ENUM_ELEMENT\", \"element {0} does not exist on this enum\");\n\n    static final com.google.javascript.jscomp.DiagnosticType INEXISTENT_PROPERTY = com.google.javascript.jscomp.DiagnosticType.disabled(\"JSC_INEXISTENT_PROPERTY\", \"Property {0} never defined on {1}\");\n\n    protected static final com.google.javascript.jscomp.DiagnosticType NOT_A_CONSTRUCTOR = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_NOT_A_CONSTRUCTOR\", \"cannot instantiate non-constructor\");\n\n    static final com.google.javascript.jscomp.DiagnosticType BIT_OPERATION = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_BAD_TYPE_FOR_BIT_OPERATION\", \"operator {0} cannot be applied to {1}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType NOT_CALLABLE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_NOT_FUNCTION_TYPE\", \"{0} expressions are not callable\");\n\n    static final com.google.javascript.jscomp.DiagnosticType CONSTRUCTOR_NOT_CALLABLE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_CONSTRUCTOR_NOT_CALLABLE\", \"Constructor {0} should be called with the \\\"new\\\" keyword\");\n\n    static final com.google.javascript.jscomp.DiagnosticType FUNCTION_MASKS_VARIABLE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_FUNCTION_MASKS_VARIABLE\", \"function {0} masks variable (IE bug)\");\n\n    static final com.google.javascript.jscomp.DiagnosticType MULTIPLE_VAR_DEF = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_MULTIPLE_VAR_DEF\", \"declaration of multiple variables with shared type information\");\n\n    static final com.google.javascript.jscomp.DiagnosticType ENUM_DUP = com.google.javascript.jscomp.DiagnosticType.error(\"JSC_ENUM_DUP\", \"enum element {0} already defined\");\n\n    static final com.google.javascript.jscomp.DiagnosticType ENUM_NOT_CONSTANT = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_ENUM_NOT_CONSTANT\", \"enum key {0} must be a syntactic constant\");\n\n    static final com.google.javascript.jscomp.DiagnosticType INVALID_INTERFACE_MEMBER_DECLARATION = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_INVALID_INTERFACE_MEMBER_DECLARATION\", \"interface members can only be empty property declarations,\" + \" empty functions{0}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType INTERFACE_FUNCTION_NOT_EMPTY = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_INTERFACE_FUNCTION_NOT_EMPTY\", \"interface member functions must have an empty body\");\n\n    static final com.google.javascript.jscomp.DiagnosticType CONFLICTING_EXTENDED_TYPE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_CONFLICTING_EXTENDED_TYPE\", \"{0} cannot extend this type; \" + (\"a constructor can only extend objects \" + \"and an interface can only extend interfaces\"));\n\n    static final com.google.javascript.jscomp.DiagnosticType BAD_IMPLEMENTED_TYPE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_IMPLEMENTS_NON_INTERFACE\", \"can only implement interfaces\");\n\n    static final com.google.javascript.jscomp.DiagnosticType HIDDEN_SUPERCLASS_PROPERTY = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY\", \"property {0} already defined on superclass {1}; \" + \"use @override to override it\");\n\n    static final com.google.javascript.jscomp.DiagnosticType HIDDEN_INTERFACE_PROPERTY = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_HIDDEN_INTERFACE_PROPERTY\", \"property {0} already defined on interface {1}; \" + \"use @override to override it\");\n\n    static final com.google.javascript.jscomp.DiagnosticType HIDDEN_SUPERCLASS_PROPERTY_MISMATCH = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_HIDDEN_SUPERCLASS_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + ((\"of the property it overrides from superclass {1}\\n\" + \"original: {2}\\n\") + \"override: {3}\"));\n\n    static final com.google.javascript.jscomp.DiagnosticType HIDDEN_INTERFACE_PROPERTY_MISMATCH = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH\", \"mismatch of the {0} property type and the type \" + ((\"of the property it overrides from interface {1}\\n\" + \"original: {2}\\n\") + \"override: {3}\"));\n\n    static final com.google.javascript.jscomp.DiagnosticType UNKNOWN_OVERRIDE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_UNKNOWN_OVERRIDE\", \"property {0} not defined on any superclass of {1}\");\n\n    static final com.google.javascript.jscomp.DiagnosticType INTERFACE_METHOD_OVERRIDE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_INTERFACE_METHOD_OVERRIDE\", \"property {0} is already defined by the {1} extended interface\");\n\n    static final com.google.javascript.jscomp.DiagnosticType UNKNOWN_EXPR_TYPE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_UNKNOWN_EXPR_TYPE\", \"could not determine the type of this expression\");\n\n    static final com.google.javascript.jscomp.DiagnosticType UNRESOLVED_TYPE = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_UNRESOLVED_TYPE\", \"could not resolve the name {0} to a type\");\n\n    static final com.google.javascript.jscomp.DiagnosticType WRONG_ARGUMENT_COUNT = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_WRONG_ARGUMENT_COUNT\", \"Function {0}: called with {1} argument(s). \" + \"Function requires at least {2} argument(s){3}.\");\n\n    static final com.google.javascript.jscomp.DiagnosticType ILLEGAL_IMPLICIT_CAST = com.google.javascript.jscomp.DiagnosticType.warning(\"JSC_ILLEGAL_IMPLICIT_CAST\", \"Illegal annotation on {0}. @implicitCast may only be used in \" + \"externs.\");\n\n    static final com.google.javascript.jscomp.DiagnosticGroup ALL_DIAGNOSTICS = new com.google.javascript.jscomp.DiagnosticGroup(com.google.javascript.jscomp.TypeCheck.DETERMINISTIC_TEST, com.google.javascript.jscomp.TypeCheck.DETERMINISTIC_TEST_NO_RESULT, com.google.javascript.jscomp.TypeCheck.INEXISTENT_ENUM_ELEMENT, com.google.javascript.jscomp.TypeCheck.INEXISTENT_PROPERTY, com.google.javascript.jscomp.TypeCheck.NOT_A_CONSTRUCTOR, com.google.javascript.jscomp.TypeCheck.BIT_OPERATION, com.google.javascript.jscomp.TypeCheck.NOT_CALLABLE, com.google.javascript.jscomp.TypeCheck.CONSTRUCTOR_NOT_CALLABLE, com.google.javascript.jscomp.TypeCheck.FUNCTION_MASKS_VARIABLE, com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF, com.google.javascript.jscomp.TypeCheck.ENUM_DUP, com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT, com.google.javascript.jscomp.TypeCheck.INVALID_INTERFACE_MEMBER_DECLARATION, com.google.javascript.jscomp.TypeCheck.INTERFACE_FUNCTION_NOT_EMPTY, com.google.javascript.jscomp.TypeCheck.CONFLICTING_EXTENDED_TYPE, com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE, com.google.javascript.jscomp.TypeCheck.HIDDEN_SUPERCLASS_PROPERTY, com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY, com.google.javascript.jscomp.TypeCheck.HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY_MISMATCH, com.google.javascript.jscomp.TypeCheck.UNKNOWN_OVERRIDE, com.google.javascript.jscomp.TypeCheck.INTERFACE_METHOD_OVERRIDE, com.google.javascript.jscomp.TypeCheck.UNKNOWN_EXPR_TYPE, com.google.javascript.jscomp.TypeCheck.UNRESOLVED_TYPE, com.google.javascript.jscomp.TypeCheck.WRONG_ARGUMENT_COUNT, com.google.javascript.jscomp.TypeCheck.ILLEGAL_IMPLICIT_CAST, TypedScopeCreator.UNKNOWN_LENDS, TypedScopeCreator.LENDS_ON_NON_OBJECT, TypedScopeCreator.CTOR_INITIALIZER, TypedScopeCreator.IFACE_INITIALIZER, FunctionTypeBuilder.THIS_TYPE_NON_OBJECT);\n\n    private final com.google.javascript.jscomp.AbstractCompiler compiler;\n\n    private final com.google.javascript.jscomp.TypeValidator validator;\n\n    private final com.google.javascript.jscomp.ReverseAbstractInterpreter reverseInterpreter;\n\n    private final com.google.javascript.rhino.jstype.JSTypeRegistry typeRegistry;\n\n    private com.google.javascript.jscomp.Scope topScope;\n\n    private com.google.javascript.jscomp.ScopeCreator scopeCreator;\n\n    private final com.google.javascript.jscomp.CheckLevel reportMissingOverride;\n\n    private final com.google.javascript.jscomp.CheckLevel reportUnknownTypes;\n\n    private boolean reportMissingProperties = true;\n\n    private com.google.javascript.jscomp.InferJSDocInfo inferJSDocInfo = null;\n\n    private int typedCount = 0;\n\n    private int nullCount = 0;\n\n    private int unknownCount = 0;\n\n    private boolean inExterns;\n\n    private int noTypeCheckSection = 0;\n\n    public TypeCheck(com.google.javascript.jscomp.AbstractCompiler compiler, com.google.javascript.jscomp.ReverseAbstractInterpreter reverseInterpreter, com.google.javascript.rhino.jstype.JSTypeRegistry typeRegistry, com.google.javascript.jscomp.Scope topScope, com.google.javascript.jscomp.ScopeCreator scopeCreator, com.google.javascript.jscomp.CheckLevel reportMissingOverride, com.google.javascript.jscomp.CheckLevel reportUnknownTypes) {\n        this.compiler = compiler;\n        this.validator = compiler.getTypeValidator();\n        this.reverseInterpreter = reverseInterpreter;\n        this.typeRegistry = typeRegistry;\n        this.topScope = topScope;\n        this.scopeCreator = scopeCreator;\n        this.reportMissingOverride = reportMissingOverride;\n        this.reportUnknownTypes = reportUnknownTypes;\n        this.inferJSDocInfo = new com.google.javascript.jscomp.InferJSDocInfo(compiler);\n    }\n\n    public TypeCheck(com.google.javascript.jscomp.AbstractCompiler compiler, com.google.javascript.jscomp.ReverseAbstractInterpreter reverseInterpreter, com.google.javascript.rhino.jstype.JSTypeRegistry typeRegistry, com.google.javascript.jscomp.CheckLevel reportMissingOverride, com.google.javascript.jscomp.CheckLevel reportUnknownTypes) {\n        this(compiler, reverseInterpreter, typeRegistry, null, null, reportMissingOverride, reportUnknownTypes);\n    }\n\n    TypeCheck(com.google.javascript.jscomp.AbstractCompiler compiler, com.google.javascript.jscomp.ReverseAbstractInterpreter reverseInterpreter, com.google.javascript.rhino.jstype.JSTypeRegistry typeRegistry) {\n        this(compiler, reverseInterpreter, typeRegistry, null, null, CheckLevel.WARNING, CheckLevel.OFF);\n    }\n\n    com.google.javascript.jscomp.TypeCheck reportMissingProperties(boolean report) {\n        reportMissingProperties = report;\n        return this;\n    }\n\n    public void process(com.google.javascript.rhino.Node externsRoot, com.google.javascript.rhino.Node jsRoot) {\n        com.google.common.base.Preconditions.checkNotNull(scopeCreator);\n        com.google.common.base.Preconditions.checkNotNull(topScope);\n        com.google.javascript.rhino.Node externsAndJs = jsRoot.getParent();\n        com.google.common.base.Preconditions.checkState(externsAndJs != null);\n        com.google.common.base.Preconditions.checkState((externsRoot == null) || externsAndJs.hasChild(externsRoot));\n        if (externsRoot != null) {\n            check(externsRoot, true);\n        }\n        check(jsRoot, false);\n    }\n\n    public com.google.javascript.jscomp.Scope processForTesting(com.google.javascript.rhino.Node externsRoot, com.google.javascript.rhino.Node jsRoot) {\n        com.google.common.base.Preconditions.checkState(scopeCreator == null);\n        com.google.common.base.Preconditions.checkState(topScope == null);\n        com.google.common.base.Preconditions.checkState(jsRoot.getParent() != null);\n        com.google.javascript.rhino.Node externsAndJsRoot = jsRoot.getParent();\n        scopeCreator = new com.google.javascript.jscomp.MemoizedScopeCreator(new com.google.javascript.jscomp.TypedScopeCreator(compiler));\n        topScope = scopeCreator.createScope(externsAndJsRoot, null);\n        com.google.javascript.jscomp.TypeInferencePass inference = new com.google.javascript.jscomp.TypeInferencePass(compiler, reverseInterpreter, topScope, scopeCreator);\n        inference.process(externsRoot, jsRoot);\n        process(externsRoot, jsRoot);\n        return topScope;\n    }\n\n    public void check(com.google.javascript.rhino.Node node, boolean externs) {\n        com.google.common.base.Preconditions.checkNotNull(node);\n        com.google.javascript.jscomp.NodeTraversal t = new com.google.javascript.jscomp.NodeTraversal(compiler, this, scopeCreator);\n        inExterns = externs;\n        t.traverseWithScope(node, topScope);\n        if (externs) {\n            inferJSDocInfo.process(node, null);\n        } else {\n            inferJSDocInfo.process(null, node);\n        }\n    }\n\n    private void checkNoTypeCheckSection(com.google.javascript.rhino.Node n, boolean enterSection) {\n        switch (n.getType()) {\n            case com.google.javascript.rhino.Token.SCRIPT :\n            case com.google.javascript.rhino.Token.BLOCK :\n            case com.google.javascript.rhino.Token.VAR :\n            case com.google.javascript.rhino.Token.FUNCTION :\n            case com.google.javascript.rhino.Token.ASSIGN :\n                com.google.javascript.rhino.JSDocInfo info = n.getJSDocInfo();\n                if ((info != null) && info.isNoTypeCheck()) {\n                    if (enterSection) {\n                        noTypeCheckSection++;\n                    } else {\n                        noTypeCheckSection--;\n                    }\n                }\n                validator.setShouldReport(noTypeCheckSection == 0);\n                break;\n        }\n    }\n\n    private void report(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.jscomp.DiagnosticType diagnosticType, java.lang.String... arguments) {\n        if (noTypeCheckSection == 0) {\n            t.report(n, diagnosticType, arguments);\n        }\n    }\n\n    public boolean shouldTraverse(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.Node parent) {\n        checkNoTypeCheckSection(n, true);\n        switch (n.getType()) {\n            case com.google.javascript.rhino.Token.FUNCTION :\n                final com.google.javascript.jscomp.TypeCheck outerThis = this;\n                final com.google.javascript.jscomp.Scope outerScope = t.getScope();\n                final com.google.javascript.rhino.jstype.FunctionType functionType = ((com.google.javascript.rhino.jstype.FunctionType) (n.getJSType()));\n                final java.lang.String functionPrivateName = n.getFirstChild().getString();\n                if ((((functionPrivateName != null) && (functionPrivateName.length() > 0)) && outerScope.isDeclared(functionPrivateName, false)) && (!(outerScope.getVar(functionPrivateName).getType() instanceof com.google.javascript.rhino.jstype.FunctionType))) {\n                    report(t, n, com.google.javascript.jscomp.TypeCheck.FUNCTION_MASKS_VARIABLE, functionPrivateName);\n                }\n                break;\n        }\n        return true;\n    }\n\n    public void visit(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.Node parent) {\n        com.google.javascript.rhino.jstype.JSType childType;\n        com.google.javascript.rhino.jstype.JSType leftType;\n        com.google.javascript.rhino.jstype.JSType rightType;\n        com.google.javascript.rhino.Node left;\n        com.google.javascript.rhino.Node right;\n        boolean typeable = true;\n        switch (n.getType()) {\n            case com.google.javascript.rhino.Token.NAME :\n                typeable = visitName(t, n, parent);\n                break;\n            case com.google.javascript.rhino.Token.LP :\n                if (parent.getType() != com.google.javascript.rhino.Token.FUNCTION) {\n                    ensureTyped(t, n, getJSType(n.getFirstChild()));\n                } else {\n                    typeable = false;\n                }\n                break;\n            case com.google.javascript.rhino.Token.COMMA :\n                ensureTyped(t, n, getJSType(n.getLastChild()));\n                break;\n            case com.google.javascript.rhino.Token.TRUE :\n            case com.google.javascript.rhino.Token.FALSE :\n                ensureTyped(t, n, com.google.javascript.jscomp.BOOLEAN_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.THIS :\n                ensureTyped(t, n, t.getScope().getTypeOfThis());\n                break;\n            case com.google.javascript.rhino.Token.REF_SPECIAL :\n                ensureTyped(t, n);\n                break;\n            case com.google.javascript.rhino.Token.GET_REF :\n                ensureTyped(t, n, getJSType(n.getFirstChild()));\n                break;\n            case com.google.javascript.rhino.Token.NULL :\n                ensureTyped(t, n, com.google.javascript.jscomp.NULL_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.NUMBER :\n                if (!com.google.javascript.jscomp.NodeUtil.isObjectLitKey(n, n.getParent())) {\n                    ensureTyped(t, n, com.google.javascript.jscomp.NUMBER_TYPE);\n                }\n                break;\n            case com.google.javascript.rhino.Token.STRING :\n                if (!com.google.javascript.jscomp.NodeUtil.isObjectLitKey(n, n.getParent())) {\n                    ensureTyped(t, n, com.google.javascript.jscomp.STRING_TYPE);\n                }\n                break;\n            case com.google.javascript.rhino.Token.GET :\n            case com.google.javascript.rhino.Token.SET :\n                break;\n            case com.google.javascript.rhino.Token.ARRAYLIT :\n                ensureTyped(t, n, com.google.javascript.jscomp.ARRAY_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.REGEXP :\n                ensureTyped(t, n, com.google.javascript.jscomp.REGEXP_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.GETPROP :\n                visitGetProp(t, n, parent);\n                typeable = !((parent.getType() == com.google.javascript.rhino.Token.ASSIGN) && (parent.getFirstChild() == n));\n                break;\n            case com.google.javascript.rhino.Token.GETELEM :\n                visitGetElem(t, n);\n                typeable = false;\n                break;\n            case com.google.javascript.rhino.Token.VAR :\n                visitVar(t, n);\n                typeable = false;\n                break;\n            case com.google.javascript.rhino.Token.NEW :\n                visitNew(t, n);\n                typeable = true;\n                break;\n            case com.google.javascript.rhino.Token.CALL :\n                visitCall(t, n);\n                typeable = !com.google.javascript.jscomp.NodeUtil.isExpressionNode(parent);\n                break;\n            case com.google.javascript.rhino.Token.RETURN :\n                visitReturn(t, n);\n                typeable = false;\n                break;\n            case com.google.javascript.rhino.Token.DEC :\n            case com.google.javascript.rhino.Token.INC :\n                left = n.getFirstChild();\n                validator.expectNumber(t, left, getJSType(left), \"increment/decrement\");\n                ensureTyped(t, n, com.google.javascript.jscomp.NUMBER_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.NOT :\n                ensureTyped(t, n, com.google.javascript.jscomp.BOOLEAN_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.VOID :\n                ensureTyped(t, n, com.google.javascript.jscomp.VOID_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.TYPEOF :\n                ensureTyped(t, n, com.google.javascript.jscomp.STRING_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.BITNOT :\n                childType = getJSType(n.getFirstChild());\n                if (!childType.matchesInt32Context()) {\n                    report(t, n, com.google.javascript.jscomp.TypeCheck.BIT_OPERATION, com.google.javascript.jscomp.NodeUtil.opToStr(n.getType()), childType.toString());\n                }\n                ensureTyped(t, n, com.google.javascript.jscomp.NUMBER_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.POS :\n            case com.google.javascript.rhino.Token.NEG :\n                left = n.getFirstChild();\n                validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n                ensureTyped(t, n, com.google.javascript.jscomp.NUMBER_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.EQ :\n            case com.google.javascript.rhino.Token.NE :\n                {\n                    leftType = getJSType(n.getFirstChild());\n                    rightType = getJSType(n.getLastChild());\n                    com.google.javascript.rhino.jstype.JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n                    com.google.javascript.rhino.jstype.JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n                    com.google.javascript.rhino.jstype.TernaryValue result = leftTypeRestricted.testForEquality(rightTypeRestricted);\n                    if (result != com.google.javascript.rhino.jstype.TernaryValue.UNKNOWN) {\n                        if (n.getType() == com.google.javascript.rhino.Token.NE) {\n                            result = result.not();\n                        }\n                        report(t, n, com.google.javascript.jscomp.TypeCheck.DETERMINISTIC_TEST, leftType.toString(), rightType.toString(), result.toString());\n                    }\n                    ensureTyped(t, n, com.google.javascript.jscomp.BOOLEAN_TYPE);\n                    break;\n                }\n            case com.google.javascript.rhino.Token.SHEQ :\n            case com.google.javascript.rhino.Token.SHNE :\n                {\n                    leftType = getJSType(n.getFirstChild());\n                    rightType = getJSType(n.getLastChild());\n                    com.google.javascript.rhino.jstype.JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n                    com.google.javascript.rhino.jstype.JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n                    if (!leftTypeRestricted.canTestForShallowEqualityWith(rightTypeRestricted)) {\n                        report(t, n, com.google.javascript.jscomp.TypeCheck.DETERMINISTIC_TEST_NO_RESULT, leftType.toString(), rightType.toString());\n                    }\n                    ensureTyped(t, n, com.google.javascript.jscomp.BOOLEAN_TYPE);\n                    break;\n                }\n            case com.google.javascript.rhino.Token.LT :\n            case com.google.javascript.rhino.Token.LE :\n            case com.google.javascript.rhino.Token.GT :\n            case com.google.javascript.rhino.Token.GE :\n                leftType = getJSType(n.getFirstChild());\n                rightType = getJSType(n.getLastChild());\n                if (rightType.isNumber()) {\n                    validator.expectNumber(t, n, leftType, \"left side of numeric comparison\");\n                } else if (leftType.isNumber()) {\n                    validator.expectNumber(t, n, rightType, \"right side of numeric comparison\");\n                } else if (leftType.matchesNumberContext() && rightType.matchesNumberContext()) {\n                } else {\n                    java.lang.String message = \"left side of comparison\";\n                    validator.expectString(t, n, leftType, message);\n                    validator.expectNotNullOrUndefined(t, n, leftType, message, getNativeType(com.google.javascript.jscomp.STRING_TYPE));\n                    message = \"right side of comparison\";\n                    validator.expectString(t, n, rightType, message);\n                    validator.expectNotNullOrUndefined(t, n, rightType, message, getNativeType(com.google.javascript.jscomp.STRING_TYPE));\n                }\n                ensureTyped(t, n, com.google.javascript.jscomp.BOOLEAN_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.IN :\n                left = n.getFirstChild();\n                right = n.getLastChild();\n                leftType = getJSType(left);\n                rightType = getJSType(right);\n                validator.expectObject(t, n, rightType, \"'in' requires an object\");\n                validator.expectString(t, left, leftType, \"left side of 'in'\");\n                ensureTyped(t, n, com.google.javascript.jscomp.BOOLEAN_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.INSTANCEOF :\n                left = n.getFirstChild();\n                right = n.getLastChild();\n                leftType = getJSType(left);\n                rightType = getJSType(right).restrictByNotNullOrUndefined();\n                validator.expectAnyObject(t, left, leftType, \"deterministic instanceof yields false\");\n                validator.expectActualObject(t, right, rightType, \"instanceof requires an object\");\n                ensureTyped(t, n, com.google.javascript.jscomp.BOOLEAN_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.ASSIGN :\n                visitAssign(t, n);\n                typeable = false;\n                break;\n            case com.google.javascript.rhino.Token.ASSIGN_LSH :\n            case com.google.javascript.rhino.Token.ASSIGN_RSH :\n            case com.google.javascript.rhino.Token.ASSIGN_URSH :\n            case com.google.javascript.rhino.Token.ASSIGN_DIV :\n            case com.google.javascript.rhino.Token.ASSIGN_MOD :\n            case com.google.javascript.rhino.Token.ASSIGN_BITOR :\n            case com.google.javascript.rhino.Token.ASSIGN_BITXOR :\n            case com.google.javascript.rhino.Token.ASSIGN_BITAND :\n            case com.google.javascript.rhino.Token.ASSIGN_SUB :\n            case com.google.javascript.rhino.Token.ASSIGN_ADD :\n            case com.google.javascript.rhino.Token.ASSIGN_MUL :\n            case com.google.javascript.rhino.Token.LSH :\n            case com.google.javascript.rhino.Token.RSH :\n            case com.google.javascript.rhino.Token.URSH :\n            case com.google.javascript.rhino.Token.DIV :\n            case com.google.javascript.rhino.Token.MOD :\n            case com.google.javascript.rhino.Token.BITOR :\n            case com.google.javascript.rhino.Token.BITXOR :\n            case com.google.javascript.rhino.Token.BITAND :\n            case com.google.javascript.rhino.Token.SUB :\n            case com.google.javascript.rhino.Token.ADD :\n            case com.google.javascript.rhino.Token.MUL :\n                visitBinaryOperator(n.getType(), t, n);\n                break;\n            case com.google.javascript.rhino.Token.DELPROP :\n                if (!com.google.javascript.jscomp.TypeCheck.isReference(n.getFirstChild())) {\n                    report(t, n, com.google.javascript.jscomp.TypeCheck.BAD_DELETE);\n                }\n                ensureTyped(t, n, com.google.javascript.jscomp.BOOLEAN_TYPE);\n                break;\n            case com.google.javascript.rhino.Token.CASE :\n                com.google.javascript.rhino.jstype.JSType switchType = getJSType(parent.getFirstChild());\n                com.google.javascript.rhino.jstype.JSType caseType = getJSType(n.getFirstChild());\n                validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n                typeable = false;\n                break;\n            case com.google.javascript.rhino.Token.WITH :\n                {\n                    com.google.javascript.rhino.Node child = n.getFirstChild();\n                    childType = getJSType(child);\n                    validator.expectObject(t, child, childType, \"with requires an object\");\n                    typeable = false;\n                    break;\n                }\n            case com.google.javascript.rhino.Token.FUNCTION :\n                visitFunction(t, n);\n                break;\n            case com.google.javascript.rhino.Token.LABEL :\n            case com.google.javascript.rhino.Token.LABEL_NAME :\n            case com.google.javascript.rhino.Token.SWITCH :\n            case com.google.javascript.rhino.Token.BREAK :\n            case com.google.javascript.rhino.Token.CATCH :\n            case com.google.javascript.rhino.Token.TRY :\n            case com.google.javascript.rhino.Token.SCRIPT :\n            case com.google.javascript.rhino.Token.EXPR_RESULT :\n            case com.google.javascript.rhino.Token.BLOCK :\n            case com.google.javascript.rhino.Token.EMPTY :\n            case com.google.javascript.rhino.Token.DEFAULT :\n            case com.google.javascript.rhino.Token.CONTINUE :\n            case com.google.javascript.rhino.Token.DEBUGGER :\n            case com.google.javascript.rhino.Token.THROW :\n                typeable = false;\n                break;\n            case com.google.javascript.rhino.Token.DO :\n            case com.google.javascript.rhino.Token.FOR :\n            case com.google.javascript.rhino.Token.IF :\n            case com.google.javascript.rhino.Token.WHILE :\n                typeable = false;\n                break;\n            case com.google.javascript.rhino.Token.AND :\n            case com.google.javascript.rhino.Token.HOOK :\n            case com.google.javascript.rhino.Token.OBJECTLIT :\n            case com.google.javascript.rhino.Token.OR :\n                if (n.getJSType() != null) {\n                    ensureTyped(t, n);\n                } else if ((n.getType() == com.google.javascript.rhino.Token.OBJECTLIT) && (parent.getJSType() instanceof com.google.javascript.rhino.jstype.EnumType)) {\n                    ensureTyped(t, n, parent.getJSType());\n                } else {\n                    ensureTyped(t, n);\n                }\n                if (n.getType() == com.google.javascript.rhino.Token.OBJECTLIT) {\n                    for (com.google.javascript.rhino.Node key : n.children()) {\n                        visitObjLitKey(t, key, n);\n                    }\n                }\n                break;\n            default :\n                report(t, n, com.google.javascript.jscomp.TypeCheck.UNEXPECTED_TOKEN, com.google.javascript.rhino.Token.name(n.getType()));\n                ensureTyped(t, n);\n                break;\n        }\n        typeable = typeable && (!inExterns);\n        if (typeable) {\n            doPercentTypedAccounting(t, n);\n        }\n        checkNoTypeCheckSection(n, false);\n    }\n\n    private void doPercentTypedAccounting(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.jstype.JSType type = n.getJSType();\n        if (type == null) {\n            nullCount++;\n        } else if (type.isUnknownType()) {\n            if (reportUnknownTypes.isOn()) {\n                compiler.report(t.makeError(n, reportUnknownTypes, com.google.javascript.jscomp.TypeCheck.UNKNOWN_EXPR_TYPE));\n            }\n            unknownCount++;\n        } else {\n            typedCount++;\n        }\n    }\n\n    private void visitAssign(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node assign) {\n        com.google.javascript.rhino.JSDocInfo info = assign.getJSDocInfo();\n        com.google.javascript.rhino.Node lvalue = assign.getFirstChild();\n        com.google.javascript.rhino.Node rvalue = assign.getLastChild();\n        if (lvalue.getType() == com.google.javascript.rhino.Token.GETPROP) {\n            com.google.javascript.rhino.Node object = lvalue.getFirstChild();\n            com.google.javascript.rhino.jstype.JSType objectJsType = getJSType(object);\n            java.lang.String property = lvalue.getLastChild().getString();\n            if (object.getType() == com.google.javascript.rhino.Token.GETPROP) {\n                com.google.javascript.rhino.jstype.JSType jsType = getJSType(object.getFirstChild());\n                if (jsType.isInterface() && object.getLastChild().getString().equals(\"prototype\")) {\n                    visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n                }\n            }\n            if ((info != null) && info.hasType()) {\n                visitAnnotatedAssignGetprop(t, assign, info.getType().evaluate(t.getScope(), typeRegistry), object, property, rvalue);\n                return;\n            }\n            if ((info != null) && info.hasEnumParameterType()) {\n                checkEnumInitializer(t, rvalue, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n                return;\n            }\n            if (property.equals(\"prototype\")) {\n                if (objectJsType instanceof com.google.javascript.rhino.jstype.FunctionType) {\n                    com.google.javascript.rhino.jstype.FunctionType functionType = ((com.google.javascript.rhino.jstype.FunctionType) (objectJsType));\n                    if (functionType.isConstructor()) {\n                        com.google.javascript.rhino.jstype.JSType rvalueType = rvalue.getJSType();\n                        validator.expectObject(t, rvalue, rvalueType, com.google.javascript.jscomp.TypeCheck.OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n                    }\n                } else {\n                }\n                return;\n            }\n            if (object.getType() == com.google.javascript.rhino.Token.GETPROP) {\n                com.google.javascript.rhino.Node object2 = object.getFirstChild();\n                java.lang.String property2 = com.google.javascript.jscomp.NodeUtil.getStringValue(object.getLastChild());\n                if (\"prototype\".equals(property2)) {\n                    com.google.javascript.rhino.jstype.JSType jsType = object2.getJSType();\n                    if (jsType instanceof com.google.javascript.rhino.jstype.FunctionType) {\n                        com.google.javascript.rhino.jstype.FunctionType functionType = ((com.google.javascript.rhino.jstype.FunctionType) (jsType));\n                        if (functionType.isConstructor() || functionType.isInterface()) {\n                            checkDeclaredPropertyInheritance(t, assign, functionType, property, info, getJSType(rvalue));\n                        }\n                    } else {\n                    }\n                    return;\n                }\n            }\n            com.google.javascript.rhino.jstype.ObjectType type = com.google.javascript.rhino.jstype.ObjectType.cast(objectJsType.restrictByNotNullOrUndefined());\n            if (type != null) {\n                if ((type.hasProperty(property) && (!type.isPropertyTypeInferred(property))) && (!propertyIsImplicitCast(type, property))) {\n                    validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type.getPropertyType(property), object, property);\n                }\n                return;\n            }\n        } else if (lvalue.getType() == com.google.javascript.rhino.Token.NAME) {\n            com.google.javascript.rhino.jstype.JSType rvalueType = getJSType(assign.getLastChild());\n            com.google.javascript.jscomp.Scope.Var var = t.getScope().getVar(lvalue.getString());\n            if (var != null) {\n                if (var.isTypeInferred()) {\n                    return;\n                }\n            }\n        }\n        com.google.javascript.rhino.jstype.JSType leftType = getJSType(lvalue);\n        com.google.javascript.rhino.Node rightChild = assign.getLastChild();\n        com.google.javascript.rhino.jstype.JSType rightType = getJSType(rightChild);\n        if (validator.expectCanAssignTo(t, assign, rightType, leftType, \"assignment\")) {\n            ensureTyped(t, assign, rightType);\n        } else {\n            ensureTyped(t, assign);\n        }\n    }\n\n    private void visitObjLitKey(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node key, com.google.javascript.rhino.Node objlit) {\n        com.google.javascript.rhino.Node rvalue = key.getFirstChild();\n        com.google.javascript.rhino.jstype.JSType rightType = com.google.javascript.jscomp.NodeUtil.getObjectLitKeyTypeFromValueType(key, getJSType(rvalue));\n        if (rightType == null) {\n            rightType = getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE);\n        }\n        com.google.javascript.rhino.Node owner = objlit;\n        com.google.javascript.rhino.jstype.JSType keyType = getJSType(key);\n        boolean valid = validator.expectCanAssignToPropertyOf(t, key, rightType, keyType, owner, com.google.javascript.jscomp.NodeUtil.getObjectLitKeyName(key));\n        if (valid) {\n            ensureTyped(t, key, rightType);\n        } else {\n            ensureTyped(t, key);\n        }\n        com.google.javascript.rhino.jstype.JSType objlitType = getJSType(objlit);\n        com.google.javascript.rhino.jstype.ObjectType type = com.google.javascript.rhino.jstype.ObjectType.cast(objlitType.restrictByNotNullOrUndefined());\n        if (type != null) {\n            java.lang.String property = com.google.javascript.jscomp.NodeUtil.getObjectLitKeyName(key);\n            if ((type.hasProperty(property) && (!type.isPropertyTypeInferred(property))) && (!propertyIsImplicitCast(type, property))) {\n                validator.expectCanAssignToPropertyOf(t, key, keyType, type.getPropertyType(property), owner, property);\n            }\n            return;\n        }\n    }\n\n    private boolean propertyIsImplicitCast(com.google.javascript.rhino.jstype.ObjectType type, java.lang.String prop) {\n        for (; type != null; type = type.getImplicitPrototype()) {\n            com.google.javascript.rhino.JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop);\n            if ((docInfo != null) && docInfo.isImplicitCast()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void checkDeclaredPropertyInheritance(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.FunctionType ctorType, java.lang.String propertyName, com.google.javascript.rhino.JSDocInfo info, com.google.javascript.rhino.jstype.JSType propertyType) {\n        if (com.google.javascript.jscomp.TypeCheck.hasUnknownOrEmptySupertype(ctorType)) {\n            return;\n        }\n        com.google.javascript.rhino.jstype.FunctionType superClass = ctorType.getSuperClassConstructor();\n        boolean superClassHasProperty = (superClass != null) && superClass.getPrototype().hasProperty(propertyName);\n        boolean declaredOverride = (info != null) && info.isOverride();\n        boolean foundInterfaceProperty = false;\n        if (ctorType.isConstructor()) {\n            for (com.google.javascript.rhino.jstype.JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n                if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                    continue;\n                }\n                com.google.javascript.rhino.jstype.FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n                com.google.common.base.Preconditions.checkNotNull(interfaceType);\n                boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n                foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n                if ((reportMissingOverride.isOn() && (!declaredOverride)) && interfaceHasProperty) {\n                    compiler.report(t.makeError(n, reportMissingOverride, com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n                }\n                if (interfaceHasProperty) {\n                    com.google.javascript.rhino.jstype.JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                    if (!propertyType.canAssignTo(interfacePropType)) {\n                        compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                    }\n                }\n            }\n        }\n        if ((!declaredOverride) && (!superClassHasProperty)) {\n            return;\n        }\n        com.google.javascript.rhino.jstype.JSType topInstanceType = (superClassHasProperty) ? superClass.getTopMostDefiningType(propertyName) : null;\n        if (((reportMissingOverride.isOn() && ctorType.isConstructor()) && (!declaredOverride)) && superClassHasProperty) {\n            compiler.report(t.makeError(n, reportMissingOverride, com.google.javascript.jscomp.TypeCheck.HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n        }\n        if (!declaredOverride) {\n            return;\n        }\n        if (superClassHasProperty) {\n            com.google.javascript.rhino.jstype.JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n            if (!propertyType.canAssignTo(superClassPropType)) {\n                compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeCheck.HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n            }\n        } else if (!foundInterfaceProperty) {\n            compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeCheck.UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n        }\n    }\n\n    private static boolean hasUnknownOrEmptySupertype(com.google.javascript.rhino.jstype.FunctionType ctor) {\n        com.google.common.base.Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n        com.google.common.base.Preconditions.checkArgument(!ctor.isUnknownType());\n        while (true) {\n            com.google.javascript.rhino.jstype.ObjectType maybeSuperInstanceType = ctor.getPrototype().getImplicitPrototype();\n            if (maybeSuperInstanceType == null) {\n                return false;\n            }\n            if (maybeSuperInstanceType.isUnknownType() || maybeSuperInstanceType.isEmptyType()) {\n                return true;\n            }\n            ctor = maybeSuperInstanceType.getConstructor();\n            if (ctor == null) {\n                return false;\n            }\n            com.google.common.base.Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n        } \n    }\n\n    private void visitInterfaceGetprop(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node assign, com.google.javascript.rhino.Node object, java.lang.String property, com.google.javascript.rhino.Node lvalue, com.google.javascript.rhino.Node rvalue) {\n        com.google.javascript.rhino.jstype.JSType rvalueType = getJSType(rvalue);\n        java.lang.String abstractMethodName = compiler.getCodingConvention().getAbstractMethodName();\n        if ((!rvalueType.isOrdinaryFunction()) && (!(rvalue.isQualifiedName() && rvalue.getQualifiedName().equals(abstractMethodName)))) {\n            java.lang.String abstractMethodMessage = (abstractMethodName != null) ? \", or \" + abstractMethodName : \"\";\n            compiler.report(t.makeError(object, com.google.javascript.jscomp.TypeCheck.INVALID_INTERFACE_MEMBER_DECLARATION, abstractMethodMessage));\n        }\n        if ((assign.getLastChild().getType() == com.google.javascript.rhino.Token.FUNCTION) && (!com.google.javascript.jscomp.NodeUtil.isEmptyBlock(assign.getLastChild().getLastChild()))) {\n            compiler.report(t.makeError(object, com.google.javascript.jscomp.TypeCheck.INTERFACE_FUNCTION_NOT_EMPTY, abstractMethodName));\n        }\n    }\n\n    private void visitAnnotatedAssignGetprop(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node assign, com.google.javascript.rhino.jstype.JSType type, com.google.javascript.rhino.Node object, java.lang.String property, com.google.javascript.rhino.Node rvalue) {\n        validator.expectCanAssignToPropertyOf(t, assign, getJSType(rvalue), type, object, property);\n    }\n\n    boolean visitName(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.Node parent) {\n        int parentNodeType = parent.getType();\n        if ((((parentNodeType == com.google.javascript.rhino.Token.FUNCTION) || (parentNodeType == com.google.javascript.rhino.Token.CATCH)) || (parentNodeType == com.google.javascript.rhino.Token.LP)) || (parentNodeType == com.google.javascript.rhino.Token.VAR)) {\n            return false;\n        }\n        com.google.javascript.rhino.jstype.JSType type = n.getJSType();\n        if (type == null) {\n            type = getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE);\n            com.google.javascript.jscomp.Scope.Var var = t.getScope().getVar(n.getString());\n            if (var != null) {\n                com.google.javascript.rhino.jstype.JSType varType = var.getType();\n                if (varType != null) {\n                    type = varType;\n                }\n            }\n        }\n        ensureTyped(t, n, type);\n        return true;\n    }\n\n    private void visitGetProp(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.Node parent) {\n        if ((n.getJSType() != null) && (parent.getType() == com.google.javascript.rhino.Token.ASSIGN)) {\n            return;\n        }\n        com.google.javascript.rhino.Node property = n.getLastChild();\n        com.google.javascript.rhino.Node objNode = n.getFirstChild();\n        com.google.javascript.rhino.jstype.JSType childType = getJSType(objNode);\n        if (!validator.expectNotNullOrUndefined(t, n, childType, childType + \" has no properties\", getNativeType(com.google.javascript.jscomp.OBJECT_TYPE))) {\n            ensureTyped(t, n);\n            return;\n        }\n        checkPropertyAccess(childType, property.getString(), t, n);\n        ensureTyped(t, n);\n    }\n\n    private void checkPropertyAccess(com.google.javascript.rhino.jstype.JSType childType, java.lang.String propName, com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.jstype.ObjectType objectType = childType.dereference();\n        if (objectType != null) {\n            com.google.javascript.rhino.jstype.JSType propType = getJSType(n);\n            if (((!objectType.hasProperty(propName)) || objectType.equals(typeRegistry.getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE))) && propType.equals(typeRegistry.getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE))) {\n                if (objectType instanceof com.google.javascript.rhino.jstype.EnumType) {\n                    report(t, n, com.google.javascript.jscomp.TypeCheck.INEXISTENT_ENUM_ELEMENT, propName);\n                } else if (((!objectType.isEmptyType()) && reportMissingProperties) && (!isPropertyTest(n))) {\n                    if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {\n                        report(t, n, com.google.javascript.jscomp.TypeCheck.INEXISTENT_PROPERTY, propName, validator.getReadableJSTypeName(n.getFirstChild(), true));\n                    }\n                }\n            }\n        } else {\n        }\n    }\n\n    private boolean isPropertyTest(com.google.javascript.rhino.Node getProp) {\n        com.google.javascript.rhino.Node parent = getProp.getParent();\n        switch (parent.getType()) {\n            case com.google.javascript.rhino.Token.CALL :\n                return (parent.getFirstChild() != getProp) && compiler.getCodingConvention().isPropertyTestFunction(parent);\n            case com.google.javascript.rhino.Token.IF :\n            case com.google.javascript.rhino.Token.WHILE :\n            case com.google.javascript.rhino.Token.DO :\n            case com.google.javascript.rhino.Token.FOR :\n                return com.google.javascript.jscomp.NodeUtil.getConditionExpression(parent) == getProp;\n            case com.google.javascript.rhino.Token.INSTANCEOF :\n            case com.google.javascript.rhino.Token.TYPEOF :\n                return true;\n            case com.google.javascript.rhino.Token.AND :\n            case com.google.javascript.rhino.Token.HOOK :\n                return parent.getFirstChild() == getProp;\n            case com.google.javascript.rhino.Token.NOT :\n                return (parent.getParent().getType() == com.google.javascript.rhino.Token.OR) && (parent.getParent().getFirstChild() == parent);\n        }\n        return false;\n    }\n\n    private void visitGetElem(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.Node left = n.getFirstChild();\n        com.google.javascript.rhino.Node right = n.getLastChild();\n        validator.expectIndexMatch(t, n, getJSType(left), getJSType(right));\n        ensureTyped(t, n);\n    }\n\n    private void visitVar(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.JSDocInfo varInfo = (n.hasOneChild()) ? n.getJSDocInfo() : null;\n        for (com.google.javascript.rhino.Node name : n.children()) {\n            com.google.javascript.rhino.Node value = name.getFirstChild();\n            com.google.javascript.jscomp.Scope.Var var = t.getScope().getVar(name.getString());\n            if (value != null) {\n                com.google.javascript.rhino.jstype.JSType valueType = getJSType(value);\n                com.google.javascript.rhino.jstype.JSType nameType = var.getType();\n                nameType = (nameType == null) ? getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE) : nameType;\n                com.google.javascript.rhino.JSDocInfo info = name.getJSDocInfo();\n                if (info == null) {\n                    info = varInfo;\n                }\n                if ((info != null) && info.hasEnumParameterType()) {\n                    checkEnumInitializer(t, value, info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n                } else if (var.isTypeInferred()) {\n                    ensureTyped(t, name, valueType);\n                } else {\n                    validator.expectCanAssignTo(t, value, valueType, nameType, \"initializing variable\");\n                }\n            }\n        }\n    }\n\n    private void visitNew(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.Node constructor = n.getFirstChild();\n        com.google.javascript.rhino.jstype.FunctionType type = getFunctionType(constructor);\n        if ((type != null) && type.isConstructor()) {\n            visitParameterList(t, n, type);\n            ensureTyped(t, n, type.getInstanceType());\n        } else {\n            if (constructor.getType() != com.google.javascript.rhino.Token.GETPROP) {\n                com.google.javascript.rhino.Node line;\n                if ((constructor.getLineno() < 0) || (constructor.getCharno() < 0)) {\n                    line = n;\n                } else {\n                    line = constructor;\n                }\n                report(t, line, com.google.javascript.jscomp.TypeCheck.NOT_A_CONSTRUCTOR);\n            }\n            ensureTyped(t, n);\n        }\n    }\n\n    private void visitFunction(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.JSDocInfo info = n.getJSDocInfo();\n        com.google.javascript.rhino.jstype.FunctionType functionType = ((com.google.javascript.rhino.jstype.FunctionType) (n.getJSType()));\n        java.lang.String functionPrivateName = n.getFirstChild().getString();\n        if (functionType.isInterface() || functionType.isConstructor()) {\n            com.google.javascript.rhino.jstype.FunctionType baseConstructor = functionType.getPrototype().getImplicitPrototype().getConstructor();\n            if (((baseConstructor != null) && (baseConstructor != getNativeType(com.google.javascript.jscomp.OBJECT_FUNCTION_TYPE))) && ((baseConstructor.isConstructor() && functionType.isInterface()) || (baseConstructor.isInterface() && functionType.isConstructor()))) {\n                compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeCheck.CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n            }\n            for (com.google.javascript.rhino.jstype.JSType baseInterface : functionType.getImplementedInterfaces()) {\n                boolean badImplementedType = false;\n                com.google.javascript.rhino.jstype.ObjectType baseInterfaceObj = com.google.javascript.rhino.jstype.ObjectType.cast(baseInterface);\n                if (baseInterfaceObj != null) {\n                    com.google.javascript.rhino.jstype.FunctionType interfaceConstructor = baseInterfaceObj.getConstructor();\n                    if ((interfaceConstructor != null) && (!interfaceConstructor.isInterface())) {\n                        badImplementedType = true;\n                    }\n                } else {\n                    badImplementedType = true;\n                }\n                if (badImplementedType) {\n                    report(t, n, com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE, functionPrivateName);\n                }\n            }\n            if (functionType.isConstructor()) {\n                validator.expectAllInterfaceProperties(t, n, functionType);\n            }\n        }\n    }\n\n    private void visitCall(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.Node child = n.getFirstChild();\n        com.google.javascript.rhino.jstype.JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n        if (!childType.canBeCalled()) {\n            report(t, n, com.google.javascript.jscomp.TypeCheck.NOT_CALLABLE, childType.toString());\n            ensureTyped(t, n);\n            return;\n        }\n        if (childType instanceof com.google.javascript.rhino.jstype.FunctionType) {\n            com.google.javascript.rhino.jstype.FunctionType functionType = ((com.google.javascript.rhino.jstype.FunctionType) (childType));\n            if (functionType.isConstructor() && (!functionType.isNativeObjectType())) {\n                report(t, n, com.google.javascript.jscomp.TypeCheck.CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n            }\n            visitParameterList(t, n, functionType);\n            ensureTyped(t, n, functionType.getReturnType());\n        } else {\n            ensureTyped(t, n);\n        }\n    }\n\n    private void visitParameterList(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node call, com.google.javascript.rhino.jstype.FunctionType functionType) {\n        java.util.Iterator<com.google.javascript.rhino.Node> arguments = call.children().iterator();\n        arguments.next();\n        java.util.Iterator<com.google.javascript.rhino.Node> parameters = functionType.getParameters().iterator();\n        int ordinal = 0;\n        com.google.javascript.rhino.Node parameter = null;\n        com.google.javascript.rhino.Node argument = null;\n        while (arguments.hasNext() && (parameters.hasNext() || ((parameter != null) && parameter.isVarArgs()))) {\n            if (parameters.hasNext()) {\n                parameter = parameters.next();\n            }\n            argument = arguments.next();\n            ordinal++;\n            validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);\n        } \n        int numArgs = call.getChildCount() - 1;\n        int minArgs = functionType.getMinArguments();\n        int maxArgs = functionType.getMaxArguments();\n        if ((minArgs > numArgs) || (maxArgs < numArgs)) {\n            report(t, call, com.google.javascript.jscomp.TypeCheck.WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false), java.lang.String.valueOf(numArgs), java.lang.String.valueOf(minArgs), maxArgs != java.lang.Integer.MAX_VALUE ? (\" and no more than \" + maxArgs) + \" argument(s)\" : \"\");\n        }\n    }\n\n    private void visitReturn(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.Node function = t.getEnclosingFunction();\n        if (function == null) {\n            return;\n        }\n        com.google.javascript.rhino.jstype.JSType jsType = getJSType(function);\n        if (jsType instanceof com.google.javascript.rhino.jstype.FunctionType) {\n            com.google.javascript.rhino.jstype.FunctionType functionType = ((com.google.javascript.rhino.jstype.FunctionType) (jsType));\n            com.google.javascript.rhino.jstype.JSType returnType = functionType.getReturnType();\n            if (returnType == null) {\n                returnType = getNativeType(com.google.javascript.jscomp.VOID_TYPE);\n            }\n            com.google.javascript.rhino.Node valueNode = n.getFirstChild();\n            com.google.javascript.rhino.jstype.JSType actualReturnType;\n            if (valueNode == null) {\n                actualReturnType = getNativeType(com.google.javascript.jscomp.VOID_TYPE);\n                valueNode = n;\n            } else {\n                actualReturnType = getJSType(valueNode);\n            }\n            validator.expectCanAssignTo(t, valueNode, actualReturnType, returnType, \"inconsistent return type\");\n        }\n    }\n\n    private void visitBinaryOperator(int op, com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.Node left = n.getFirstChild();\n        com.google.javascript.rhino.jstype.JSType leftType = getJSType(left);\n        com.google.javascript.rhino.Node right = n.getLastChild();\n        com.google.javascript.rhino.jstype.JSType rightType = getJSType(right);\n        switch (op) {\n            case com.google.javascript.rhino.Token.ASSIGN_LSH :\n            case com.google.javascript.rhino.Token.ASSIGN_RSH :\n            case com.google.javascript.rhino.Token.LSH :\n            case com.google.javascript.rhino.Token.RSH :\n            case com.google.javascript.rhino.Token.ASSIGN_URSH :\n            case com.google.javascript.rhino.Token.URSH :\n                if (!leftType.matchesInt32Context()) {\n                    report(t, left, com.google.javascript.jscomp.TypeCheck.BIT_OPERATION, com.google.javascript.jscomp.NodeUtil.opToStr(n.getType()), leftType.toString());\n                }\n                if (!rightType.matchesUint32Context()) {\n                    report(t, right, com.google.javascript.jscomp.TypeCheck.BIT_OPERATION, com.google.javascript.jscomp.NodeUtil.opToStr(n.getType()), rightType.toString());\n                }\n                break;\n            case com.google.javascript.rhino.Token.ASSIGN_DIV :\n            case com.google.javascript.rhino.Token.ASSIGN_MOD :\n            case com.google.javascript.rhino.Token.ASSIGN_MUL :\n            case com.google.javascript.rhino.Token.ASSIGN_SUB :\n            case com.google.javascript.rhino.Token.DIV :\n            case com.google.javascript.rhino.Token.MOD :\n            case com.google.javascript.rhino.Token.MUL :\n            case com.google.javascript.rhino.Token.SUB :\n                validator.expectNumber(t, left, leftType, \"left operand\");\n                validator.expectNumber(t, right, rightType, \"right operand\");\n                break;\n            case com.google.javascript.rhino.Token.ASSIGN_BITAND :\n            case com.google.javascript.rhino.Token.ASSIGN_BITXOR :\n            case com.google.javascript.rhino.Token.ASSIGN_BITOR :\n            case com.google.javascript.rhino.Token.BITAND :\n            case com.google.javascript.rhino.Token.BITXOR :\n            case com.google.javascript.rhino.Token.BITOR :\n                validator.expectBitwiseable(t, left, leftType, \"bad left operand to bitwise operator\");\n                validator.expectBitwiseable(t, right, rightType, \"bad right operand to bitwise operator\");\n                break;\n            case com.google.javascript.rhino.Token.ASSIGN_ADD :\n            case com.google.javascript.rhino.Token.ADD :\n                break;\n            default :\n                report(t, n, com.google.javascript.jscomp.TypeCheck.UNEXPECTED_TOKEN, com.google.javascript.rhino.Node.tokenToName(op));\n        }\n        ensureTyped(t, n);\n    }\n\n    private void checkEnumInitializer(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node value, com.google.javascript.rhino.jstype.JSType primitiveType) {\n        if (value.getType() == com.google.javascript.rhino.Token.OBJECTLIT) {\n            for (com.google.javascript.rhino.Node key = value.getFirstChild(); key != null; key = key.getNext()) {\n                com.google.javascript.rhino.Node propValue = key.getFirstChild();\n                validator.expectCanAssignTo(t, propValue, getJSType(propValue), primitiveType, \"element type must match enum's type\");\n            }\n        } else if (value.getJSType() instanceof com.google.javascript.rhino.jstype.EnumType) {\n            com.google.javascript.rhino.jstype.EnumType valueEnumType = ((com.google.javascript.rhino.jstype.EnumType) (value.getJSType()));\n            com.google.javascript.rhino.jstype.JSType valueEnumPrimitiveType = valueEnumType.getElementsType().getPrimitiveType();\n            validator.expectCanAssignTo(t, value, valueEnumPrimitiveType, primitiveType, \"incompatible enum element types\");\n        } else {\n        }\n    }\n\n    private static boolean isReference(com.google.javascript.rhino.Node n) {\n        switch (n.getType()) {\n            case com.google.javascript.rhino.Token.GETELEM :\n            case com.google.javascript.rhino.Token.GETPROP :\n            case com.google.javascript.rhino.Token.NAME :\n                return true;\n            default :\n                return false;\n        }\n    }\n\n    private com.google.javascript.rhino.jstype.JSType getJSType(com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.jstype.JSType jsType = n.getJSType();\n        if (jsType == null) {\n            return getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE);\n        } else {\n            return jsType;\n        }\n    }\n\n    private com.google.javascript.rhino.jstype.FunctionType getFunctionType(com.google.javascript.rhino.Node n) {\n        com.google.javascript.rhino.jstype.JSType type = getJSType(n).restrictByNotNullOrUndefined();\n        if (type.isUnknownType()) {\n            return typeRegistry.getNativeFunctionType(com.google.javascript.jscomp.U2U_CONSTRUCTOR_TYPE);\n        } else if (type instanceof com.google.javascript.rhino.jstype.FunctionType) {\n            return ((com.google.javascript.rhino.jstype.FunctionType) (type));\n        } else {\n            return null;\n        }\n    }\n\n    private void ensureTyped(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n) {\n        ensureTyped(t, n, getNativeType(com.google.javascript.jscomp.UNKNOWN_TYPE));\n    }\n\n    private void ensureTyped(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSTypeNative type) {\n        ensureTyped(t, n, getNativeType(type));\n    }\n\n    private void ensureTyped(com.google.javascript.jscomp.NodeTraversal t, com.google.javascript.rhino.Node n, com.google.javascript.rhino.jstype.JSType type) {\n        com.google.common.base.Preconditions.checkState(((n.getType() != com.google.javascript.rhino.Token.FUNCTION) || (type instanceof com.google.javascript.rhino.jstype.FunctionType)) || type.isUnknownType());\n        com.google.javascript.rhino.JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            if (info.hasType()) {\n                com.google.javascript.rhino.jstype.JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n                validator.expectCanCast(t, n, infoType, type);\n                type = infoType;\n            }\n            if (info.isImplicitCast() && (!inExterns)) {\n                java.lang.String propName = (n.getType() == com.google.javascript.rhino.Token.GETPROP) ? n.getLastChild().getString() : \"(missing)\";\n                compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeCheck.ILLEGAL_IMPLICIT_CAST, propName));\n            }\n        }\n        if (n.getJSType() == null) {\n            n.setJSType(type);\n        }\n    }\n\n    double getTypedPercent() {\n        int total = (nullCount + unknownCount) + typedCount;\n        if (total == 0) {\n            return 0.0;\n        } else {\n            return (100.0 * typedCount) / total;\n        }\n    }\n\n    private com.google.javascript.rhino.jstype.JSType getNativeType(com.google.javascript.rhino.jstype.JSTypeNative typeId) {\n        return typeRegistry.getNativeType(typeId);\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Field",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ConstructorCall",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY_MISMATCH",
            "src_parent": "new com.google.javascript.jscomp.DiagnosticGroup(com.google.javascript.jscomp.TypeCheck.DETERMINISTIC_TEST, com.google.javascript.jscomp.TypeCheck.DETERMINISTIC_TEST_NO_RESULT, com.google.javascript.jscomp.TypeCheck.INEXISTENT_ENUM_ELEMENT, com.google.javascript.jscomp.TypeCheck.INEXISTENT_PROPERTY, com.google.javascript.jscomp.TypeCheck.NOT_A_CONSTRUCTOR, com.google.javascript.jscomp.TypeCheck.BIT_OPERATION, com.google.javascript.jscomp.TypeCheck.NOT_CALLABLE, com.google.javascript.jscomp.TypeCheck.CONSTRUCTOR_NOT_CALLABLE, com.google.javascript.jscomp.TypeCheck.FUNCTION_MASKS_VARIABLE, com.google.javascript.jscomp.TypeCheck.MULTIPLE_VAR_DEF, com.google.javascript.jscomp.TypeCheck.ENUM_DUP, com.google.javascript.jscomp.TypeCheck.ENUM_NOT_CONSTANT, com.google.javascript.jscomp.TypeCheck.INVALID_INTERFACE_MEMBER_DECLARATION, com.google.javascript.jscomp.TypeCheck.INTERFACE_FUNCTION_NOT_EMPTY, com.google.javascript.jscomp.TypeCheck.CONFLICTING_EXTENDED_TYPE, com.google.javascript.jscomp.TypeCheck.BAD_IMPLEMENTED_TYPE, com.google.javascript.jscomp.TypeCheck.HIDDEN_SUPERCLASS_PROPERTY, com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY, com.google.javascript.jscomp.TypeCheck.HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY_MISMATCH, com.google.javascript.jscomp.TypeCheck.UNKNOWN_OVERRIDE, com.google.javascript.jscomp.TypeCheck.INTERFACE_METHOD_OVERRIDE, com.google.javascript.jscomp.TypeCheck.UNKNOWN_EXPR_TYPE, com.google.javascript.jscomp.TypeCheck.UNRESOLVED_TYPE, com.google.javascript.jscomp.TypeCheck.WRONG_ARGUMENT_COUNT, com.google.javascript.jscomp.TypeCheck.ILLEGAL_IMPLICIT_CAST, TypedScopeCreator.UNKNOWN_LENDS, TypedScopeCreator.LENDS_ON_NON_OBJECT, TypedScopeCreator.CTOR_INITIALIZER, TypedScopeCreator.IFACE_INITIALIZER, FunctionTypeBuilder.THIS_TYPE_NON_OBJECT)",
            "src_parent_type": "ConstructorCall",
            "src_type": "FieldRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (interfaceHasProperty) {\n    com.google.javascript.rhino.jstype.JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n    if (!propertyType.canAssignTo(interfacePropType)) {\n        compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n    }\n}",
            "src_parent": "{\n    if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n        continue;\n    }\n    com.google.javascript.rhino.jstype.FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n    com.google.common.base.Preconditions.checkNotNull(interfaceType);\n    boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n    foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n    if ((reportMissingOverride.isOn() && (!declaredOverride)) && interfaceHasProperty) {\n        compiler.report(t.makeError(n, reportMissingOverride, com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n    }\n    if (interfaceHasProperty) {\n        com.google.javascript.rhino.jstype.JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.canAssignTo(interfacePropType)) {\n            compiler.report(t.makeError(n, com.google.javascript.jscomp.TypeCheck.HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        }
      ],
      "file_name": "TypeCheck"
    }
  ],
  "id": "Closure_154"
}