{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Field",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "NewClass",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "new java.lang.ThreadLocal<java.lang.Boolean>() {\n    protected java.lang.Boolean initialValue() {\n        return java.lang.Boolean.FALSE;\n    }\n}",
            "src_parent": "static java.lang.ThreadLocal<java.lang.Boolean> cVerbose = new java.lang.ThreadLocal<java.lang.Boolean>() {\n    protected java.lang.Boolean initialValue() {\n        return java.lang.Boolean.FALSE;\n    }\n};",
            "src_parent_type": "Field",
            "src_type": "NewClass"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "static {\n    cVerbose.set(java.lang.Boolean.FALSE);\n}",
            "src_parent": "public class ZoneInfoCompiler {\n    static org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear cStartOfYear;\n\n    static org.joda.time.Chronology cLenientISO;\n\n    static java.lang.ThreadLocal<java.lang.Boolean> cVerbose = new java.lang.ThreadLocal<java.lang.Boolean>();\n\n    static {\n        cVerbose.set(java.lang.Boolean.FALSE);\n    }\n\n    public static boolean verbose() {\n        return org.joda.time.tz.ZoneInfoCompiler.cVerbose.get();\n    }\n\n    public static void main(java.lang.String[] args) throws java.lang.Exception {\n        if (args.length == 0) {\n            org.joda.time.tz.ZoneInfoCompiler.printUsage();\n            return;\n        }\n        java.io.File inputDir = null;\n        java.io.File outputDir = null;\n        boolean verbose = false;\n        int i;\n        for (i = 0; i < args.length; i++) {\n            try {\n                if (\"-src\".equals(args[i])) {\n                    inputDir = new java.io.File(args[++i]);\n                } else if (\"-dst\".equals(args[i])) {\n                    outputDir = new java.io.File(args[++i]);\n                } else if (\"-verbose\".equals(args[i])) {\n                    verbose = true;\n                } else if (\"-?\".equals(args[i])) {\n                    org.joda.time.tz.ZoneInfoCompiler.printUsage();\n                    return;\n                } else {\n                    break;\n                }\n            } catch (java.lang.IndexOutOfBoundsException e) {\n                org.joda.time.tz.ZoneInfoCompiler.printUsage();\n                return;\n            }\n        }\n        if (i >= args.length) {\n            org.joda.time.tz.ZoneInfoCompiler.printUsage();\n            return;\n        }\n        java.io.File[] sources = new java.io.File[args.length - i];\n        for (int j = 0; i < args.length; i++ , j++) {\n            sources[j] = (inputDir == null) ? new java.io.File(args[i]) : new java.io.File(inputDir, args[i]);\n        }\n        org.joda.time.tz.ZoneInfoCompiler.cVerbose.set(verbose);\n        org.joda.time.tz.ZoneInfoCompiler zic = new org.joda.time.tz.ZoneInfoCompiler();\n        zic.compile(outputDir, sources);\n    }\n\n    private static void printUsage() {\n        java.lang.System.out.println(\"Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>\");\n        java.lang.System.out.println(\"where possible options include:\");\n        java.lang.System.out.println(\"  -src <directory>    Specify where to read source files\");\n        java.lang.System.out.println(\"  -dst <directory>    Specify where to write generated files\");\n        java.lang.System.out.println(\"  -verbose            Output verbosely (default false)\");\n    }\n\n    static org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear getStartOfYear() {\n        if (org.joda.time.tz.ZoneInfoCompiler.cStartOfYear == null) {\n            org.joda.time.tz.ZoneInfoCompiler.cStartOfYear = new org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear();\n        }\n        return org.joda.time.tz.ZoneInfoCompiler.cStartOfYear;\n    }\n\n    static org.joda.time.Chronology getLenientISOChronology() {\n        if (org.joda.time.tz.ZoneInfoCompiler.cLenientISO == null) {\n            org.joda.time.tz.ZoneInfoCompiler.cLenientISO = org.joda.time.chrono.LenientChronology.getInstance(org.joda.time.chrono.ISOChronology.getInstanceUTC());\n        }\n        return org.joda.time.tz.ZoneInfoCompiler.cLenientISO;\n    }\n\n    static void writeZoneInfoMap(java.io.DataOutputStream dout, java.util.Map<java.lang.String, org.joda.time.DateTimeZone> zimap) throws java.io.IOException {\n        java.util.Map<java.lang.String, java.lang.Short> idToIndex = new java.util.HashMap<java.lang.String, java.lang.Short>(zimap.size());\n        java.util.TreeMap<java.lang.Short, java.lang.String> indexToId = new java.util.TreeMap<java.lang.Short, java.lang.String>();\n        short count = 0;\n        for (java.util.Map.Entry<java.lang.String, org.joda.time.DateTimeZone> entry : zimap.entrySet()) {\n            java.lang.String id = ((java.lang.String) (entry.getKey()));\n            if (!idToIndex.containsKey(id)) {\n                java.lang.Short index = java.lang.Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if ((++count) == 0) {\n                    throw new java.lang.InternalError(\"Too many time zone ids\");\n                }\n            }\n            id = ((org.joda.time.DateTimeZone) (entry.getValue())).getID();\n            if (!idToIndex.containsKey(id)) {\n                java.lang.Short index = java.lang.Short.valueOf(count);\n                idToIndex.put(id, index);\n                indexToId.put(index, id);\n                if ((++count) == 0) {\n                    throw new java.lang.InternalError(\"Too many time zone ids\");\n                }\n            }\n        }\n        dout.writeShort(indexToId.size());\n        for (java.lang.String id : indexToId.values()) {\n            dout.writeUTF(id);\n        }\n        dout.writeShort(zimap.size());\n        for (java.util.Map.Entry<java.lang.String, org.joda.time.DateTimeZone> entry : zimap.entrySet()) {\n            java.lang.String id = entry.getKey();\n            dout.writeShort(idToIndex.get(id).shortValue());\n            id = entry.getValue().getID();\n            dout.writeShort(idToIndex.get(id).shortValue());\n        }\n    }\n\n    static int parseYear(java.lang.String str, int def) {\n        str = str.toLowerCase();\n        if (str.equals(\"minimum\") || str.equals(\"min\")) {\n            return java.lang.Integer.MIN_VALUE;\n        } else if (str.equals(\"maximum\") || str.equals(\"max\")) {\n            return java.lang.Integer.MAX_VALUE;\n        } else if (str.equals(\"only\")) {\n            return def;\n        }\n        return java.lang.Integer.parseInt(str);\n    }\n\n    static int parseMonth(java.lang.String str) {\n        org.joda.time.DateTimeField field = org.joda.time.chrono.ISOChronology.getInstanceUTC().monthOfYear();\n        return field.get(field.set(0, str, java.util.Locale.ENGLISH));\n    }\n\n    static int parseDayOfWeek(java.lang.String str) {\n        org.joda.time.DateTimeField field = org.joda.time.chrono.ISOChronology.getInstanceUTC().dayOfWeek();\n        return field.get(field.set(0, str, java.util.Locale.ENGLISH));\n    }\n\n    static java.lang.String parseOptional(java.lang.String str) {\n        return str.equals(\"-\") ? null : str;\n    }\n\n    static int parseTime(java.lang.String str) {\n        org.joda.time.format.DateTimeFormatter p = org.joda.time.format.ISODateTimeFormat.hourMinuteSecondFraction();\n        org.joda.time.MutableDateTime mdt = new org.joda.time.MutableDateTime(0, org.joda.time.tz.ZoneInfoCompiler.getLenientISOChronology());\n        int pos = 0;\n        if (str.startsWith(\"-\")) {\n            pos = 1;\n        }\n        int newPos = p.parseInto(mdt, str, pos);\n        if (newPos == (~pos)) {\n            throw new java.lang.IllegalArgumentException(str);\n        }\n        int millis = ((int) (mdt.getMillis()));\n        if (pos == 1) {\n            millis = -millis;\n        }\n        return millis;\n    }\n\n    static char parseZoneChar(char c) {\n        switch (c) {\n            case 's' :\n            case 'S' :\n                return 's';\n            case 'u' :\n            case 'U' :\n            case 'g' :\n            case 'G' :\n            case 'z' :\n            case 'Z' :\n                return 'u';\n            case 'w' :\n            case 'W' :\n            default :\n                return 'w';\n        }\n    }\n\n    static boolean test(java.lang.String id, org.joda.time.DateTimeZone tz) {\n        if (!id.equals(tz.getID())) {\n            return true;\n        }\n        long millis = org.joda.time.chrono.ISOChronology.getInstanceUTC().year().set(0, 1850);\n        long end = org.joda.time.chrono.ISOChronology.getInstanceUTC().year().set(0, 2050);\n        int offset = tz.getOffset(millis);\n        java.lang.String key = tz.getNameKey(millis);\n        java.util.List<java.lang.Long> transitions = new java.util.ArrayList<java.lang.Long>();\n        while (true) {\n            long next = tz.nextTransition(millis);\n            if ((next == millis) || (next > end)) {\n                break;\n            }\n            millis = next;\n            int nextOffset = tz.getOffset(millis);\n            java.lang.String nextKey = tz.getNameKey(millis);\n            if ((offset == nextOffset) && key.equals(nextKey)) {\n                java.lang.System.out.println(((\"*d* Error in \" + tz.getID()) + \" \") + new org.joda.time.DateTime(millis, org.joda.time.chrono.ISOChronology.getInstanceUTC()));\n                return false;\n            }\n            if ((nextKey == null) || ((nextKey.length() < 3) && (!\"??\".equals(nextKey)))) {\n                java.lang.System.out.println(((((\"*s* Error in \" + tz.getID()) + \" \") + new org.joda.time.DateTime(millis, org.joda.time.chrono.ISOChronology.getInstanceUTC())) + \", nameKey=\") + nextKey);\n                return false;\n            }\n            transitions.add(java.lang.Long.valueOf(millis));\n            offset = nextOffset;\n            key = nextKey;\n        } \n        millis = org.joda.time.chrono.ISOChronology.getInstanceUTC().year().set(0, 2050);\n        end = org.joda.time.chrono.ISOChronology.getInstanceUTC().year().set(0, 1850);\n        for (int i = transitions.size(); (--i) >= 0;) {\n            long prev = tz.previousTransition(millis);\n            if ((prev == millis) || (prev < end)) {\n                break;\n            }\n            millis = prev;\n            long trans = transitions.get(i).longValue();\n            if ((trans - 1) != millis) {\n                java.lang.System.out.println(((((\"*r* Error in \" + tz.getID()) + \" \") + new org.joda.time.DateTime(millis, org.joda.time.chrono.ISOChronology.getInstanceUTC())) + \" != \") + new org.joda.time.DateTime(trans - 1, org.joda.time.chrono.ISOChronology.getInstanceUTC()));\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private java.util.Map<java.lang.String, org.joda.time.tz.ZoneInfoCompiler.RuleSet> iRuleSets;\n\n    private java.util.List<org.joda.time.tz.ZoneInfoCompiler.Zone> iZones;\n\n    private java.util.List<java.lang.String> iLinks;\n\n    public ZoneInfoCompiler() {\n        iRuleSets = new java.util.HashMap<java.lang.String, org.joda.time.tz.ZoneInfoCompiler.RuleSet>();\n        iZones = new java.util.ArrayList<org.joda.time.tz.ZoneInfoCompiler.Zone>();\n        iLinks = new java.util.ArrayList<java.lang.String>();\n    }\n\n    public java.util.Map<java.lang.String, org.joda.time.DateTimeZone> compile(java.io.File outputDir, java.io.File[] sources) throws java.io.IOException {\n        if (sources != null) {\n            for (int i = 0; i < sources.length; i++) {\n                java.io.BufferedReader in = new java.io.BufferedReader(new java.io.FileReader(sources[i]));\n                parseDataFile(in);\n                in.close();\n            }\n        }\n        if (outputDir != null) {\n            if (!outputDir.exists()) {\n                if (!outputDir.mkdirs()) {\n                    throw new java.io.IOException(\"Destination directory doesn't exist and cannot be created: \" + outputDir);\n                }\n            }\n            if (!outputDir.isDirectory()) {\n                throw new java.io.IOException(\"Destination is not a directory: \" + outputDir);\n            }\n        }\n        java.util.Map<java.lang.String, org.joda.time.DateTimeZone> map = new java.util.TreeMap<java.lang.String, org.joda.time.DateTimeZone>();\n        java.lang.System.out.println(\"Writing zoneinfo files\");\n        for (int i = 0; i < iZones.size(); i++) {\n            org.joda.time.tz.ZoneInfoCompiler.Zone zone = iZones.get(i);\n            org.joda.time.tz.DateTimeZoneBuilder builder = new org.joda.time.tz.DateTimeZoneBuilder();\n            zone.addToBuilder(builder, iRuleSets);\n            final org.joda.time.DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n            org.joda.time.DateTimeZone tz = original;\n            if (org.joda.time.tz.ZoneInfoCompiler.test(tz.getID(), tz)) {\n                map.put(tz.getID(), tz);\n                if (outputDir != null) {\n                    if (org.joda.time.tz.ZoneInfoCompiler.verbose()) {\n                        java.lang.System.out.println(\"Writing \" + tz.getID());\n                    }\n                    java.io.File file = new java.io.File(outputDir, tz.getID());\n                    if (!file.getParentFile().exists()) {\n                        file.getParentFile().mkdirs();\n                    }\n                    java.io.OutputStream out = new java.io.FileOutputStream(file);\n                    try {\n                        builder.writeTo(zone.iName, out);\n                    } finally {\n                        out.close();\n                    }\n                    java.io.InputStream in = new java.io.FileInputStream(file);\n                    org.joda.time.DateTimeZone tz2 = org.joda.time.tz.DateTimeZoneBuilder.readFrom(in, tz.getID());\n                    in.close();\n                    if (!original.equals(tz2)) {\n                        java.lang.System.out.println((\"*e* Error in \" + tz.getID()) + \": Didn't read properly from file\");\n                    }\n                }\n            }\n        }\n        for (int pass = 0; pass < 2; pass++) {\n            for (int i = 0; i < iLinks.size(); i += 2) {\n                java.lang.String id = iLinks.get(i);\n                java.lang.String alias = iLinks.get(i + 1);\n                org.joda.time.DateTimeZone tz = map.get(id);\n                if (tz == null) {\n                    if (pass > 0) {\n                        java.lang.System.out.println((((\"Cannot find time zone '\" + id) + \"' to link alias '\") + alias) + \"' to\");\n                    }\n                } else {\n                    map.put(alias, tz);\n                }\n            }\n        }\n        if (outputDir != null) {\n            java.lang.System.out.println(\"Writing ZoneInfoMap\");\n            java.io.File file = new java.io.File(outputDir, \"ZoneInfoMap\");\n            if (!file.getParentFile().exists()) {\n                file.getParentFile().mkdirs();\n            }\n            java.io.OutputStream out = new java.io.FileOutputStream(file);\n            java.io.DataOutputStream dout = new java.io.DataOutputStream(out);\n            try {\n                java.util.Map<java.lang.String, org.joda.time.DateTimeZone> zimap = new java.util.TreeMap<java.lang.String, org.joda.time.DateTimeZone>(java.lang.String.CASE_INSENSITIVE_ORDER);\n                zimap.putAll(map);\n                org.joda.time.tz.ZoneInfoCompiler.writeZoneInfoMap(dout, zimap);\n            } finally {\n                dout.close();\n            }\n        }\n        return map;\n    }\n\n    public void parseDataFile(java.io.BufferedReader in) throws java.io.IOException {\n        org.joda.time.tz.ZoneInfoCompiler.Zone zone = null;\n        java.lang.String line;\n        while ((line = in.readLine()) != null) {\n            java.lang.String trimmed = line.trim();\n            if ((trimmed.length() == 0) || (trimmed.charAt(0) == '#')) {\n                continue;\n            }\n            int index = line.indexOf('#');\n            if (index >= 0) {\n                line = line.substring(0, index);\n            }\n            java.util.StringTokenizer st = new java.util.StringTokenizer(line, \" \\t\");\n            if (java.lang.Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {\n                if (zone != null) {\n                    zone.chain(st);\n                }\n                continue;\n            } else {\n                if (zone != null) {\n                    iZones.add(zone);\n                }\n                zone = null;\n            }\n            if (st.hasMoreTokens()) {\n                java.lang.String token = st.nextToken();\n                if (token.equalsIgnoreCase(\"Rule\")) {\n                    org.joda.time.tz.ZoneInfoCompiler.Rule r = new org.joda.time.tz.ZoneInfoCompiler.Rule(st);\n                    org.joda.time.tz.ZoneInfoCompiler.RuleSet rs = iRuleSets.get(r.iName);\n                    if (rs == null) {\n                        rs = new org.joda.time.tz.ZoneInfoCompiler.RuleSet(r);\n                        iRuleSets.put(r.iName, rs);\n                    } else {\n                        rs.addRule(r);\n                    }\n                } else if (token.equalsIgnoreCase(\"Zone\")) {\n                    zone = new org.joda.time.tz.ZoneInfoCompiler.Zone(st);\n                } else if (token.equalsIgnoreCase(\"Link\")) {\n                    iLinks.add(st.nextToken());\n                    iLinks.add(st.nextToken());\n                } else {\n                    java.lang.System.out.println(\"Unknown line: \" + line);\n                }\n            }\n        } \n        if (zone != null) {\n            iZones.add(zone);\n        }\n    }\n\n    static class DateTimeOfYear {\n        public final int iMonthOfYear;\n\n        public final int iDayOfMonth;\n\n        public final int iDayOfWeek;\n\n        public final boolean iAdvanceDayOfWeek;\n\n        public final int iMillisOfDay;\n\n        public final char iZoneChar;\n\n        DateTimeOfYear() {\n            iMonthOfYear = 1;\n            iDayOfMonth = 1;\n            iDayOfWeek = 0;\n            iAdvanceDayOfWeek = false;\n            iMillisOfDay = 0;\n            iZoneChar = 'w';\n        }\n\n        DateTimeOfYear(java.util.StringTokenizer st) {\n            int month = 1;\n            int day = 1;\n            int dayOfWeek = 0;\n            int millis = 0;\n            boolean advance = false;\n            char zoneChar = 'w';\n            if (st.hasMoreTokens()) {\n                month = org.joda.time.tz.ZoneInfoCompiler.parseMonth(st.nextToken());\n                if (st.hasMoreTokens()) {\n                    java.lang.String str = st.nextToken();\n                    if (str.startsWith(\"last\")) {\n                        day = -1;\n                        dayOfWeek = org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(str.substring(4));\n                        advance = false;\n                    } else {\n                        try {\n                            day = java.lang.Integer.parseInt(str);\n                            dayOfWeek = 0;\n                            advance = false;\n                        } catch (java.lang.NumberFormatException e) {\n                            int index = str.indexOf(\">=\");\n                            if (index > 0) {\n                                day = java.lang.Integer.parseInt(str.substring(index + 2));\n                                dayOfWeek = org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(str.substring(0, index));\n                                advance = true;\n                            } else {\n                                index = str.indexOf(\"<=\");\n                                if (index > 0) {\n                                    day = java.lang.Integer.parseInt(str.substring(index + 2));\n                                    dayOfWeek = org.joda.time.tz.ZoneInfoCompiler.parseDayOfWeek(str.substring(0, index));\n                                    advance = false;\n                                } else {\n                                    throw new java.lang.IllegalArgumentException(str);\n                                }\n                            }\n                        }\n                    }\n                    if (st.hasMoreTokens()) {\n                        str = st.nextToken();\n                        zoneChar = org.joda.time.tz.ZoneInfoCompiler.parseZoneChar(str.charAt(str.length() - 1));\n                        if (str.equals(\"24:00\")) {\n                            org.joda.time.LocalDate date = (day == (-1)) ? new org.joda.time.LocalDate(2001, month, 1).plusMonths(1) : new org.joda.time.LocalDate(2001, month, day).plusDays(1);\n                            advance = day != (-1);\n                            month = date.getMonthOfYear();\n                            day = date.getDayOfMonth();\n                            dayOfWeek = (((dayOfWeek - 1) + 1) % 7) + 1;\n                        } else {\n                            millis = org.joda.time.tz.ZoneInfoCompiler.parseTime(str);\n                        }\n                    }\n                }\n            }\n            iMonthOfYear = month;\n            iDayOfMonth = day;\n            iDayOfWeek = dayOfWeek;\n            iAdvanceDayOfWeek = advance;\n            iMillisOfDay = millis;\n            iZoneChar = zoneChar;\n        }\n\n        public void addRecurring(org.joda.time.tz.DateTimeZoneBuilder builder, java.lang.String nameKey, int saveMillis, int fromYear, int toYear) {\n            builder.addRecurringSavings(nameKey, saveMillis, fromYear, toYear, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay);\n        }\n\n        public void addCutover(org.joda.time.tz.DateTimeZoneBuilder builder, int year) {\n            builder.addCutover(year, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay);\n        }\n\n        public java.lang.String toString() {\n            return ((((((((((((((((\"MonthOfYear: \" + iMonthOfYear) + \"\\n\") + \"DayOfMonth: \") + iDayOfMonth) + \"\\n\") + \"DayOfWeek: \") + iDayOfWeek) + \"\\n\") + \"AdvanceDayOfWeek: \") + iAdvanceDayOfWeek) + \"\\n\") + \"MillisOfDay: \") + iMillisOfDay) + \"\\n\") + \"ZoneChar: \") + iZoneChar) + \"\\n\";\n        }\n    }\n\n    private static class Rule {\n        public final java.lang.String iName;\n\n        public final int iFromYear;\n\n        public final int iToYear;\n\n        public final java.lang.String iType;\n\n        public final org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear iDateTimeOfYear;\n\n        public final int iSaveMillis;\n\n        public final java.lang.String iLetterS;\n\n        Rule(java.util.StringTokenizer st) {\n            iName = st.nextToken().intern();\n            iFromYear = org.joda.time.tz.ZoneInfoCompiler.parseYear(st.nextToken(), 0);\n            iToYear = org.joda.time.tz.ZoneInfoCompiler.parseYear(st.nextToken(), iFromYear);\n            if (iToYear < iFromYear) {\n                throw new java.lang.IllegalArgumentException();\n            }\n            iType = org.joda.time.tz.ZoneInfoCompiler.parseOptional(st.nextToken());\n            iDateTimeOfYear = new org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear(st);\n            iSaveMillis = org.joda.time.tz.ZoneInfoCompiler.parseTime(st.nextToken());\n            iLetterS = org.joda.time.tz.ZoneInfoCompiler.parseOptional(st.nextToken());\n        }\n\n        public void addRecurring(org.joda.time.tz.DateTimeZoneBuilder builder, java.lang.String nameFormat) {\n            java.lang.String nameKey = formatName(nameFormat);\n            iDateTimeOfYear.addRecurring(builder, nameKey, iSaveMillis, iFromYear, iToYear);\n        }\n\n        private java.lang.String formatName(java.lang.String nameFormat) {\n            int index = nameFormat.indexOf('/');\n            if (index > 0) {\n                if (iSaveMillis == 0) {\n                    return nameFormat.substring(0, index).intern();\n                } else {\n                    return nameFormat.substring(index + 1).intern();\n                }\n            }\n            index = nameFormat.indexOf(\"%s\");\n            if (index < 0) {\n                return nameFormat;\n            }\n            java.lang.String left = nameFormat.substring(0, index);\n            java.lang.String right = nameFormat.substring(index + 2);\n            java.lang.String name;\n            if (iLetterS == null) {\n                name = left.concat(right);\n            } else {\n                name = (left + iLetterS) + right;\n            }\n            return name.intern();\n        }\n\n        public java.lang.String toString() {\n            return ((((((((((((((((((\"[Rule]\\n\" + \"Name: \") + iName) + \"\\n\") + \"FromYear: \") + iFromYear) + \"\\n\") + \"ToYear: \") + iToYear) + \"\\n\") + \"Type: \") + iType) + \"\\n\") + iDateTimeOfYear) + \"SaveMillis: \") + iSaveMillis) + \"\\n\") + \"LetterS: \") + iLetterS) + \"\\n\";\n        }\n    }\n\n    private static class RuleSet {\n        private java.util.List<org.joda.time.tz.ZoneInfoCompiler.Rule> iRules;\n\n        RuleSet(org.joda.time.tz.ZoneInfoCompiler.Rule rule) {\n            iRules = new java.util.ArrayList<org.joda.time.tz.ZoneInfoCompiler.Rule>();\n            iRules.add(rule);\n        }\n\n        void addRule(org.joda.time.tz.ZoneInfoCompiler.Rule rule) {\n            if (!rule.iName.equals(iRules.get(0).iName)) {\n                throw new java.lang.IllegalArgumentException(\"Rule name mismatch\");\n            }\n            iRules.add(rule);\n        }\n\n        public void addRecurring(org.joda.time.tz.DateTimeZoneBuilder builder, java.lang.String nameFormat) {\n            for (int i = 0; i < iRules.size(); i++) {\n                org.joda.time.tz.ZoneInfoCompiler.Rule rule = iRules.get(i);\n                rule.addRecurring(builder, nameFormat);\n            }\n        }\n    }\n\n    private static class Zone {\n        public final java.lang.String iName;\n\n        public final int iOffsetMillis;\n\n        public final java.lang.String iRules;\n\n        public final java.lang.String iFormat;\n\n        public final int iUntilYear;\n\n        public final org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear iUntilDateTimeOfYear;\n\n        private org.joda.time.tz.ZoneInfoCompiler.Zone iNext;\n\n        Zone(java.util.StringTokenizer st) {\n            this(st.nextToken(), st);\n        }\n\n        private Zone(java.lang.String name, java.util.StringTokenizer st) {\n            iName = name.intern();\n            iOffsetMillis = org.joda.time.tz.ZoneInfoCompiler.parseTime(st.nextToken());\n            iRules = org.joda.time.tz.ZoneInfoCompiler.parseOptional(st.nextToken());\n            iFormat = st.nextToken().intern();\n            int year = java.lang.Integer.MAX_VALUE;\n            org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear dtOfYear = org.joda.time.tz.ZoneInfoCompiler.getStartOfYear();\n            if (st.hasMoreTokens()) {\n                year = java.lang.Integer.parseInt(st.nextToken());\n                if (st.hasMoreTokens()) {\n                    dtOfYear = new org.joda.time.tz.ZoneInfoCompiler.DateTimeOfYear(st);\n                }\n            }\n            iUntilYear = year;\n            iUntilDateTimeOfYear = dtOfYear;\n        }\n\n        void chain(java.util.StringTokenizer st) {\n            if (iNext != null) {\n                iNext.chain(st);\n            } else {\n                iNext = new org.joda.time.tz.ZoneInfoCompiler.Zone(iName, st);\n            }\n        }\n\n        public void addToBuilder(org.joda.time.tz.DateTimeZoneBuilder builder, java.util.Map<java.lang.String, org.joda.time.tz.ZoneInfoCompiler.RuleSet> ruleSets) {\n            org.joda.time.tz.ZoneInfoCompiler.Zone.addToBuilder(this, builder, ruleSets);\n        }\n\n        private static void addToBuilder(org.joda.time.tz.ZoneInfoCompiler.Zone zone, org.joda.time.tz.DateTimeZoneBuilder builder, java.util.Map<java.lang.String, org.joda.time.tz.ZoneInfoCompiler.RuleSet> ruleSets) {\n            for (; zone != null; zone = zone.iNext) {\n                builder.setStandardOffset(zone.iOffsetMillis);\n                if (zone.iRules == null) {\n                    builder.setFixedSavings(zone.iFormat, 0);\n                } else {\n                    try {\n                        int saveMillis = org.joda.time.tz.ZoneInfoCompiler.parseTime(zone.iRules);\n                        builder.setFixedSavings(zone.iFormat, saveMillis);\n                    } catch (java.lang.Exception e) {\n                        org.joda.time.tz.ZoneInfoCompiler.RuleSet rs = ruleSets.get(zone.iRules);\n                        if (rs == null) {\n                            throw new java.lang.IllegalArgumentException(\"Rules not found: \" + zone.iRules);\n                        }\n                        rs.addRecurring(builder, zone.iFormat);\n                    }\n                }\n                if (zone.iUntilYear == java.lang.Integer.MAX_VALUE) {\n                    break;\n                }\n                zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear);\n            }\n        }\n\n        public java.lang.String toString() {\n            java.lang.String str = (((((((((((((((\"[Zone]\\n\" + \"Name: \") + iName) + \"\\n\") + \"OffsetMillis: \") + iOffsetMillis) + \"\\n\") + \"Rules: \") + iRules) + \"\\n\") + \"Format: \") + iFormat) + \"\\n\") + \"UntilYear: \") + iUntilYear) + \"\\n\") + iUntilDateTimeOfYear;\n            if (iNext == null) {\n                return str;\n            }\n            return (str + \"...\\n\") + iNext.toString();\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "AnonymousExecutable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "new java.lang.ThreadLocal<java.lang.Boolean>()",
            "src_parent": "static java.lang.ThreadLocal<java.lang.Boolean> cVerbose = new java.lang.ThreadLocal<java.lang.Boolean>();",
            "src_parent_type": "Field",
            "src_type": "ConstructorCall"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "java.lang.Boolean.FALSE",
            "dst_parent": "cVerbose.set(java.lang.Boolean.FALSE)",
            "dst_parent_type": "Invocation",
            "dst_type": "FieldRead",
            "operator": "MOV",
            "src": "java.lang.Boolean.FALSE",
            "src_parent": "return java.lang.Boolean.FALSE",
            "src_parent_type": "Return",
            "src_type": "FieldRead"
          }
        }
      ],
      "file_name": "ZoneInfoCompiler"
    }
  ],
  "id": "Time_11"
}