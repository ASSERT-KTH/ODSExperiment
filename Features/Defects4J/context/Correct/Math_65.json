{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "public double getRMS() {\n    double criterion = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        criterion += (residual * residual) * residualsWeights[i];\n    }\n    return java.lang.Math.sqrt(criterion / rows);\n}",
            "dst_parent": "public abstract class AbstractLeastSquaresOptimizer implements org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer {\n    public static final int DEFAULT_MAX_ITERATIONS = 100;\n\n    protected org.apache.commons.math.optimization.VectorialConvergenceChecker checker;\n\n    protected double[][] jacobian;\n\n    protected int cols;\n\n    protected int rows;\n\n    protected double[] targetValues;\n\n    protected double[] residualsWeights;\n\n    protected double[] point;\n\n    protected double[] objective;\n\n    protected double[] residuals;\n\n    protected double cost;\n\n    private int maxIterations;\n\n    private int iterations;\n\n    private int maxEvaluations;\n\n    private int objectiveEvaluations;\n\n    private int jacobianEvaluations;\n\n    private org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction function;\n\n    private org.apache.commons.math.analysis.MultivariateMatrixFunction jF;\n\n    protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new org.apache.commons.math.optimization.SimpleVectorialValueChecker());\n        setMaxIterations(org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(java.lang.Integer.MAX_VALUE);\n    }\n\n    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    public int getIterations() {\n        return iterations;\n    }\n\n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    public void setConvergenceChecker(org.apache.commons.math.optimization.VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n\n    public org.apache.commons.math.optimization.VectorialConvergenceChecker getConvergenceChecker() {\n        return checker;\n    }\n\n    protected void incrementIterationsCounter() throws org.apache.commons.math.optimization.OptimizationException {\n        if ((++iterations) > maxIterations) {\n            throw new org.apache.commons.math.optimization.OptimizationException(new org.apache.commons.math.MaxIterationsExceededException(maxIterations));\n        }\n    }\n\n    protected void updateJacobian() throws org.apache.commons.math.FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -java.lang.Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n\n    protected void updateResidualsAndCost() throws org.apache.commons.math.FunctionEvaluationException {\n        if ((++objectiveEvaluations) > maxEvaluations) {\n            throw new org.apache.commons.math.FunctionEvaluationException(new org.apache.commons.math.MaxEvaluationsExceededException(maxEvaluations), point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += (residualsWeights[i] * residual) * residual;\n            index += cols;\n        }\n        cost = java.lang.Math.sqrt(cost);\n    }\n\n    public double getRMS() {\n        double criterion = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            criterion += (residual * residual) * residualsWeights[i];\n        }\n        return java.lang.Math.sqrt(criterion / rows);\n    }\n\n    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            chiSquare += (residual * residual) / residualsWeights[i];\n        }\n        return chiSquare;\n    }\n\n    public double[][] getCovariances() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        updateJacobian();\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n        try {\n            org.apache.commons.math.linear.RealMatrix inverse = new org.apache.commons.math.linear.LUDecompositionImpl(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (org.apache.commons.math.linear.InvalidMatrixException ime) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n    }\n\n    public double[] guessParametersErrors() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (rows <= cols) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = java.lang.Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = java.lang.Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    public org.apache.commons.math.optimization.VectorialPointValuePair optimize(final org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (target.length != weights.length) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);\n        }\n        iterations = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations = 0;\n        function = f;\n        jF = f.jacobian();\n        targetValues = target.clone();\n        residualsWeights = weights.clone();\n        this.point = startPoint.clone();\n        this.residuals = new double[target.length];\n        rows = target.length;\n        cols = point.length;\n        jacobian = new double[rows][cols];\n        cost = java.lang.Double.POSITIVE_INFINITY;\n        return doOptimize();\n    }\n\n    protected abstract org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException;\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += (residual * residual) * residualsWeights[i];\n    }\n    return chiSquare;\n}",
            "src_parent": "public abstract class AbstractLeastSquaresOptimizer implements org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer {\n    public static final int DEFAULT_MAX_ITERATIONS = 100;\n\n    protected org.apache.commons.math.optimization.VectorialConvergenceChecker checker;\n\n    protected double[][] jacobian;\n\n    protected int cols;\n\n    protected int rows;\n\n    protected double[] targetValues;\n\n    protected double[] residualsWeights;\n\n    protected double[] point;\n\n    protected double[] objective;\n\n    protected double[] residuals;\n\n    protected double cost;\n\n    private int maxIterations;\n\n    private int iterations;\n\n    private int maxEvaluations;\n\n    private int objectiveEvaluations;\n\n    private int jacobianEvaluations;\n\n    private org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction function;\n\n    private org.apache.commons.math.analysis.MultivariateMatrixFunction jF;\n\n    protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new org.apache.commons.math.optimization.SimpleVectorialValueChecker());\n        setMaxIterations(org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(java.lang.Integer.MAX_VALUE);\n    }\n\n    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    public int getIterations() {\n        return iterations;\n    }\n\n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    public void setConvergenceChecker(org.apache.commons.math.optimization.VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n\n    public org.apache.commons.math.optimization.VectorialConvergenceChecker getConvergenceChecker() {\n        return checker;\n    }\n\n    protected void incrementIterationsCounter() throws org.apache.commons.math.optimization.OptimizationException {\n        if ((++iterations) > maxIterations) {\n            throw new org.apache.commons.math.optimization.OptimizationException(new org.apache.commons.math.MaxIterationsExceededException(maxIterations));\n        }\n    }\n\n    protected void updateJacobian() throws org.apache.commons.math.FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -java.lang.Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n\n    protected void updateResidualsAndCost() throws org.apache.commons.math.FunctionEvaluationException {\n        if ((++objectiveEvaluations) > maxEvaluations) {\n            throw new org.apache.commons.math.FunctionEvaluationException(new org.apache.commons.math.MaxEvaluationsExceededException(maxEvaluations), point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += (residualsWeights[i] * residual) * residual;\n            index += cols;\n        }\n        cost = java.lang.Math.sqrt(cost);\n    }\n\n    public double getRMS() {\n        return java.lang.Math.sqrt(getChiSquare() / rows);\n    }\n\n    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            chiSquare += (residual * residual) * residualsWeights[i];\n        }\n        return chiSquare;\n    }\n\n    public double[][] getCovariances() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        updateJacobian();\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n        try {\n            org.apache.commons.math.linear.RealMatrix inverse = new org.apache.commons.math.linear.LUDecompositionImpl(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (org.apache.commons.math.linear.InvalidMatrixException ime) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n    }\n\n    public double[] guessParametersErrors() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (rows <= cols) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = java.lang.Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = java.lang.Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    public org.apache.commons.math.optimization.VectorialPointValuePair optimize(final org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (target.length != weights.length) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);\n        }\n        iterations = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations = 0;\n        function = f;\n        jF = f.jacobian();\n        targetValues = target.clone();\n        residualsWeights = weights.clone();\n        this.point = startPoint.clone();\n        this.residuals = new double[target.length];\n        rows = target.length;\n        cols = point.length;\n        jacobian = new double[rows][cols];\n        cost = java.lang.Double.POSITIVE_INFINITY;\n        return doOptimize();\n    }\n\n    protected abstract org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException;\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += (residual * residual) / residualsWeights[i];\n    }\n    return chiSquare;\n}",
            "dst_parent": "public abstract class AbstractLeastSquaresOptimizer implements org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer {\n    public static final int DEFAULT_MAX_ITERATIONS = 100;\n\n    protected org.apache.commons.math.optimization.VectorialConvergenceChecker checker;\n\n    protected double[][] jacobian;\n\n    protected int cols;\n\n    protected int rows;\n\n    protected double[] targetValues;\n\n    protected double[] residualsWeights;\n\n    protected double[] point;\n\n    protected double[] objective;\n\n    protected double[] residuals;\n\n    protected double cost;\n\n    private int maxIterations;\n\n    private int iterations;\n\n    private int maxEvaluations;\n\n    private int objectiveEvaluations;\n\n    private int jacobianEvaluations;\n\n    private org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction function;\n\n    private org.apache.commons.math.analysis.MultivariateMatrixFunction jF;\n\n    protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new org.apache.commons.math.optimization.SimpleVectorialValueChecker());\n        setMaxIterations(org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(java.lang.Integer.MAX_VALUE);\n    }\n\n    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    public int getIterations() {\n        return iterations;\n    }\n\n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    public void setConvergenceChecker(org.apache.commons.math.optimization.VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n\n    public org.apache.commons.math.optimization.VectorialConvergenceChecker getConvergenceChecker() {\n        return checker;\n    }\n\n    protected void incrementIterationsCounter() throws org.apache.commons.math.optimization.OptimizationException {\n        if ((++iterations) > maxIterations) {\n            throw new org.apache.commons.math.optimization.OptimizationException(new org.apache.commons.math.MaxIterationsExceededException(maxIterations));\n        }\n    }\n\n    protected void updateJacobian() throws org.apache.commons.math.FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -java.lang.Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n\n    protected void updateResidualsAndCost() throws org.apache.commons.math.FunctionEvaluationException {\n        if ((++objectiveEvaluations) > maxEvaluations) {\n            throw new org.apache.commons.math.FunctionEvaluationException(new org.apache.commons.math.MaxEvaluationsExceededException(maxEvaluations), point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += (residualsWeights[i] * residual) * residual;\n            index += cols;\n        }\n        cost = java.lang.Math.sqrt(cost);\n    }\n\n    public double getRMS() {\n        double criterion = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            criterion += (residual * residual) * residualsWeights[i];\n        }\n        return java.lang.Math.sqrt(criterion / rows);\n    }\n\n    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            chiSquare += (residual * residual) / residualsWeights[i];\n        }\n        return chiSquare;\n    }\n\n    public double[][] getCovariances() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        updateJacobian();\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n        try {\n            org.apache.commons.math.linear.RealMatrix inverse = new org.apache.commons.math.linear.LUDecompositionImpl(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (org.apache.commons.math.linear.InvalidMatrixException ime) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n    }\n\n    public double[] guessParametersErrors() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (rows <= cols) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = java.lang.Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = java.lang.Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    public org.apache.commons.math.optimization.VectorialPointValuePair optimize(final org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (target.length != weights.length) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);\n        }\n        iterations = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations = 0;\n        function = f;\n        jF = f.jacobian();\n        targetValues = target.clone();\n        residualsWeights = weights.clone();\n        this.point = startPoint.clone();\n        this.residuals = new double[target.length];\n        rows = target.length;\n        cols = point.length;\n        jacobian = new double[rows][cols];\n        cost = java.lang.Double.POSITIVE_INFINITY;\n        return doOptimize();\n    }\n\n    protected abstract org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException;\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "public double getRMS() {\n    return java.lang.Math.sqrt(getChiSquare() / rows);\n}",
            "src_parent": "public abstract class AbstractLeastSquaresOptimizer implements org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer {\n    public static final int DEFAULT_MAX_ITERATIONS = 100;\n\n    protected org.apache.commons.math.optimization.VectorialConvergenceChecker checker;\n\n    protected double[][] jacobian;\n\n    protected int cols;\n\n    protected int rows;\n\n    protected double[] targetValues;\n\n    protected double[] residualsWeights;\n\n    protected double[] point;\n\n    protected double[] objective;\n\n    protected double[] residuals;\n\n    protected double cost;\n\n    private int maxIterations;\n\n    private int iterations;\n\n    private int maxEvaluations;\n\n    private int objectiveEvaluations;\n\n    private int jacobianEvaluations;\n\n    private org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction function;\n\n    private org.apache.commons.math.analysis.MultivariateMatrixFunction jF;\n\n    protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new org.apache.commons.math.optimization.SimpleVectorialValueChecker());\n        setMaxIterations(org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(java.lang.Integer.MAX_VALUE);\n    }\n\n    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    public int getIterations() {\n        return iterations;\n    }\n\n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    public void setConvergenceChecker(org.apache.commons.math.optimization.VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n\n    public org.apache.commons.math.optimization.VectorialConvergenceChecker getConvergenceChecker() {\n        return checker;\n    }\n\n    protected void incrementIterationsCounter() throws org.apache.commons.math.optimization.OptimizationException {\n        if ((++iterations) > maxIterations) {\n            throw new org.apache.commons.math.optimization.OptimizationException(new org.apache.commons.math.MaxIterationsExceededException(maxIterations));\n        }\n    }\n\n    protected void updateJacobian() throws org.apache.commons.math.FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -java.lang.Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n\n    protected void updateResidualsAndCost() throws org.apache.commons.math.FunctionEvaluationException {\n        if ((++objectiveEvaluations) > maxEvaluations) {\n            throw new org.apache.commons.math.FunctionEvaluationException(new org.apache.commons.math.MaxEvaluationsExceededException(maxEvaluations), point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += (residualsWeights[i] * residual) * residual;\n            index += cols;\n        }\n        cost = java.lang.Math.sqrt(cost);\n    }\n\n    public double getRMS() {\n        return java.lang.Math.sqrt(getChiSquare() / rows);\n    }\n\n    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            chiSquare += (residual * residual) * residualsWeights[i];\n        }\n        return chiSquare;\n    }\n\n    public double[][] getCovariances() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        updateJacobian();\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n        try {\n            org.apache.commons.math.linear.RealMatrix inverse = new org.apache.commons.math.linear.LUDecompositionImpl(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (org.apache.commons.math.linear.InvalidMatrixException ime) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n    }\n\n    public double[] guessParametersErrors() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (rows <= cols) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = java.lang.Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = java.lang.Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    public org.apache.commons.math.optimization.VectorialPointValuePair optimize(final org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (target.length != weights.length) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);\n        }\n        iterations = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations = 0;\n        function = f;\n        jF = f.jacobian();\n        targetValues = target.clone();\n        residualsWeights = weights.clone();\n        this.point = startPoint.clone();\n        this.residuals = new double[target.length];\n        rows = target.length;\n        cols = point.length;\n        jacobian = new double[rows][cols];\n        cost = java.lang.Double.POSITIVE_INFINITY;\n        return doOptimize();\n    }\n\n    protected abstract org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException;\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "For",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "OperatorAssignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "criterion",
            "dst_parent": "criterion += (residual * residual) * residualsWeights[i]",
            "dst_parent_type": "OperatorAssignment",
            "dst_type": "VariableWrite",
            "operator": "UPD",
            "src": "chiSquare",
            "src_parent": "chiSquare += (residual * residual) * residualsWeights[i]",
            "src_parent_type": "OperatorAssignment",
            "src_type": "VariableWrite"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n        chiSquare += (residual * residual) / residualsWeights[i];\n    }\n    return chiSquare;\n}",
            "dst_parent": "public abstract class AbstractLeastSquaresOptimizer implements org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer {\n    public static final int DEFAULT_MAX_ITERATIONS = 100;\n\n    protected org.apache.commons.math.optimization.VectorialConvergenceChecker checker;\n\n    protected double[][] jacobian;\n\n    protected int cols;\n\n    protected int rows;\n\n    protected double[] targetValues;\n\n    protected double[] residualsWeights;\n\n    protected double[] point;\n\n    protected double[] objective;\n\n    protected double[] residuals;\n\n    protected double cost;\n\n    private int maxIterations;\n\n    private int iterations;\n\n    private int maxEvaluations;\n\n    private int objectiveEvaluations;\n\n    private int jacobianEvaluations;\n\n    private org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction function;\n\n    private org.apache.commons.math.analysis.MultivariateMatrixFunction jF;\n\n    protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new org.apache.commons.math.optimization.SimpleVectorialValueChecker());\n        setMaxIterations(org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(java.lang.Integer.MAX_VALUE);\n    }\n\n    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    public int getIterations() {\n        return iterations;\n    }\n\n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    public void setConvergenceChecker(org.apache.commons.math.optimization.VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n\n    public org.apache.commons.math.optimization.VectorialConvergenceChecker getConvergenceChecker() {\n        return checker;\n    }\n\n    protected void incrementIterationsCounter() throws org.apache.commons.math.optimization.OptimizationException {\n        if ((++iterations) > maxIterations) {\n            throw new org.apache.commons.math.optimization.OptimizationException(new org.apache.commons.math.MaxIterationsExceededException(maxIterations));\n        }\n    }\n\n    protected void updateJacobian() throws org.apache.commons.math.FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -java.lang.Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n\n    protected void updateResidualsAndCost() throws org.apache.commons.math.FunctionEvaluationException {\n        if ((++objectiveEvaluations) > maxEvaluations) {\n            throw new org.apache.commons.math.FunctionEvaluationException(new org.apache.commons.math.MaxEvaluationsExceededException(maxEvaluations), point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += (residualsWeights[i] * residual) * residual;\n            index += cols;\n        }\n        cost = java.lang.Math.sqrt(cost);\n    }\n\n    public double getRMS() {\n        double criterion = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            criterion += (residual * residual) * residualsWeights[i];\n        }\n        return java.lang.Math.sqrt(criterion / rows);\n    }\n\n    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            chiSquare += (residual * residual) / residualsWeights[i];\n        }\n        return chiSquare;\n    }\n\n    public double[][] getCovariances() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        updateJacobian();\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n        try {\n            org.apache.commons.math.linear.RealMatrix inverse = new org.apache.commons.math.linear.LUDecompositionImpl(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (org.apache.commons.math.linear.InvalidMatrixException ime) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n    }\n\n    public double[] guessParametersErrors() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (rows <= cols) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = java.lang.Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = java.lang.Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    public org.apache.commons.math.optimization.VectorialPointValuePair optimize(final org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (target.length != weights.length) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);\n        }\n        iterations = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations = 0;\n        function = f;\n        jF = f.jacobian();\n        targetValues = target.clone();\n        residualsWeights = weights.clone();\n        this.point = startPoint.clone();\n        this.residuals = new double[target.length];\n        rows = target.length;\n        cols = point.length;\n        jacobian = new double[rows][cols];\n        cost = java.lang.Double.POSITIVE_INFINITY;\n        return doOptimize();\n    }\n\n    protected abstract org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException;\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "MOV",
            "src": "public double getRMS() {\n    return java.lang.Math.sqrt(getChiSquare() / rows);\n}",
            "src_parent": "public abstract class AbstractLeastSquaresOptimizer implements org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer {\n    public static final int DEFAULT_MAX_ITERATIONS = 100;\n\n    protected org.apache.commons.math.optimization.VectorialConvergenceChecker checker;\n\n    protected double[][] jacobian;\n\n    protected int cols;\n\n    protected int rows;\n\n    protected double[] targetValues;\n\n    protected double[] residualsWeights;\n\n    protected double[] point;\n\n    protected double[] objective;\n\n    protected double[] residuals;\n\n    protected double cost;\n\n    private int maxIterations;\n\n    private int iterations;\n\n    private int maxEvaluations;\n\n    private int objectiveEvaluations;\n\n    private int jacobianEvaluations;\n\n    private org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction function;\n\n    private org.apache.commons.math.analysis.MultivariateMatrixFunction jF;\n\n    protected AbstractLeastSquaresOptimizer() {\n        setConvergenceChecker(new org.apache.commons.math.optimization.SimpleVectorialValueChecker());\n        setMaxIterations(org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.DEFAULT_MAX_ITERATIONS);\n        setMaxEvaluations(java.lang.Integer.MAX_VALUE);\n    }\n\n    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    public int getIterations() {\n        return iterations;\n    }\n\n    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }\n\n    public int getMaxEvaluations() {\n        return maxEvaluations;\n    }\n\n    public int getEvaluations() {\n        return objectiveEvaluations;\n    }\n\n    public int getJacobianEvaluations() {\n        return jacobianEvaluations;\n    }\n\n    public void setConvergenceChecker(org.apache.commons.math.optimization.VectorialConvergenceChecker convergenceChecker) {\n        this.checker = convergenceChecker;\n    }\n\n    public org.apache.commons.math.optimization.VectorialConvergenceChecker getConvergenceChecker() {\n        return checker;\n    }\n\n    protected void incrementIterationsCounter() throws org.apache.commons.math.optimization.OptimizationException {\n        if ((++iterations) > maxIterations) {\n            throw new org.apache.commons.math.optimization.OptimizationException(new org.apache.commons.math.MaxIterationsExceededException(maxIterations));\n        }\n    }\n\n    protected void updateJacobian() throws org.apache.commons.math.FunctionEvaluationException {\n        ++jacobianEvaluations;\n        jacobian = jF.value(point);\n        if (jacobian.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, jacobian.length, rows);\n        }\n        for (int i = 0; i < rows; i++) {\n            final double[] ji = jacobian[i];\n            final double factor = -java.lang.Math.sqrt(residualsWeights[i]);\n            for (int j = 0; j < cols; ++j) {\n                ji[j] *= factor;\n            }\n        }\n    }\n\n    protected void updateResidualsAndCost() throws org.apache.commons.math.FunctionEvaluationException {\n        if ((++objectiveEvaluations) > maxEvaluations) {\n            throw new org.apache.commons.math.FunctionEvaluationException(new org.apache.commons.math.MaxEvaluationsExceededException(maxEvaluations), point);\n        }\n        objective = function.value(point);\n        if (objective.length != rows) {\n            throw new org.apache.commons.math.FunctionEvaluationException(point, org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, objective.length, rows);\n        }\n        cost = 0;\n        int index = 0;\n        for (int i = 0; i < rows; i++) {\n            final double residual = targetValues[i] - objective[i];\n            residuals[i] = residual;\n            cost += (residualsWeights[i] * residual) * residual;\n            index += cols;\n        }\n        cost = java.lang.Math.sqrt(cost);\n    }\n\n    public double getRMS() {\n        return java.lang.Math.sqrt(getChiSquare() / rows);\n    }\n\n    public double getChiSquare() {\n        double chiSquare = 0;\n        for (int i = 0; i < rows; ++i) {\n            final double residual = residuals[i];\n            chiSquare += (residual * residual) * residualsWeights[i];\n        }\n        return chiSquare;\n    }\n\n    public double[][] getCovariances() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        updateJacobian();\n        double[][] jTj = new double[cols][cols];\n        for (int i = 0; i < cols; ++i) {\n            for (int j = i; j < cols; ++j) {\n                double sum = 0;\n                for (int k = 0; k < rows; ++k) {\n                    sum += jacobian[k][i] * jacobian[k][j];\n                }\n                jTj[i][j] = sum;\n                jTj[j][i] = sum;\n            }\n        }\n        try {\n            org.apache.commons.math.linear.RealMatrix inverse = new org.apache.commons.math.linear.LUDecompositionImpl(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n            return inverse.getData();\n        } catch (org.apache.commons.math.linear.InvalidMatrixException ime) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n        }\n    }\n\n    public double[] guessParametersErrors() throws org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (rows <= cols) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.NO_DEGREES_OF_FREEDOM, rows, cols);\n        }\n        double[] errors = new double[cols];\n        final double c = java.lang.Math.sqrt(getChiSquare() / (rows - cols));\n        double[][] covar = getCovariances();\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = java.lang.Math.sqrt(covar[i][i]) * c;\n        }\n        return errors;\n    }\n\n    public org.apache.commons.math.optimization.VectorialPointValuePair optimize(final org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction f, final double[] target, final double[] weights, final double[] startPoint) throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException {\n        if (target.length != weights.length) {\n            throw new org.apache.commons.math.optimization.OptimizationException(org.apache.commons.math.exception.LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, target.length, weights.length);\n        }\n        iterations = 0;\n        objectiveEvaluations = 0;\n        jacobianEvaluations = 0;\n        function = f;\n        jF = f.jacobian();\n        targetValues = target.clone();\n        residualsWeights = weights.clone();\n        this.point = startPoint.clone();\n        this.residuals = new double[target.length];\n        rows = target.length;\n        cols = point.length;\n        jacobian = new double[rows][cols];\n        cost = java.lang.Double.POSITIVE_INFINITY;\n        return doOptimize();\n    }\n\n    protected abstract org.apache.commons.math.optimization.VectorialPointValuePair doOptimize() throws java.lang.IllegalArgumentException, org.apache.commons.math.FunctionEvaluationException, org.apache.commons.math.optimization.OptimizationException;\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "rows",
            "dst_parent": "criterion / rows",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "FieldRead",
            "operator": "MOV",
            "src": "rows",
            "src_parent": "getChiSquare() / rows",
            "src_parent_type": "BinaryOperator",
            "src_type": "FieldRead"
          }
        }
      ],
      "file_name": "AbstractLeastSquaresOptimizer"
    }
  ],
  "id": "Math_65"
}