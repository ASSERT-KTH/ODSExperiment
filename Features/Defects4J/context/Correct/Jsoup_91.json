{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "if (isBinary()) {\n    throw new org.jsoup.UncheckedIOException(\"Input is binary and unsupported\");\n}",
            "src_parent": "{\n    org.jsoup.helper.Validate.notNull(input);\n    org.jsoup.helper.Validate.isTrue(input.markSupported());\n    reader = input;\n    charBuf = new char[sz > org.jsoup.parser.CharacterReader.maxBufferLen ? org.jsoup.parser.CharacterReader.maxBufferLen : sz];\n    bufferUp();\n    if (isBinary()) {\n        throw new org.jsoup.UncheckedIOException(\"Input is binary and unsupported\");\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "private static final int numNullsConsideredBinary = 10;",
            "src_parent": "public final class CharacterReader {\n    static final char EOF = ((char) (-1));\n\n    private static final int maxStringCacheLen = 12;\n\n    static final int maxBufferLen = 1024 * 32;\n\n    private static final int readAheadLimit = ((int) (org.jsoup.parser.CharacterReader.maxBufferLen * 0.75));\n\n    private final char[] charBuf;\n\n    private final java.io.Reader reader;\n\n    private int bufLength;\n\n    private int bufSplitPoint;\n\n    private int bufPos;\n\n    private int readerPos;\n\n    private int bufMark = -1;\n\n    private final java.lang.String[] stringCache = new java.lang.String[512];\n\n    public CharacterReader(java.io.Reader input, int sz) {\n        org.jsoup.helper.Validate.notNull(input);\n        org.jsoup.helper.Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > org.jsoup.parser.CharacterReader.maxBufferLen ? org.jsoup.parser.CharacterReader.maxBufferLen : sz];\n        bufferUp();\n        if (isBinary()) {\n            throw new org.jsoup.UncheckedIOException(\"Input is binary and unsupported\");\n        }\n    }\n\n    public CharacterReader(java.io.Reader input) {\n        this(input, org.jsoup.parser.CharacterReader.maxBufferLen);\n    }\n\n    public CharacterReader(java.lang.String input) {\n        this(new java.io.StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        final int pos = bufPos;\n        if (pos < bufSplitPoint) {\n            return;\n        }\n        try {\n            reader.skip(pos);\n            reader.mark(org.jsoup.parser.CharacterReader.maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != (-1)) {\n                bufLength = read;\n                readerPos += pos;\n                bufPos = 0;\n                bufMark = -1;\n                bufSplitPoint = (bufLength > org.jsoup.parser.CharacterReader.readAheadLimit) ? org.jsoup.parser.CharacterReader.readAheadLimit : bufLength;\n            }\n        } catch (java.io.IOException e) {\n            throw new org.jsoup.UncheckedIOException(e);\n        }\n    }\n\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? org.jsoup.parser.CharacterReader.EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = (isEmptyNoBufferUp()) ? org.jsoup.parser.CharacterReader.EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        if (bufPos < 1) {\n            throw new org.jsoup.UncheckedIOException(new java.io.IOException(\"No buffer left to unconsume\"));\n        }\n        bufPos--;\n    }\n\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufSplitPoint = 0;\n        bufferUp();\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        if (bufMark == (-1)) {\n            throw new org.jsoup.UncheckedIOException(new java.io.IOException(\"Mark invalid\"));\n        }\n        bufPos = bufMark;\n    }\n\n    int nextIndexOf(char c) {\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i]) {\n                return i - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    int nextIndexOf(java.lang.CharSequence seq) {\n        bufferUp();\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            if (startChar != charBuf[offset]) {\n                while (((++offset) < bufLength) && (startChar != charBuf[offset])) {\n                } \n            }\n            int i = offset + 1;\n            int last = (i + seq.length()) - 1;\n            if ((offset < bufLength) && (last <= bufLength)) {\n                for (int j = 1; (i < last) && (seq.charAt(j) == charBuf[i]); i++ , j++) {\n                }\n                if (i == last) {\n                    return offset - bufPos;\n                }\n            }\n        }\n        return -1;\n    }\n\n    public java.lang.String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != (-1)) {\n            java.lang.String consumed = org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    java.lang.String consumeTo(java.lang.String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != (-1)) {\n            java.lang.String consumed = org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    public java.lang.String consumeToAny(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        final int charLen = chars.length;\n        int i;\n        OUTER : while (pos < remaining) {\n            for (i = 0; i < charLen; i++) {\n                if (val[pos] == chars[i]) {\n                    break OUTER;\n                }\n            }\n            pos++;\n        } \n        bufPos = pos;\n        return pos > start ? org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, pos - start) : \"\";\n    }\n\n    java.lang.String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        while (pos < remaining) {\n            if (java.util.Arrays.binarySearch(chars, val[pos]) >= 0) {\n                break;\n            }\n            pos++;\n        } \n        bufPos = pos;\n        return bufPos > start ? org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, pos - start) : \"\";\n    }\n\n    java.lang.String consumeData() {\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        OUTER : while (pos < remaining) {\n            switch (val[pos]) {\n                case '&' :\n                case '<' :\n                case TokeniserState.nullChar :\n                    break OUTER;\n                default :\n                    pos++;\n            }\n        } \n        bufPos = pos;\n        return pos > start ? org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, pos - start) : \"\";\n    }\n\n    java.lang.String consumeTagName() {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        OUTER : while (pos < remaining) {\n            switch (val[pos]) {\n                case '\\t' :\n                case '\\n' :\n                case '\\r' :\n                case '\\f' :\n                case ' ' :\n                case '/' :\n                case '>' :\n                case '<' :\n                case TokeniserState.nullChar :\n                    break OUTER;\n            }\n            pos++;\n        } \n        bufPos = pos;\n        return pos > start ? org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, pos - start) : \"\";\n    }\n\n    java.lang.String consumeToEnd() {\n        bufferUp();\n        java.lang.String data = org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    java.lang.String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) || java.lang.Character.isLetter(c)) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        return org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    java.lang.String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) || java.lang.Character.isLetter(c)) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if ((c >= '0') && (c <= '9')) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        return org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    java.lang.String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((((c >= '0') && (c <= '9')) || ((c >= 'A') && (c <= 'F'))) || ((c >= 'a') && (c <= 'f'))) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        return org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    java.lang.String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0') && (c <= '9')) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        return org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return (!isEmpty()) && (charBuf[bufPos] == c);\n    }\n\n    boolean matches(java.lang.String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > (bufLength - bufPos)) {\n            return false;\n        }\n        for (int offset = 0; offset < scanLength; offset++) {\n            if (seq.charAt(offset) != charBuf[bufPos + offset]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    boolean matchesIgnoreCase(java.lang.String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > (bufLength - bufPos)) {\n            return false;\n        }\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = java.lang.Character.toUpperCase(seq.charAt(offset));\n            char upTarget = java.lang.Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty()) {\n            return false;\n        }\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return (!isEmpty()) && (java.util.Arrays.binarySearch(seq, charBuf[bufPos]) >= 0);\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty()) {\n            return false;\n        }\n        char c = charBuf[bufPos];\n        return (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) || java.lang.Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty()) {\n            return false;\n        }\n        char c = charBuf[bufPos];\n        return (c >= '0') && (c <= '9');\n    }\n\n    boolean matchConsume(java.lang.String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(java.lang.String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(java.lang.String seq) {\n        java.lang.String loScan = seq.toLowerCase(java.util.Locale.ENGLISH);\n        java.lang.String hiScan = seq.toUpperCase(java.util.Locale.ENGLISH);\n        return (nextIndexOf(loScan) > (-1)) || (nextIndexOf(hiScan) > (-1));\n    }\n\n    private static final int numNullsConsideredBinary = 10;\n\n    boolean isBinary() {\n        int nullsSeen = 0;\n        for (int i = bufPos; i < bufLength; i++) {\n            if (charBuf[i] == '\\u0000') {\n                nullsSeen++;\n            }\n        }\n        return nullsSeen >= org.jsoup.parser.CharacterReader.numNullsConsideredBinary;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return new java.lang.String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    private static java.lang.String cacheString(final char[] charBuf, final java.lang.String[] stringCache, final int start, final int count) {\n        if (count > org.jsoup.parser.CharacterReader.maxStringCacheLen) {\n            return new java.lang.String(charBuf, start, count);\n        }\n        if (count < 1) {\n            return \"\";\n        }\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = (31 * hash) + charBuf[offset++];\n        }\n        final int index = hash & (stringCache.length - 1);\n        java.lang.String cached = stringCache[index];\n        if (cached == null) {\n            cached = new java.lang.String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else if (org.jsoup.parser.CharacterReader.rangeEquals(charBuf, start, count, cached)) {\n            return cached;\n        } else {\n            cached = new java.lang.String(charBuf, start, count);\n            stringCache[index] = cached;\n        }\n        return cached;\n    }\n\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final java.lang.String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while ((count--) != 0) {\n                if (charBuf[i++] != cached.charAt(j++)) {\n                    return false;\n                }\n            } \n            return true;\n        }\n        return false;\n    }\n\n    boolean rangeEquals(final int start, final int count, final java.lang.String cached) {\n        return org.jsoup.parser.CharacterReader.rangeEquals(charBuf, start, count, cached);\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "boolean isBinary() {\n    int nullsSeen = 0;\n    for (int i = bufPos; i < bufLength; i++) {\n        if (charBuf[i] == '\\u0000') {\n            nullsSeen++;\n        }\n    }\n    return nullsSeen >= org.jsoup.parser.CharacterReader.numNullsConsideredBinary;\n}",
            "src_parent": "public final class CharacterReader {\n    static final char EOF = ((char) (-1));\n\n    private static final int maxStringCacheLen = 12;\n\n    static final int maxBufferLen = 1024 * 32;\n\n    private static final int readAheadLimit = ((int) (org.jsoup.parser.CharacterReader.maxBufferLen * 0.75));\n\n    private final char[] charBuf;\n\n    private final java.io.Reader reader;\n\n    private int bufLength;\n\n    private int bufSplitPoint;\n\n    private int bufPos;\n\n    private int readerPos;\n\n    private int bufMark = -1;\n\n    private final java.lang.String[] stringCache = new java.lang.String[512];\n\n    public CharacterReader(java.io.Reader input, int sz) {\n        org.jsoup.helper.Validate.notNull(input);\n        org.jsoup.helper.Validate.isTrue(input.markSupported());\n        reader = input;\n        charBuf = new char[sz > org.jsoup.parser.CharacterReader.maxBufferLen ? org.jsoup.parser.CharacterReader.maxBufferLen : sz];\n        bufferUp();\n        if (isBinary()) {\n            throw new org.jsoup.UncheckedIOException(\"Input is binary and unsupported\");\n        }\n    }\n\n    public CharacterReader(java.io.Reader input) {\n        this(input, org.jsoup.parser.CharacterReader.maxBufferLen);\n    }\n\n    public CharacterReader(java.lang.String input) {\n        this(new java.io.StringReader(input), input.length());\n    }\n\n    private void bufferUp() {\n        final int pos = bufPos;\n        if (pos < bufSplitPoint) {\n            return;\n        }\n        try {\n            reader.skip(pos);\n            reader.mark(org.jsoup.parser.CharacterReader.maxBufferLen);\n            final int read = reader.read(charBuf);\n            reader.reset();\n            if (read != (-1)) {\n                bufLength = read;\n                readerPos += pos;\n                bufPos = 0;\n                bufMark = -1;\n                bufSplitPoint = (bufLength > org.jsoup.parser.CharacterReader.readAheadLimit) ? org.jsoup.parser.CharacterReader.readAheadLimit : bufLength;\n            }\n        } catch (java.io.IOException e) {\n            throw new org.jsoup.UncheckedIOException(e);\n        }\n    }\n\n    public int pos() {\n        return readerPos + bufPos;\n    }\n\n    public boolean isEmpty() {\n        bufferUp();\n        return bufPos >= bufLength;\n    }\n\n    private boolean isEmptyNoBufferUp() {\n        return bufPos >= bufLength;\n    }\n\n    public char current() {\n        bufferUp();\n        return isEmptyNoBufferUp() ? org.jsoup.parser.CharacterReader.EOF : charBuf[bufPos];\n    }\n\n    char consume() {\n        bufferUp();\n        char val = (isEmptyNoBufferUp()) ? org.jsoup.parser.CharacterReader.EOF : charBuf[bufPos];\n        bufPos++;\n        return val;\n    }\n\n    void unconsume() {\n        if (bufPos < 1) {\n            throw new org.jsoup.UncheckedIOException(new java.io.IOException(\"No buffer left to unconsume\"));\n        }\n        bufPos--;\n    }\n\n    public void advance() {\n        bufPos++;\n    }\n\n    void mark() {\n        bufSplitPoint = 0;\n        bufferUp();\n        bufMark = bufPos;\n    }\n\n    void rewindToMark() {\n        if (bufMark == (-1)) {\n            throw new org.jsoup.UncheckedIOException(new java.io.IOException(\"Mark invalid\"));\n        }\n        bufPos = bufMark;\n    }\n\n    int nextIndexOf(char c) {\n        bufferUp();\n        for (int i = bufPos; i < bufLength; i++) {\n            if (c == charBuf[i]) {\n                return i - bufPos;\n            }\n        }\n        return -1;\n    }\n\n    int nextIndexOf(java.lang.CharSequence seq) {\n        bufferUp();\n        char startChar = seq.charAt(0);\n        for (int offset = bufPos; offset < bufLength; offset++) {\n            if (startChar != charBuf[offset]) {\n                while (((++offset) < bufLength) && (startChar != charBuf[offset])) {\n                } \n            }\n            int i = offset + 1;\n            int last = (i + seq.length()) - 1;\n            if ((offset < bufLength) && (last <= bufLength)) {\n                for (int j = 1; (i < last) && (seq.charAt(j) == charBuf[i]); i++ , j++) {\n                }\n                if (i == last) {\n                    return offset - bufPos;\n                }\n            }\n        }\n        return -1;\n    }\n\n    public java.lang.String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != (-1)) {\n            java.lang.String consumed = org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    java.lang.String consumeTo(java.lang.String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != (-1)) {\n            java.lang.String consumed = org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, bufPos, offset);\n            bufPos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    public java.lang.String consumeToAny(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        final int charLen = chars.length;\n        int i;\n        OUTER : while (pos < remaining) {\n            for (i = 0; i < charLen; i++) {\n                if (val[pos] == chars[i]) {\n                    break OUTER;\n                }\n            }\n            pos++;\n        } \n        bufPos = pos;\n        return pos > start ? org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, pos - start) : \"\";\n    }\n\n    java.lang.String consumeToAnySorted(final char... chars) {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        while (pos < remaining) {\n            if (java.util.Arrays.binarySearch(chars, val[pos]) >= 0) {\n                break;\n            }\n            pos++;\n        } \n        bufPos = pos;\n        return bufPos > start ? org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, pos - start) : \"\";\n    }\n\n    java.lang.String consumeData() {\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        OUTER : while (pos < remaining) {\n            switch (val[pos]) {\n                case '&' :\n                case '<' :\n                case TokeniserState.nullChar :\n                    break OUTER;\n                default :\n                    pos++;\n            }\n        } \n        bufPos = pos;\n        return pos > start ? org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, pos - start) : \"\";\n    }\n\n    java.lang.String consumeTagName() {\n        bufferUp();\n        int pos = bufPos;\n        final int start = pos;\n        final int remaining = bufLength;\n        final char[] val = charBuf;\n        OUTER : while (pos < remaining) {\n            switch (val[pos]) {\n                case '\\t' :\n                case '\\n' :\n                case '\\r' :\n                case '\\f' :\n                case ' ' :\n                case '/' :\n                case '>' :\n                case '<' :\n                case TokeniserState.nullChar :\n                    break OUTER;\n            }\n            pos++;\n        } \n        bufPos = pos;\n        return pos > start ? org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, pos - start) : \"\";\n    }\n\n    java.lang.String consumeToEnd() {\n        bufferUp();\n        java.lang.String data = org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n        bufPos = bufLength;\n        return data;\n    }\n\n    java.lang.String consumeLetterSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) || java.lang.Character.isLetter(c)) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        return org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    java.lang.String consumeLetterThenDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) || java.lang.Character.isLetter(c)) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        while (!isEmptyNoBufferUp()) {\n            char c = charBuf[bufPos];\n            if ((c >= '0') && (c <= '9')) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        return org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    java.lang.String consumeHexSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((((c >= '0') && (c <= '9')) || ((c >= 'A') && (c <= 'F'))) || ((c >= 'a') && (c <= 'f'))) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        return org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    java.lang.String consumeDigitSequence() {\n        bufferUp();\n        int start = bufPos;\n        while (bufPos < bufLength) {\n            char c = charBuf[bufPos];\n            if ((c >= '0') && (c <= '9')) {\n                bufPos++;\n            } else {\n                break;\n            }\n        } \n        return org.jsoup.parser.CharacterReader.cacheString(charBuf, stringCache, start, bufPos - start);\n    }\n\n    boolean matches(char c) {\n        return (!isEmpty()) && (charBuf[bufPos] == c);\n    }\n\n    boolean matches(java.lang.String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > (bufLength - bufPos)) {\n            return false;\n        }\n        for (int offset = 0; offset < scanLength; offset++) {\n            if (seq.charAt(offset) != charBuf[bufPos + offset]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    boolean matchesIgnoreCase(java.lang.String seq) {\n        bufferUp();\n        int scanLength = seq.length();\n        if (scanLength > (bufLength - bufPos)) {\n            return false;\n        }\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = java.lang.Character.toUpperCase(seq.charAt(offset));\n            char upTarget = java.lang.Character.toUpperCase(charBuf[bufPos + offset]);\n            if (upScan != upTarget) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty()) {\n            return false;\n        }\n        bufferUp();\n        char c = charBuf[bufPos];\n        for (char seek : seq) {\n            if (seek == c) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        bufferUp();\n        return (!isEmpty()) && (java.util.Arrays.binarySearch(seq, charBuf[bufPos]) >= 0);\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty()) {\n            return false;\n        }\n        char c = charBuf[bufPos];\n        return (((c >= 'A') && (c <= 'Z')) || ((c >= 'a') && (c <= 'z'))) || java.lang.Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty()) {\n            return false;\n        }\n        char c = charBuf[bufPos];\n        return (c >= '0') && (c <= '9');\n    }\n\n    boolean matchConsume(java.lang.String seq) {\n        bufferUp();\n        if (matches(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(java.lang.String seq) {\n        if (matchesIgnoreCase(seq)) {\n            bufPos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(java.lang.String seq) {\n        java.lang.String loScan = seq.toLowerCase(java.util.Locale.ENGLISH);\n        java.lang.String hiScan = seq.toUpperCase(java.util.Locale.ENGLISH);\n        return (nextIndexOf(loScan) > (-1)) || (nextIndexOf(hiScan) > (-1));\n    }\n\n    private static final int numNullsConsideredBinary = 10;\n\n    boolean isBinary() {\n        int nullsSeen = 0;\n        for (int i = bufPos; i < bufLength; i++) {\n            if (charBuf[i] == '\\u0000') {\n                nullsSeen++;\n            }\n        }\n        return nullsSeen >= org.jsoup.parser.CharacterReader.numNullsConsideredBinary;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return new java.lang.String(charBuf, bufPos, bufLength - bufPos);\n    }\n\n    private static java.lang.String cacheString(final char[] charBuf, final java.lang.String[] stringCache, final int start, final int count) {\n        if (count > org.jsoup.parser.CharacterReader.maxStringCacheLen) {\n            return new java.lang.String(charBuf, start, count);\n        }\n        if (count < 1) {\n            return \"\";\n        }\n        int hash = 0;\n        int offset = start;\n        for (int i = 0; i < count; i++) {\n            hash = (31 * hash) + charBuf[offset++];\n        }\n        final int index = hash & (stringCache.length - 1);\n        java.lang.String cached = stringCache[index];\n        if (cached == null) {\n            cached = new java.lang.String(charBuf, start, count);\n            stringCache[index] = cached;\n        } else if (org.jsoup.parser.CharacterReader.rangeEquals(charBuf, start, count, cached)) {\n            return cached;\n        } else {\n            cached = new java.lang.String(charBuf, start, count);\n            stringCache[index] = cached;\n        }\n        return cached;\n    }\n\n    static boolean rangeEquals(final char[] charBuf, final int start, int count, final java.lang.String cached) {\n        if (count == cached.length()) {\n            int i = start;\n            int j = 0;\n            while ((count--) != 0) {\n                if (charBuf[i++] != cached.charAt(j++)) {\n                    return false;\n                }\n            } \n            return true;\n        }\n        return false;\n    }\n\n    boolean rangeEquals(final int start, final int count, final java.lang.String cached) {\n        return org.jsoup.parser.CharacterReader.rangeEquals(charBuf, start, count, cached);\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        }
      ],
      "file_name": "CharacterReader"
    },
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "true",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Constructor",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "public UncheckedIOException(java.lang.String message) {\n    super(new java.io.IOException(message));\n}",
            "src_parent": "public class UncheckedIOException extends java.lang.RuntimeException {\n    public UncheckedIOException(java.io.IOException cause) {\n        super(cause);\n    }\n\n    public UncheckedIOException(java.lang.String message) {\n        super(new java.io.IOException(message));\n    }\n\n    public java.io.IOException ioException() {\n        return ((java.io.IOException) (getCause()));\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Constructor"
          }
        }
      ],
      "file_name": "UncheckedIOException"
    }
  ],
  "id": "Jsoup_91"
}