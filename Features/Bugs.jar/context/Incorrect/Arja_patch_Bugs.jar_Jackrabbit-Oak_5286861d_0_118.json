{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "{\n    branches.remove(parentId);\n}",
            "src_parent": "public class MicroKernelImpl implements org.apache.jackrabbit.mk.api.MicroKernel {\n    protected org.apache.jackrabbit.mk.core.Repository rep;\n\n    private final org.apache.jackrabbit.mk.util.CommitGate gate = new org.apache.jackrabbit.mk.util.CommitGate();\n\n    public MicroKernelImpl(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        init(homeDir);\n    }\n\n    public MicroKernelImpl() {\n        this(new org.apache.jackrabbit.mk.core.Repository());\n    }\n\n    public MicroKernelImpl(org.apache.jackrabbit.mk.core.Repository rep) {\n        this.rep = rep;\n        try {\n            gate.commit(rep.getHeadRevision().toString());\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    protected void init(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            rep = new org.apache.jackrabbit.mk.core.Repository(homeDir);\n            rep.init();\n            gate.commit(rep.getHeadRevision().toString());\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public void dispose() {\n        gate.commit(\"end\");\n        if (rep != null) {\n            try {\n                rep.shutDown();\n            } catch (java.lang.Exception ignore) {\n            }\n            rep = null;\n        }\n    }\n\n    public java.lang.String getHeadRevision() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        return getHeadRevisionId().toString();\n    }\n\n    public java.lang.String checkpoint(long lifetime) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        return getHeadRevision();\n    }\n\n    private org.apache.jackrabbit.mk.model.Id getHeadRevisionId() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            return rep.getHeadRevision();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    private org.apache.jackrabbit.mk.model.Id getBaseRevisionId(org.apache.jackrabbit.mk.model.Id branchId) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            return rep.getBaseRevision(branchId);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getRevisionHistory(long since, int maxEntries, java.lang.String path) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        path = ((path == null) || \"\".equals(path)) ? \"/\" : path;\n        boolean filtered = !\"/\".equals(path);\n        maxEntries = (maxEntries < 0) ? java.lang.Integer.MAX_VALUE : maxEntries;\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> history = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = rep.getHeadCommit();\n            while (((commit != null) && (history.size() < maxEntries)) && (commit.getCommitTS() >= since)) {\n                if (filtered) {\n                    try {\n                        org.apache.jackrabbit.mk.store.RevisionStore rs = rep.getRevisionStore();\n                        java.lang.String diff = new org.apache.jackrabbit.mk.model.DiffBuilder(rs.getRootNode(commit.getParentId()), rs.getNode(commit.getRootNodeId()), \"/\", -1, rep.getRevisionStore(), path).build();\n                        if (!diff.isEmpty()) {\n                            history.add(commit);\n                        }\n                    } catch (java.lang.Exception e) {\n                        throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n                    }\n                } else {\n                    history.add(commit);\n                }\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n            } \n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder buff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = history.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = history.get(i);\n            buff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg()).endObject();\n        }\n        return buff.endArray().toString();\n    }\n\n    public java.lang.String waitForCommit(java.lang.String oldHeadRevisionId, long maxWaitMillis) throws java.lang.InterruptedException, org.apache.jackrabbit.mk.api.MicroKernelException {\n        return gate.waitForCommit(oldHeadRevisionId, maxWaitMillis);\n    }\n\n    public java.lang.String getJournal(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String path) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        path = ((path == null) || \"\".equals(path)) ? \"/\" : path;\n        boolean filtered = !\"/\".equals(path);\n        org.apache.jackrabbit.mk.model.Id fromRevisionId = org.apache.jackrabbit.mk.model.Id.fromString(fromRevision);\n        org.apache.jackrabbit.mk.model.Id toRevisionId = (toRevision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> commits = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit toCommit = rep.getCommit(toRevisionId);\n            org.apache.jackrabbit.mk.model.Commit fromCommit;\n            if (toRevisionId.equals(fromRevisionId)) {\n                fromCommit = toCommit;\n            } else {\n                fromCommit = rep.getCommit(fromRevisionId);\n            }\n            if (fromCommit.getBranchRootId() != null) {\n                if (!fromCommit.getBranchRootId().equals(toCommit.getBranchRootId())) {\n                    throw new org.apache.jackrabbit.mk.api.MicroKernelException(\"inconsistent range specified: fromRevision denotes a private branch while toRevision denotes a head or another private branch\");\n                }\n            }\n            if (fromCommit.getCommitTS() > toCommit.getCommitTS()) {\n                return \"[]\";\n            }\n            org.apache.jackrabbit.mk.model.StoredCommit commit = toCommit;\n            while (commit != null) {\n                commits.add(commit);\n                if (commit.getId().equals(fromRevisionId)) {\n                    break;\n                }\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n                if (commit.getCommitTS() < fromCommit.getCommitTS()) {\n                    break;\n                }\n            } \n        } catch (org.apache.jackrabbit.mk.api.MicroKernelException e) {\n            throw e;\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder commitBuff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = commits.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = commits.get(i);\n            if (commit.getParentId() == null) {\n                continue;\n            }\n            java.lang.String diff = commit.getChanges();\n            if (filtered) {\n                try {\n                    org.apache.jackrabbit.mk.store.RevisionStore rs = rep.getRevisionStore();\n                    diff = new org.apache.jackrabbit.mk.model.DiffBuilder(rs.getRootNode(commit.getParentId()), rs.getNode(commit.getRootNodeId()), \"/\", -1, rep.getRevisionStore(), path).build();\n                    if (diff.isEmpty()) {\n                        continue;\n                    }\n                } catch (java.lang.Exception e) {\n                    throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n                }\n            }\n            commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg());\n            if (commit.getBranchRootId() != null) {\n                commitBuff.key(\"branchRootId\").value(commit.getBranchRootId().toString());\n            }\n            commitBuff.key(\"changes\").value(diff).endObject();\n        }\n        return commitBuff.endArray().toString();\n    }\n\n    public java.lang.String diff(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String path, int depth) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        path = ((path == null) || \"\".equals(path)) ? \"/\" : path;\n        if (depth < (-1)) {\n            throw new java.lang.IllegalArgumentException(\"depth\");\n        }\n        org.apache.jackrabbit.mk.model.Id fromRevisionId;\n        org.apache.jackrabbit.mk.model.Id toRevisionId;\n        if ((fromRevision == null) || (toRevision == null)) {\n            org.apache.jackrabbit.mk.model.Id head = getHeadRevisionId();\n            fromRevisionId = (fromRevision == null) ? head : org.apache.jackrabbit.mk.model.Id.fromString(fromRevision);\n            toRevisionId = (toRevision == null) ? head : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        } else {\n            fromRevisionId = org.apache.jackrabbit.mk.model.Id.fromString(fromRevision);\n            toRevisionId = org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        }\n        if (fromRevisionId.equals(toRevisionId)) {\n            return \"\";\n        }\n        try {\n            if (\"/\".equals(path)) {\n                org.apache.jackrabbit.mk.model.StoredCommit toCommit = rep.getCommit(toRevisionId);\n                if (toCommit.getParentId().equals(fromRevisionId) && (depth == (-1))) {\n                    return toCommit.getChanges();\n                }\n            }\n            org.apache.jackrabbit.mk.model.StoredNode from = null;\n            org.apache.jackrabbit.mk.model.StoredNode to = null;\n            try {\n                from = rep.getNode(fromRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException ignore) {\n            }\n            try {\n                to = rep.getNode(toRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException ignore) {\n            }\n            return new org.apache.jackrabbit.mk.model.DiffBuilder(from, to, path, depth, rep.getRevisionStore(), path).build();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public boolean nodeExists(java.lang.String path, java.lang.String revisionId) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revId = (revisionId == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revisionId);\n        try {\n            return rep.nodeExists(revId, path);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    {\n        branches.remove(parentId);\n    }\n\n    public long getChildNodeCount(java.lang.String path, java.lang.String revisionId) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revId = (revisionId == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revisionId);\n        try {\n            return rep.getNode(revId, path).getChildNodeCount();\n        } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(((\"Path \" + path) + \" not found in revision \") + revisionId);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getNodes(java.lang.String path, java.lang.String revisionId, int depth, long offset, int maxChildNodes, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id id = null;\n        if (!path.startsWith(\"/\")) {\n            id = org.apache.jackrabbit.mk.model.Id.fromString(path);\n        }\n        org.apache.jackrabbit.mk.model.Id revId = (revisionId == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revisionId);\n        org.apache.jackrabbit.mk.util.NodeFilter nodeFilter = ((filter == null) || filter.isEmpty()) ? null : org.apache.jackrabbit.mk.util.NodeFilter.parse(filter);\n        if (((offset > 0) && (nodeFilter != null)) && (nodeFilter.getChildNodeFilter() != null)) {\n            throw new java.lang.IllegalArgumentException(\"offset > 0 with child node filter\");\n        }\n        try {\n            org.apache.jackrabbit.mk.model.StoredNode node;\n            try {\n                if (id != null) {\n                    node = rep.getRevisionStore().getNode(id);\n                } else {\n                    node = rep.getNode(revId, path);\n                }\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n                return null;\n            }\n            org.apache.jackrabbit.mk.json.JsopBuilder buf = new org.apache.jackrabbit.mk.json.JsopBuilder().object();\n            toJson(buf, node, depth, ((int) (offset)), maxChildNodes, true, nodeFilter);\n            return buf.endObject().toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String commit(java.lang.String path, java.lang.String jsonDiff, java.lang.String revisionId, java.lang.String message) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        if ((path.length() > 0) && (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(path))) {\n            throw new java.lang.IllegalArgumentException(\"absolute path expected: \" + path);\n        }\n        if ((jsonDiff == null) || (jsonDiff.length() == 0)) {\n            return getHeadRevision();\n        }\n        org.apache.jackrabbit.mk.model.Id revId = (revisionId == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revisionId);\n        try {\n            org.apache.jackrabbit.mk.json.JsopTokenizer t = new org.apache.jackrabbit.mk.json.JsopTokenizer(jsonDiff);\n            org.apache.jackrabbit.mk.model.CommitBuilder cb = rep.getCommitBuilder(revId, message);\n            while (true) {\n                int r = t.read();\n                if (r == org.apache.jackrabbit.mk.json.JsopReader.END) {\n                    break;\n                }\n                int pos;\n                switch (r) {\n                    case '+' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            t.read('{');\n                            java.lang.String nodePath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(nodePath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + nodePath) + \", pos: \") + pos);\n                            }\n                            java.lang.String parentPath = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(nodePath);\n                            java.lang.String nodeName = org.apache.jackrabbit.oak.commons.PathUtils.getName(nodePath);\n                            cb.addNode(parentPath, nodeName, org.apache.jackrabbit.mk.json.JsonObject.create(t));\n                            break;\n                        }\n                    case '-' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String targetPath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            cb.removeNode(targetPath);\n                            break;\n                        }\n                    case '^' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            java.lang.String value;\n                            if (t.matches(JsopReader.NULL)) {\n                                value = null;\n                            } else {\n                                value = t.readRawValue().trim();\n                            }\n                            java.lang.String targetPath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            java.lang.String parentPath = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(targetPath);\n                            java.lang.String propName = org.apache.jackrabbit.oak.commons.PathUtils.getName(targetPath);\n                            cb.setProperty(parentPath, propName, value);\n                            break;\n                        }\n                    case '>' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.moveNode(srcPath, targetPath);\n                            break;\n                        }\n                    case '*' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.copyNode(srcPath, targetPath);\n                            break;\n                        }\n                    default :\n                        throw new java.lang.IllegalArgumentException(((\"jsonDiff: illegal token '\" + t.getToken()) + \"' at pos: \") + t.getLastPos());\n                }\n            } \n            org.apache.jackrabbit.mk.model.Id newHead = cb.doCommit();\n            if (!newHead.equals(revId)) {\n                if (rep.getCommit(newHead).getBranchRootId() == null) {\n                    gate.commit(newHead.toString());\n                }\n            }\n            return newHead.toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String branch(java.lang.String trunkRevisionId) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revId = (trunkRevisionId == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(trunkRevisionId);\n        try {\n            org.apache.jackrabbit.mk.model.CommitBuilder cb = rep.getCommitBuilder(revId, \"\");\n            return cb.doCommit(true).toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String merge(java.lang.String branchRevisionId, java.lang.String message) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revId = org.apache.jackrabbit.mk.model.Id.fromString(branchRevisionId);\n        try {\n            return rep.getCommitBuilder(revId, message).doMerge().toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String rebase(java.lang.String branchRevisionId, java.lang.String newBaseRevisionId) {\n        org.apache.jackrabbit.mk.model.Id branchId = org.apache.jackrabbit.mk.model.Id.fromString(branchRevisionId);\n        org.apache.jackrabbit.mk.model.Id baseId = getBaseRevisionId(branchId);\n        org.apache.jackrabbit.mk.model.Id newBaseId = (newBaseRevisionId == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(newBaseRevisionId);\n        if (baseId.equals(newBaseId)) {\n            return branchRevisionId;\n        } else {\n            org.apache.jackrabbit.mk.model.Id newBranchId = org.apache.jackrabbit.mk.model.Id.fromString(branch(newBaseRevisionId));\n            try {\n                org.apache.jackrabbit.mk.model.CommitBuilder cb = rep.getCommitBuilder(newBranchId, ((\"rebasing \" + branchRevisionId) + \" onto \") + newBaseRevisionId);\n                return cb.rebase(baseId, branchId).toString();\n            } catch (java.lang.Exception e) {\n                throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n            }\n        }\n    }\n\n    public long getLength(java.lang.String blobId) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().getBlobLength(blobId);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public int read(java.lang.String blobId, long pos, byte[] buff, int off, int length) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().readBlob(blobId, pos, buff, off, length);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String write(java.io.InputStream in) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().writeBlob(in);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    void toJson(org.apache.jackrabbit.mk.json.JsopBuilder builder, org.apache.jackrabbit.mk.model.StoredNode node, int depth, int offset, int maxChildNodes, boolean inclVirtualProps, org.apache.jackrabbit.mk.util.NodeFilter filter) throws java.lang.Exception {\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> prop : node.getProperties().entrySet()) {\n            if ((filter == null) || filter.includeProperty(prop.getKey())) {\n                builder.key(prop.getKey()).encodedValue(prop.getValue());\n            }\n        }\n        long childCount = node.getChildNodeCount();\n        if (inclVirtualProps) {\n            if ((filter == null) || filter.includeProperty(\":childNodeCount\")) {\n                builder.key(\":childNodeCount\").value(childCount);\n            }\n            if (filter != null) {\n                org.apache.jackrabbit.mk.util.NameFilter nf = filter.getPropertyFilter();\n                if (nf != null) {\n                    if (nf.getInclusionPatterns().contains(\":hash\") && (!nf.getExclusionPatterns().contains(\":hash\"))) {\n                        builder.key(\":hash\").value(node.getId().toString());\n                    }\n                    if (nf.getInclusionPatterns().contains(\":id\") && (!nf.getExclusionPatterns().contains(\":id\"))) {\n                        builder.key(\":id\").value(node.getId().toString());\n                    }\n                }\n            }\n        }\n        if ((childCount > 0) && (depth >= 0)) {\n            if (filter != null) {\n                org.apache.jackrabbit.mk.util.NameFilter childFilter = filter.getChildNodeFilter();\n                if ((childFilter != null) && (!childFilter.containsWildcard())) {\n                    int count = (maxChildNodes == (-1)) ? java.lang.Integer.MAX_VALUE : maxChildNodes;\n                    for (java.lang.String name : childFilter.getInclusionPatterns()) {\n                        org.apache.jackrabbit.mk.model.ChildNodeEntry cne = node.getChildNodeEntry(name);\n                        if (cne != null) {\n                            boolean incl = true;\n                            for (java.lang.String exclName : childFilter.getExclusionPatterns()) {\n                                if (name.equals(exclName)) {\n                                    incl = false;\n                                    break;\n                                }\n                            }\n                            if (incl) {\n                                if ((count--) <= 0) {\n                                    break;\n                                }\n                                builder.key(name).object();\n                                if (depth > 0) {\n                                    toJson(builder, rep.getRevisionStore().getNode(cne.getId()), depth - 1, 0, maxChildNodes, inclVirtualProps, filter);\n                                }\n                                builder.endObject();\n                            }\n                        }\n                    }\n                    return;\n                }\n            }\n            int count = maxChildNodes;\n            if (((count != (-1)) && (filter != null)) && (filter.getChildNodeFilter() != null)) {\n                count = -1;\n            }\n            int numSiblings = 0;\n            for (java.util.Iterator<org.apache.jackrabbit.mk.model.ChildNodeEntry> it = node.getChildNodeEntries(offset, count); it.hasNext();) {\n                org.apache.jackrabbit.mk.model.ChildNodeEntry cne = it.next();\n                if ((filter == null) || filter.includeNode(cne.getName())) {\n                    if ((maxChildNodes != (-1)) && ((++numSiblings) > maxChildNodes)) {\n                        break;\n                    }\n                    builder.key(cne.getName()).object();\n                    if (depth > 0) {\n                        toJson(builder, rep.getRevisionStore().getNode(cne.getId()), depth - 1, 0, maxChildNodes, inclVirtualProps, filter);\n                    }\n                    builder.endObject();\n                }\n            }\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "AnonymousExecutable"
          }
        }
      ],
      "file_name": "MicroKernelImpl"
    }
  ],
  "id": "Arja_patch_Bugs.jar_Jackrabbit-Oak_5286861d_0_118"
}