{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "(!sortOrder.isEmpty())",
            "src_parent": "((!indexedProps.isEmpty()) || (!sortOrder.isEmpty()))",
            "src_parent_type": "BinaryOperator",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean canHandleSorting(java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> sortOrder) {\n    if (sortOrder.isEmpty()) {\n        return false;\n    }\n    if ((sortOrder.size() == 1) && org.apache.jackrabbit.JcrConstants.JCR_SCORE.equals(sortOrder.get(0).getPropertyName())) {\n        return false;\n    }\n    return true;\n}",
            "src_parent": "class IndexPlanner {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.class);\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition defn;\n\n    private final org.apache.jackrabbit.oak.spi.query.Filter filter;\n\n    private final java.lang.String indexPath;\n\n    private final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> sortOrder;\n\n    private org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode indexNode;\n\n    private org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult result;\n\n    public IndexPlanner(org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode indexNode, java.lang.String indexPath, org.apache.jackrabbit.oak.spi.query.Filter filter, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> sortOrder) {\n        this.indexNode = indexNode;\n        this.indexPath = indexPath;\n        this.defn = indexNode.getDefinition();\n        this.filter = filter;\n        this.sortOrder = sortOrder;\n    }\n\n    org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan getPlan() {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan.Builder builder = getPlanBuilder();\n        if (defn.isTestMode()) {\n            if (builder == null) {\n                if (notSupportedFeature()) {\n                    return null;\n                }\n                java.lang.String msg = java.lang.String.format(\"No plan found for filter [%s] \" + \"while using definition [%s] and testMode is found to be enabled\", filter, defn);\n                throw new java.lang.IllegalStateException(msg);\n            } else {\n                builder.setEstimatedEntryCount(1).setCostPerExecution(0.001).setCostPerEntry(0.001);\n            }\n        }\n        return builder != null ? builder.build() : null;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return (((((((\"IndexPlanner{\" + \"indexPath='\") + indexPath) + '\\'') + \", filter=\") + filter) + \", sortOrder=\") + sortOrder) + '}';\n    }\n\n    private IndexPlan.Builder getPlanBuilder() {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.log.trace(\"Evaluating plan with index definition {}\", defn);\n        org.apache.jackrabbit.oak.query.fulltext.FullTextExpression ft = filter.getFullTextConstraint();\n        if (!defn.getVersion().isAtLeast(IndexFormatVersion.V2)) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.log.trace(\"Index is old format. Not supported\");\n            return null;\n        }\n        if ((ft != null) && (!defn.isFullTextEnabled())) {\n            return null;\n        }\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule indexingRule = getApplicableRule();\n        if (indexingRule == null) {\n            return null;\n        }\n        if ((ft != null) && (!indexingRule.isFulltextEnabled())) {\n            return null;\n        }\n        result = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult(indexPath, defn, indexingRule);\n        if (defn.hasFunctionDefined() && (filter.getPropertyRestriction(defn.getFunctionName()) != null)) {\n            return defaultPlan().setEstimatedEntryCount(1);\n        }\n        java.util.List<java.lang.String> indexedProps = com.google.common.collect.Lists.newArrayListWithCapacity(filter.getPropertyRestrictions().size());\n        if (indexingRule.propertyIndexEnabled) {\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyRestriction pr : filter.getPropertyRestrictions()) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = indexingRule.getConfig(pr.propertyName);\n                if ((pd != null) && pd.propertyIndexEnabled()) {\n                    indexedProps.add(pr.propertyName);\n                    result.propDefns.put(pr.propertyName, pd);\n                }\n            }\n        }\n        boolean evalPathRestrictions = canEvalPathRestrictions(indexingRule);\n        boolean canEvalAlFullText = canEvalAllFullText(indexingRule, ft);\n        if ((ft != null) && (!canEvalAlFullText)) {\n            return null;\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> sortOrder = createSortOrder(indexingRule);\n        boolean canSort = canHandleSorting(sortOrder);\n        if ((((!indexedProps.isEmpty()) || canSort) || (ft != null)) || evalPathRestrictions) {\n            int costPerEntryFactor = indexedProps.size();\n            costPerEntryFactor += sortOrder.size();\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan.Builder plan = defaultPlan();\n            if (!sortOrder.isEmpty()) {\n                plan.setSortOrder(sortOrder);\n            }\n            if (costPerEntryFactor == 0) {\n                costPerEntryFactor = 1;\n            }\n            if (ft == null) {\n                result.enableNonFullTextConstraints();\n            }\n            return plan.setCostPerEntry(defn.getCostPerEntry() / costPerEntryFactor);\n        }\n        return null;\n    }\n\n    private boolean canHandleSorting(java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> sortOrder) {\n        if (sortOrder.isEmpty()) {\n            return false;\n        }\n        if ((sortOrder.size() == 1) && org.apache.jackrabbit.JcrConstants.JCR_SCORE.equals(sortOrder.get(0).getPropertyName())) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canEvalAllFullText(final org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule indexingRule, org.apache.jackrabbit.oak.query.fulltext.FullTextExpression ft) {\n        if (ft == null) {\n            return false;\n        }\n        final java.util.HashSet<java.lang.String> relPaths = new java.util.HashSet<java.lang.String>();\n        final java.util.HashSet<java.lang.String> nonIndexedPaths = new java.util.HashSet<java.lang.String>();\n        final java.util.concurrent.atomic.AtomicBoolean relativeParentsFound = new java.util.concurrent.atomic.AtomicBoolean();\n        ft.accept(new org.apache.jackrabbit.oak.query.fulltext.FullTextVisitor.FullTextVisitorBase() {\n            @java.lang.Override\n            public boolean visit(org.apache.jackrabbit.oak.query.fulltext.FullTextContains contains) {\n                visitTerm(contains.getPropertyName());\n                return true;\n            }\n\n            @java.lang.Override\n            public boolean visit(org.apache.jackrabbit.oak.query.fulltext.FullTextTerm term) {\n                visitTerm(term.getPropertyName());\n                return true;\n            }\n\n            private void visitTerm(java.lang.String propertyName) {\n                java.lang.String p = propertyName;\n                java.lang.String propertyPath = null;\n                java.lang.String nodePath = null;\n                if (p == null) {\n                    relPaths.add(\"\");\n                } else if (p.startsWith(\"../\") || p.startsWith(\"./\")) {\n                    relPaths.add(p);\n                    relativeParentsFound.set(true);\n                } else if (getDepth(p) > 1) {\n                    java.lang.String parent = getParentPath(p);\n                    if (org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.isNodePath(p)) {\n                        nodePath = parent;\n                    } else {\n                        propertyPath = p;\n                    }\n                    relPaths.add(parent);\n                } else {\n                    propertyPath = p;\n                    relPaths.add(\"\");\n                }\n                if ((nodePath != null) && (!indexingRule.isAggregated(nodePath))) {\n                    nonIndexedPaths.add(p);\n                } else if ((propertyPath != null) && (!indexingRule.isIndexed(propertyPath))) {\n                    nonIndexedPaths.add(p);\n                }\n            }\n        });\n        if (relativeParentsFound.get()) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.log.debug(\"Relative parents found {} which are not supported\", relPaths);\n            return false;\n        }\n        if (!nonIndexedPaths.isEmpty()) {\n            if (relPaths.size() > 1) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.log.debug(\"Following relative  property paths are not index\", relPaths);\n                return false;\n            }\n            result.setParentPath(com.google.common.collect.Iterables.getOnlyElement(relPaths, \"\"));\n            return defn.indexesAllTypes();\n        } else {\n            result.setParentPath(\"\");\n        }\n        return true;\n    }\n\n    private boolean canEvalPathRestrictions(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule rule) {\n        if (filter.getPathRestriction() == Filter.PathRestriction.NO_RESTRICTION) {\n            return false;\n        }\n        return defn.evaluatePathRestrictions() && rule.indexesAllNodesOfMatchingType();\n    }\n\n    private IndexPlan.Builder defaultPlan() {\n        return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan.Builder().setCostPerExecution(defn.getCostPerExecution()).setCostPerEntry(defn.getCostPerEntry()).setFulltextIndex(defn.isFullTextEnabled()).setIncludesNodeData(false).setFilter(filter).setPathPrefix(getPathPrefix()).setDelayed(true).setAttribute(LucenePropertyIndex.ATTR_PLAN_RESULT, result).setEstimatedEntryCount(estimatedEntryCount());\n    }\n\n    private long estimatedEntryCount() {\n        org.apache.jackrabbit.oak.query.fulltext.FullTextExpression ft = filter.getFullTextConstraint();\n        if ((ft != null) && defn.isFullTextEnabled()) {\n            return defn.getFulltextEntryCount(getReader().numDocs());\n        }\n        return java.lang.Math.min(defn.getEntryCount(), getReader().numDocs());\n    }\n\n    private java.lang.String getPathPrefix() {\n        java.lang.String parentPath = org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(indexPath, 2);\n        return org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(parentPath) ? \"\" : parentPath;\n    }\n\n    private org.apache.lucene.index.IndexReader getReader() {\n        return indexNode.getSearcher().getIndexReader();\n    }\n\n    private java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> createSortOrder(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule rule) {\n        if (sortOrder == null) {\n            return java.util.Collections.emptyList();\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> orderEntries = com.google.common.collect.Lists.newArrayListWithCapacity(sortOrder.size());\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry o : sortOrder) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = rule.getConfig(o.getPropertyName());\n            if ((((pd != null) && pd.ordered) && (o.getPropertyType() != null)) && (!o.getPropertyType().isArray())) {\n                orderEntries.add(o);\n                result.sortedProperties.add(pd);\n            } else if (o.getPropertyName().equals(IndexDefinition.NATIVE_SORT_ORDER.getPropertyName())) {\n                orderEntries.add(IndexDefinition.NATIVE_SORT_ORDER);\n            }\n        }\n        return orderEntries;\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule getApplicableRule() {\n        if (filter.matchesAllTypes()) {\n            return defn.getApplicableIndexingRule(JcrConstants.NT_BASE);\n        } else {\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule rule : defn.getDefinedRules()) {\n                if (filter.getSupertypes().contains(rule.getNodeTypeName())) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule matchingRule = defn.getApplicableIndexingRule(rule.getNodeTypeName());\n                    if (matchingRule != null) {\n                        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.log.debug(\"Applicable IndexingRule found {}\", matchingRule);\n                        return rule;\n                    }\n                }\n                if (rule.getNodeTypeName().equals(JcrConstants.NT_BASE)) {\n                    return rule;\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.log.trace(\"No applicable IndexingRule found for any of the superTypes {}\", filter.getSupertypes());\n        }\n        return null;\n    }\n\n    private boolean notSupportedFeature() {\n        if (((filter.getPathRestriction() == Filter.PathRestriction.NO_RESTRICTION) && filter.matchesAllTypes()) && filter.getPropertyRestrictions().isEmpty()) {\n            return true;\n        }\n        return false;\n    }\n\n    public static class PlanResult {\n        final java.lang.String indexPath;\n\n        final org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition indexDefinition;\n\n        final org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule indexingRule;\n\n        private java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> sortedProperties = com.google.common.collect.Lists.newArrayList();\n\n        private java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> propDefns = com.google.common.collect.Maps.newHashMap();\n\n        private boolean nonFullTextConstraints;\n\n        private int parentDepth;\n\n        private java.lang.String parentPathSegment;\n\n        private boolean relativize;\n\n        public PlanResult(java.lang.String indexPath, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition defn, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule indexingRule) {\n            this.indexPath = indexPath;\n            this.indexDefinition = defn;\n            this.indexingRule = indexingRule;\n        }\n\n        public org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition getPropDefn(org.apache.jackrabbit.oak.plugins.index.lucene.PropertyRestriction pr) {\n            return propDefns.get(pr.propertyName);\n        }\n\n        public org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition getOrderedProperty(int index) {\n            return sortedProperties.get(index);\n        }\n\n        public boolean isPathTransformed() {\n            return relativize;\n        }\n\n        @javax.annotation.CheckForNull\n        public java.lang.String transformPath(java.lang.String path) {\n            if (isPathTransformed()) {\n                if (!path.endsWith(parentPathSegment)) {\n                    return null;\n                }\n                return getAncestorPath(path, parentDepth);\n            }\n            return path;\n        }\n\n        public boolean evaluateNonFullTextConstraints() {\n            return nonFullTextConstraints;\n        }\n\n        private void setParentPath(java.lang.String relativePath) {\n            parentPathSegment = \"/\" + relativePath;\n            if (relativePath.isEmpty()) {\n                enableNonFullTextConstraints();\n            } else {\n                relativize = true;\n                parentDepth = getDepth(relativePath);\n            }\n        }\n\n        private void enableNonFullTextConstraints() {\n            nonFullTextConstraints = true;\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "boolean canSort = canHandleSorting(sortOrder)",
            "src_parent": "{\n    org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.log.trace(\"Evaluating plan with index definition {}\", defn);\n    org.apache.jackrabbit.oak.query.fulltext.FullTextExpression ft = filter.getFullTextConstraint();\n    if (!defn.getVersion().isAtLeast(IndexFormatVersion.V2)) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.log.trace(\"Index is old format. Not supported\");\n        return null;\n    }\n    if ((ft != null) && (!defn.isFullTextEnabled())) {\n        return null;\n    }\n    org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule indexingRule = getApplicableRule();\n    if (indexingRule == null) {\n        return null;\n    }\n    if ((ft != null) && (!indexingRule.isFulltextEnabled())) {\n        return null;\n    }\n    result = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult(indexPath, defn, indexingRule);\n    if (defn.hasFunctionDefined() && (filter.getPropertyRestriction(defn.getFunctionName()) != null)) {\n        return defaultPlan().setEstimatedEntryCount(1);\n    }\n    java.util.List<java.lang.String> indexedProps = com.google.common.collect.Lists.newArrayListWithCapacity(filter.getPropertyRestrictions().size());\n    if (indexingRule.propertyIndexEnabled) {\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = indexingRule.getConfig(pr.propertyName);\n            if ((pd != null) && pd.propertyIndexEnabled()) {\n                indexedProps.add(pr.propertyName);\n                result.propDefns.put(pr.propertyName, pd);\n            }\n        }\n    }\n    boolean evalPathRestrictions = canEvalPathRestrictions(indexingRule);\n    boolean canEvalAlFullText = canEvalAllFullText(indexingRule, ft);\n    if ((ft != null) && (!canEvalAlFullText)) {\n        return null;\n    }\n    java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> sortOrder = createSortOrder(indexingRule);\n    boolean canSort = canHandleSorting(sortOrder);\n    if ((((!indexedProps.isEmpty()) || canSort) || (ft != null)) || evalPathRestrictions) {\n        int costPerEntryFactor = indexedProps.size();\n        costPerEntryFactor += sortOrder.size();\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan.Builder plan = defaultPlan();\n        if (!sortOrder.isEmpty()) {\n            plan.setSortOrder(sortOrder);\n        }\n        if (costPerEntryFactor == 0) {\n            costPerEntryFactor = 1;\n        }\n        if (ft == null) {\n            result.enableNonFullTextConstraints();\n        }\n        return plan.setCostPerEntry(defn.getCostPerEntry() / costPerEntryFactor);\n    }\n    return null;\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "canSort",
            "src_parent": "((!indexedProps.isEmpty()) || canSort)",
            "src_parent_type": "BinaryOperator",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "sortOrder.isEmpty()",
            "dst_parent": "if (sortOrder.isEmpty()) {\n    return false;\n}",
            "dst_parent_type": "If",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "sortOrder.isEmpty()",
            "src_parent": "(!sortOrder.isEmpty())",
            "src_parent_type": "UnaryOperator",
            "src_type": "Invocation"
          }
        }
      ],
      "file_name": "IndexPlanner"
    }
  ],
  "id": "jackrabbit-oak_beaca1a4"
}