{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "1.0",
            "src_parent": "getOptionalValue(defn, LuceneIndexConstants.COST_PER_ENTRY, 1.0)",
            "src_parent_type": "Invocation",
            "src_type": "Literal"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static double getDefaultCostPerEntry(org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion version) {\n    return version == IndexFormatVersion.V1 ? 1.5 : 1.0;\n}",
            "src_parent": "class IndexDefinition implements org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.AggregateMapper {\n    private static final java.lang.String OAK_CHILD_ORDER = \":childOrder\";\n\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.class);\n\n    static final int DEFAULT_ACTIVE_DELETE = -1;\n\n    static final int DEFAULT_BLOB_SIZE = (1024 * 1024) - 1024;\n\n    static final long DEFAULT_ENTRY_COUNT = 1000;\n\n    public static final int DEFAULT_MAX_FIELD_LENGTH = 10000;\n\n    static final int DEFAULT_MAX_EXTRACT_LENGTH = -10;\n\n    static final java.lang.String INDEX_VERSION = \":version\";\n\n    private static java.lang.String TYPES_ALLOW_ALL_NAME = \"all\";\n\n    static final int TYPES_ALLOW_NONE = javax.jcr.PropertyType.UNDEFINED;\n\n    static final int TYPES_ALLOW_ALL = -1;\n\n    static final int DEFAULT_SUGGESTER_UPDATE_FREQUENCY_MINUTES = 10;\n\n    static final org.apache.jackrabbit.oak.spi.query.QueryIndex.OrderEntry NATIVE_SORT_ORDER = new org.apache.jackrabbit.oak.spi.query.QueryIndex.OrderEntry(org.apache.jackrabbit.JcrConstants.JCR_SCORE, org.apache.jackrabbit.oak.api.Type.UNDEFINED, OrderEntry.Order.DESCENDING);\n\n    private final boolean fullTextEnabled;\n\n    private final org.apache.jackrabbit.oak.spi.state.NodeState definition;\n\n    private final org.apache.jackrabbit.oak.spi.state.NodeState root;\n\n    private final java.lang.String funcName;\n\n    private final int activeDelete;\n\n    private final int blobSize;\n\n    private final org.apache.lucene.codecs.Codec codec;\n\n    private final long entryCount;\n\n    private final boolean entryCountDefined;\n\n    private final double costPerEntry;\n\n    private final double costPerExecution;\n\n    private final java.util.Map<java.lang.String, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule>> indexRules;\n\n    private final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> definedRules;\n\n    private final java.lang.String indexName;\n\n    private final boolean testMode;\n\n    private final boolean evaluatePathRestrictions;\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion version;\n\n    private final java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate> aggregates;\n\n    private final boolean indexesAllTypes;\n\n    private final org.apache.lucene.analysis.Analyzer analyzer;\n\n    private final java.lang.String scorerProviderName;\n\n    private final java.util.Map<java.lang.String, org.apache.lucene.analysis.Analyzer> analyzers;\n\n    private final boolean hasCustomTikaConfig;\n\n    private final int maxFieldLength;\n\n    private final int maxExtractLength;\n\n    private final int suggesterUpdateFrequencyMinutes;\n\n    private final long reindexCount;\n\n    private final org.apache.jackrabbit.oak.plugins.index.PathFilter pathFilter;\n\n    @javax.annotation.Nullable\n    private final java.lang.String[] queryPaths;\n\n    private final boolean saveDirListing;\n\n    private final boolean suggestAnalyzed;\n\n    private final boolean secureFacets;\n\n    private final boolean suggestEnabled;\n\n    private final boolean spellcheckEnabled;\n\n    private final java.lang.String indexPath;\n\n    public IndexDefinition(org.apache.jackrabbit.oak.spi.state.NodeState root, org.apache.jackrabbit.oak.spi.state.NodeBuilder defn) {\n        this(root, defn.getBaseState(), defn);\n    }\n\n    public IndexDefinition(org.apache.jackrabbit.oak.spi.state.NodeState root, org.apache.jackrabbit.oak.spi.state.NodeState defn) {\n        this(root, defn, null);\n    }\n\n    public IndexDefinition(org.apache.jackrabbit.oak.spi.state.NodeState root, org.apache.jackrabbit.oak.spi.state.NodeState defn, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder defnb) {\n        this.root = root;\n        this.version = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.determineIndexFormatVersion(defn, defnb);\n        this.definition = defn;\n        this.indexPath = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.determineIndexPath(defn, defnb);\n        this.indexName = indexPath;\n        this.blobSize = getOptionalValue(defn, org.apache.jackrabbit.oak.plugins.index.lucene.BLOB_SIZE, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.DEFAULT_BLOB_SIZE);\n        this.activeDelete = getOptionalValue(defn, org.apache.jackrabbit.oak.plugins.index.lucene.ACTIVE_DELETE, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.DEFAULT_ACTIVE_DELETE);\n        this.testMode = getOptionalValue(defn, LuceneIndexConstants.TEST_MODE, false);\n        this.aggregates = collectAggregates(defn);\n        org.apache.jackrabbit.oak.spi.state.NodeState rulesState = defn.getChildNode(LuceneIndexConstants.INDEX_RULES);\n        if (!rulesState.exists()) {\n            rulesState = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.createIndexRules(defn).getNodeState();\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> definedIndexRules = com.google.common.collect.Lists.newArrayList();\n        this.indexRules = collectIndexRules(rulesState, definedIndexRules);\n        this.definedRules = com.google.common.collect.ImmutableList.copyOf(definedIndexRules);\n        this.fullTextEnabled = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.hasFulltextEnabledIndexRule(definedIndexRules);\n        this.evaluatePathRestrictions = getOptionalValue(defn, org.apache.jackrabbit.oak.plugins.index.lucene.EVALUATE_PATH_RESTRICTION, false);\n        java.lang.String functionName = getOptionalValue(defn, LuceneIndexConstants.FUNC_NAME, null);\n        if (fullTextEnabled && (functionName == null)) {\n            functionName = \"lucene\";\n        }\n        this.funcName = (functionName != null) ? \"native*\" + functionName : null;\n        this.codec = createCodec();\n        if (defn.hasProperty(org.apache.jackrabbit.oak.plugins.index.IndexConstants.ENTRY_COUNT_PROPERTY_NAME)) {\n            this.entryCountDefined = true;\n            this.entryCount = defn.getProperty(org.apache.jackrabbit.oak.plugins.index.IndexConstants.ENTRY_COUNT_PROPERTY_NAME).getValue(Type.LONG);\n        } else {\n            this.entryCountDefined = false;\n            this.entryCount = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.DEFAULT_ENTRY_COUNT;\n        }\n        this.maxFieldLength = getOptionalValue(defn, LuceneIndexConstants.MAX_FIELD_LENGTH, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.DEFAULT_MAX_FIELD_LENGTH);\n        this.costPerEntry = getOptionalValue(defn, LuceneIndexConstants.COST_PER_ENTRY, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getDefaultCostPerEntry(version));\n        this.costPerExecution = getOptionalValue(defn, LuceneIndexConstants.COST_PER_EXECUTION, 1.0);\n        this.indexesAllTypes = areAllTypesIndexed();\n        this.analyzers = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.collectAnalyzers(defn);\n        this.analyzer = createAnalyzer();\n        this.hasCustomTikaConfig = getTikaConfigNode().exists();\n        this.maxExtractLength = determineMaxExtractLength();\n        this.suggesterUpdateFrequencyMinutes = evaluateSuggesterUpdateFrequencyMinutes(defn, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.DEFAULT_SUGGESTER_UPDATE_FREQUENCY_MINUTES);\n        this.scorerProviderName = getOptionalValue(defn, LuceneIndexConstants.PROP_SCORER_PROVIDER, null);\n        this.reindexCount = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.determineReindexCount(defn, defnb);\n        this.pathFilter = org.apache.jackrabbit.oak.plugins.index.PathFilter.from(new org.apache.jackrabbit.oak.spi.state.ReadOnlyBuilder(defn));\n        this.queryPaths = getQueryPaths(defn);\n        this.saveDirListing = getOptionalValue(defn, LuceneIndexConstants.SAVE_DIR_LISTING, true);\n        this.suggestAnalyzed = evaluateSuggestAnalyzed(defn, false);\n        this.secureFacets = defn.hasChildNode(org.apache.jackrabbit.oak.plugins.index.lucene.FACETS) && getOptionalValue(defn.getChildNode(org.apache.jackrabbit.oak.plugins.index.lucene.FACETS), org.apache.jackrabbit.oak.plugins.index.lucene.PROP_SECURE_FACETS, true);\n        this.suggestEnabled = evaluateSuggestionEnabled();\n        this.spellcheckEnabled = evaluateSpellcheckEnabled();\n    }\n\n    public org.apache.jackrabbit.oak.spi.state.NodeState getDefinitionNodeState() {\n        return definition;\n    }\n\n    public boolean isFullTextEnabled() {\n        return fullTextEnabled;\n    }\n\n    public java.lang.String getFunctionName() {\n        return funcName;\n    }\n\n    public boolean hasFunctionDefined() {\n        return funcName != null;\n    }\n\n    public int getBlobSize() {\n        return blobSize;\n    }\n\n    public org.apache.lucene.codecs.Codec getCodec() {\n        return codec;\n    }\n\n    public long getReindexCount() {\n        return reindexCount;\n    }\n\n    public long getEntryCount() {\n        return entryCount;\n    }\n\n    private int evaluateSuggesterUpdateFrequencyMinutes(org.apache.jackrabbit.oak.spi.state.NodeState defn, int defaultValue) {\n        org.apache.jackrabbit.oak.spi.state.NodeState suggestionConfig = defn.getChildNode(LuceneIndexConstants.SUGGESTION_CONFIG);\n        if (!suggestionConfig.exists()) {\n            return getOptionalValue(defn, LuceneIndexConstants.SUGGEST_UPDATE_FREQUENCY_MINUTES, defaultValue);\n        }\n        return getOptionalValue(suggestionConfig, LuceneIndexConstants.SUGGEST_UPDATE_FREQUENCY_MINUTES, defaultValue);\n    }\n\n    public int getSuggesterUpdateFrequencyMinutes() {\n        return suggesterUpdateFrequencyMinutes;\n    }\n\n    public boolean isEntryCountDefined() {\n        return entryCountDefined;\n    }\n\n    public double getCostPerEntry() {\n        return costPerEntry;\n    }\n\n    public double getCostPerExecution() {\n        return costPerExecution;\n    }\n\n    public long getFulltextEntryCount(long numOfDocs) {\n        if (isEntryCountDefined()) {\n            return java.lang.Math.min(getEntryCount(), numOfDocs);\n        }\n        return numOfDocs;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion getVersion() {\n        return version;\n    }\n\n    public boolean isOfOldFormat() {\n        return !org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.hasIndexingRules(definition);\n    }\n\n    public boolean isTestMode() {\n        return testMode;\n    }\n\n    public boolean evaluatePathRestrictions() {\n        return evaluatePathRestrictions;\n    }\n\n    public boolean indexesAllTypes() {\n        return indexesAllTypes;\n    }\n\n    public org.apache.lucene.analysis.Analyzer getAnalyzer() {\n        return analyzer;\n    }\n\n    public boolean hasCustomTikaConfig() {\n        return hasCustomTikaConfig;\n    }\n\n    public java.io.InputStream getTikaConfig() {\n        return org.apache.jackrabbit.oak.plugins.index.lucene.util.ConfigUtil.getBlob(getTikaConfigNode(), org.apache.jackrabbit.oak.plugins.index.lucene.TIKA_CONFIG).getNewStream();\n    }\n\n    public java.lang.String getIndexName() {\n        return indexName;\n    }\n\n    public int getMaxExtractLength() {\n        return maxExtractLength;\n    }\n\n    public java.lang.String getScorerProviderName() {\n        return scorerProviderName;\n    }\n\n    public boolean saveDirListing() {\n        return saveDirListing;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.index.PathFilter getPathFilter() {\n        return pathFilter;\n    }\n\n    @javax.annotation.Nullable\n    public java.lang.String[] getQueryPaths() {\n        return queryPaths;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return \"Lucene Index : \" + indexName;\n    }\n\n    private org.apache.lucene.analysis.Analyzer createAnalyzer() {\n        org.apache.lucene.analysis.Analyzer result;\n        org.apache.lucene.analysis.Analyzer defaultAnalyzer = org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.LuceneIndexConstants.ANALYZER;\n        if (analyzers.containsKey(LuceneIndexConstants.ANL_DEFAULT)) {\n            defaultAnalyzer = analyzers.get(LuceneIndexConstants.ANL_DEFAULT);\n        }\n        if (!evaluatePathRestrictions()) {\n            result = defaultAnalyzer;\n        } else {\n            java.util.Map<java.lang.String, org.apache.lucene.analysis.Analyzer> analyzerMap = com.google.common.collect.ImmutableMap.<java.lang.String, org.apache.lucene.analysis.Analyzer>builder().put(FieldNames.ANCESTORS, new org.apache.jackrabbit.oak.plugins.index.lucene.util.TokenizerChain(new org.apache.lucene.analysis.path.PathHierarchyTokenizerFactory(java.util.Collections.<java.lang.String, java.lang.String>emptyMap()))).build();\n            result = new org.apache.lucene.analysis.miscellaneous.PerFieldAnalyzerWrapper(defaultAnalyzer, analyzerMap);\n        }\n        if (maxFieldLength < 0) {\n            return result;\n        }\n        return new org.apache.lucene.analysis.miscellaneous.LimitTokenCountAnalyzer(result, maxFieldLength);\n    }\n\n    private static java.util.Map<java.lang.String, org.apache.lucene.analysis.Analyzer> collectAnalyzers(org.apache.jackrabbit.oak.spi.state.NodeState defn) {\n        java.util.Map<java.lang.String, org.apache.lucene.analysis.Analyzer> analyzerMap = com.google.common.collect.Maps.newHashMap();\n        org.apache.jackrabbit.oak.plugins.index.lucene.NodeStateAnalyzerFactory factory = new org.apache.jackrabbit.oak.plugins.index.lucene.NodeStateAnalyzerFactory(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.LuceneIndexConstants.VERSION);\n        for (org.apache.jackrabbit.oak.spi.state.ChildNodeEntry cne : defn.getChildNode(LuceneIndexConstants.ANALYZERS).getChildNodeEntries()) {\n            org.apache.lucene.analysis.Analyzer a = factory.createInstance(cne.getNodeState());\n            analyzerMap.put(cne.getName(), a);\n        }\n        return com.google.common.collect.ImmutableMap.copyOf(analyzerMap);\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate getAggregate(java.lang.String nodeType) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate agg = aggregates.get(nodeType);\n        return agg != null ? agg : null;\n    }\n\n    private java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate> collectAggregates(org.apache.jackrabbit.oak.spi.state.NodeState defn) {\n        java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate> aggregateMap = com.google.common.collect.Maps.newHashMap();\n        for (org.apache.jackrabbit.oak.spi.state.ChildNodeEntry cne : defn.getChildNode(LuceneIndexConstants.AGGREGATES).getChildNodeEntries()) {\n            java.lang.String nodeType = cne.getName();\n            int recursionLimit = getOptionalValue(cne.getNodeState(), LuceneIndexConstants.AGG_RECURSIVE_LIMIT, Aggregate.RECURSIVE_AGGREGATION_LIMIT_DEFAULT);\n            java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Include> includes = com.google.common.collect.Lists.newArrayList();\n            for (org.apache.jackrabbit.oak.spi.state.ChildNodeEntry include : cne.getNodeState().getChildNodeEntries()) {\n                org.apache.jackrabbit.oak.spi.state.NodeState is = include.getNodeState();\n                java.lang.String primaryType = is.getString(LuceneIndexConstants.AGG_PRIMARY_TYPE);\n                java.lang.String path = is.getString(LuceneIndexConstants.AGG_PATH);\n                boolean relativeNode = getOptionalValue(is, LuceneIndexConstants.AGG_RELATIVE_NODE, false);\n                if (path == null) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.log.warn(\"Aggregate pattern in {} does not have required property [{}]. {} aggregate rule would \" + \"be ignored\", this, LuceneIndexConstants.AGG_PATH, include.getName());\n                    continue;\n                }\n                includes.add(new org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.NodeInclude(this, primaryType, path, relativeNode));\n            }\n            aggregateMap.put(nodeType, new org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate(nodeType, includes, recursionLimit));\n        }\n        return com.google.common.collect.ImmutableMap.copyOf(aggregateMap);\n    }\n\n    public java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> getDefinedRules() {\n        return definedRules;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule getApplicableIndexingRule(java.lang.String primaryNodeType) {\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> rules = null;\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> r = indexRules.get(primaryNodeType);\n        if (r != null) {\n            rules = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule>();\n            rules.addAll(r);\n        }\n        if (rules != null) {\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule rule : rules) {\n                if (rule.appliesTo(primaryNodeType)) {\n                    return rule;\n                }\n            }\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule getApplicableIndexingRule(org.apache.jackrabbit.oak.api.Tree state) {\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> rules = null;\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> r = indexRules.get(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getPrimaryTypeName(state));\n        if (r != null) {\n            rules = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule>();\n            rules.addAll(r);\n        }\n        for (java.lang.String name : org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getMixinTypeNames(state)) {\n            r = indexRules.get(name);\n            if (r != null) {\n                if (rules == null) {\n                    rules = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule>();\n                }\n                rules.addAll(r);\n            }\n        }\n        if (rules != null) {\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule rule : rules) {\n                if (rule.appliesTo(state)) {\n                    return rule;\n                }\n            }\n        }\n        return null;\n    }\n\n    private java.util.Map<java.lang.String, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule>> collectIndexRules(org.apache.jackrabbit.oak.spi.state.NodeState indexRules, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> definedIndexRules) {\n        if (!indexRules.exists()) {\n            return java.util.Collections.emptyMap();\n        }\n        if (!org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.hasOrderableChildren(indexRules)) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.log.warn(\"IndexRule node does not have orderable children in [{}]\", this);\n        }\n        java.util.Map<java.lang.String, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule>> nt2rules = com.google.common.collect.Maps.newHashMap();\n        org.apache.jackrabbit.oak.plugins.nodetype.ReadOnlyNodeTypeManager ntReg = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.createNodeTypeManager(org.apache.jackrabbit.oak.plugins.tree.TreeFactory.createReadOnlyTree(root));\n        org.apache.jackrabbit.oak.api.Tree ruleTree = org.apache.jackrabbit.oak.plugins.tree.TreeFactory.createReadOnlyTree(indexRules);\n        final java.util.List<java.lang.String> allNames = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getAllNodeTypes(ntReg);\n        for (org.apache.jackrabbit.oak.api.Tree ruleEntry : ruleTree.getChildren()) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule rule = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule(ruleEntry.getName(), indexRules.getChildNode(ruleEntry.getName()));\n            definedIndexRules.add(rule);\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.log.trace(\"Found rule '{}' for NodeType '{}'\", rule, rule.getNodeTypeName());\n            java.util.List<java.lang.String> ntNames = allNames;\n            if (!rule.inherited) {\n                ntNames = java.util.Collections.singletonList(rule.getNodeTypeName());\n            }\n            for (java.lang.String ntName : ntNames) {\n                if (ntReg.isNodeType(ntName, rule.getNodeTypeName())) {\n                    java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> perNtConfig = nt2rules.get(ntName);\n                    if (perNtConfig == null) {\n                        perNtConfig = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule>();\n                        nt2rules.put(ntName, perNtConfig);\n                    }\n                    org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.log.trace(\"Registering rule '{}' for name '{}'\", rule, ntName);\n                    perNtConfig.add(new org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule(rule, ntName));\n                }\n            }\n        }\n        for (java.util.Map.Entry<java.lang.String, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule>> e : nt2rules.entrySet()) {\n            e.setValue(com.google.common.collect.ImmutableList.copyOf(e.getValue()));\n        }\n        return com.google.common.collect.ImmutableMap.copyOf(nt2rules);\n    }\n\n    private boolean areAllTypesIndexed() {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule ntBaseRule = getApplicableIndexingRule(org.apache.jackrabbit.JcrConstants.NT_BASE);\n        return ntBaseRule != null;\n    }\n\n    private boolean evaluateSuggestionEnabled() {\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule indexingRule : definedRules) {\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition propertyDefinition : indexingRule.propConfigs.values()) {\n                if (propertyDefinition.useInSuggest) {\n                    return true;\n                }\n            }\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern np : indexingRule.namePatterns) {\n                if (np.getConfig().useInSuggest) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean isSuggestEnabled() {\n        return suggestEnabled;\n    }\n\n    private boolean evaluateSpellcheckEnabled() {\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule indexingRule : definedRules) {\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition propertyDefinition : indexingRule.propConfigs.values()) {\n                if (propertyDefinition.useInSpellcheck) {\n                    return true;\n                }\n            }\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern np : indexingRule.namePatterns) {\n                if (np.getConfig().useInSpellcheck) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean isSpellcheckEnabled() {\n        return spellcheckEnabled;\n    }\n\n    public java.lang.String getIndexPathFromConfig() {\n        return com.google.common.base.Preconditions.checkNotNull(indexPath, \"Index path property [%s] not found\", IndexConstants.INDEX_PATH);\n    }\n\n    private boolean evaluateSuggestAnalyzed(org.apache.jackrabbit.oak.spi.state.NodeState defn, boolean defaultValue) {\n        org.apache.jackrabbit.oak.spi.state.NodeState suggestionConfig = defn.getChildNode(LuceneIndexConstants.SUGGESTION_CONFIG);\n        if (!suggestionConfig.exists()) {\n            return getOptionalValue(defn, LuceneIndexConstants.SUGGEST_ANALYZED, defaultValue);\n        }\n        return getOptionalValue(suggestionConfig, LuceneIndexConstants.SUGGEST_ANALYZED, defaultValue);\n    }\n\n    public boolean isSuggestAnalyzed() {\n        return suggestAnalyzed;\n    }\n\n    public boolean isSecureFacets() {\n        return secureFacets;\n    }\n\n    public class IndexingRule {\n        private final java.lang.String baseNodeType;\n\n        private final java.lang.String nodeTypeName;\n\n        private final java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> propConfigs;\n\n        private final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern> namePatterns;\n\n        private final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> nullCheckEnabledProperties;\n\n        private final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> notNullCheckEnabledProperties;\n\n        private final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> nodeScopeAnalyzedProps;\n\n        private final boolean indexesAllNodesOfMatchingType;\n\n        private final boolean nodeNameIndexed;\n\n        final float boost;\n\n        final boolean inherited;\n\n        final int propertyTypes;\n\n        final boolean fulltextEnabled;\n\n        final boolean propertyIndexEnabled;\n\n        final boolean nodeFullTextIndexed;\n\n        final org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate aggregate;\n\n        final org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate propAggregate;\n\n        IndexingRule(java.lang.String nodeTypeName, org.apache.jackrabbit.oak.spi.state.NodeState config) {\n            this.nodeTypeName = nodeTypeName;\n            this.baseNodeType = nodeTypeName;\n            this.boost = getOptionalValue(config, org.apache.jackrabbit.oak.plugins.index.lucene.FIELD_BOOST, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition.DEFAULT_BOOST);\n            this.inherited = getOptionalValue(config, LuceneIndexConstants.RULE_INHERITED, true);\n            this.propertyTypes = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getSupportedTypes(config, org.apache.jackrabbit.oak.plugins.index.lucene.INCLUDE_PROPERTY_TYPES, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.TYPES_ALLOW_ALL);\n            java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern> namePatterns = com.google.common.collect.Lists.newArrayList();\n            java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> nonExistentProperties = com.google.common.collect.Lists.newArrayList();\n            java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> existentProperties = com.google.common.collect.Lists.newArrayList();\n            java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> nodeScopeAnalyzedProps = com.google.common.collect.Lists.newArrayList();\n            java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Include> propIncludes = com.google.common.collect.Lists.newArrayList();\n            this.propConfigs = collectPropConfigs(config, namePatterns, propIncludes, nonExistentProperties, existentProperties, nodeScopeAnalyzedProps);\n            this.propAggregate = new org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate(nodeTypeName, propIncludes);\n            this.aggregate = combine(propAggregate, nodeTypeName);\n            this.namePatterns = com.google.common.collect.ImmutableList.copyOf(namePatterns);\n            this.nodeScopeAnalyzedProps = com.google.common.collect.ImmutableList.copyOf(nodeScopeAnalyzedProps);\n            this.nullCheckEnabledProperties = com.google.common.collect.ImmutableList.copyOf(nonExistentProperties);\n            this.notNullCheckEnabledProperties = com.google.common.collect.ImmutableList.copyOf(existentProperties);\n            this.fulltextEnabled = aggregate.hasNodeAggregates() || hasAnyFullTextEnabledProperty();\n            this.nodeFullTextIndexed = aggregate.hasNodeAggregates() || anyNodeScopeIndexedProperty();\n            this.propertyIndexEnabled = hasAnyPropertyIndexConfigured();\n            this.indexesAllNodesOfMatchingType = areAlMatchingNodeByTypeIndexed();\n            this.nodeNameIndexed = evaluateNodeNameIndexed(config);\n            validateRuleDefinition();\n        }\n\n        IndexingRule(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule original, java.lang.String nodeTypeName) {\n            this.nodeTypeName = nodeTypeName;\n            this.baseNodeType = original.getNodeTypeName();\n            this.propConfigs = original.propConfigs;\n            this.namePatterns = original.namePatterns;\n            this.boost = original.boost;\n            this.inherited = original.inherited;\n            this.propertyTypes = original.propertyTypes;\n            this.propertyIndexEnabled = original.propertyIndexEnabled;\n            this.propAggregate = original.propAggregate;\n            this.nullCheckEnabledProperties = original.nullCheckEnabledProperties;\n            this.notNullCheckEnabledProperties = original.notNullCheckEnabledProperties;\n            this.nodeScopeAnalyzedProps = original.nodeScopeAnalyzedProps;\n            this.aggregate = combine(propAggregate, nodeTypeName);\n            this.fulltextEnabled = aggregate.hasNodeAggregates() || original.fulltextEnabled;\n            this.nodeFullTextIndexed = aggregate.hasNodeAggregates() || original.nodeFullTextIndexed;\n            this.indexesAllNodesOfMatchingType = areAlMatchingNodeByTypeIndexed();\n            this.nodeNameIndexed = original.nodeNameIndexed;\n        }\n\n        public boolean isIndexed(java.lang.String propertyName) {\n            return getConfig(propertyName) != null;\n        }\n\n        public java.lang.String getNodeTypeName() {\n            return nodeTypeName;\n        }\n\n        public java.lang.String getBaseNodeType() {\n            return baseNodeType;\n        }\n\n        public java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> getNullCheckEnabledProperties() {\n            return nullCheckEnabledProperties;\n        }\n\n        public java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> getNotNullCheckEnabledProperties() {\n            return notNullCheckEnabledProperties;\n        }\n\n        public java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> getNodeScopeAnalyzedProps() {\n            return nodeScopeAnalyzedProps;\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            java.lang.String str = \"IndexRule: \" + nodeTypeName;\n            if (!baseNodeType.equals(nodeTypeName)) {\n                str += (\"(\" + baseNodeType) + \")\";\n            }\n            return str;\n        }\n\n        public boolean isAggregated(java.lang.String nodePath) {\n            return aggregate.hasRelativeNodeInclude(nodePath);\n        }\n\n        public boolean appliesTo(org.apache.jackrabbit.oak.api.Tree state) {\n            for (java.lang.String mixinName : org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getMixinTypeNames(state)) {\n                if (nodeTypeName.equals(mixinName)) {\n                    return true;\n                }\n            }\n            if (!nodeTypeName.equals(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getPrimaryTypeName(state))) {\n                return false;\n            }\n            return true;\n        }\n\n        public boolean appliesTo(java.lang.String nodeTypeName) {\n            if (!this.nodeTypeName.equals(nodeTypeName)) {\n                return false;\n            }\n            return true;\n        }\n\n        public boolean isNodeNameIndexed() {\n            return nodeNameIndexed;\n        }\n\n        public boolean isFulltextEnabled() {\n            return fulltextEnabled;\n        }\n\n        public boolean isNodeFullTextIndexed() {\n            return nodeFullTextIndexed;\n        }\n\n        @javax.annotation.CheckForNull\n        public org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition getConfig(java.lang.String propertyName) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition config = propConfigs.get(propertyName.toLowerCase(java.util.Locale.ENGLISH));\n            if (config != null) {\n                return config;\n            } else if (namePatterns.size() > 0) {\n                for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern np : namePatterns) {\n                    if (np.matches(propertyName)) {\n                        return np.getConfig();\n                    }\n                }\n            }\n            return null;\n        }\n\n        public boolean includePropertyType(int type) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.includePropertyType(propertyTypes, type);\n        }\n\n        public org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate getAggregate() {\n            return aggregate;\n        }\n\n        public boolean indexesAllNodesOfMatchingType() {\n            return indexesAllNodesOfMatchingType;\n        }\n\n        public boolean isBasedOnNtBase() {\n            return JcrConstants.NT_BASE.equals(baseNodeType);\n        }\n\n        private java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> collectPropConfigs(org.apache.jackrabbit.oak.spi.state.NodeState config, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern> patterns, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Include> propAggregate, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> nonExistentProperties, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> existentProperties, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> nodeScopeAnalyzedProps) {\n            java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition> propDefns = com.google.common.collect.Maps.newHashMap();\n            org.apache.jackrabbit.oak.spi.state.NodeState propNode = config.getChildNode(LuceneIndexConstants.PROP_NODE);\n            if (!propNode.exists()) {\n                return java.util.Collections.emptyMap();\n            }\n            if (!org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.hasOrderableChildren(propNode)) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.log.warn(\"Properties node for [{}] does not have orderable \" + \"children in [{}]\", this, IndexDefinition.this);\n            }\n            org.apache.jackrabbit.oak.api.Tree propTree = org.apache.jackrabbit.oak.plugins.tree.TreeFactory.createReadOnlyTree(propNode);\n            for (org.apache.jackrabbit.oak.api.Tree prop : propTree.getChildren()) {\n                java.lang.String propName = prop.getName();\n                org.apache.jackrabbit.oak.spi.state.NodeState propDefnNode = propNode.getChildNode(propName);\n                if (propDefnNode.exists() && (!propDefns.containsKey(propName))) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = new org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition(this, propName, propDefnNode);\n                    if (pd.isRegexp) {\n                        patterns.add(new org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern(pd.name, pd));\n                    } else {\n                        propDefns.put(pd.name.toLowerCase(java.util.Locale.ENGLISH), pd);\n                    }\n                    if (pd.relative) {\n                        propAggregate.add(new org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.PropertyInclude(pd));\n                    }\n                    if (pd.nullCheckEnabled) {\n                        nonExistentProperties.add(pd);\n                    }\n                    if (pd.notNullCheckEnabled) {\n                        existentProperties.add(pd);\n                    }\n                    if ((pd.nodeScopeIndex && pd.analyzed) && (!pd.isRegexp)) {\n                        nodeScopeAnalyzedProps.add(pd);\n                    }\n                }\n            }\n            return com.google.common.collect.ImmutableMap.copyOf(propDefns);\n        }\n\n        private boolean hasAnyFullTextEnabledProperty() {\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : propConfigs.values()) {\n                if (pd.fulltextEnabled()) {\n                    return true;\n                }\n            }\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern np : namePatterns) {\n                if (np.getConfig().fulltextEnabled()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private boolean hasAnyPropertyIndexConfigured() {\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : propConfigs.values()) {\n                if (pd.propertyIndex) {\n                    return true;\n                }\n            }\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern np : namePatterns) {\n                if (np.getConfig().propertyIndex) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private boolean anyNodeScopeIndexedProperty() {\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : propConfigs.values()) {\n                if (pd.nodeScopeIndex) {\n                    return true;\n                }\n            }\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NamePattern np : namePatterns) {\n                if (np.getConfig().nodeScopeIndex) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private boolean areAlMatchingNodeByTypeIndexed() {\n            if (nodeFullTextIndexed) {\n                return true;\n            }\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : nullCheckEnabledProperties) {\n                if (!pd.relative) {\n                    return true;\n                }\n            }\n            if (getConfig(JcrConstants.JCR_PRIMARYTYPE) != null) {\n                return true;\n            }\n            return false;\n        }\n\n        private boolean evaluateNodeNameIndexed(org.apache.jackrabbit.oak.spi.state.NodeState config) {\n            if (getOptionalValue(config, LuceneIndexConstants.INDEX_NODE_NAME, false)) {\n                return true;\n            }\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : propConfigs.values()) {\n                if (LuceneIndexConstants.PROPDEF_PROP_NODE_NAME.equals(pd.name)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        private org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate combine(org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate propAggregate, java.lang.String nodeTypeName) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate nodeTypeAgg = IndexDefinition.this.getAggregate(nodeTypeName);\n            java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Include> includes = com.google.common.collect.Lists.newArrayList();\n            includes.addAll(propAggregate.getIncludes());\n            if (nodeTypeAgg != null) {\n                includes.addAll(nodeTypeAgg.getIncludes());\n            }\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate(nodeTypeName, includes);\n        }\n\n        private void validateRuleDefinition() {\n            if ((!nullCheckEnabledProperties.isEmpty()) && isBasedOnNtBase()) {\n                throw new java.lang.IllegalStateException(\"nt:base based rule cannot have a \" + \"PropertyDefinition with nullCheckEnabled\");\n            }\n        }\n    }\n\n    private static final class NamePattern {\n        private final java.lang.String parentPath;\n\n        private final java.util.regex.Pattern pattern;\n\n        private final org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition config;\n\n        private NamePattern(java.lang.String pattern, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition config) {\n            if (LuceneIndexConstants.REGEX_ALL_PROPS.equals(pattern)) {\n                this.parentPath = \"\";\n                this.pattern = java.util.regex.Pattern.compile(pattern);\n            } else {\n                this.parentPath = getParentPath(pattern);\n                this.pattern = java.util.regex.Pattern.compile(org.apache.jackrabbit.oak.commons.PathUtils.getName(pattern));\n            }\n            this.config = config;\n        }\n\n        boolean matches(java.lang.String propertyPath) {\n            java.lang.String parentPath = getParentPath(propertyPath);\n            java.lang.String propertyName = org.apache.jackrabbit.oak.commons.PathUtils.getName(propertyPath);\n            if (!this.parentPath.equals(parentPath)) {\n                return false;\n            }\n            return pattern.matcher(propertyName).matches();\n        }\n\n        org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition getConfig() {\n            return config;\n        }\n    }\n\n    public static org.apache.jackrabbit.oak.spi.state.NodeBuilder updateDefinition(org.apache.jackrabbit.oak.spi.state.NodeBuilder indexDefn) {\n        org.apache.jackrabbit.oak.spi.state.NodeState defn = indexDefn.getBaseState();\n        if (!org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.hasIndexingRules(defn)) {\n            org.apache.jackrabbit.oak.spi.state.NodeState rulesState = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.createIndexRules(defn).getNodeState();\n            indexDefn.setChildNode(LuceneIndexConstants.INDEX_RULES, rulesState);\n            indexDefn.setProperty(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.INDEX_VERSION, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.determineIndexFormatVersion(defn, indexDefn).getVersion());\n            indexDefn.removeProperty(org.apache.jackrabbit.oak.plugins.index.IndexConstants.DECLARING_NODE_TYPES);\n            indexDefn.removeProperty(org.apache.jackrabbit.oak.plugins.index.lucene.INCLUDE_PROPERTY_NAMES);\n            indexDefn.removeProperty(org.apache.jackrabbit.oak.plugins.index.lucene.EXCLUDE_PROPERTY_NAMES);\n            indexDefn.removeProperty(org.apache.jackrabbit.oak.plugins.index.lucene.ORDERED_PROP_NAMES);\n            indexDefn.removeProperty(org.apache.jackrabbit.oak.plugins.index.lucene.FULL_TEXT_ENABLED);\n            indexDefn.child(org.apache.jackrabbit.oak.plugins.index.lucene.PROP_NODE).remove();\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.log.info(\"Updated index definition for {}\", indexDefn.getString(org.apache.jackrabbit.oak.plugins.index.IndexConstants.INDEX_PATH));\n        }\n        return indexDefn;\n    }\n\n    private static org.apache.jackrabbit.oak.spi.state.NodeBuilder createIndexRules(org.apache.jackrabbit.oak.spi.state.NodeState defn) {\n        org.apache.jackrabbit.oak.spi.state.NodeBuilder builder = org.apache.jackrabbit.oak.plugins.index.lucene.EMPTY_NODE.builder();\n        java.util.Set<java.lang.String> declaringNodeTypes = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getMultiProperty(defn, org.apache.jackrabbit.oak.plugins.index.IndexConstants.DECLARING_NODE_TYPES);\n        java.util.Set<java.lang.String> includes = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getMultiProperty(defn, org.apache.jackrabbit.oak.plugins.index.lucene.INCLUDE_PROPERTY_NAMES);\n        java.util.Set<java.lang.String> excludes = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.toLowerCase(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getMultiProperty(defn, org.apache.jackrabbit.oak.plugins.index.lucene.EXCLUDE_PROPERTY_NAMES));\n        java.util.Set<java.lang.String> orderedProps = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getMultiProperty(defn, org.apache.jackrabbit.oak.plugins.index.lucene.ORDERED_PROP_NAMES);\n        boolean fullTextEnabled = getOptionalValue(defn, org.apache.jackrabbit.oak.plugins.index.lucene.FULL_TEXT_ENABLED, true);\n        boolean storageEnabled = getOptionalValue(defn, org.apache.jackrabbit.oak.plugins.index.lucene.EXPERIMENTAL_STORAGE, true);\n        org.apache.jackrabbit.oak.spi.state.NodeState propNodeState = defn.getChildNode(LuceneIndexConstants.PROP_NODE);\n        if (declaringNodeTypes.isEmpty()) {\n            declaringNodeTypes = java.util.Collections.singleton(org.apache.jackrabbit.JcrConstants.NT_BASE);\n        }\n        java.util.Set<java.lang.String> propNamesSet = com.google.common.collect.Sets.newHashSet();\n        propNamesSet.addAll(includes);\n        propNamesSet.addAll(excludes);\n        propNamesSet.addAll(orderedProps);\n        for (org.apache.jackrabbit.oak.spi.state.ChildNodeEntry cne : propNodeState.getChildNodeEntries()) {\n            if ((!propNamesSet.contains(cne.getName())) && com.google.common.collect.Iterables.isEmpty(cne.getNodeState().getChildNodeNames())) {\n                propNamesSet.add(cne.getName());\n            }\n        }\n        java.util.List<java.lang.String> propNames = new java.util.ArrayList<java.lang.String>(propNamesSet);\n        final java.lang.String includeAllProp = org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.LuceneIndexConstants.REGEX_ALL_PROPS;\n        if (fullTextEnabled && includes.isEmpty()) {\n            propNames.add(includeAllProp);\n        }\n        for (java.lang.String typeName : declaringNodeTypes) {\n            org.apache.jackrabbit.oak.spi.state.NodeBuilder rule = builder.child(typeName);\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.markAsNtUnstructured(rule);\n            java.util.List<java.lang.String> propNodeNames = com.google.common.collect.Lists.newArrayListWithCapacity(propNamesSet.size());\n            org.apache.jackrabbit.oak.spi.state.NodeBuilder propNodes = rule.child(org.apache.jackrabbit.oak.plugins.index.lucene.PROP_NODE);\n            int i = 0;\n            for (java.lang.String propName : propNames) {\n                java.lang.String propNodeName = propName;\n                if (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition.isRelativeProperty(propName) || propName.equals(includeAllProp)) {\n                    propNodeName = \"prop\" + (i++);\n                }\n                propNodeNames.add(propNodeName);\n                org.apache.jackrabbit.oak.spi.state.NodeBuilder prop = propNodes.child(propNodeName);\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.markAsNtUnstructured(prop);\n                prop.setProperty(LuceneIndexConstants.PROP_NAME, propName);\n                if (excludes.contains(propName)) {\n                    prop.setProperty(LuceneIndexConstants.PROP_INDEX, false);\n                } else if (fullTextEnabled) {\n                    prop.setProperty(LuceneIndexConstants.PROP_ANALYZED, true);\n                    prop.setProperty(LuceneIndexConstants.PROP_NODE_SCOPE_INDEX, true);\n                    prop.setProperty(LuceneIndexConstants.PROP_USE_IN_EXCERPT, storageEnabled);\n                    prop.setProperty(LuceneIndexConstants.PROP_PROPERTY_INDEX, false);\n                } else {\n                    prop.setProperty(LuceneIndexConstants.PROP_PROPERTY_INDEX, true);\n                    if (orderedProps.contains(propName)) {\n                        prop.setProperty(LuceneIndexConstants.PROP_ORDERED, true);\n                    }\n                }\n                if (propName.equals(includeAllProp)) {\n                    prop.setProperty(LuceneIndexConstants.PROP_IS_REGEX, true);\n                }\n                org.apache.jackrabbit.oak.spi.state.NodeState propDefNode = org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getPropDefnNode(defn, propName);\n                if (propDefNode != null) {\n                    for (org.apache.jackrabbit.oak.api.PropertyState ps : propDefNode.getProperties()) {\n                        prop.setProperty(ps);\n                    }\n                }\n            }\n            org.apache.jackrabbit.oak.api.PropertyState supportedTypes = defn.getProperty(org.apache.jackrabbit.oak.plugins.index.lucene.INCLUDE_PROPERTY_TYPES);\n            if (supportedTypes == null) {\n                supportedTypes = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(org.apache.jackrabbit.oak.plugins.index.lucene.INCLUDE_PROPERTY_TYPES, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.TYPES_ALLOW_ALL_NAME);\n            }\n            rule.setProperty(supportedTypes);\n            if (!org.apache.jackrabbit.JcrConstants.NT_BASE.equals(typeName)) {\n                rule.setProperty(LuceneIndexConstants.RULE_INHERITED, false);\n            }\n            propNodes.setProperty(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.OAK_CHILD_ORDER, propNodeNames, org.apache.jackrabbit.oak.plugins.index.lucene.NAMES);\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.markAsNtUnstructured(propNodes);\n        }\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.markAsNtUnstructured(builder);\n        builder.setProperty(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.OAK_CHILD_ORDER, declaringNodeTypes, org.apache.jackrabbit.oak.plugins.index.lucene.NAMES);\n        return builder;\n    }\n\n    private static org.apache.jackrabbit.oak.spi.state.NodeState getPropDefnNode(org.apache.jackrabbit.oak.spi.state.NodeState defn, java.lang.String propName) {\n        org.apache.jackrabbit.oak.spi.state.NodeState propNode = defn.getChildNode(LuceneIndexConstants.PROP_NODE);\n        org.apache.jackrabbit.oak.spi.state.NodeState propDefNode;\n        if (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition.isRelativeProperty(propName)) {\n            org.apache.jackrabbit.oak.spi.state.NodeState result = propNode;\n            for (java.lang.String name : org.apache.jackrabbit.oak.commons.PathUtils.elements(propName)) {\n                result = result.getChildNode(name);\n            }\n            propDefNode = result;\n        } else {\n            propDefNode = propNode.getChildNode(propName);\n        }\n        return propDefNode.exists() ? propDefNode : null;\n    }\n\n    private int determineMaxExtractLength() {\n        int length = getOptionalValue(definition.getChildNode(org.apache.jackrabbit.oak.plugins.index.lucene.TIKA), LuceneIndexConstants.TIKA_MAX_EXTRACT_LENGTH, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.DEFAULT_MAX_EXTRACT_LENGTH);\n        if (length < 0) {\n            return (-length) * maxFieldLength;\n        }\n        return length;\n    }\n\n    private org.apache.jackrabbit.oak.spi.state.NodeState getTikaConfigNode() {\n        return definition.getChildNode(org.apache.jackrabbit.oak.plugins.index.lucene.TIKA).getChildNode(org.apache.jackrabbit.oak.plugins.index.lucene.TIKA_CONFIG);\n    }\n\n    private org.apache.lucene.codecs.Codec createCodec() {\n        java.lang.String codecName = getOptionalValue(definition, LuceneIndexConstants.CODEC_NAME, null);\n        org.apache.lucene.codecs.Codec codec = null;\n        if (codecName != null) {\n            codec = org.apache.lucene.codecs.Codec.forName(codecName);\n        } else if (fullTextEnabled) {\n            codec = new org.apache.jackrabbit.oak.plugins.index.lucene.OakCodec();\n        }\n        return codec;\n    }\n\n    private static java.lang.String determineIndexPath(org.apache.jackrabbit.oak.spi.state.NodeState defn, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder defnb) {\n        java.lang.String indexPath = defn.getString(IndexConstants.INDEX_PATH);\n        if ((indexPath == null) && (defnb != null)) {\n            indexPath = defnb.getString(IndexConstants.INDEX_PATH);\n        }\n        return indexPath;\n    }\n\n    private static java.util.Set<java.lang.String> getMultiProperty(org.apache.jackrabbit.oak.spi.state.NodeState definition, java.lang.String propName) {\n        org.apache.jackrabbit.oak.api.PropertyState pse = definition.getProperty(propName);\n        return pse != null ? com.google.common.collect.ImmutableSet.copyOf(pse.getValue(Type.STRINGS)) : java.util.Collections.<java.lang.String>emptySet();\n    }\n\n    private static java.util.Set<java.lang.String> toLowerCase(java.util.Set<java.lang.String> values) {\n        java.util.Set<java.lang.String> result = com.google.common.collect.Sets.newHashSet();\n        for (java.lang.String val : values) {\n            result.add(val.toLowerCase());\n        }\n        return com.google.common.collect.ImmutableSet.copyOf(result);\n    }\n\n    private static java.util.List<java.lang.String> getAllNodeTypes(org.apache.jackrabbit.oak.plugins.nodetype.ReadOnlyNodeTypeManager ntReg) {\n        try {\n            java.util.List<java.lang.String> typeNames = com.google.common.collect.Lists.newArrayList();\n            javax.jcr.nodetype.NodeTypeIterator ntItr = ntReg.getAllNodeTypes();\n            while (ntItr.hasNext()) {\n                typeNames.add(ntItr.nextNodeType().getName());\n            } \n            return typeNames;\n        } catch (javax.jcr.RepositoryException e) {\n            throw new java.lang.RuntimeException(e);\n        }\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.nodetype.ReadOnlyNodeTypeManager createNodeTypeManager(final org.apache.jackrabbit.oak.api.Tree root) {\n        return new org.apache.jackrabbit.oak.plugins.nodetype.ReadOnlyNodeTypeManager() {\n            @java.lang.Override\n            protected org.apache.jackrabbit.oak.api.Tree getTypes() {\n                return org.apache.jackrabbit.oak.util.TreeUtil.getTree(root, org.apache.jackrabbit.oak.plugins.index.lucene.NODE_TYPES_PATH);\n            }\n\n            @javax.annotation.Nonnull\n            @java.lang.Override\n            protected org.apache.jackrabbit.oak.namepath.NamePathMapper getNamePathMapper() {\n                return org.apache.jackrabbit.oak.namepath.NamePathMapper.DEFAULT;\n            }\n        };\n    }\n\n    private static java.lang.String getPrimaryTypeName(org.apache.jackrabbit.oak.api.Tree state) {\n        java.lang.String primaryType = org.apache.jackrabbit.oak.util.TreeUtil.getPrimaryTypeName(state);\n        return primaryType != null ? primaryType : \"nt:base\";\n    }\n\n    private static java.lang.Iterable<java.lang.String> getMixinTypeNames(org.apache.jackrabbit.oak.api.Tree tree) {\n        org.apache.jackrabbit.oak.api.PropertyState property = tree.getProperty(JcrConstants.JCR_MIXINTYPES);\n        return property != null ? property.getValue(Type.NAMES) : java.util.Collections.<java.lang.String>emptyList();\n    }\n\n    private static boolean hasOrderableChildren(org.apache.jackrabbit.oak.spi.state.NodeState state) {\n        return state.hasProperty(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.OAK_CHILD_ORDER);\n    }\n\n    static int getSupportedTypes(org.apache.jackrabbit.oak.spi.state.NodeState defn, java.lang.String typePropertyName, int defaultVal) {\n        org.apache.jackrabbit.oak.api.PropertyState pst = defn.getProperty(typePropertyName);\n        if (pst != null) {\n            int types = 0;\n            for (java.lang.String inc : pst.getValue(Type.STRINGS)) {\n                if (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.TYPES_ALLOW_ALL_NAME.equals(inc)) {\n                    return org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.TYPES_ALLOW_ALL;\n                }\n                try {\n                    types |= 1 << javax.jcr.PropertyType.valueFromName(inc);\n                } catch (java.lang.IllegalArgumentException e) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.log.warn(\"Unknown property type: \" + inc);\n                }\n            }\n            return types;\n        }\n        return defaultVal;\n    }\n\n    static boolean includePropertyType(int includedPropertyTypes, int type) {\n        if (includedPropertyTypes == org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.TYPES_ALLOW_ALL) {\n            return true;\n        }\n        if (includedPropertyTypes == org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.TYPES_ALLOW_NONE) {\n            return false;\n        }\n        return (includedPropertyTypes & (1 << type)) != 0;\n    }\n\n    private static boolean hasFulltextEnabledIndexRule(java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule> rules) {\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule rule : rules) {\n            if (rule.isFulltextEnabled()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static void markAsNtUnstructured(org.apache.jackrabbit.oak.spi.state.NodeBuilder nb) {\n        nb.setProperty(JcrConstants.JCR_PRIMARYTYPE, JcrConstants.NT_UNSTRUCTURED, Type.NAME);\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion determineIndexFormatVersion(org.apache.jackrabbit.oak.spi.state.NodeState defn, org.apache.jackrabbit.oak.spi.state.NodeBuilder defnb) {\n        if ((defnb != null) && (!defnb.getChildNode(org.apache.jackrabbit.oak.plugins.index.lucene.INDEX_DATA_CHILD_NAME).exists())) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.determineVersionForFreshIndex(defnb);\n        }\n        if (defn.hasProperty(org.apache.jackrabbit.oak.plugins.index.lucene.COMPAT_MODE)) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.versionFrom(defn.getProperty(org.apache.jackrabbit.oak.plugins.index.lucene.COMPAT_MODE));\n        }\n        if (defn.hasProperty(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.INDEX_VERSION)) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.versionFrom(defn.getProperty(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.INDEX_VERSION));\n        }\n        if (!defn.getChildNode(org.apache.jackrabbit.oak.plugins.index.lucene.INDEX_DATA_CHILD_NAME).exists()) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.determineVersionForFreshIndex(defn);\n        }\n        boolean fullTextEnabled = getOptionalValue(defn, org.apache.jackrabbit.oak.plugins.index.lucene.FULL_TEXT_ENABLED, true);\n        return fullTextEnabled ? IndexFormatVersion.V1 : IndexFormatVersion.V2;\n    }\n\n    static org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion determineVersionForFreshIndex(org.apache.jackrabbit.oak.spi.state.NodeState defn) {\n        return org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.determineVersionForFreshIndex(defn.getProperty(org.apache.jackrabbit.oak.plugins.index.lucene.FULL_TEXT_ENABLED), defn.getProperty(org.apache.jackrabbit.oak.plugins.index.lucene.COMPAT_MODE), defn.getProperty(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.INDEX_VERSION));\n    }\n\n    static org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion determineVersionForFreshIndex(org.apache.jackrabbit.oak.spi.state.NodeBuilder defnb) {\n        return org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.determineVersionForFreshIndex(defnb.getProperty(org.apache.jackrabbit.oak.plugins.index.lucene.FULL_TEXT_ENABLED), defnb.getProperty(org.apache.jackrabbit.oak.plugins.index.lucene.COMPAT_MODE), defnb.getProperty(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.INDEX_VERSION));\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion determineVersionForFreshIndex(org.apache.jackrabbit.oak.api.PropertyState fulltext, org.apache.jackrabbit.oak.api.PropertyState compat, org.apache.jackrabbit.oak.api.PropertyState version) {\n        if (compat != null) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.versionFrom(compat);\n        }\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion defaultToUse = org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion.getDefault();\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion existing = (version != null) ? org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.versionFrom(version) : null;\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion result = defaultToUse;\n        if (existing != null) {\n            result = org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion.max(result, existing);\n        }\n        if ((fulltext != null) && (!fulltext.getValue(Type.BOOLEAN))) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion.max(result, IndexFormatVersion.V2);\n        }\n        return result;\n    }\n\n    private java.lang.String[] getQueryPaths(org.apache.jackrabbit.oak.spi.state.NodeState defn) {\n        org.apache.jackrabbit.oak.api.PropertyState ps = defn.getProperty(IndexConstants.QUERY_PATHS);\n        if (ps != null) {\n            return com.google.common.collect.Iterables.toArray(ps.getValue(Type.STRINGS), java.lang.String.class);\n        }\n        return null;\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion versionFrom(org.apache.jackrabbit.oak.api.PropertyState ps) {\n        return org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion.getVersion(com.google.common.primitives.Ints.checkedCast(ps.getValue(Type.LONG)));\n    }\n\n    private static boolean hasIndexingRules(org.apache.jackrabbit.oak.spi.state.NodeState defn) {\n        return defn.getChildNode(LuceneIndexConstants.INDEX_RULES).exists();\n    }\n\n    private static long determineReindexCount(org.apache.jackrabbit.oak.spi.state.NodeState defn, org.apache.jackrabbit.oak.spi.state.NodeBuilder defnb) {\n        if ((defnb != null) && defnb.hasProperty(org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_COUNT)) {\n            return defnb.getProperty(org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_COUNT).getValue(Type.LONG);\n        }\n        if (defn.hasProperty(org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_COUNT)) {\n            return defn.getProperty(org.apache.jackrabbit.oak.plugins.index.IndexConstants.REINDEX_COUNT).getValue(Type.LONG);\n        }\n        return 0;\n    }\n\n    public boolean getActiveDeleteEnabled() {\n        return activeDelete >= 0;\n    }\n\n    private static double getDefaultCostPerEntry(org.apache.jackrabbit.oak.plugins.index.lucene.IndexFormatVersion version) {\n        return version == IndexFormatVersion.V1 ? 1.5 : 1.0;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getDefaultCostPerEntry(version)",
            "src_parent": "getOptionalValue(defn, LuceneIndexConstants.COST_PER_ENTRY, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.getDefaultCostPerEntry(version))",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        }
      ],
      "file_name": "IndexDefinition"
    }
  ],
  "id": "jackrabbit-oak_06c367af"
}