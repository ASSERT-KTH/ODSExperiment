{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree parseNode(org.apache.jackrabbit.mk.json.JsopTokenizer t) throws java.lang.Exception {\n    org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree node = new org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree();\n    if (!t.matches('}')) {\n        do {\n            java.lang.String key = t.readString();\n            t.read(':');\n            if (t.matches('{')) {\n                node.nodes.put(key, parseNode(t));\n            } else {\n                node.props.put(key, t.readRawValue().trim());\n            }\n        } while (t.matches(',') );\n        t.read('}');\n    }\n    return node;\n}",
            "dst_parent": "public class MicroKernelImpl implements org.apache.jackrabbit.mk.api.MicroKernel {\n    protected org.apache.jackrabbit.mk.core.Repository rep;\n\n    private final org.apache.jackrabbit.mk.util.CommitGate gate = new org.apache.jackrabbit.mk.util.CommitGate();\n\n    public MicroKernelImpl(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        init(homeDir);\n    }\n\n    public MicroKernelImpl() {\n        this(new org.apache.jackrabbit.mk.core.Repository());\n    }\n\n    public MicroKernelImpl(org.apache.jackrabbit.mk.core.Repository rep) {\n        this.rep = rep;\n    }\n\n    protected void init(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            rep = new org.apache.jackrabbit.mk.core.Repository(homeDir);\n            rep.init();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public void dispose() {\n        gate.commit(\"end\");\n        if (rep != null) {\n            try {\n                rep.shutDown();\n            } catch (java.lang.Exception ignore) {\n            }\n            rep = null;\n        }\n    }\n\n    public java.lang.String getHeadRevision() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        return getHeadRevisionId().toString();\n    }\n\n    private org.apache.jackrabbit.mk.model.Id getHeadRevisionId() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            return rep.getHeadRevision();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getRevisions(long since, int maxEntries) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        maxEntries = (maxEntries < 0) ? java.lang.Integer.MAX_VALUE : maxEntries;\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> history = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = rep.getHeadCommit();\n            while (((commit != null) && (history.size() < maxEntries)) && (commit.getCommitTS() >= since)) {\n                history.add(commit);\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n            } \n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder buff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = history.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = history.get(i);\n            buff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).endObject();\n        }\n        return buff.endArray().toString();\n    }\n\n    public java.lang.String waitForCommit(java.lang.String oldHeadRevision, long maxWaitMillis) throws java.lang.InterruptedException, org.apache.jackrabbit.mk.api.MicroKernelException {\n        return gate.waitForCommit(oldHeadRevision, maxWaitMillis);\n    }\n\n    public java.lang.String getJournal(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id fromRevisionId = org.apache.jackrabbit.mk.model.Id.fromString(fromRevision);\n        org.apache.jackrabbit.mk.model.Id toRevisionId = (toRevision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> commits = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit toCommit = rep.getCommit(toRevisionId);\n            org.apache.jackrabbit.mk.model.Commit fromCommit;\n            if (toRevisionId.equals(fromRevisionId)) {\n                fromCommit = toCommit;\n            } else {\n                fromCommit = rep.getCommit(fromRevisionId);\n                if (fromCommit.getCommitTS() > toCommit.getCommitTS()) {\n                    return \"[]\";\n                }\n            }\n            org.apache.jackrabbit.mk.model.StoredCommit commit = toCommit;\n            while (commit != null) {\n                commits.add(commit);\n                if (commit.getId().equals(fromRevisionId)) {\n                    break;\n                }\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n            } \n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder commitBuff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = commits.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = commits.get(i);\n            if (commit.getParentId() == null) {\n                continue;\n            }\n            commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg()).key(\"changes\").value(commit.getChanges()).endObject();\n        }\n        return commitBuff.endArray().toString();\n    }\n\n    public java.lang.String diff(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        org.apache.jackrabbit.mk.model.Id toRevisionId = (toRevision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        return diff(org.apache.jackrabbit.mk.model.Id.fromString(fromRevision), toRevisionId, filter);\n    }\n\n    private java.lang.String diff(org.apache.jackrabbit.mk.model.Id fromRevisionId, org.apache.jackrabbit.mk.model.Id toRevisionId, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        java.lang.String path = \"/\";\n        try {\n            final org.apache.jackrabbit.mk.json.JsopBuilder buff = new org.apache.jackrabbit.mk.json.JsopBuilder();\n            final org.apache.jackrabbit.mk.store.RevisionProvider rp = rep.getRevisionStore();\n            final java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String> addedNodes = new java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String>();\n            final java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String> removedNodes = new java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String>();\n            org.apache.jackrabbit.mk.model.NodeState node1;\n            org.apache.jackrabbit.mk.model.NodeState node2;\n            try {\n                node1 = rep.getNodeState(fromRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n                node1 = null;\n            }\n            try {\n                node2 = rep.getNodeState(toRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n                node2 = null;\n            }\n            if (node1 == null) {\n                if (node2 != null) {\n                    buff.tag('+').key(path).object();\n                    toJson(buff, node2, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                    return buff.endObject().newline().toString();\n                } else {\n                    throw new org.apache.jackrabbit.mk.api.MicroKernelException(\"path doesn't exist in the specified revisions: \" + path);\n                }\n            } else if (node2 == null) {\n                buff.tag('-');\n                buff.value(path);\n                return buff.newline().toString();\n            }\n            org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler diffHandler = new org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler(rp) {\n                @java.lang.Override\n                public void propertyAdded(org.apache.jackrabbit.mk.model.PropertyState after) {\n                    buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                }\n\n                @java.lang.Override\n                public void propertyChanged(org.apache.jackrabbit.mk.model.PropertyState before, org.apache.jackrabbit.mk.model.PropertyState after) {\n                    buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                }\n\n                @java.lang.Override\n                public void propertyDeleted(org.apache.jackrabbit.mk.model.PropertyState before) {\n                    buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), before.getName())).value(null).newline();\n                }\n\n                @java.lang.Override\n                public void childNodeAdded(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState after) {\n                    addedNodes.put(rp.getId(after), org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name)).object();\n                    toJson(buff, after, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                    buff.endObject().newline();\n                }\n\n                @java.lang.Override\n                public void childNodeDeleted(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState before) {\n                    removedNodes.put(rp.getId(before), org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.tag('-');\n                    buff.value(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.newline();\n                }\n            };\n            diffHandler.start(node1, node2, path);\n            addedNodes.keySet().retainAll(removedNodes.keySet());\n            if (!addedNodes.isEmpty()) {\n                removedNodes.keySet().retainAll(addedNodes.keySet());\n                buff.resetWriter();\n                diffHandler = new org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler(rp) {\n                    @java.lang.Override\n                    public void propertyAdded(org.apache.jackrabbit.mk.model.PropertyState after) {\n                        buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                    }\n\n                    @java.lang.Override\n                    public void propertyChanged(org.apache.jackrabbit.mk.model.PropertyState before, org.apache.jackrabbit.mk.model.PropertyState after) {\n                        buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                    }\n\n                    @java.lang.Override\n                    public void propertyDeleted(org.apache.jackrabbit.mk.model.PropertyState before) {\n                        buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), before.getName())).value(null).newline();\n                    }\n\n                    @java.lang.Override\n                    public void childNodeAdded(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState after) {\n                        if (addedNodes.containsKey(rp.getId(after))) {\n                            return;\n                        }\n                        buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name)).object();\n                        toJson(buff, after, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                        buff.endObject().newline();\n                    }\n\n                    @java.lang.Override\n                    public void childNodeDeleted(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState before) {\n                        if (addedNodes.containsKey(rp.getId(before))) {\n                            return;\n                        }\n                        buff.tag('-');\n                        buff.value(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                        buff.newline();\n                    }\n                };\n                diffHandler.start(node1, node2, path);\n                for (java.util.Map.Entry<org.apache.jackrabbit.mk.model.Id, java.lang.String> entry : addedNodes.entrySet()) {\n                    buff.tag('>').key(removedNodes.get(entry.getKey())).value(entry.getValue()).newline();\n                }\n            }\n            return buff.toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public boolean nodeExists(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        return rep.nodeExists(revisionId, path);\n    }\n\n    public long getChildNodeCount(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            return rep.getNodeState(revisionId, path).getChildNodeCount();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getNodes(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        return getNodes(path, revision, 1, 0, -1, null);\n    }\n\n    public java.lang.String getNodes(java.lang.String path, java.lang.String revision, int depth, long offset, int count, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            org.apache.jackrabbit.mk.json.JsopBuilder buf = new org.apache.jackrabbit.mk.json.JsopBuilder().object();\n            toJson(buf, rep.getNodeState(revisionId, path), depth, ((int) (offset)), count, true);\n            return buf.endObject().toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String commit(java.lang.String path, java.lang.String jsonDiff, java.lang.String revision, java.lang.String message) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        if ((path.length() > 0) && (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(path))) {\n            throw new java.lang.IllegalArgumentException(\"absolute path expected: \" + path);\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            org.apache.jackrabbit.mk.json.JsopTokenizer t = new org.apache.jackrabbit.mk.json.JsopTokenizer(jsonDiff);\n            org.apache.jackrabbit.mk.model.CommitBuilder cb = rep.getCommitBuilder(revisionId, message);\n            while (true) {\n                int r = t.read();\n                if (r == org.apache.jackrabbit.mk.json.JsopTokenizer.END) {\n                    break;\n                }\n                int pos;\n                switch (r) {\n                    case '+' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            if (t.matches('{')) {\n                                java.lang.String nodePath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(nodePath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + nodePath) + \", pos: \") + pos);\n                                }\n                                java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(nodePath);\n                                java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getName(nodePath);\n                                cb.addNode(parentPath, nodeName, parseNode(t));\n                            } else {\n                                java.lang.String value;\n                                if (t.matches(JsopTokenizer.NULL)) {\n                                    value = null;\n                                } else {\n                                    value = t.readRawValue().trim();\n                                }\n                                java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                                java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(targetPath);\n                                java.lang.String propName = org.apache.jackrabbit.mk.util.PathUtils.getName(targetPath);\n                                cb.setProperty(parentPath, propName, value);\n                            }\n                            break;\n                        }\n                    case '-' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            cb.removeNode(targetPath);\n                            break;\n                        }\n                    case '^' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            java.lang.String value;\n                            if (t.matches(JsopTokenizer.NULL)) {\n                                value = null;\n                            } else {\n                                value = t.readRawValue().trim();\n                            }\n                            java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(targetPath);\n                            java.lang.String propName = org.apache.jackrabbit.mk.util.PathUtils.getName(targetPath);\n                            cb.setProperty(parentPath, propName, value);\n                            break;\n                        }\n                    case '>' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.moveNode(srcPath, targetPath);\n                            break;\n                        }\n                    case '*' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.copyNode(srcPath, targetPath);\n                            break;\n                        }\n                    default :\n                        throw new java.lang.AssertionError(\"token type: \" + t.getTokenType());\n                }\n            } \n            org.apache.jackrabbit.mk.model.Id newHead = cb.doCommit();\n            if (!newHead.equals(revisionId)) {\n                gate.commit(newHead.toString());\n            }\n            return newHead.toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public long getLength(java.lang.String blobId) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().getBlobLength(blobId);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public int read(java.lang.String blobId, long pos, byte[] buff, int off, int length) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().readBlob(blobId, pos, buff, off, length);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String write(java.io.InputStream in) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().writeBlob(in);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    void toJson(org.apache.jackrabbit.mk.json.JsopBuilder builder, org.apache.jackrabbit.mk.model.NodeState node, int depth, int offset, int count, boolean inclVirtualProps) {\n        for (org.apache.jackrabbit.mk.model.PropertyState property : node.getProperties()) {\n            builder.key(property.getName()).encodedValue(property.getEncodedValue());\n        }\n        long childCount = node.getChildNodeCount();\n        if (inclVirtualProps) {\n            builder.key(\":childNodeCount\").value(childCount);\n        }\n        if ((childCount > 0) && (depth >= 0)) {\n            for (org.apache.jackrabbit.mk.model.ChildNodeEntry entry : node.getChildNodeEntries(offset, count)) {\n                builder.key(entry.getName()).object();\n                if (depth > 0) {\n                    toJson(builder, entry.getNode(), depth - 1, 0, -1, inclVirtualProps);\n                }\n                builder.endObject();\n            }\n        }\n    }\n\n    org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree parseNode(org.apache.jackrabbit.mk.json.JsopTokenizer t) throws java.lang.Exception {\n        org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree node = new org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree();\n        if (!t.matches('}')) {\n            do {\n                java.lang.String key = t.readString();\n                t.read(':');\n                if (t.matches('{')) {\n                    node.nodes.put(key, parseNode(t));\n                } else {\n                    node.props.put(key, t.readRawValue().trim());\n                }\n            } while (t.matches(',') );\n            t.read('}');\n        }\n        return node;\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "static void addNode(java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list, java.lang.String path, java.lang.String name, org.apache.jackrabbit.mk.json.JsopTokenizer t) throws java.lang.Exception {\n    org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op = new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation();\n    op.path = path;\n    op.name = name;\n    list.add(op);\n    if (!t.matches('}')) {\n        do {\n            java.lang.String key = t.readString();\n            t.read(':');\n            if (t.matches('{')) {\n                org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, org.apache.jackrabbit.mk.util.PathUtils.concat(path, name), key, t);\n            } else {\n                op.props.put(key, t.readRawValue().trim());\n            }\n        } while (t.matches(',') );\n        t.read('}');\n    }\n}",
            "src_parent": "public class MicroKernelImpl implements org.apache.jackrabbit.mk.api.MicroKernel {\n    protected org.apache.jackrabbit.mk.core.Repository rep;\n\n    private final org.apache.jackrabbit.mk.util.CommitGate gate = new org.apache.jackrabbit.mk.util.CommitGate();\n\n    private final java.util.Map<org.apache.jackrabbit.mk.model.Id, java.lang.String> diffCache = java.util.Collections.synchronizedMap(org.apache.jackrabbit.mk.util.SimpleLRUCache.<org.apache.jackrabbit.mk.model.Id, java.lang.String>newInstance(100));\n\n    public MicroKernelImpl(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        init(homeDir);\n    }\n\n    public MicroKernelImpl() {\n        this(new org.apache.jackrabbit.mk.core.Repository());\n    }\n\n    public MicroKernelImpl(org.apache.jackrabbit.mk.core.Repository rep) {\n        this.rep = rep;\n    }\n\n    protected void init(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            rep = new org.apache.jackrabbit.mk.core.Repository(homeDir);\n            rep.init();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public void dispose() {\n        gate.commit(\"end\");\n        if (rep != null) {\n            try {\n                rep.shutDown();\n            } catch (java.lang.Exception ignore) {\n            }\n            rep = null;\n        }\n        diffCache.clear();\n    }\n\n    public java.lang.String getHeadRevision() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        return getHeadRevisionId().toString();\n    }\n\n    private org.apache.jackrabbit.mk.model.Id getHeadRevisionId() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            return rep.getHeadRevision();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getRevisions(long since, int maxEntries) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        maxEntries = (maxEntries < 0) ? java.lang.Integer.MAX_VALUE : maxEntries;\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> history = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = rep.getHeadCommit();\n            while (((commit != null) && (history.size() < maxEntries)) && (commit.getCommitTS() >= since)) {\n                history.add(commit);\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n            } \n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder buff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = history.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = history.get(i);\n            buff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).endObject();\n        }\n        return buff.endArray().toString();\n    }\n\n    public java.lang.String waitForCommit(java.lang.String oldHeadRevision, long maxWaitMillis) throws java.lang.InterruptedException, org.apache.jackrabbit.mk.api.MicroKernelException {\n        return gate.waitForCommit(oldHeadRevision, maxWaitMillis);\n    }\n\n    public java.lang.String getJournal(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id fromRevisionId = org.apache.jackrabbit.mk.model.Id.fromString(fromRevision);\n        org.apache.jackrabbit.mk.model.Id toRevisionId = (toRevision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> commits = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit toCommit = rep.getCommit(toRevisionId);\n            org.apache.jackrabbit.mk.model.Commit fromCommit;\n            if (toRevisionId.equals(fromRevisionId)) {\n                fromCommit = toCommit;\n            } else {\n                fromCommit = rep.getCommit(fromRevisionId);\n                if (fromCommit.getCommitTS() > toCommit.getCommitTS()) {\n                    return \"[]\";\n                }\n            }\n            org.apache.jackrabbit.mk.model.StoredCommit commit = toCommit;\n            while (commit != null) {\n                commits.add(commit);\n                if (commit.getId().equals(fromRevisionId)) {\n                    break;\n                }\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n            } \n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder commitBuff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = commits.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = commits.get(i);\n            if (commit.getParentId() == null) {\n                continue;\n            }\n            commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg());\n            java.lang.String diff = diffCache.get(commit.getId());\n            if (diff == null) {\n                diff = diff(commit.getParentId(), commit.getId(), filter);\n                diffCache.put(commit.getId(), diff);\n            }\n            commitBuff.key(\"changes\").value(diff).endObject();\n        }\n        return commitBuff.endArray().toString();\n    }\n\n    public java.lang.String diff(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        org.apache.jackrabbit.mk.model.Id toRevisionId = (toRevision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        return diff(org.apache.jackrabbit.mk.model.Id.fromString(fromRevision), toRevisionId, filter);\n    }\n\n    private java.lang.String diff(org.apache.jackrabbit.mk.model.Id fromRevisionId, org.apache.jackrabbit.mk.model.Id toRevisionId, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        java.lang.String path = \"/\";\n        try {\n            final org.apache.jackrabbit.mk.json.JsopBuilder buff = new org.apache.jackrabbit.mk.json.JsopBuilder();\n            final org.apache.jackrabbit.mk.store.RevisionProvider rp = rep.getRevisionStore();\n            final java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String> addedNodes = new java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String>();\n            final java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String> removedNodes = new java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String>();\n            org.apache.jackrabbit.mk.model.NodeState node1;\n            org.apache.jackrabbit.mk.model.NodeState node2;\n            try {\n                node1 = rep.getNodeState(fromRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n                node1 = null;\n            }\n            try {\n                node2 = rep.getNodeState(toRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n                node2 = null;\n            }\n            if (node1 == null) {\n                if (node2 != null) {\n                    buff.tag('+').key(path).object();\n                    toJson(buff, node2, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                    return buff.endObject().newline().toString();\n                } else {\n                    throw new org.apache.jackrabbit.mk.api.MicroKernelException(\"path doesn't exist in the specified revisions: \" + path);\n                }\n            } else if (node2 == null) {\n                buff.tag('-');\n                buff.value(path);\n                return buff.newline().toString();\n            }\n            org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler diffHandler = new org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler(rp) {\n                @java.lang.Override\n                public void propertyAdded(org.apache.jackrabbit.mk.model.PropertyState after) {\n                    buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                }\n\n                @java.lang.Override\n                public void propertyChanged(org.apache.jackrabbit.mk.model.PropertyState before, org.apache.jackrabbit.mk.model.PropertyState after) {\n                    buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                }\n\n                @java.lang.Override\n                public void propertyDeleted(org.apache.jackrabbit.mk.model.PropertyState before) {\n                    buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), before.getName())).value(null).newline();\n                }\n\n                @java.lang.Override\n                public void childNodeAdded(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState after) {\n                    addedNodes.put(rp.getId(after), org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name)).object();\n                    toJson(buff, after, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                    buff.endObject().newline();\n                }\n\n                @java.lang.Override\n                public void childNodeDeleted(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState before) {\n                    removedNodes.put(rp.getId(before), org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.tag('-');\n                    buff.value(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.newline();\n                }\n            };\n            diffHandler.start(node1, node2, path);\n            addedNodes.keySet().retainAll(removedNodes.keySet());\n            if (!addedNodes.isEmpty()) {\n                removedNodes.keySet().retainAll(addedNodes.keySet());\n                buff.resetWriter();\n                diffHandler = new org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler(rp) {\n                    @java.lang.Override\n                    public void propertyAdded(org.apache.jackrabbit.mk.model.PropertyState after) {\n                        buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                    }\n\n                    @java.lang.Override\n                    public void propertyChanged(org.apache.jackrabbit.mk.model.PropertyState before, org.apache.jackrabbit.mk.model.PropertyState after) {\n                        buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                    }\n\n                    @java.lang.Override\n                    public void propertyDeleted(org.apache.jackrabbit.mk.model.PropertyState before) {\n                        buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), before.getName())).value(null).newline();\n                    }\n\n                    @java.lang.Override\n                    public void childNodeAdded(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState after) {\n                        if (addedNodes.containsKey(rp.getId(after))) {\n                            return;\n                        }\n                        buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name)).object();\n                        toJson(buff, after, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                        buff.endObject().newline();\n                    }\n\n                    @java.lang.Override\n                    public void childNodeDeleted(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState before) {\n                        if (addedNodes.containsKey(rp.getId(before))) {\n                            return;\n                        }\n                        buff.tag('-');\n                        buff.value(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                        buff.newline();\n                    }\n                };\n                diffHandler.start(node1, node2, path);\n                for (java.util.Map.Entry<org.apache.jackrabbit.mk.model.Id, java.lang.String> entry : addedNodes.entrySet()) {\n                    buff.tag('>').key(removedNodes.get(entry.getKey())).value(entry.getValue()).newline();\n                }\n            }\n            return buff.toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public boolean nodeExists(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        return rep.nodeExists(revisionId, path);\n    }\n\n    public long getChildNodeCount(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            return rep.getNodeState(revisionId, path).getChildNodeCount();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getNodes(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        return getNodes(path, revision, 1, 0, -1, null);\n    }\n\n    public java.lang.String getNodes(java.lang.String path, java.lang.String revision, int depth, long offset, int count, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            org.apache.jackrabbit.mk.json.JsopBuilder buf = new org.apache.jackrabbit.mk.json.JsopBuilder().object();\n            toJson(buf, rep.getNodeState(revisionId, path), depth, ((int) (offset)), count, true);\n            return buf.endObject().toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String commit(java.lang.String path, java.lang.String jsonDiff, java.lang.String revision, java.lang.String message) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        if ((path.length() > 0) && (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(path))) {\n            throw new java.lang.IllegalArgumentException(\"absolute path expected: \" + path);\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            org.apache.jackrabbit.mk.json.JsopTokenizer t = new org.apache.jackrabbit.mk.json.JsopTokenizer(jsonDiff);\n            org.apache.jackrabbit.mk.model.CommitBuilder cb = rep.getCommitBuilder(revisionId, message);\n            while (true) {\n                int r = t.read();\n                if (r == org.apache.jackrabbit.mk.json.JsopTokenizer.END) {\n                    break;\n                }\n                int pos;\n                switch (r) {\n                    case '+' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            if (t.matches('{')) {\n                                java.lang.String nodePath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(nodePath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + nodePath) + \", pos: \") + pos);\n                                }\n                                java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(nodePath);\n                                java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getName(nodePath);\n                                java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list = new java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation>();\n                                org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, parentPath, nodeName, t);\n                                for (org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op : list) {\n                                    cb.addNode(op.path, op.name, op.props);\n                                }\n                            } else {\n                                java.lang.String value;\n                                if (t.matches(JsopTokenizer.NULL)) {\n                                    value = null;\n                                } else {\n                                    value = t.readRawValue().trim();\n                                }\n                                java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                                java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(targetPath);\n                                java.lang.String propName = org.apache.jackrabbit.mk.util.PathUtils.getName(targetPath);\n                                cb.setProperty(parentPath, propName, value);\n                            }\n                            break;\n                        }\n                    case '-' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            cb.removeNode(targetPath);\n                            break;\n                        }\n                    case '^' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            java.lang.String value;\n                            if (t.matches(JsopTokenizer.NULL)) {\n                                value = null;\n                            } else {\n                                value = t.readRawValue().trim();\n                            }\n                            java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(targetPath);\n                            java.lang.String propName = org.apache.jackrabbit.mk.util.PathUtils.getName(targetPath);\n                            cb.setProperty(parentPath, propName, value);\n                            break;\n                        }\n                    case '>' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.moveNode(srcPath, targetPath);\n                            break;\n                        }\n                    case '*' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.copyNode(srcPath, targetPath);\n                            break;\n                        }\n                    default :\n                        throw new java.lang.AssertionError(\"token type: \" + t.getTokenType());\n                }\n            } \n            org.apache.jackrabbit.mk.model.Id newHead = cb.doCommit();\n            if (!newHead.equals(revisionId)) {\n                gate.commit(newHead.toString());\n            }\n            return newHead.toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public long getLength(java.lang.String blobId) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().getBlobLength(blobId);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public int read(java.lang.String blobId, long pos, byte[] buff, int off, int length) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().readBlob(blobId, pos, buff, off, length);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String write(java.io.InputStream in) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().writeBlob(in);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    void toJson(org.apache.jackrabbit.mk.json.JsopBuilder builder, org.apache.jackrabbit.mk.model.NodeState node, int depth, int offset, int count, boolean inclVirtualProps) {\n        for (org.apache.jackrabbit.mk.model.PropertyState property : node.getProperties()) {\n            builder.key(property.getName()).encodedValue(property.getEncodedValue());\n        }\n        long childCount = node.getChildNodeCount();\n        if (inclVirtualProps) {\n            builder.key(\":childNodeCount\").value(childCount);\n        }\n        if ((childCount > 0) && (depth >= 0)) {\n            for (org.apache.jackrabbit.mk.model.ChildNodeEntry entry : node.getChildNodeEntries(offset, count)) {\n                builder.key(entry.getName()).object();\n                if (depth > 0) {\n                    toJson(builder, entry.getNode(), depth - 1, 0, -1, inclVirtualProps);\n                }\n                builder.endObject();\n            }\n        }\n    }\n\n    static void addNode(java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list, java.lang.String path, java.lang.String name, org.apache.jackrabbit.mk.json.JsopTokenizer t) throws java.lang.Exception {\n        org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op = new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation();\n        op.path = path;\n        op.name = name;\n        list.add(op);\n        if (!t.matches('}')) {\n            do {\n                java.lang.String key = t.readString();\n                t.read(':');\n                if (t.matches('{')) {\n                    org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, org.apache.jackrabbit.mk.util.PathUtils.concat(path, name), key, t);\n                } else {\n                    op.props.put(key, t.readRawValue().trim());\n                }\n            } while (t.matches(',') );\n            t.read('}');\n        }\n    }\n\n    static class AddNodeOperation {\n        java.lang.String path;\n\n        java.lang.String name;\n\n        java.util.Map<java.lang.String, java.lang.String> props = new java.util.HashMap<java.lang.String, java.lang.String>();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "TypeReference",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree",
            "dst_parent": "org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree parseNode(org.apache.jackrabbit.mk.json.JsopTokenizer t) throws java.lang.Exception {\n    org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree node = new org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree();\n    if (!t.matches('}')) {\n        do {\n            java.lang.String key = t.readString();\n            t.read(':');\n            if (t.matches('{')) {\n                node.nodes.put(key, parseNode(t));\n            } else {\n                node.props.put(key, t.readRawValue().trim());\n            }\n        } while (t.matches(',') );\n        t.read('}');\n    }\n    return node;\n}",
            "dst_parent_type": "Method",
            "dst_type": "TypeReference",
            "operator": "UPD",
            "src": "void",
            "src_parent": "static void addNode(java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list, java.lang.String path, java.lang.String name, org.apache.jackrabbit.mk.json.JsopTokenizer t) throws java.lang.Exception {\n    org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op = new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation();\n    op.path = path;\n    op.name = name;\n    list.add(op);\n    if (!t.matches('}')) {\n        do {\n            java.lang.String key = t.readString();\n            t.read(':');\n            if (t.matches('{')) {\n                org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, org.apache.jackrabbit.mk.util.PathUtils.concat(path, name), key, t);\n            } else {\n                op.props.put(key, t.readRawValue().trim());\n            }\n        } while (t.matches(',') );\n        t.read('}');\n    }\n}",
            "src_parent_type": "Method",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree node = new org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree()",
            "dst_parent": "{\n    org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree node = new org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree();\n    if (!t.matches('}')) {\n        do {\n            java.lang.String key = t.readString();\n            t.read(':');\n            if (t.matches('{')) {\n                node.nodes.put(key, parseNode(t));\n            } else {\n                node.props.put(key, t.readRawValue().trim());\n            }\n        } while (t.matches(',') );\n        t.read('}');\n    }\n    return node;\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "UPD",
            "src": "org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op = new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation()",
            "src_parent": "{\n    org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op = new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation();\n    op.path = path;\n    op.name = name;\n    list.add(op);\n    if (!t.matches('}')) {\n        do {\n            java.lang.String key = t.readString();\n            t.read(':');\n            if (t.matches('{')) {\n                org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, org.apache.jackrabbit.mk.util.PathUtils.concat(path, name), key, t);\n            } else {\n                op.props.put(key, t.readRawValue().trim());\n            }\n        } while (t.matches(',') );\n        t.read('}');\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree",
            "dst_parent": "org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree node = new org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree()",
            "dst_parent_type": "LocalVariable",
            "dst_type": "TypeReference",
            "operator": "UPD",
            "src": "org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation",
            "src_parent": "org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op = new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation()",
            "src_parent_type": "LocalVariable",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "new org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree()",
            "dst_parent": "org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree node = new org.apache.jackrabbit.mk.model.CommitBuilder.NodeTree()",
            "dst_parent_type": "LocalVariable",
            "dst_type": "ConstructorCall",
            "operator": "UPD",
            "src": "new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation()",
            "src_parent": "org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op = new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation()",
            "src_parent_type": "LocalVariable",
            "src_type": "ConstructorCall"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "For",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "commit",
            "dst_parent": "commit.getChanges()",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "UPD",
            "src": "diff",
            "src_parent": "commitBuff.key(\"changes\").value(diff)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Do",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "node.nodes.put(key, parseNode(t))",
            "dst_parent": "{\n    node.nodes.put(key, parseNode(t));\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, org.apache.jackrabbit.mk.util.PathUtils.concat(path, name), key, t)",
            "src_parent": "{\n    org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, org.apache.jackrabbit.mk.util.PathUtils.concat(path, name), key, t);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "cb",
            "dst_parent": "cb.addNode(parentPath, nodeName, parseNode(t))",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "UPD",
            "src": "list",
            "src_parent": "org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, parentPath, nodeName, t)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "node",
            "dst_parent": "node.props",
            "dst_parent_type": "FieldRead",
            "dst_type": "VariableRead",
            "operator": "UPD",
            "src": "op",
            "src_parent": "op.props",
            "src_parent_type": "FieldRead",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "private final java.util.Map<org.apache.jackrabbit.mk.model.Id, java.lang.String> diffCache = java.util.Collections.synchronizedMap(org.apache.jackrabbit.mk.util.SimpleLRUCache.<org.apache.jackrabbit.mk.model.Id, java.lang.String>newInstance(100));",
            "src_parent": "public class MicroKernelImpl implements org.apache.jackrabbit.mk.api.MicroKernel {\n    protected org.apache.jackrabbit.mk.core.Repository rep;\n\n    private final org.apache.jackrabbit.mk.util.CommitGate gate = new org.apache.jackrabbit.mk.util.CommitGate();\n\n    private final java.util.Map<org.apache.jackrabbit.mk.model.Id, java.lang.String> diffCache = java.util.Collections.synchronizedMap(org.apache.jackrabbit.mk.util.SimpleLRUCache.<org.apache.jackrabbit.mk.model.Id, java.lang.String>newInstance(100));\n\n    public MicroKernelImpl(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        init(homeDir);\n    }\n\n    public MicroKernelImpl() {\n        this(new org.apache.jackrabbit.mk.core.Repository());\n    }\n\n    public MicroKernelImpl(org.apache.jackrabbit.mk.core.Repository rep) {\n        this.rep = rep;\n    }\n\n    protected void init(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            rep = new org.apache.jackrabbit.mk.core.Repository(homeDir);\n            rep.init();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public void dispose() {\n        gate.commit(\"end\");\n        if (rep != null) {\n            try {\n                rep.shutDown();\n            } catch (java.lang.Exception ignore) {\n            }\n            rep = null;\n        }\n        diffCache.clear();\n    }\n\n    public java.lang.String getHeadRevision() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        return getHeadRevisionId().toString();\n    }\n\n    private org.apache.jackrabbit.mk.model.Id getHeadRevisionId() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            return rep.getHeadRevision();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getRevisions(long since, int maxEntries) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        maxEntries = (maxEntries < 0) ? java.lang.Integer.MAX_VALUE : maxEntries;\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> history = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = rep.getHeadCommit();\n            while (((commit != null) && (history.size() < maxEntries)) && (commit.getCommitTS() >= since)) {\n                history.add(commit);\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n            } \n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder buff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = history.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = history.get(i);\n            buff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).endObject();\n        }\n        return buff.endArray().toString();\n    }\n\n    public java.lang.String waitForCommit(java.lang.String oldHeadRevision, long maxWaitMillis) throws java.lang.InterruptedException, org.apache.jackrabbit.mk.api.MicroKernelException {\n        return gate.waitForCommit(oldHeadRevision, maxWaitMillis);\n    }\n\n    public java.lang.String getJournal(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id fromRevisionId = org.apache.jackrabbit.mk.model.Id.fromString(fromRevision);\n        org.apache.jackrabbit.mk.model.Id toRevisionId = (toRevision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> commits = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit toCommit = rep.getCommit(toRevisionId);\n            org.apache.jackrabbit.mk.model.Commit fromCommit;\n            if (toRevisionId.equals(fromRevisionId)) {\n                fromCommit = toCommit;\n            } else {\n                fromCommit = rep.getCommit(fromRevisionId);\n                if (fromCommit.getCommitTS() > toCommit.getCommitTS()) {\n                    return \"[]\";\n                }\n            }\n            org.apache.jackrabbit.mk.model.StoredCommit commit = toCommit;\n            while (commit != null) {\n                commits.add(commit);\n                if (commit.getId().equals(fromRevisionId)) {\n                    break;\n                }\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n            } \n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder commitBuff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = commits.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = commits.get(i);\n            if (commit.getParentId() == null) {\n                continue;\n            }\n            commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg());\n            java.lang.String diff = diffCache.get(commit.getId());\n            if (diff == null) {\n                diff = diff(commit.getParentId(), commit.getId(), filter);\n                diffCache.put(commit.getId(), diff);\n            }\n            commitBuff.key(\"changes\").value(diff).endObject();\n        }\n        return commitBuff.endArray().toString();\n    }\n\n    public java.lang.String diff(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        org.apache.jackrabbit.mk.model.Id toRevisionId = (toRevision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        return diff(org.apache.jackrabbit.mk.model.Id.fromString(fromRevision), toRevisionId, filter);\n    }\n\n    private java.lang.String diff(org.apache.jackrabbit.mk.model.Id fromRevisionId, org.apache.jackrabbit.mk.model.Id toRevisionId, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        java.lang.String path = \"/\";\n        try {\n            final org.apache.jackrabbit.mk.json.JsopBuilder buff = new org.apache.jackrabbit.mk.json.JsopBuilder();\n            final org.apache.jackrabbit.mk.store.RevisionProvider rp = rep.getRevisionStore();\n            final java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String> addedNodes = new java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String>();\n            final java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String> removedNodes = new java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String>();\n            org.apache.jackrabbit.mk.model.NodeState node1;\n            org.apache.jackrabbit.mk.model.NodeState node2;\n            try {\n                node1 = rep.getNodeState(fromRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n                node1 = null;\n            }\n            try {\n                node2 = rep.getNodeState(toRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n                node2 = null;\n            }\n            if (node1 == null) {\n                if (node2 != null) {\n                    buff.tag('+').key(path).object();\n                    toJson(buff, node2, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                    return buff.endObject().newline().toString();\n                } else {\n                    throw new org.apache.jackrabbit.mk.api.MicroKernelException(\"path doesn't exist in the specified revisions: \" + path);\n                }\n            } else if (node2 == null) {\n                buff.tag('-');\n                buff.value(path);\n                return buff.newline().toString();\n            }\n            org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler diffHandler = new org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler(rp) {\n                @java.lang.Override\n                public void propertyAdded(org.apache.jackrabbit.mk.model.PropertyState after) {\n                    buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                }\n\n                @java.lang.Override\n                public void propertyChanged(org.apache.jackrabbit.mk.model.PropertyState before, org.apache.jackrabbit.mk.model.PropertyState after) {\n                    buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                }\n\n                @java.lang.Override\n                public void propertyDeleted(org.apache.jackrabbit.mk.model.PropertyState before) {\n                    buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), before.getName())).value(null).newline();\n                }\n\n                @java.lang.Override\n                public void childNodeAdded(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState after) {\n                    addedNodes.put(rp.getId(after), org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name)).object();\n                    toJson(buff, after, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                    buff.endObject().newline();\n                }\n\n                @java.lang.Override\n                public void childNodeDeleted(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState before) {\n                    removedNodes.put(rp.getId(before), org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.tag('-');\n                    buff.value(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.newline();\n                }\n            };\n            diffHandler.start(node1, node2, path);\n            addedNodes.keySet().retainAll(removedNodes.keySet());\n            if (!addedNodes.isEmpty()) {\n                removedNodes.keySet().retainAll(addedNodes.keySet());\n                buff.resetWriter();\n                diffHandler = new org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler(rp) {\n                    @java.lang.Override\n                    public void propertyAdded(org.apache.jackrabbit.mk.model.PropertyState after) {\n                        buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                    }\n\n                    @java.lang.Override\n                    public void propertyChanged(org.apache.jackrabbit.mk.model.PropertyState before, org.apache.jackrabbit.mk.model.PropertyState after) {\n                        buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                    }\n\n                    @java.lang.Override\n                    public void propertyDeleted(org.apache.jackrabbit.mk.model.PropertyState before) {\n                        buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), before.getName())).value(null).newline();\n                    }\n\n                    @java.lang.Override\n                    public void childNodeAdded(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState after) {\n                        if (addedNodes.containsKey(rp.getId(after))) {\n                            return;\n                        }\n                        buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name)).object();\n                        toJson(buff, after, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                        buff.endObject().newline();\n                    }\n\n                    @java.lang.Override\n                    public void childNodeDeleted(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState before) {\n                        if (addedNodes.containsKey(rp.getId(before))) {\n                            return;\n                        }\n                        buff.tag('-');\n                        buff.value(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                        buff.newline();\n                    }\n                };\n                diffHandler.start(node1, node2, path);\n                for (java.util.Map.Entry<org.apache.jackrabbit.mk.model.Id, java.lang.String> entry : addedNodes.entrySet()) {\n                    buff.tag('>').key(removedNodes.get(entry.getKey())).value(entry.getValue()).newline();\n                }\n            }\n            return buff.toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public boolean nodeExists(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        return rep.nodeExists(revisionId, path);\n    }\n\n    public long getChildNodeCount(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            return rep.getNodeState(revisionId, path).getChildNodeCount();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getNodes(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        return getNodes(path, revision, 1, 0, -1, null);\n    }\n\n    public java.lang.String getNodes(java.lang.String path, java.lang.String revision, int depth, long offset, int count, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            org.apache.jackrabbit.mk.json.JsopBuilder buf = new org.apache.jackrabbit.mk.json.JsopBuilder().object();\n            toJson(buf, rep.getNodeState(revisionId, path), depth, ((int) (offset)), count, true);\n            return buf.endObject().toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String commit(java.lang.String path, java.lang.String jsonDiff, java.lang.String revision, java.lang.String message) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        if ((path.length() > 0) && (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(path))) {\n            throw new java.lang.IllegalArgumentException(\"absolute path expected: \" + path);\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            org.apache.jackrabbit.mk.json.JsopTokenizer t = new org.apache.jackrabbit.mk.json.JsopTokenizer(jsonDiff);\n            org.apache.jackrabbit.mk.model.CommitBuilder cb = rep.getCommitBuilder(revisionId, message);\n            while (true) {\n                int r = t.read();\n                if (r == org.apache.jackrabbit.mk.json.JsopTokenizer.END) {\n                    break;\n                }\n                int pos;\n                switch (r) {\n                    case '+' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            if (t.matches('{')) {\n                                java.lang.String nodePath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(nodePath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + nodePath) + \", pos: \") + pos);\n                                }\n                                java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(nodePath);\n                                java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getName(nodePath);\n                                java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list = new java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation>();\n                                org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, parentPath, nodeName, t);\n                                for (org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op : list) {\n                                    cb.addNode(op.path, op.name, op.props);\n                                }\n                            } else {\n                                java.lang.String value;\n                                if (t.matches(JsopTokenizer.NULL)) {\n                                    value = null;\n                                } else {\n                                    value = t.readRawValue().trim();\n                                }\n                                java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                                java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(targetPath);\n                                java.lang.String propName = org.apache.jackrabbit.mk.util.PathUtils.getName(targetPath);\n                                cb.setProperty(parentPath, propName, value);\n                            }\n                            break;\n                        }\n                    case '-' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            cb.removeNode(targetPath);\n                            break;\n                        }\n                    case '^' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            java.lang.String value;\n                            if (t.matches(JsopTokenizer.NULL)) {\n                                value = null;\n                            } else {\n                                value = t.readRawValue().trim();\n                            }\n                            java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(targetPath);\n                            java.lang.String propName = org.apache.jackrabbit.mk.util.PathUtils.getName(targetPath);\n                            cb.setProperty(parentPath, propName, value);\n                            break;\n                        }\n                    case '>' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.moveNode(srcPath, targetPath);\n                            break;\n                        }\n                    case '*' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.copyNode(srcPath, targetPath);\n                            break;\n                        }\n                    default :\n                        throw new java.lang.AssertionError(\"token type: \" + t.getTokenType());\n                }\n            } \n            org.apache.jackrabbit.mk.model.Id newHead = cb.doCommit();\n            if (!newHead.equals(revisionId)) {\n                gate.commit(newHead.toString());\n            }\n            return newHead.toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public long getLength(java.lang.String blobId) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().getBlobLength(blobId);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public int read(java.lang.String blobId, long pos, byte[] buff, int off, int length) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().readBlob(blobId, pos, buff, off, length);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String write(java.io.InputStream in) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().writeBlob(in);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    void toJson(org.apache.jackrabbit.mk.json.JsopBuilder builder, org.apache.jackrabbit.mk.model.NodeState node, int depth, int offset, int count, boolean inclVirtualProps) {\n        for (org.apache.jackrabbit.mk.model.PropertyState property : node.getProperties()) {\n            builder.key(property.getName()).encodedValue(property.getEncodedValue());\n        }\n        long childCount = node.getChildNodeCount();\n        if (inclVirtualProps) {\n            builder.key(\":childNodeCount\").value(childCount);\n        }\n        if ((childCount > 0) && (depth >= 0)) {\n            for (org.apache.jackrabbit.mk.model.ChildNodeEntry entry : node.getChildNodeEntries(offset, count)) {\n                builder.key(entry.getName()).object();\n                if (depth > 0) {\n                    toJson(builder, entry.getNode(), depth - 1, 0, -1, inclVirtualProps);\n                }\n                builder.endObject();\n            }\n        }\n    }\n\n    static void addNode(java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list, java.lang.String path, java.lang.String name, org.apache.jackrabbit.mk.json.JsopTokenizer t) throws java.lang.Exception {\n        org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op = new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation();\n        op.path = path;\n        op.name = name;\n        list.add(op);\n        if (!t.matches('}')) {\n            do {\n                java.lang.String key = t.readString();\n                t.read(':');\n                if (t.matches('{')) {\n                    org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, org.apache.jackrabbit.mk.util.PathUtils.concat(path, name), key, t);\n                } else {\n                    op.props.put(key, t.readRawValue().trim());\n                }\n            } while (t.matches(',') );\n            t.read('}');\n        }\n    }\n\n    static class AddNodeOperation {\n        java.lang.String path;\n\n        java.lang.String name;\n\n        java.util.Map<java.lang.String, java.lang.String> props = new java.util.HashMap<java.lang.String, java.lang.String>();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "diffCache.clear()",
            "src_parent": "{\n    gate.commit(\"end\");\n    if (rep != null) {\n        try {\n            rep.shutDown();\n        } catch (java.lang.Exception ignore) {\n        }\n        rep = null;\n    }\n    diffCache.clear();\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Try",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "java.lang.String diff = diffCache.get(commit.getId())",
            "src_parent": "{\n    org.apache.jackrabbit.mk.model.StoredCommit commit = commits.get(i);\n    if (commit.getParentId() == null) {\n        continue;\n    }\n    commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg());\n    java.lang.String diff = diffCache.get(commit.getId());\n    if (diff == null) {\n        diff = diff(commit.getParentId(), commit.getId(), filter);\n        diffCache.put(commit.getId(), diff);\n    }\n    commitBuff.key(\"changes\").value(diff).endObject();\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Try",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "if (diff == null) {\n    diff = diff(commit.getParentId(), commit.getId(), filter);\n    diffCache.put(commit.getId(), diff);\n}",
            "src_parent": "{\n    org.apache.jackrabbit.mk.model.StoredCommit commit = commits.get(i);\n    if (commit.getParentId() == null) {\n        continue;\n    }\n    commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg());\n    java.lang.String diff = diffCache.get(commit.getId());\n    if (diff == null) {\n        diff = diff(commit.getParentId(), commit.getId(), filter);\n        diffCache.put(commit.getId(), diff);\n    }\n    commitBuff.key(\"changes\").value(diff).endObject();\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "For",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "commitBuff",
            "src_parent": "commitBuff.key(\"changes\")",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Break",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Case",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list = new java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation>()",
            "src_parent": "{\n    java.lang.String nodePath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n    if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(nodePath)) {\n        throw new java.lang.Exception(((\"absolute path expected: \" + nodePath) + \", pos: \") + pos);\n    }\n    java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(nodePath);\n    java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getName(nodePath);\n    java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list = new java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation>();\n    org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, parentPath, nodeName, t);\n    for (org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op : list) {\n        cb.addNode(op.path, op.name, op.props);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Break",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Case",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "for (org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op : list) {\n    cb.addNode(op.path, op.name, op.props);\n}",
            "src_parent": "{\n    java.lang.String nodePath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n    if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(nodePath)) {\n        throw new java.lang.Exception(((\"absolute path expected: \" + nodePath) + \", pos: \") + pos);\n    }\n    java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(nodePath);\n    java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getName(nodePath);\n    java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list = new java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation>();\n    org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, parentPath, nodeName, t);\n    for (org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op : list) {\n        cb.addNode(op.path, op.name, op.props);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "ForEach"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "static class AddNodeOperation {\n    java.lang.String path;\n\n    java.lang.String name;\n\n    java.util.Map<java.lang.String, java.lang.String> props = new java.util.HashMap<java.lang.String, java.lang.String>();\n}",
            "src_parent": "public class MicroKernelImpl implements org.apache.jackrabbit.mk.api.MicroKernel {\n    protected org.apache.jackrabbit.mk.core.Repository rep;\n\n    private final org.apache.jackrabbit.mk.util.CommitGate gate = new org.apache.jackrabbit.mk.util.CommitGate();\n\n    private final java.util.Map<org.apache.jackrabbit.mk.model.Id, java.lang.String> diffCache = java.util.Collections.synchronizedMap(org.apache.jackrabbit.mk.util.SimpleLRUCache.<org.apache.jackrabbit.mk.model.Id, java.lang.String>newInstance(100));\n\n    public MicroKernelImpl(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        init(homeDir);\n    }\n\n    public MicroKernelImpl() {\n        this(new org.apache.jackrabbit.mk.core.Repository());\n    }\n\n    public MicroKernelImpl(org.apache.jackrabbit.mk.core.Repository rep) {\n        this.rep = rep;\n    }\n\n    protected void init(java.lang.String homeDir) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            rep = new org.apache.jackrabbit.mk.core.Repository(homeDir);\n            rep.init();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public void dispose() {\n        gate.commit(\"end\");\n        if (rep != null) {\n            try {\n                rep.shutDown();\n            } catch (java.lang.Exception ignore) {\n            }\n            rep = null;\n        }\n        diffCache.clear();\n    }\n\n    public java.lang.String getHeadRevision() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        return getHeadRevisionId().toString();\n    }\n\n    private org.apache.jackrabbit.mk.model.Id getHeadRevisionId() throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        try {\n            return rep.getHeadRevision();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getRevisions(long since, int maxEntries) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        maxEntries = (maxEntries < 0) ? java.lang.Integer.MAX_VALUE : maxEntries;\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> history = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = rep.getHeadCommit();\n            while (((commit != null) && (history.size() < maxEntries)) && (commit.getCommitTS() >= since)) {\n                history.add(commit);\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n            } \n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder buff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = history.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = history.get(i);\n            buff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).endObject();\n        }\n        return buff.endArray().toString();\n    }\n\n    public java.lang.String waitForCommit(java.lang.String oldHeadRevision, long maxWaitMillis) throws java.lang.InterruptedException, org.apache.jackrabbit.mk.api.MicroKernelException {\n        return gate.waitForCommit(oldHeadRevision, maxWaitMillis);\n    }\n\n    public java.lang.String getJournal(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id fromRevisionId = org.apache.jackrabbit.mk.model.Id.fromString(fromRevision);\n        org.apache.jackrabbit.mk.model.Id toRevisionId = (toRevision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        java.util.List<org.apache.jackrabbit.mk.model.StoredCommit> commits = new java.util.ArrayList<org.apache.jackrabbit.mk.model.StoredCommit>();\n        try {\n            org.apache.jackrabbit.mk.model.StoredCommit toCommit = rep.getCommit(toRevisionId);\n            org.apache.jackrabbit.mk.model.Commit fromCommit;\n            if (toRevisionId.equals(fromRevisionId)) {\n                fromCommit = toCommit;\n            } else {\n                fromCommit = rep.getCommit(fromRevisionId);\n                if (fromCommit.getCommitTS() > toCommit.getCommitTS()) {\n                    return \"[]\";\n                }\n            }\n            org.apache.jackrabbit.mk.model.StoredCommit commit = toCommit;\n            while (commit != null) {\n                commits.add(commit);\n                if (commit.getId().equals(fromRevisionId)) {\n                    break;\n                }\n                org.apache.jackrabbit.mk.model.Id commitId = commit.getParentId();\n                if (commitId == null) {\n                    break;\n                }\n                commit = rep.getCommit(commitId);\n            } \n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n        org.apache.jackrabbit.mk.json.JsopBuilder commitBuff = new org.apache.jackrabbit.mk.json.JsopBuilder().array();\n        for (int i = commits.size() - 1; i >= 0; i--) {\n            org.apache.jackrabbit.mk.model.StoredCommit commit = commits.get(i);\n            if (commit.getParentId() == null) {\n                continue;\n            }\n            commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg());\n            java.lang.String diff = diffCache.get(commit.getId());\n            if (diff == null) {\n                diff = diff(commit.getParentId(), commit.getId(), filter);\n                diffCache.put(commit.getId(), diff);\n            }\n            commitBuff.key(\"changes\").value(diff).endObject();\n        }\n        return commitBuff.endArray().toString();\n    }\n\n    public java.lang.String diff(java.lang.String fromRevision, java.lang.String toRevision, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        org.apache.jackrabbit.mk.model.Id toRevisionId = (toRevision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(toRevision);\n        return diff(org.apache.jackrabbit.mk.model.Id.fromString(fromRevision), toRevisionId, filter);\n    }\n\n    private java.lang.String diff(org.apache.jackrabbit.mk.model.Id fromRevisionId, org.apache.jackrabbit.mk.model.Id toRevisionId, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        java.lang.String path = \"/\";\n        try {\n            final org.apache.jackrabbit.mk.json.JsopBuilder buff = new org.apache.jackrabbit.mk.json.JsopBuilder();\n            final org.apache.jackrabbit.mk.store.RevisionProvider rp = rep.getRevisionStore();\n            final java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String> addedNodes = new java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String>();\n            final java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String> removedNodes = new java.util.HashMap<org.apache.jackrabbit.mk.model.Id, java.lang.String>();\n            org.apache.jackrabbit.mk.model.NodeState node1;\n            org.apache.jackrabbit.mk.model.NodeState node2;\n            try {\n                node1 = rep.getNodeState(fromRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n                node1 = null;\n            }\n            try {\n                node2 = rep.getNodeState(toRevisionId, path);\n            } catch (org.apache.jackrabbit.mk.store.NotFoundException e) {\n                node2 = null;\n            }\n            if (node1 == null) {\n                if (node2 != null) {\n                    buff.tag('+').key(path).object();\n                    toJson(buff, node2, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                    return buff.endObject().newline().toString();\n                } else {\n                    throw new org.apache.jackrabbit.mk.api.MicroKernelException(\"path doesn't exist in the specified revisions: \" + path);\n                }\n            } else if (node2 == null) {\n                buff.tag('-');\n                buff.value(path);\n                return buff.newline().toString();\n            }\n            org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler diffHandler = new org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler(rp) {\n                @java.lang.Override\n                public void propertyAdded(org.apache.jackrabbit.mk.model.PropertyState after) {\n                    buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                }\n\n                @java.lang.Override\n                public void propertyChanged(org.apache.jackrabbit.mk.model.PropertyState before, org.apache.jackrabbit.mk.model.PropertyState after) {\n                    buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                }\n\n                @java.lang.Override\n                public void propertyDeleted(org.apache.jackrabbit.mk.model.PropertyState before) {\n                    buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), before.getName())).value(null).newline();\n                }\n\n                @java.lang.Override\n                public void childNodeAdded(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState after) {\n                    addedNodes.put(rp.getId(after), org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name)).object();\n                    toJson(buff, after, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                    buff.endObject().newline();\n                }\n\n                @java.lang.Override\n                public void childNodeDeleted(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState before) {\n                    removedNodes.put(rp.getId(before), org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.tag('-');\n                    buff.value(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                    buff.newline();\n                }\n            };\n            diffHandler.start(node1, node2, path);\n            addedNodes.keySet().retainAll(removedNodes.keySet());\n            if (!addedNodes.isEmpty()) {\n                removedNodes.keySet().retainAll(addedNodes.keySet());\n                buff.resetWriter();\n                diffHandler = new org.apache.jackrabbit.mk.model.TraversingNodeDiffHandler(rp) {\n                    @java.lang.Override\n                    public void propertyAdded(org.apache.jackrabbit.mk.model.PropertyState after) {\n                        buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                    }\n\n                    @java.lang.Override\n                    public void propertyChanged(org.apache.jackrabbit.mk.model.PropertyState before, org.apache.jackrabbit.mk.model.PropertyState after) {\n                        buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), after.getName())).encodedValue(after.getEncodedValue()).newline();\n                    }\n\n                    @java.lang.Override\n                    public void propertyDeleted(org.apache.jackrabbit.mk.model.PropertyState before) {\n                        buff.tag('^').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), before.getName())).value(null).newline();\n                    }\n\n                    @java.lang.Override\n                    public void childNodeAdded(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState after) {\n                        if (addedNodes.containsKey(rp.getId(after))) {\n                            return;\n                        }\n                        buff.tag('+').key(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name)).object();\n                        toJson(buff, after, java.lang.Integer.MAX_VALUE, 0, -1, false);\n                        buff.endObject().newline();\n                    }\n\n                    @java.lang.Override\n                    public void childNodeDeleted(java.lang.String name, org.apache.jackrabbit.mk.model.NodeState before) {\n                        if (addedNodes.containsKey(rp.getId(before))) {\n                            return;\n                        }\n                        buff.tag('-');\n                        buff.value(org.apache.jackrabbit.mk.util.PathUtils.concat(getCurrentPath(), name));\n                        buff.newline();\n                    }\n                };\n                diffHandler.start(node1, node2, path);\n                for (java.util.Map.Entry<org.apache.jackrabbit.mk.model.Id, java.lang.String> entry : addedNodes.entrySet()) {\n                    buff.tag('>').key(removedNodes.get(entry.getKey())).value(entry.getValue()).newline();\n                }\n            }\n            return buff.toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public boolean nodeExists(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        return rep.nodeExists(revisionId, path);\n    }\n\n    public long getChildNodeCount(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            return rep.getNodeState(revisionId, path).getChildNodeCount();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String getNodes(java.lang.String path, java.lang.String revision) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        return getNodes(path, revision, 1, 0, -1, null);\n    }\n\n    public java.lang.String getNodes(java.lang.String path, java.lang.String revision, int depth, long offset, int count, java.lang.String filter) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            org.apache.jackrabbit.mk.json.JsopBuilder buf = new org.apache.jackrabbit.mk.json.JsopBuilder().object();\n            toJson(buf, rep.getNodeState(revisionId, path), depth, ((int) (offset)), count, true);\n            return buf.endObject().toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String commit(java.lang.String path, java.lang.String jsonDiff, java.lang.String revision, java.lang.String message) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        if ((path.length() > 0) && (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(path))) {\n            throw new java.lang.IllegalArgumentException(\"absolute path expected: \" + path);\n        }\n        org.apache.jackrabbit.mk.model.Id revisionId = (revision == null) ? getHeadRevisionId() : org.apache.jackrabbit.mk.model.Id.fromString(revision);\n        try {\n            org.apache.jackrabbit.mk.json.JsopTokenizer t = new org.apache.jackrabbit.mk.json.JsopTokenizer(jsonDiff);\n            org.apache.jackrabbit.mk.model.CommitBuilder cb = rep.getCommitBuilder(revisionId, message);\n            while (true) {\n                int r = t.read();\n                if (r == org.apache.jackrabbit.mk.json.JsopTokenizer.END) {\n                    break;\n                }\n                int pos;\n                switch (r) {\n                    case '+' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            if (t.matches('{')) {\n                                java.lang.String nodePath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(nodePath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + nodePath) + \", pos: \") + pos);\n                                }\n                                java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(nodePath);\n                                java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getName(nodePath);\n                                java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list = new java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation>();\n                                org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, parentPath, nodeName, t);\n                                for (org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op : list) {\n                                    cb.addNode(op.path, op.name, op.props);\n                                }\n                            } else {\n                                java.lang.String value;\n                                if (t.matches(JsopTokenizer.NULL)) {\n                                    value = null;\n                                } else {\n                                    value = t.readRawValue().trim();\n                                }\n                                java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                                java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(targetPath);\n                                java.lang.String propName = org.apache.jackrabbit.mk.util.PathUtils.getName(targetPath);\n                                cb.setProperty(parentPath, propName, value);\n                            }\n                            break;\n                        }\n                    case '-' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            cb.removeNode(targetPath);\n                            break;\n                        }\n                    case '^' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            t.read(':');\n                            java.lang.String value;\n                            if (t.matches(JsopTokenizer.NULL)) {\n                                value = null;\n                            } else {\n                                value = t.readRawValue().trim();\n                            }\n                            java.lang.String targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                            }\n                            java.lang.String parentPath = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(targetPath);\n                            java.lang.String propName = org.apache.jackrabbit.mk.util.PathUtils.getName(targetPath);\n                            cb.setProperty(parentPath, propName, value);\n                            break;\n                        }\n                    case '>' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.moveNode(srcPath, targetPath);\n                            break;\n                        }\n                    case '*' :\n                        {\n                            pos = t.getLastPos();\n                            java.lang.String subPath = t.readString();\n                            java.lang.String srcPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, subPath);\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(srcPath)) {\n                                throw new java.lang.Exception(((\"absolute path expected: \" + srcPath) + \", pos: \") + pos);\n                            }\n                            t.read(':');\n                            pos = t.getLastPos();\n                            java.lang.String targetPath = t.readString();\n                            if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                targetPath = org.apache.jackrabbit.mk.util.PathUtils.concat(path, targetPath);\n                                if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(targetPath)) {\n                                    throw new java.lang.Exception(((\"absolute path expected: \" + targetPath) + \", pos: \") + pos);\n                                }\n                            }\n                            cb.copyNode(srcPath, targetPath);\n                            break;\n                        }\n                    default :\n                        throw new java.lang.AssertionError(\"token type: \" + t.getTokenType());\n                }\n            } \n            org.apache.jackrabbit.mk.model.Id newHead = cb.doCommit();\n            if (!newHead.equals(revisionId)) {\n                gate.commit(newHead.toString());\n            }\n            return newHead.toString();\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public long getLength(java.lang.String blobId) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().getBlobLength(blobId);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public int read(java.lang.String blobId, long pos, byte[] buff, int off, int length) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().readBlob(blobId, pos, buff, off, length);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    public java.lang.String write(java.io.InputStream in) throws org.apache.jackrabbit.mk.api.MicroKernelException {\n        if (rep == null) {\n            throw new java.lang.IllegalStateException(\"this instance has already been disposed\");\n        }\n        try {\n            return rep.getBlobStore().writeBlob(in);\n        } catch (java.lang.Exception e) {\n            throw new org.apache.jackrabbit.mk.api.MicroKernelException(e);\n        }\n    }\n\n    void toJson(org.apache.jackrabbit.mk.json.JsopBuilder builder, org.apache.jackrabbit.mk.model.NodeState node, int depth, int offset, int count, boolean inclVirtualProps) {\n        for (org.apache.jackrabbit.mk.model.PropertyState property : node.getProperties()) {\n            builder.key(property.getName()).encodedValue(property.getEncodedValue());\n        }\n        long childCount = node.getChildNodeCount();\n        if (inclVirtualProps) {\n            builder.key(\":childNodeCount\").value(childCount);\n        }\n        if ((childCount > 0) && (depth >= 0)) {\n            for (org.apache.jackrabbit.mk.model.ChildNodeEntry entry : node.getChildNodeEntries(offset, count)) {\n                builder.key(entry.getName()).object();\n                if (depth > 0) {\n                    toJson(builder, entry.getNode(), depth - 1, 0, -1, inclVirtualProps);\n                }\n                builder.endObject();\n            }\n        }\n    }\n\n    static void addNode(java.util.LinkedList<org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation> list, java.lang.String path, java.lang.String name, org.apache.jackrabbit.mk.json.JsopTokenizer t) throws java.lang.Exception {\n        org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation op = new org.apache.jackrabbit.mk.core.MicroKernelImpl.AddNodeOperation();\n        op.path = path;\n        op.name = name;\n        list.add(op);\n        if (!t.matches('}')) {\n            do {\n                java.lang.String key = t.readString();\n                t.read(':');\n                if (t.matches('{')) {\n                    org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, org.apache.jackrabbit.mk.util.PathUtils.concat(path, name), key, t);\n                } else {\n                    op.props.put(key, t.readRawValue().trim());\n                }\n            } while (t.matches(',') );\n            t.read('}');\n        }\n    }\n\n    static class AddNodeOperation {\n        java.lang.String path;\n\n        java.lang.String name;\n\n        java.util.Map<java.lang.String, java.lang.String> props = new java.util.HashMap<java.lang.String, java.lang.String>();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Class"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "For",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "commit.getChanges()",
            "src_parent": "commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg()).key(\"changes\").value(commit.getChanges())",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Break",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Case",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "parseNode(t)",
            "src_parent": "cb.addNode(parentPath, nodeName, parseNode(t))",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Try",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "For",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg())",
            "dst_parent": "commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg()).key(\"changes\")",
            "dst_parent_type": "Invocation",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg())",
            "src_parent": "{\n    org.apache.jackrabbit.mk.model.StoredCommit commit = commits.get(i);\n    if (commit.getParentId() == null) {\n        continue;\n    }\n    commitBuff.object().key(\"id\").value(commit.getId().toString()).key(\"ts\").value(commit.getCommitTS()).key(\"msg\").value(commit.getMsg());\n    java.lang.String diff = diffCache.get(commit.getId());\n    if (diff == null) {\n        diff = diff(commit.getParentId(), commit.getId(), filter);\n        diffCache.put(commit.getId(), diff);\n    }\n    commitBuff.key(\"changes\").value(diff).endObject();\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "For",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "commit",
            "dst_parent": "commit.getChanges()",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "diff",
            "src_parent": "commitBuff.key(\"changes\").value(diff)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "t",
            "dst_parent": "parseNode(t)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "t",
            "src_parent": "org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, org.apache.jackrabbit.mk.util.PathUtils.concat(path, name), key, t)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "t",
            "dst_parent": "parseNode(t)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "t",
            "src_parent": "org.apache.jackrabbit.mk.core.MicroKernelImpl.addNode(list, parentPath, nodeName, t)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        }
      ],
      "file_name": "MicroKernelImpl"
    }
  ],
  "id": "jackrabbit-oak_668f08f2"
}