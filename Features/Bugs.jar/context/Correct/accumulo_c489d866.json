{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "java.util.HashSet<java.lang.String> emptyTableIds = new java.util.HashSet<java.lang.String>()",
            "src_parent": "{\n    org.apache.accumulo.core.util.TableDiskUsage tdu = new org.apache.accumulo.core.util.TableDiskUsage();\n    java.util.HashSet<java.lang.String> tableIds = new java.util.HashSet<java.lang.String>();\n    for (java.lang.String tableName : tables) {\n        java.lang.String tableId = conn.tableOperations().tableIdMap().get(tableName);\n        if (tableId == null) {\n            throw new org.apache.accumulo.core.client.TableNotFoundException(null, tableName, (\"Table \" + tableName) + \" not found\");\n        }\n        tableIds.add(tableId);\n    }\n    for (java.lang.String tableId : tableIds) {\n        tdu.addTable(tableId);\n    }\n    java.util.HashSet<java.lang.String> tablesReferenced = new java.util.HashSet<java.lang.String>(tableIds);\n    java.util.HashSet<java.lang.String> emptyTableIds = new java.util.HashSet<java.lang.String>();\n    for (java.lang.String tableId : tableIds) {\n        org.apache.accumulo.core.client.Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\n        mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\n        mdScanner.setRange(new org.apache.accumulo.core.data.KeyExtent(new org.apache.hadoop.io.Text(tableId), null, null).toMetadataRange());\n        if (!mdScanner.iterator().hasNext()) {\n            emptyTableIds.add(tableId);\n        }\n        for (java.util.Map.Entry<org.apache.accumulo.core.data.Key, org.apache.accumulo.core.data.Value> entry : mdScanner) {\n            java.lang.String file = entry.getKey().getColumnQualifier().toString();\n            if (file.startsWith(\"../\")) {\n                file = file.substring(2);\n                tablesReferenced.add(file.split(\"\\\\/\")[1]);\n            } else {\n                file = (\"/\" + tableId) + file;\n            }\n            tdu.linkFileAndTable(tableId, file);\n        }\n    }\n    for (java.lang.String tableId : tablesReferenced) {\n        org.apache.hadoop.fs.FileStatus[] files = fs.globStatus(new org.apache.hadoop.fs.Path(((org.apache.accumulo.core.Constants.getTablesDir(acuConf) + \"/\") + tableId) + \"/*/*\"));\n        for (org.apache.hadoop.fs.FileStatus fileStatus : files) {\n            java.lang.String dir = fileStatus.getPath().getParent().getName();\n            java.lang.String name = fileStatus.getPath().getName();\n            tdu.addFileSize(((((\"/\" + tableId) + \"/\") + dir) + \"/\") + name, fileStatus.getLen());\n        }\n    }\n    java.util.HashMap<java.lang.String, java.lang.String> reverseTableIdMap = new java.util.HashMap<java.lang.String, java.lang.String>();\n    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : conn.tableOperations().tableIdMap().entrySet()) {\n        reverseTableIdMap.put(entry.getValue(), entry.getKey());\n    }\n    java.util.TreeMap<java.util.TreeSet<java.lang.String>, java.lang.Long> usage = new java.util.TreeMap<java.util.TreeSet<java.lang.String>, java.lang.Long>(new java.util.Comparator<java.util.TreeSet<java.lang.String>>() {\n        @java.lang.Override\n        public int compare(java.util.TreeSet<java.lang.String> o1, java.util.TreeSet<java.lang.String> o2) {\n            int len1 = o1.size();\n            int len2 = o2.size();\n            int min = java.lang.Math.min(len1, len2);\n            java.util.Iterator<java.lang.String> iter1 = o1.iterator();\n            java.util.Iterator<java.lang.String> iter2 = o2.iterator();\n            int count = 0;\n            while (count < min) {\n                java.lang.String s1 = iter1.next();\n                java.lang.String s2 = iter2.next();\n                int cmp = s1.compareTo(s2);\n                if (cmp != 0) {\n                    return cmp;\n                }\n                count++;\n            } \n            return len1 - len2;\n        }\n    });\n    for (java.util.Map.Entry<java.util.List<java.lang.String>, java.lang.Long> entry : tdu.calculateUsage().entrySet()) {\n        java.util.TreeSet<java.lang.String> tableNames = new java.util.TreeSet<java.lang.String>();\n        for (java.lang.String tableId : entry.getKey()) {\n            tableNames.add(reverseTableIdMap.get(tableId));\n        }\n        usage.put(tableNames, entry.getValue());\n    }\n    if (!emptyTableIds.isEmpty()) {\n        java.util.TreeSet<java.lang.String> emptyTables = new java.util.TreeSet<java.lang.String>();\n        for (java.lang.String tableId : emptyTableIds) {\n            emptyTables.add(reverseTableIdMap.get(tableId));\n        }\n        usage.put(emptyTables, 0L);\n    }\n    for (java.util.Map.Entry<java.util.TreeSet<java.lang.String>, java.lang.Long> entry : usage.entrySet()) {\n        printer.print(java.lang.String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (!emptyTableIds.isEmpty()) {\n    java.util.TreeSet<java.lang.String> emptyTables = new java.util.TreeSet<java.lang.String>();\n    for (java.lang.String tableId : emptyTableIds) {\n        emptyTables.add(reverseTableIdMap.get(tableId));\n    }\n    usage.put(emptyTables, 0L);\n}",
            "src_parent": "{\n    org.apache.accumulo.core.util.TableDiskUsage tdu = new org.apache.accumulo.core.util.TableDiskUsage();\n    java.util.HashSet<java.lang.String> tableIds = new java.util.HashSet<java.lang.String>();\n    for (java.lang.String tableName : tables) {\n        java.lang.String tableId = conn.tableOperations().tableIdMap().get(tableName);\n        if (tableId == null) {\n            throw new org.apache.accumulo.core.client.TableNotFoundException(null, tableName, (\"Table \" + tableName) + \" not found\");\n        }\n        tableIds.add(tableId);\n    }\n    for (java.lang.String tableId : tableIds) {\n        tdu.addTable(tableId);\n    }\n    java.util.HashSet<java.lang.String> tablesReferenced = new java.util.HashSet<java.lang.String>(tableIds);\n    java.util.HashSet<java.lang.String> emptyTableIds = new java.util.HashSet<java.lang.String>();\n    for (java.lang.String tableId : tableIds) {\n        org.apache.accumulo.core.client.Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\n        mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\n        mdScanner.setRange(new org.apache.accumulo.core.data.KeyExtent(new org.apache.hadoop.io.Text(tableId), null, null).toMetadataRange());\n        if (!mdScanner.iterator().hasNext()) {\n            emptyTableIds.add(tableId);\n        }\n        for (java.util.Map.Entry<org.apache.accumulo.core.data.Key, org.apache.accumulo.core.data.Value> entry : mdScanner) {\n            java.lang.String file = entry.getKey().getColumnQualifier().toString();\n            if (file.startsWith(\"../\")) {\n                file = file.substring(2);\n                tablesReferenced.add(file.split(\"\\\\/\")[1]);\n            } else {\n                file = (\"/\" + tableId) + file;\n            }\n            tdu.linkFileAndTable(tableId, file);\n        }\n    }\n    for (java.lang.String tableId : tablesReferenced) {\n        org.apache.hadoop.fs.FileStatus[] files = fs.globStatus(new org.apache.hadoop.fs.Path(((org.apache.accumulo.core.Constants.getTablesDir(acuConf) + \"/\") + tableId) + \"/*/*\"));\n        for (org.apache.hadoop.fs.FileStatus fileStatus : files) {\n            java.lang.String dir = fileStatus.getPath().getParent().getName();\n            java.lang.String name = fileStatus.getPath().getName();\n            tdu.addFileSize(((((\"/\" + tableId) + \"/\") + dir) + \"/\") + name, fileStatus.getLen());\n        }\n    }\n    java.util.HashMap<java.lang.String, java.lang.String> reverseTableIdMap = new java.util.HashMap<java.lang.String, java.lang.String>();\n    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : conn.tableOperations().tableIdMap().entrySet()) {\n        reverseTableIdMap.put(entry.getValue(), entry.getKey());\n    }\n    java.util.TreeMap<java.util.TreeSet<java.lang.String>, java.lang.Long> usage = new java.util.TreeMap<java.util.TreeSet<java.lang.String>, java.lang.Long>(new java.util.Comparator<java.util.TreeSet<java.lang.String>>() {\n        @java.lang.Override\n        public int compare(java.util.TreeSet<java.lang.String> o1, java.util.TreeSet<java.lang.String> o2) {\n            int len1 = o1.size();\n            int len2 = o2.size();\n            int min = java.lang.Math.min(len1, len2);\n            java.util.Iterator<java.lang.String> iter1 = o1.iterator();\n            java.util.Iterator<java.lang.String> iter2 = o2.iterator();\n            int count = 0;\n            while (count < min) {\n                java.lang.String s1 = iter1.next();\n                java.lang.String s2 = iter2.next();\n                int cmp = s1.compareTo(s2);\n                if (cmp != 0) {\n                    return cmp;\n                }\n                count++;\n            } \n            return len1 - len2;\n        }\n    });\n    for (java.util.Map.Entry<java.util.List<java.lang.String>, java.lang.Long> entry : tdu.calculateUsage().entrySet()) {\n        java.util.TreeSet<java.lang.String> tableNames = new java.util.TreeSet<java.lang.String>();\n        for (java.lang.String tableId : entry.getKey()) {\n            tableNames.add(reverseTableIdMap.get(tableId));\n        }\n        usage.put(tableNames, entry.getValue());\n    }\n    if (!emptyTableIds.isEmpty()) {\n        java.util.TreeSet<java.lang.String> emptyTables = new java.util.TreeSet<java.lang.String>();\n        for (java.lang.String tableId : emptyTableIds) {\n            emptyTables.add(reverseTableIdMap.get(tableId));\n        }\n        usage.put(emptyTables, 0L);\n    }\n    for (java.util.Map.Entry<java.util.TreeSet<java.lang.String>, java.lang.Long> entry : usage.entrySet()) {\n        printer.print(java.lang.String.format(\"%,24d %s\", entry.getValue(), entry.getKey()));\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "ForEach",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (!mdScanner.iterator().hasNext()) {\n    emptyTableIds.add(tableId);\n}",
            "src_parent": "{\n    org.apache.accumulo.core.client.Scanner mdScanner = conn.createScanner(Constants.METADATA_TABLE_NAME, Constants.NO_AUTHS);\n    mdScanner.fetchColumnFamily(Constants.METADATA_DATAFILE_COLUMN_FAMILY);\n    mdScanner.setRange(new org.apache.accumulo.core.data.KeyExtent(new org.apache.hadoop.io.Text(tableId), null, null).toMetadataRange());\n    if (!mdScanner.iterator().hasNext()) {\n        emptyTableIds.add(tableId);\n    }\n    for (java.util.Map.Entry<org.apache.accumulo.core.data.Key, org.apache.accumulo.core.data.Value> entry : mdScanner) {\n        java.lang.String file = entry.getKey().getColumnQualifier().toString();\n        if (file.startsWith(\"../\")) {\n            file = file.substring(2);\n            tablesReferenced.add(file.split(\"\\\\/\")[1]);\n        } else {\n            file = (\"/\" + tableId) + file;\n        }\n        tdu.linkFileAndTable(tableId, file);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        }
      ],
      "file_name": "TableDiskUsage"
    }
  ],
  "id": "accumulo_c489d866"
}