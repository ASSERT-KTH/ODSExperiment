{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "(c == ':') || (c == '/')",
            "src_parent": "if ((c == ':') || (c == '/')) {\n    rewritten.append('\\\\').append(c);\n} else {\n    if (escaped) {\n        rewritten.append('\\\\');\n        escaped = false;\n    }\n    rewritten.append(c);\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static final char[] LUCENE_QUERY_OPERATORS = new char[]{ ':', '/', '!', '&', '|', '[', ']', '{', '}' };",
            "src_parent": "public class LucenePropertyIndex implements org.apache.jackrabbit.oak.spi.query.QueryIndex , org.apache.jackrabbit.oak.spi.query.QueryIndex.AdvancedQueryIndex , org.apache.jackrabbit.oak.spi.query.QueryIndex.NativeQueryIndex , org.apache.jackrabbit.oak.spi.query.QueryIndex.AdvanceFulltextQueryIndex {\n    private static double MIN_COST = 2.1;\n\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.class);\n\n    private static final org.apache.jackrabbit.oak.util.PerfLogger PERF_LOGGER = new org.apache.jackrabbit.oak.util.PerfLogger(org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.class.getName() + \".perf\"));\n\n    static final java.lang.String ATTR_PLAN_RESULT = \"oak.lucene.planResult\";\n\n    static final int LUCENE_QUERY_BATCH_SIZE = 50;\n\n    protected final org.apache.jackrabbit.oak.plugins.index.lucene.IndexTracker tracker;\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.score.ScorerProviderFactory scorerProviderFactory;\n\n    private final org.apache.lucene.search.highlight.Highlighter highlighter = new org.apache.lucene.search.highlight.Highlighter(new org.apache.lucene.search.highlight.SimpleHTMLFormatter(\"<strong>\", \"</strong>\"), new org.apache.lucene.search.highlight.SimpleHTMLEncoder(), null);\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.IndexAugmentorFactory augmentorFactory;\n\n    public LucenePropertyIndex(org.apache.jackrabbit.oak.plugins.index.lucene.IndexTracker tracker) {\n        this(tracker, ScorerProviderFactory.DEFAULT);\n    }\n\n    public LucenePropertyIndex(org.apache.jackrabbit.oak.plugins.index.lucene.IndexTracker tracker, org.apache.jackrabbit.oak.plugins.index.lucene.score.ScorerProviderFactory factory) {\n        this(tracker, factory, null);\n    }\n\n    public LucenePropertyIndex(org.apache.jackrabbit.oak.plugins.index.lucene.IndexTracker tracker, org.apache.jackrabbit.oak.plugins.index.lucene.score.ScorerProviderFactory factory, org.apache.jackrabbit.oak.plugins.index.lucene.IndexAugmentorFactory augmentorFactory) {\n        this.tracker = tracker;\n        this.scorerProviderFactory = factory;\n        this.augmentorFactory = augmentorFactory;\n    }\n\n    @java.lang.Override\n    public double getMinimumCost() {\n        return org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.MIN_COST;\n    }\n\n    @java.lang.Override\n    public java.lang.String getIndexName() {\n        return \"lucene-property\";\n    }\n\n    @java.lang.Override\n    public java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan> getPlans(org.apache.jackrabbit.oak.spi.query.Filter filter, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> sortOrder, org.apache.jackrabbit.oak.spi.state.NodeState rootState) {\n        java.util.Collection<java.lang.String> indexPaths = new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexLookup(rootState).collectIndexNodePaths(filter);\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan> plans = com.google.common.collect.Lists.newArrayListWithCapacity(indexPaths.size());\n        for (java.lang.String path : indexPaths) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode indexNode = null;\n            try {\n                indexNode = tracker.acquireIndexNode(path);\n                if (indexNode != null) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner(indexNode, path, filter, sortOrder).getPlan();\n                    if (plan != null) {\n                        plans.add(plan);\n                    }\n                }\n            } finally {\n                if (indexNode != null) {\n                    indexNode.release();\n                }\n            }\n        }\n        return plans;\n    }\n\n    @java.lang.Override\n    public double getCost(org.apache.jackrabbit.oak.spi.query.Filter filter, org.apache.jackrabbit.oak.spi.state.NodeState root) {\n        throw new java.lang.UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\n    }\n\n    @java.lang.Override\n    public java.lang.String getPlan(org.apache.jackrabbit.oak.spi.query.Filter filter, org.apache.jackrabbit.oak.spi.state.NodeState root) {\n        throw new java.lang.UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\n    }\n\n    @java.lang.Override\n    public java.lang.String getPlanDescription(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan, org.apache.jackrabbit.oak.spi.state.NodeState root) {\n        org.apache.jackrabbit.oak.spi.query.Filter filter = plan.getFilter();\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode index = tracker.acquireIndexNode(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan).indexPath);\n        com.google.common.base.Preconditions.checkState(index != null, \"The Lucene index is not available\");\n        try {\n            org.apache.jackrabbit.oak.query.fulltext.FullTextExpression ft = filter.getFullTextConstraint();\n            java.lang.StringBuilder sb = new java.lang.StringBuilder(\"lucene:\");\n            java.lang.String path = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan).indexPath;\n            sb.append(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getIndexName(plan)).append(\"(\").append(path).append(\") \");\n            sb.append(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getLuceneRequest(plan, augmentorFactory, null));\n            if ((plan.getSortOrder() != null) && (!plan.getSortOrder().isEmpty())) {\n                sb.append(\" ordering:\").append(plan.getSortOrder());\n            }\n            if (ft != null) {\n                sb.append(\" ft:(\").append(ft).append(\")\");\n            }\n            return sb.toString();\n        } finally {\n            index.release();\n        }\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.query.Cursor query(final org.apache.jackrabbit.oak.spi.query.Filter filter, final org.apache.jackrabbit.oak.spi.state.NodeState root) {\n        throw new java.lang.UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.query.Cursor query(final org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan, org.apache.jackrabbit.oak.spi.state.NodeState rootState) {\n        final org.apache.jackrabbit.oak.spi.query.Filter filter = plan.getFilter();\n        final org.apache.lucene.search.Sort sort = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getSort(plan);\n        final org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult pr = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan);\n        org.apache.jackrabbit.oak.query.QueryEngineSettings settings = filter.getQueryEngineSettings();\n        java.util.Iterator<org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow> itr = new com.google.common.collect.AbstractIterator<org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow>() {\n            private final java.util.Deque<org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow> queue = com.google.common.collect.Queues.newArrayDeque();\n\n            private final java.util.Set<java.lang.String> seenPaths = com.google.common.collect.Sets.newHashSet();\n\n            private org.apache.lucene.search.ScoreDoc lastDoc;\n\n            private int nextBatchSize = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LUCENE_QUERY_BATCH_SIZE;\n\n            private boolean noDocs = false;\n\n            private long lastSearchIndexerVersion;\n\n            @java.lang.Override\n            protected org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow computeNext() {\n                while ((!queue.isEmpty()) || loadDocs()) {\n                    return queue.remove();\n                } \n                return endOfData();\n            }\n\n            private org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow convertToRow(org.apache.lucene.search.ScoreDoc doc, org.apache.lucene.search.IndexSearcher searcher, java.lang.String excerpt, org.apache.lucene.facet.Facets facets, java.lang.String explanation) throws java.io.IOException {\n                org.apache.lucene.index.IndexReader reader = searcher.getIndexReader();\n                org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.PathStoredFieldVisitor visitor = new org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.PathStoredFieldVisitor();\n                reader.document(doc.doc, visitor);\n                java.lang.String path = visitor.getPath();\n                if (path != null) {\n                    if (\"\".equals(path)) {\n                        path = \"/\";\n                    }\n                    if (pr.isPathTransformed()) {\n                        java.lang.String originalPath = path;\n                        path = pr.transformPath(path);\n                        if (path == null) {\n                            org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.trace(\"Ignoring path {} : Transformation returned null\", originalPath);\n                            return null;\n                        }\n                        if (seenPaths.contains(path)) {\n                            org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.trace(\"Ignoring path {} : Duplicate post transformation\", originalPath);\n                            return null;\n                        }\n                        seenPaths.add(path);\n                    }\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.trace(\"Matched path {}\", path);\n                    return new org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow(path, doc.score, excerpt, facets, explanation);\n                }\n                return null;\n            }\n\n            private boolean loadDocs() {\n                if (noDocs) {\n                    return false;\n                }\n                org.apache.lucene.search.ScoreDoc lastDocToRecord = null;\n                final org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode indexNode = acquireIndexNode(plan);\n                com.google.common.base.Preconditions.checkState(indexNode != null);\n                try {\n                    org.apache.lucene.search.IndexSearcher searcher = indexNode.getSearcher();\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade luceneRequestFacade = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getLuceneRequest(plan, augmentorFactory, searcher.getIndexReader());\n                    if (luceneRequestFacade.getLuceneRequest() instanceof org.apache.lucene.search.Query) {\n                        org.apache.lucene.search.Query query = ((org.apache.lucene.search.Query) (luceneRequestFacade.getLuceneRequest()));\n                        org.apache.lucene.queries.CustomScoreQuery customScoreQuery = getCustomScoreQuery(plan, query);\n                        if (customScoreQuery != null) {\n                            query = customScoreQuery;\n                        }\n                        checkForIndexVersionChange(searcher);\n                        org.apache.lucene.search.TopDocs docs;\n                        long start = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.PERF_LOGGER.start();\n                        while (true) {\n                            if (lastDoc != null) {\n                                org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.debug(\"loading the next {} entries for query {}\", nextBatchSize, query);\n                                if (sort == null) {\n                                    docs = searcher.searchAfter(lastDoc, query, nextBatchSize);\n                                } else {\n                                    docs = searcher.searchAfter(lastDoc, query, nextBatchSize, sort);\n                                }\n                            } else {\n                                org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.debug(\"loading the first {} entries for query {}\", nextBatchSize, query);\n                                if (sort == null) {\n                                    docs = searcher.search(query, nextBatchSize);\n                                } else {\n                                    docs = searcher.search(query, nextBatchSize, sort);\n                                }\n                            }\n                            org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.PERF_LOGGER.end(start, -1, \"{} ...\", docs.scoreDocs.length);\n                            nextBatchSize = ((int) (java.lang.Math.min(nextBatchSize * 2L, 100000)));\n                            long f = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.PERF_LOGGER.start();\n                            org.apache.lucene.facet.Facets facets = org.apache.jackrabbit.oak.plugins.index.lucene.util.FacetHelper.getFacets(searcher, query, docs, plan, indexNode.getDefinition().isSecureFacets());\n                            org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.PERF_LOGGER.end(f, -1, \"facets retrieved\");\n                            org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction restriction = filter.getPropertyRestriction(QueryImpl.REP_EXCERPT);\n                            boolean addExcerpt = (restriction != null) && restriction.isNotNullRestriction();\n                            restriction = filter.getPropertyRestriction(QueryImpl.OAK_SCORE_EXPLANATION);\n                            boolean addExplain = (restriction != null) && restriction.isNotNullRestriction();\n                            for (org.apache.lucene.search.ScoreDoc doc : docs.scoreDocs) {\n                                java.lang.String excerpt = null;\n                                if (addExcerpt) {\n                                    excerpt = getExcerpt(indexNode, searcher, query, doc);\n                                }\n                                java.lang.String explanation = null;\n                                if (addExplain) {\n                                    explanation = searcher.explain(query, doc.doc).toString();\n                                }\n                                org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow row = convertToRow(doc, searcher, excerpt, facets, explanation);\n                                if (row != null) {\n                                    queue.add(row);\n                                }\n                                lastDocToRecord = doc;\n                            }\n                            if (queue.isEmpty() && (docs.scoreDocs.length > 0)) {\n                                lastDoc = lastDocToRecord;\n                            } else {\n                                break;\n                            }\n                        } \n                    } else if (luceneRequestFacade.getLuceneRequest() instanceof org.apache.jackrabbit.oak.plugins.index.lucene.util.SpellcheckHelper.SpellcheckQuery) {\n                        java.lang.String aclCheckField = (indexNode.getDefinition().isFullTextEnabled()) ? FieldNames.FULLTEXT : FieldNames.SPELLCHECK;\n                        org.apache.jackrabbit.oak.plugins.index.lucene.util.SpellcheckHelper.SpellcheckQuery spellcheckQuery = ((org.apache.jackrabbit.oak.plugins.index.lucene.util.SpellcheckHelper.SpellcheckQuery) (luceneRequestFacade.getLuceneRequest()));\n                        org.apache.lucene.search.spell.SuggestWord[] suggestWords = org.apache.jackrabbit.oak.plugins.index.lucene.util.SpellcheckHelper.getSpellcheck(spellcheckQuery);\n                        org.apache.lucene.queryparser.classic.QueryParser qp = new org.apache.lucene.queryparser.classic.QueryParser(org.apache.lucene.util.Version.LUCENE_47, aclCheckField, indexNode.getDefinition().getAnalyzer());\n                        for (org.apache.lucene.search.spell.SuggestWord suggestion : suggestWords) {\n                            org.apache.lucene.search.Query query = qp.createPhraseQuery(aclCheckField, suggestion.string);\n                            org.apache.lucene.search.TopDocs topDocs = searcher.search(query, 100);\n                            if (topDocs.totalHits > 0) {\n                                for (org.apache.lucene.search.ScoreDoc doc : topDocs.scoreDocs) {\n                                    org.apache.lucene.document.Document retrievedDoc = searcher.doc(doc.doc);\n                                    if (filter.isAccessible(retrievedDoc.get(FieldNames.PATH))) {\n                                        queue.add(new org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow(suggestion.string));\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        noDocs = true;\n                    } else if (luceneRequestFacade.getLuceneRequest() instanceof org.apache.jackrabbit.oak.plugins.index.lucene.util.SuggestHelper.SuggestQuery) {\n                        org.apache.jackrabbit.oak.plugins.index.lucene.util.SuggestHelper.SuggestQuery suggestQuery = ((org.apache.jackrabbit.oak.plugins.index.lucene.util.SuggestHelper.SuggestQuery) (luceneRequestFacade.getLuceneRequest()));\n                        java.util.List<org.apache.lucene.search.suggest.Lookup.LookupResult> lookupResults = org.apache.jackrabbit.oak.plugins.index.lucene.util.SuggestHelper.getSuggestions(indexNode.getLookup(), suggestQuery);\n                        org.apache.lucene.queryparser.classic.QueryParser qp = new org.apache.lucene.queryparser.classic.QueryParser(org.apache.lucene.util.Version.LUCENE_47, FieldNames.SUGGEST, indexNode.getDefinition().isSuggestAnalyzed() ? indexNode.getDefinition().getAnalyzer() : org.apache.jackrabbit.oak.plugins.index.lucene.util.SuggestHelper.getAnalyzer());\n                        for (org.apache.lucene.search.suggest.Lookup.LookupResult suggestion : lookupResults) {\n                            org.apache.lucene.search.Query query = qp.parse((\"\\\"\" + suggestion.key.toString()) + \"\\\"\");\n                            org.apache.lucene.search.TopDocs topDocs = searcher.search(query, 100);\n                            if (topDocs.totalHits > 0) {\n                                for (org.apache.lucene.search.ScoreDoc doc : topDocs.scoreDocs) {\n                                    org.apache.lucene.document.Document retrievedDoc = searcher.doc(doc.doc);\n                                    if (filter.isAccessible(retrievedDoc.get(FieldNames.PATH))) {\n                                        queue.add(new org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow(suggestion.key.toString(), suggestion.value));\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        noDocs = true;\n                    }\n                } catch (java.lang.Exception e) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.warn(\"query via {} failed.\", LucenePropertyIndex.this, e);\n                } finally {\n                    indexNode.release();\n                }\n                if (lastDocToRecord != null) {\n                    this.lastDoc = lastDocToRecord;\n                }\n                return !queue.isEmpty();\n            }\n\n            private void checkForIndexVersionChange(org.apache.lucene.search.IndexSearcher searcher) {\n                long currentVersion = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getVersion(searcher);\n                if ((currentVersion != lastSearchIndexerVersion) && (lastDoc != null)) {\n                    lastDoc = null;\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.debug(\"Change in index version detected {} => {}. Query would be performed without \" + \"offset\", currentVersion, lastSearchIndexerVersion);\n                }\n                this.lastSearchIndexerVersion = currentVersion;\n            }\n        };\n        org.apache.jackrabbit.oak.plugins.index.lucene.SizeEstimator sizeEstimator = new org.apache.jackrabbit.oak.plugins.index.lucene.SizeEstimator() {\n            @java.lang.Override\n            public long getSize() {\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode indexNode = acquireIndexNode(plan);\n                com.google.common.base.Preconditions.checkState(indexNode != null);\n                try {\n                    org.apache.lucene.search.IndexSearcher searcher = indexNode.getSearcher();\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade luceneRequestFacade = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getLuceneRequest(plan, augmentorFactory, searcher.getIndexReader());\n                    if (luceneRequestFacade.getLuceneRequest() instanceof org.apache.lucene.search.Query) {\n                        org.apache.lucene.search.Query query = ((org.apache.lucene.search.Query) (luceneRequestFacade.getLuceneRequest()));\n                        org.apache.lucene.search.TotalHitCountCollector collector = new org.apache.lucene.search.TotalHitCountCollector();\n                        searcher.search(query, collector);\n                        int totalHits = collector.getTotalHits();\n                        org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.debug(\"Estimated size for query {} is {}\", query, totalHits);\n                        return totalHits;\n                    }\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.debug(\"estimate size: not a Query: {}\", luceneRequestFacade.getLuceneRequest());\n                } catch (java.io.IOException e) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.warn(\"query via {} failed.\", LucenePropertyIndex.this, e);\n                } finally {\n                    indexNode.release();\n                }\n                return -1;\n            }\n        };\n        return new org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LucenePathCursor(itr, plan, settings, sizeEstimator);\n    }\n\n    private java.lang.String getExcerpt(org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode indexNode, org.apache.lucene.search.IndexSearcher searcher, org.apache.lucene.search.Query query, org.apache.lucene.search.ScoreDoc doc) throws java.io.IOException {\n        java.lang.StringBuilder excerpt = new java.lang.StringBuilder();\n        org.apache.lucene.search.highlight.QueryScorer scorer = new org.apache.lucene.search.highlight.QueryScorer(query);\n        scorer.setExpandMultiTermQuery(true);\n        highlighter.setFragmentScorer(scorer);\n        org.apache.lucene.analysis.Analyzer analyzer = indexNode.getDefinition().getAnalyzer();\n        for (org.apache.lucene.index.IndexableField field : searcher.getIndexReader().document(doc.doc).getFields()) {\n            if (!org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.SUGGEST.equals(field.name())) {\n                try {\n                    org.apache.lucene.analysis.TokenStream tokenStream = analyzer.tokenStream(field.name(), field.stringValue());\n                    tokenStream.reset();\n                    org.apache.lucene.analysis.CachingTokenFilter cachingTokenFilter = new org.apache.lucene.analysis.CachingTokenFilter(tokenStream);\n                    org.apache.lucene.search.highlight.TextFragment[] textFragments = highlighter.getBestTextFragments(cachingTokenFilter, field.stringValue(), true, 2);\n                    if ((textFragments != null) && (textFragments.length > 0)) {\n                        for (org.apache.lucene.search.highlight.TextFragment fragment : textFragments) {\n                            if (excerpt.length() > 0) {\n                                excerpt.append(\"...\");\n                            }\n                            excerpt.append(fragment.toString());\n                        }\n                    }\n                } catch (org.apache.lucene.search.highlight.InvalidTokenOffsetsException e) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LOG.error(\"higlighting failed\", e);\n                }\n            }\n        }\n        return excerpt.toString();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.index.aggregate.NodeAggregator getNodeAggregator() {\n        return null;\n    }\n\n    public static boolean isNodePath(java.lang.String fulltextTermPath) {\n        return fulltextTermPath.endsWith(\"/*\");\n    }\n\n    private org.apache.jackrabbit.oak.plugins.index.lucene.IndexNode acquireIndexNode(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan) {\n        return tracker.acquireIndexNode(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan).indexPath);\n    }\n\n    private static org.apache.lucene.search.Sort getSort(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan) {\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> sortOrder = plan.getSortOrder();\n        if ((sortOrder == null) || sortOrder.isEmpty()) {\n            return null;\n        }\n        java.util.List<org.apache.lucene.search.SortField> fieldsList = com.google.common.collect.Lists.newArrayListWithCapacity(sortOrder.size());\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult planResult = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan);\n        for (int i = 0; i < sortOrder.size(); i++) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry oe = sortOrder.get(i);\n            if (!org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.isNativeSort(oe)) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = planResult.getOrderedProperty(i);\n                boolean reverse = oe.getOrder() != OrderEntry.Order.ASCENDING;\n                java.lang.String propName = oe.getPropertyName();\n                propName = org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.createDocValFieldName(propName);\n                fieldsList.add(new org.apache.lucene.search.SortField(propName, org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.toLuceneSortType(oe, pd), reverse));\n            }\n        }\n        if (fieldsList.isEmpty()) {\n            return null;\n        } else {\n            return new org.apache.lucene.search.Sort(fieldsList.toArray(new org.apache.lucene.search.SortField[0]));\n        }\n    }\n\n    private static boolean isNativeSort(org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry oe) {\n        return oe.getPropertyName().equals(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.NATIVE_SORT_ORDER.getPropertyName());\n    }\n\n    private static org.apache.jackrabbit.oak.api.Type toLuceneSortType(org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry oe, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition defn) {\n        org.apache.jackrabbit.oak.api.Type<?> t = oe.getPropertyType();\n        com.google.common.base.Preconditions.checkState(t != null, \"Type cannot be null\");\n        com.google.common.base.Preconditions.checkState(!t.isArray(), \"Array types are not supported\");\n        int type = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPropertyType(defn, oe.getPropertyName(), t.tag());\n        switch (type) {\n            case javax.jcr.PropertyType.LONG :\n            case javax.jcr.PropertyType.DATE :\n                return org.apache.jackrabbit.oak.api.Type.LONG;\n            case javax.jcr.PropertyType.DOUBLE :\n                return org.apache.jackrabbit.oak.api.Type.DOUBLE;\n            default :\n                return org.apache.jackrabbit.oak.api.Type.STRING;\n        }\n    }\n\n    private static java.lang.String getIndexName(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan) {\n        return org.apache.jackrabbit.oak.commons.PathUtils.getName(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan).indexPath);\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade getLuceneRequest(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan, org.apache.jackrabbit.oak.plugins.index.lucene.IndexAugmentorFactory augmentorFactory, org.apache.lucene.index.IndexReader reader) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.spi.FulltextQueryTermsProvider augmentor = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getIndexAgumentor(plan, augmentorFactory);\n        java.util.List<org.apache.lucene.search.Query> qs = new java.util.ArrayList<org.apache.lucene.search.Query>();\n        org.apache.jackrabbit.oak.spi.query.Filter filter = plan.getFilter();\n        org.apache.jackrabbit.oak.query.fulltext.FullTextExpression ft = filter.getFullTextConstraint();\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult planResult = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan);\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition defn = planResult.indexDefinition;\n        org.apache.lucene.analysis.Analyzer analyzer = defn.getAnalyzer();\n        if (ft == null) {\n        } else {\n            qs.add(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getFullTextQuery(plan, ft, analyzer, augmentor));\n        }\n        org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction pr = null;\n        if (defn.hasFunctionDefined()) {\n            pr = filter.getPropertyRestriction(defn.getFunctionName());\n        }\n        if (pr != null) {\n            java.lang.String query = java.lang.String.valueOf(pr.first.getValue(pr.first.getType()));\n            org.apache.lucene.queryparser.classic.QueryParser queryParser = new org.apache.lucene.queryparser.classic.QueryParser(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexConstants.VERSION, \"\", analyzer);\n            if (query.startsWith(\"mlt?\")) {\n                java.lang.String mltQueryString = query.replace(\"mlt?\", \"\");\n                if (reader != null) {\n                    org.apache.lucene.search.Query moreLikeThis = org.apache.jackrabbit.oak.plugins.index.lucene.util.MoreLikeThisHelper.getMoreLikeThis(reader, analyzer, mltQueryString);\n                    if (moreLikeThis != null) {\n                        qs.add(moreLikeThis);\n                    }\n                }\n            } else if (query.startsWith(\"spellcheck?\")) {\n                java.lang.String spellcheckQueryString = query.replace(\"spellcheck?\", \"\");\n                if (reader != null) {\n                    return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade<org.apache.jackrabbit.oak.plugins.index.lucene.util.SpellcheckHelper.SpellcheckQuery>(org.apache.jackrabbit.oak.plugins.index.lucene.util.SpellcheckHelper.getSpellcheckQuery(spellcheckQueryString, reader));\n                }\n            } else if (query.startsWith(\"suggest?\")) {\n                java.lang.String suggestQueryString = query.replace(\"suggest?\", \"\");\n                if (reader != null) {\n                    return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade<org.apache.jackrabbit.oak.plugins.index.lucene.util.SuggestHelper.SuggestQuery>(org.apache.jackrabbit.oak.plugins.index.lucene.util.SuggestHelper.getSuggestQuery(suggestQueryString));\n                }\n            } else {\n                try {\n                    qs.add(queryParser.parse(query));\n                } catch (org.apache.lucene.queryparser.classic.ParseException e) {\n                    throw new java.lang.RuntimeException(e);\n                }\n            }\n        } else if (planResult.evaluateNonFullTextConstraints()) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.addNonFullTextConstraints(qs, plan, reader);\n        }\n        if ((qs.size() == 0) && (plan.getSortOrder() != null)) {\n            java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry> orders = plan.getSortOrder();\n            for (int i = 0; i < orders.size(); i++) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.OrderEntry oe = orders.get(i);\n                if (!org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.isNativeSort(oe)) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = planResult.getOrderedProperty(i);\n                    org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction orderRest = new org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction();\n                    orderRest.propertyName = oe.getPropertyName();\n                    org.apache.lucene.search.Query q = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.createQuery(orderRest, pd);\n                    if (q != null) {\n                        qs.add(q);\n                    }\n                }\n            }\n        }\n        if (qs.size() == 0) {\n            if (reader == null) {\n                return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade<org.apache.lucene.search.Query>(new org.apache.lucene.search.MatchAllDocsQuery());\n            }\n            if (planResult.evaluateNodeTypeRestriction()) {\n                return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade<org.apache.lucene.search.Query>(new org.apache.lucene.search.MatchAllDocsQuery());\n            }\n            throw new java.lang.IllegalStateException(\"No query created for filter \" + filter);\n        }\n        return org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.performAdditionalWraps(qs);\n    }\n\n    @javax.annotation.Nonnull\n    public static org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade<org.apache.lucene.search.Query> performAdditionalWraps(@javax.annotation.Nonnull\n    java.util.List<org.apache.lucene.search.Query> qs) {\n        com.google.common.base.Preconditions.checkNotNull(qs);\n        if (qs.size() == 1) {\n            org.apache.lucene.search.Query q = qs.get(0);\n            if (q instanceof org.apache.lucene.search.BooleanQuery) {\n                org.apache.lucene.search.BooleanQuery ibq = ((org.apache.lucene.search.BooleanQuery) (q));\n                boolean onlyNotClauses = true;\n                for (org.apache.lucene.search.BooleanClause c : ibq.getClauses()) {\n                    if (c.getOccur() != BooleanClause.Occur.MUST_NOT) {\n                        onlyNotClauses = false;\n                        break;\n                    }\n                }\n                if (onlyNotClauses) {\n                    ibq.add(new org.apache.lucene.search.MatchAllDocsQuery(), BooleanClause.Occur.SHOULD);\n                }\n            }\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade<org.apache.lucene.search.Query>(qs.get(0));\n        }\n        org.apache.lucene.search.BooleanQuery bq = new org.apache.lucene.search.BooleanQuery();\n        for (org.apache.lucene.search.Query q : qs) {\n            boolean unwrapped = false;\n            if (q instanceof org.apache.lucene.search.BooleanQuery) {\n                unwrapped = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.unwrapMustNot(((org.apache.lucene.search.BooleanQuery) (q)), bq);\n            }\n            if (!unwrapped) {\n                bq.add(q, org.apache.jackrabbit.oak.plugins.index.lucene.MUST);\n            }\n        }\n        return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneRequestFacade<org.apache.lucene.search.Query>(bq);\n    }\n\n    private static boolean unwrapMustNot(@javax.annotation.Nonnull\n    org.apache.lucene.search.BooleanQuery input, @javax.annotation.Nonnull\n    org.apache.lucene.search.BooleanQuery output) {\n        com.google.common.base.Preconditions.checkNotNull(input);\n        com.google.common.base.Preconditions.checkNotNull(output);\n        boolean unwrapped = false;\n        for (org.apache.lucene.search.BooleanClause bc : input.getClauses()) {\n            if (bc.getOccur() == BooleanClause.Occur.MUST_NOT) {\n                output.add(bc);\n                unwrapped = true;\n            }\n        }\n        return unwrapped;\n    }\n\n    private org.apache.lucene.queries.CustomScoreQuery getCustomScoreQuery(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan, org.apache.lucene.search.Query subQuery) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult planResult = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan);\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition idxDef = planResult.indexDefinition;\n        java.lang.String providerName = idxDef.getScorerProviderName();\n        if ((scorerProviderFactory != null) && (providerName != null)) {\n            return scorerProviderFactory.getScorerProvider(providerName).createCustomScoreQuery(subQuery);\n        }\n        return null;\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.index.lucene.spi.FulltextQueryTermsProvider getIndexAgumentor(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan, org.apache.jackrabbit.oak.plugins.index.lucene.IndexAugmentorFactory augmentorFactory) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult planResult = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan);\n        if (augmentorFactory != null) {\n            return augmentorFactory.getFulltextQueryTermsProvider(planResult.indexingRule.getNodeTypeName());\n        }\n        return null;\n    }\n\n    private static void addNonFullTextConstraints(java.util.List<org.apache.lucene.search.Query> qs, org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan, org.apache.lucene.index.IndexReader reader) {\n        org.apache.jackrabbit.oak.spi.query.Filter filter = plan.getFilter();\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult planResult = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan);\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition defn = planResult.indexDefinition;\n        if (!filter.matchesAllTypes()) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.addNodeTypeConstraints(planResult.indexingRule, qs, filter);\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPathRestriction(plan);\n        switch (filter.getPathRestriction()) {\n            case ALL_CHILDREN :\n                if (defn.evaluatePathRestrictions()) {\n                    if (\"/\".equals(path)) {\n                        break;\n                    }\n                    qs.add(new org.apache.lucene.search.TermQuery(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newAncestorTerm(path)));\n                }\n                break;\n            case DIRECT_CHILDREN :\n                if (defn.evaluatePathRestrictions()) {\n                    org.apache.lucene.search.BooleanQuery bq = new org.apache.lucene.search.BooleanQuery();\n                    bq.add(new org.apache.lucene.search.BooleanClause(new org.apache.lucene.search.TermQuery(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newAncestorTerm(path)), BooleanClause.Occur.MUST));\n                    bq.add(new org.apache.lucene.search.BooleanClause(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.newDepthQuery(path), BooleanClause.Occur.MUST));\n                    qs.add(bq);\n                }\n                break;\n            case EXACT :\n                qs.add(new org.apache.lucene.search.TermQuery(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(path)));\n                break;\n            case PARENT :\n                if (denotesRoot(path)) {\n                    qs.add(new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(FieldNames.PATH, \"///\")));\n                } else {\n                    qs.add(new org.apache.lucene.search.TermQuery(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(getParentPath(path))));\n                }\n                break;\n            case NO_RESTRICTION :\n                break;\n        }\n        for (org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction pr : filter.getPropertyRestrictions()) {\n            java.lang.String name = pr.propertyName;\n            if ((QueryImpl.REP_EXCERPT.equals(name) || QueryImpl.OAK_SCORE_EXPLANATION.equals(name)) || QueryImpl.REP_FACET.equals(name)) {\n                continue;\n            }\n            if (QueryConstants.RESTRICTION_LOCAL_NAME.equals(name)) {\n                if (planResult.evaluateNodeNameRestriction()) {\n                    org.apache.lucene.search.Query q = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.createNodeNameQuery(pr);\n                    if (q != null) {\n                        qs.add(q);\n                    }\n                }\n                continue;\n            }\n            if ((((pr.first != null) && pr.first.equals(pr.last)) && pr.firstIncluding) && pr.lastIncluding) {\n                java.lang.String first = pr.first.getValue(org.apache.jackrabbit.oak.plugins.index.lucene.STRING);\n                first = first.replace(\"\\\\\", \"\");\n                if (org.apache.jackrabbit.oak.plugins.index.lucene.JCR_PATH.equals(name)) {\n                    qs.add(new org.apache.lucene.search.TermQuery(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(first)));\n                    continue;\n                } else if (\"*\".equals(name)) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.addReferenceConstraint(first, qs, reader);\n                    continue;\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = planResult.getPropDefn(pr);\n            if (pd == null) {\n                continue;\n            }\n            org.apache.lucene.search.Query q = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.createQuery(pr, pd);\n            if (q != null) {\n                qs.add(q);\n            }\n        }\n    }\n\n    private static int determinePropertyType(org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition defn, org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction pr) {\n        int typeFromRestriction = pr.propertyType;\n        if (typeFromRestriction == javax.jcr.PropertyType.UNDEFINED) {\n            if ((pr.first != null) && (pr.first.getType() != org.apache.jackrabbit.oak.api.Type.UNDEFINED)) {\n                typeFromRestriction = pr.first.getType().tag();\n            } else if ((pr.last != null) && (pr.last.getType() != org.apache.jackrabbit.oak.api.Type.UNDEFINED)) {\n                typeFromRestriction = pr.last.getType().tag();\n            } else if ((pr.list != null) && (!pr.list.isEmpty())) {\n                typeFromRestriction = pr.list.get(0).getType().tag();\n            }\n        }\n        return org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPropertyType(defn, pr.propertyName, typeFromRestriction);\n    }\n\n    private static int getPropertyType(org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition defn, java.lang.String name, int defaultVal) {\n        if (defn.isTypeDefined()) {\n            return defn.getType();\n        }\n        return defaultVal;\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult getPlanResult(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan) {\n        return ((org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult) (plan.getAttribute(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.ATTR_PLAN_RESULT)));\n    }\n\n    private static org.apache.lucene.search.Query createLikeQuery(java.lang.String name, java.lang.String first) {\n        first = first.replace('%', WildcardQuery.WILDCARD_STRING);\n        first = first.replace('_', WildcardQuery.WILDCARD_CHAR);\n        int indexOfWS = first.indexOf(WildcardQuery.WILDCARD_STRING);\n        int indexOfWC = first.indexOf(WildcardQuery.WILDCARD_CHAR);\n        int len = first.length();\n        if ((indexOfWS == len) || (indexOfWC == len)) {\n            first = first.substring(0, first.length() - 1);\n            if (org.apache.jackrabbit.oak.plugins.index.lucene.JCR_PATH.equals(name)) {\n                return new org.apache.lucene.search.PrefixQuery(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(first));\n            } else {\n                return new org.apache.lucene.search.PrefixQuery(new org.apache.lucene.index.Term(name, first));\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.index.lucene.JCR_PATH.equals(name)) {\n            return new org.apache.lucene.search.WildcardQuery(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(first));\n        } else {\n            return new org.apache.lucene.search.WildcardQuery(new org.apache.lucene.index.Term(name, first));\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    private static org.apache.lucene.search.Query createQuery(org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction pr, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition defn) {\n        int propType = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.determinePropertyType(defn, pr);\n        if (pr.isNullRestriction()) {\n            return new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(FieldNames.NULL_PROPS, defn.name));\n        }\n        if (pr.isNotNullRestriction() && defn.notNullCheckEnabled) {\n            return new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(FieldNames.NOT_NULL_PROPS, defn.name));\n        }\n        switch (propType) {\n            case javax.jcr.PropertyType.DATE :\n                {\n                    java.lang.Long first = (pr.first != null) ? org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.dateToLong(pr.first.getValue(Type.DATE)) : null;\n                    java.lang.Long last = (pr.last != null) ? org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.dateToLong(pr.last.getValue(Type.DATE)) : null;\n                    if ((((pr.first != null) && pr.first.equals(pr.last)) && pr.firstIncluding) && pr.lastIncluding) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, first, first, true, true);\n                    } else if ((pr.first != null) && (pr.last != null)) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, first, last, pr.firstIncluding, pr.lastIncluding);\n                    } else if ((pr.first != null) && (pr.last == null)) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, first, null, pr.firstIncluding, true);\n                    } else if ((pr.last != null) && (!pr.last.equals(pr.first))) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, null, last, true, pr.lastIncluding);\n                    } else if (pr.list != null) {\n                        org.apache.lucene.search.BooleanQuery in = new org.apache.lucene.search.BooleanQuery();\n                        for (org.apache.jackrabbit.oak.api.PropertyValue value : pr.list) {\n                            java.lang.Long dateVal = org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.dateToLong(value.getValue(Type.DATE));\n                            in.add(org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, dateVal, dateVal, true, true), BooleanClause.Occur.SHOULD);\n                        }\n                        return in;\n                    } else if (pr.isNotNullRestriction()) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, 0L, java.lang.Long.MAX_VALUE, true, true);\n                    }\n                    break;\n                }\n            case javax.jcr.PropertyType.DOUBLE :\n                {\n                    java.lang.Double first = (pr.first != null) ? pr.first.getValue(Type.DOUBLE) : null;\n                    java.lang.Double last = (pr.last != null) ? pr.last.getValue(Type.DOUBLE) : null;\n                    if ((((pr.first != null) && pr.first.equals(pr.last)) && pr.firstIncluding) && pr.lastIncluding) {\n                        return org.apache.lucene.search.NumericRangeQuery.newDoubleRange(pr.propertyName, first, first, true, true);\n                    } else if ((pr.first != null) && (pr.last != null)) {\n                        return org.apache.lucene.search.NumericRangeQuery.newDoubleRange(pr.propertyName, first, last, pr.firstIncluding, pr.lastIncluding);\n                    } else if ((pr.first != null) && (pr.last == null)) {\n                        return org.apache.lucene.search.NumericRangeQuery.newDoubleRange(pr.propertyName, first, null, pr.firstIncluding, true);\n                    } else if ((pr.last != null) && (!pr.last.equals(pr.first))) {\n                        return org.apache.lucene.search.NumericRangeQuery.newDoubleRange(pr.propertyName, null, last, true, pr.lastIncluding);\n                    } else if (pr.list != null) {\n                        org.apache.lucene.search.BooleanQuery in = new org.apache.lucene.search.BooleanQuery();\n                        for (org.apache.jackrabbit.oak.api.PropertyValue value : pr.list) {\n                            java.lang.Double doubleVal = value.getValue(Type.DOUBLE);\n                            in.add(org.apache.lucene.search.NumericRangeQuery.newDoubleRange(pr.propertyName, doubleVal, doubleVal, true, true), BooleanClause.Occur.SHOULD);\n                        }\n                        return in;\n                    } else if (pr.isNotNullRestriction()) {\n                        return org.apache.lucene.search.NumericRangeQuery.newDoubleRange(pr.propertyName, java.lang.Double.MIN_VALUE, java.lang.Double.MAX_VALUE, true, true);\n                    }\n                    break;\n                }\n            case javax.jcr.PropertyType.LONG :\n                {\n                    java.lang.Long first = (pr.first != null) ? pr.first.getValue(org.apache.jackrabbit.oak.plugins.index.lucene.LONG) : null;\n                    java.lang.Long last = (pr.last != null) ? pr.last.getValue(org.apache.jackrabbit.oak.plugins.index.lucene.LONG) : null;\n                    if ((((pr.first != null) && pr.first.equals(pr.last)) && pr.firstIncluding) && pr.lastIncluding) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, first, first, true, true);\n                    } else if ((pr.first != null) && (pr.last != null)) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, first, last, pr.firstIncluding, pr.lastIncluding);\n                    } else if ((pr.first != null) && (pr.last == null)) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, first, null, pr.firstIncluding, true);\n                    } else if ((pr.last != null) && (!pr.last.equals(pr.first))) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, null, last, true, pr.lastIncluding);\n                    } else if (pr.list != null) {\n                        org.apache.lucene.search.BooleanQuery in = new org.apache.lucene.search.BooleanQuery();\n                        for (org.apache.jackrabbit.oak.api.PropertyValue value : pr.list) {\n                            java.lang.Long longVal = value.getValue(org.apache.jackrabbit.oak.plugins.index.lucene.LONG);\n                            in.add(org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, longVal, longVal, true, true), BooleanClause.Occur.SHOULD);\n                        }\n                        return in;\n                    } else if (pr.isNotNullRestriction()) {\n                        return org.apache.lucene.search.NumericRangeQuery.newLongRange(pr.propertyName, java.lang.Long.MIN_VALUE, java.lang.Long.MAX_VALUE, true, true);\n                    }\n                    break;\n                }\n            default :\n                {\n                    if (pr.isLike) {\n                        return org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.createLikeQuery(pr.propertyName, pr.first.getValue(org.apache.jackrabbit.oak.plugins.index.lucene.STRING));\n                    }\n                    java.lang.String first = (pr.first != null) ? pr.first.getValue(org.apache.jackrabbit.oak.plugins.index.lucene.STRING) : null;\n                    java.lang.String last = (pr.last != null) ? pr.last.getValue(org.apache.jackrabbit.oak.plugins.index.lucene.STRING) : null;\n                    if ((((pr.first != null) && pr.first.equals(pr.last)) && pr.firstIncluding) && pr.lastIncluding) {\n                        return new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(pr.propertyName, first));\n                    } else if ((pr.first != null) && (pr.last != null)) {\n                        return org.apache.lucene.search.TermRangeQuery.newStringRange(pr.propertyName, first, last, pr.firstIncluding, pr.lastIncluding);\n                    } else if ((pr.first != null) && (pr.last == null)) {\n                        return org.apache.lucene.search.TermRangeQuery.newStringRange(pr.propertyName, first, null, pr.firstIncluding, true);\n                    } else if ((pr.last != null) && (!pr.last.equals(pr.first))) {\n                        return org.apache.lucene.search.TermRangeQuery.newStringRange(pr.propertyName, null, last, true, pr.lastIncluding);\n                    } else if (pr.list != null) {\n                        org.apache.lucene.search.BooleanQuery in = new org.apache.lucene.search.BooleanQuery();\n                        for (org.apache.jackrabbit.oak.api.PropertyValue value : pr.list) {\n                            java.lang.String strVal = value.getValue(org.apache.jackrabbit.oak.plugins.index.lucene.STRING);\n                            in.add(new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(pr.propertyName, strVal)), BooleanClause.Occur.SHOULD);\n                        }\n                        return in;\n                    } else if (pr.isNotNullRestriction()) {\n                        return new org.apache.lucene.search.TermRangeQuery(pr.propertyName, null, null, true, true);\n                    }\n                }\n        }\n        throw new java.lang.IllegalStateException(((\"PropertyRestriction not handled \" + pr) + \" for index \") + defn);\n    }\n\n    static long getVersion(org.apache.lucene.search.IndexSearcher indexSearcher) {\n        org.apache.lucene.index.IndexReader reader = indexSearcher.getIndexReader();\n        if (reader instanceof org.apache.lucene.index.DirectoryReader) {\n            return ((org.apache.lucene.index.DirectoryReader) (reader)).getVersion();\n        }\n        return -1;\n    }\n\n    private static org.apache.lucene.search.Query createNodeNameQuery(org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction pr) {\n        java.lang.String first = (pr.first != null) ? pr.first.getValue(org.apache.jackrabbit.oak.plugins.index.lucene.STRING) : null;\n        if ((((pr.first != null) && pr.first.equals(pr.last)) && pr.firstIncluding) && pr.lastIncluding) {\n            return new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(FieldNames.NODE_NAME, first));\n        }\n        if (pr.isLike) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.createLikeQuery(FieldNames.NODE_NAME, first);\n        }\n        throw new java.lang.IllegalStateException(\"For nodeName queries only EQUALS and LIKE are supported \" + pr);\n    }\n\n    private static void addReferenceConstraint(java.lang.String uuid, java.util.List<org.apache.lucene.search.Query> qs, org.apache.lucene.index.IndexReader reader) {\n        if (reader == null) {\n            qs.add(new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(\"*\", uuid)));\n            return;\n        }\n        org.apache.lucene.search.BooleanQuery bq = new org.apache.lucene.search.BooleanQuery();\n        java.util.Collection<java.lang.String> fields = org.apache.lucene.index.MultiFields.getIndexedFields(reader);\n        for (java.lang.String f : fields) {\n            bq.add(new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(f, uuid)), org.apache.jackrabbit.oak.plugins.index.lucene.SHOULD);\n        }\n        qs.add(bq);\n    }\n\n    private static void addNodeTypeConstraints(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule defn, java.util.List<org.apache.lucene.search.Query> qs, org.apache.jackrabbit.oak.spi.query.Filter filter) {\n        org.apache.lucene.search.BooleanQuery bq = new org.apache.lucene.search.BooleanQuery();\n        org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition primaryType = defn.getConfig(org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE);\n        if ((primaryType != null) && primaryType.propertyIndex) {\n            for (java.lang.String type : filter.getPrimaryTypes()) {\n                bq.add(new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(org.apache.jackrabbit.JcrConstants.JCR_PRIMARYTYPE, type)), org.apache.jackrabbit.oak.plugins.index.lucene.SHOULD);\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition mixinType = defn.getConfig(org.apache.jackrabbit.JcrConstants.JCR_MIXINTYPES);\n        if ((mixinType != null) && mixinType.propertyIndex) {\n            for (java.lang.String type : filter.getMixinTypes()) {\n                bq.add(new org.apache.lucene.search.TermQuery(new org.apache.lucene.index.Term(org.apache.jackrabbit.JcrConstants.JCR_MIXINTYPES, type)), org.apache.jackrabbit.oak.plugins.index.lucene.SHOULD);\n            }\n        }\n        if (bq.clauses().size() != 0) {\n            qs.add(bq);\n        }\n    }\n\n    static org.apache.lucene.search.Query getFullTextQuery(final org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan, org.apache.jackrabbit.oak.query.fulltext.FullTextExpression ft, final org.apache.lucene.analysis.Analyzer analyzer, final org.apache.jackrabbit.oak.plugins.index.lucene.spi.FulltextQueryTermsProvider augmentor) {\n        final org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult pr = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getPlanResult(plan);\n        final java.util.concurrent.atomic.AtomicReference<org.apache.lucene.search.Query> result = new java.util.concurrent.atomic.AtomicReference<org.apache.lucene.search.Query>();\n        ft.accept(new org.apache.jackrabbit.oak.query.fulltext.FullTextVisitor() {\n            @java.lang.Override\n            public boolean visit(org.apache.jackrabbit.oak.query.fulltext.FullTextContains contains) {\n                visitTerm(contains.getPropertyName(), contains.getRawText(), null, contains.isNot());\n                return true;\n            }\n\n            @java.lang.Override\n            public boolean visit(org.apache.jackrabbit.oak.query.fulltext.FullTextOr or) {\n                org.apache.lucene.search.BooleanQuery q = new org.apache.lucene.search.BooleanQuery();\n                for (org.apache.jackrabbit.oak.query.fulltext.FullTextExpression e : or.list) {\n                    org.apache.lucene.search.Query x = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getFullTextQuery(plan, e, analyzer, augmentor);\n                    q.add(x, org.apache.jackrabbit.oak.plugins.index.lucene.SHOULD);\n                }\n                result.set(q);\n                return true;\n            }\n\n            @java.lang.Override\n            public boolean visit(org.apache.jackrabbit.oak.query.fulltext.FullTextAnd and) {\n                org.apache.lucene.search.BooleanQuery q = new org.apache.lucene.search.BooleanQuery();\n                for (org.apache.jackrabbit.oak.query.fulltext.FullTextExpression e : and.list) {\n                    org.apache.lucene.search.Query x = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getFullTextQuery(plan, e, analyzer, augmentor);\n                    boolean hasMustNot = false;\n                    if (x instanceof org.apache.lucene.search.BooleanQuery) {\n                        org.apache.lucene.search.BooleanQuery bq = ((org.apache.lucene.search.BooleanQuery) (x));\n                        if ((bq.getClauses().length == 1) && (bq.getClauses()[0].getOccur() == BooleanClause.Occur.MUST_NOT)) {\n                            hasMustNot = true;\n                            q.add(bq.getClauses()[0]);\n                        }\n                    }\n                    if (!hasMustNot) {\n                        q.add(x, org.apache.jackrabbit.oak.plugins.index.lucene.MUST);\n                    }\n                }\n                result.set(q);\n                return true;\n            }\n\n            @java.lang.Override\n            public boolean visit(org.apache.jackrabbit.oak.query.fulltext.FullTextTerm term) {\n                return visitTerm(term.getPropertyName(), term.getText(), term.getBoost(), term.isNot());\n            }\n\n            private boolean visitTerm(java.lang.String propertyName, java.lang.String text, java.lang.String boost, boolean not) {\n                java.lang.String p = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.getLuceneFieldName(propertyName, pr);\n                org.apache.lucene.search.Query q = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.tokenToQuery(text, p, pr, analyzer, augmentor);\n                if (q == null) {\n                    return false;\n                }\n                if (boost != null) {\n                    q.setBoost(java.lang.Float.parseFloat(boost));\n                }\n                if (not) {\n                    org.apache.lucene.search.BooleanQuery bq = new org.apache.lucene.search.BooleanQuery();\n                    bq.add(q, org.apache.jackrabbit.oak.plugins.index.lucene.MUST_NOT);\n                    result.set(bq);\n                } else {\n                    result.set(q);\n                }\n                return true;\n            }\n        });\n        return result.get();\n    }\n\n    static java.lang.String getLuceneFieldName(@javax.annotation.Nullable\n    java.lang.String p, org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult pr) {\n        if (p == null) {\n            return FieldNames.FULLTEXT;\n        }\n        if (org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.isNodePath(p)) {\n            if (pr.isPathTransformed()) {\n                p = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n            } else {\n                p = org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.createFulltextFieldName(org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(p));\n            }\n        } else {\n            if (pr.isPathTransformed()) {\n                p = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n            }\n            p = org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.createAnalyzedFieldName(p);\n        }\n        if (\"*\".equals(p)) {\n            p = FieldNames.FULLTEXT;\n        }\n        return p;\n    }\n\n    private static org.apache.lucene.search.Query tokenToQuery(java.lang.String text, java.lang.String fieldName, org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlanner.PlanResult pr, org.apache.lucene.analysis.Analyzer analyzer, org.apache.jackrabbit.oak.plugins.index.lucene.spi.FulltextQueryTermsProvider augmentor) {\n        org.apache.lucene.search.Query ret;\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule indexingRule = pr.indexingRule;\n        if (FieldNames.FULLTEXT.equals(fieldName) && (!indexingRule.getNodeScopeAnalyzedProps().isEmpty())) {\n            org.apache.lucene.search.BooleanQuery in = new org.apache.lucene.search.BooleanQuery();\n            for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : indexingRule.getNodeScopeAnalyzedProps()) {\n                org.apache.lucene.search.Query q = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.tokenToQuery(text, org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.createAnalyzedFieldName(pd.name), analyzer);\n                q.setBoost(pd.boost);\n                in.add(q, BooleanClause.Occur.SHOULD);\n            }\n            in.add(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.tokenToQuery(text, fieldName, analyzer), BooleanClause.Occur.SHOULD);\n            ret = in;\n        } else {\n            ret = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.tokenToQuery(text, fieldName, analyzer);\n        }\n        if ((augmentor != null) && FieldNames.FULLTEXT.equals(fieldName)) {\n            org.apache.lucene.search.Query subQuery = augmentor.getQueryTerm(text, analyzer, pr.indexDefinition.getDefinitionNodeState());\n            if (subQuery != null) {\n                org.apache.lucene.search.BooleanQuery query = new org.apache.lucene.search.BooleanQuery();\n                query.add(ret, BooleanClause.Occur.SHOULD);\n                query.add(subQuery, BooleanClause.Occur.SHOULD);\n                ret = query;\n            }\n        }\n        return ret;\n    }\n\n    static org.apache.lucene.search.Query tokenToQuery(java.lang.String text, java.lang.String fieldName, org.apache.lucene.analysis.Analyzer analyzer) {\n        if (analyzer == null) {\n            return null;\n        }\n        org.apache.lucene.queryparser.flexible.standard.StandardQueryParser parserHelper = new org.apache.lucene.queryparser.flexible.standard.StandardQueryParser(analyzer);\n        parserHelper.setAllowLeadingWildcard(true);\n        parserHelper.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);\n        text = org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.rewriteQueryText(text);\n        try {\n            return parserHelper.parse(text, fieldName);\n        } catch (org.apache.lucene.queryparser.flexible.core.QueryNodeException e) {\n            throw new java.lang.RuntimeException(e);\n        }\n    }\n\n    private static final char[] LUCENE_QUERY_OPERATORS = new char[]{ ':', '/', '!', '&', '|', '[', ']', '{', '}' };\n\n    static java.lang.String rewriteQueryText(java.lang.String textsearch) {\n        java.lang.StringBuilder rewritten = new java.lang.StringBuilder();\n        textsearch = textsearch.replaceAll(\"AND\", \"and\");\n        textsearch = textsearch.replaceAll(\"NOT\", \"not\");\n        boolean escaped = false;\n        for (int i = 0; i < textsearch.length(); i++) {\n            char c = textsearch.charAt(i);\n            if (c == '\\\\') {\n                if (escaped) {\n                    rewritten.append(\"\\\\\\\\\");\n                    escaped = false;\n                } else {\n                    escaped = true;\n                }\n            } else if (c == '\\'') {\n                if (escaped) {\n                    escaped = false;\n                }\n                rewritten.append(c);\n            } else if (com.google.common.primitives.Chars.contains(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LUCENE_QUERY_OPERATORS, c)) {\n                rewritten.append('\\\\').append(c);\n            } else {\n                if (escaped) {\n                    rewritten.append('\\\\');\n                    escaped = false;\n                }\n                rewritten.append(c);\n            }\n        }\n        return rewritten.toString();\n    }\n\n    private static java.lang.String getPathRestriction(org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan) {\n        org.apache.jackrabbit.oak.spi.query.Filter f = plan.getFilter();\n        java.lang.String pathPrefix = plan.getPathPrefix();\n        if (pathPrefix.isEmpty()) {\n            return f.getPath();\n        }\n        java.lang.String relativePath = org.apache.jackrabbit.oak.commons.PathUtils.relativize(pathPrefix, f.getPath());\n        return \"/\" + relativePath;\n    }\n\n    private static org.apache.lucene.search.Query newDepthQuery(java.lang.String path) {\n        int depth = org.apache.jackrabbit.oak.commons.PathUtils.getDepth(path) + 1;\n        return org.apache.lucene.search.NumericRangeQuery.newIntRange(FieldNames.PATH_DEPTH, depth, depth, true, true);\n    }\n\n    static class LuceneResultRow {\n        final java.lang.String path;\n\n        final double score;\n\n        final java.lang.String suggestion;\n\n        final boolean isVirutal;\n\n        final java.lang.String excerpt;\n\n        final java.lang.String explanation;\n\n        final org.apache.lucene.facet.Facets facets;\n\n        LuceneResultRow(java.lang.String path, double score, java.lang.String excerpt, org.apache.lucene.facet.Facets facets, java.lang.String explanation) {\n            this.explanation = explanation;\n            this.excerpt = excerpt;\n            this.facets = facets;\n            this.isVirutal = false;\n            this.path = path;\n            this.score = score;\n            this.suggestion = null;\n        }\n\n        LuceneResultRow(java.lang.String suggestion, long weight) {\n            this.isVirutal = true;\n            this.path = \"/\";\n            this.score = weight;\n            this.suggestion = suggestion;\n            this.excerpt = null;\n            this.facets = null;\n            this.explanation = null;\n        }\n\n        LuceneResultRow(java.lang.String suggestion) {\n            this(suggestion, 1);\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            return java.lang.String.format(\"%s (%1.2f)\", path, score);\n        }\n    }\n\n    static class LucenePathCursor implements org.apache.jackrabbit.oak.spi.query.Cursor {\n        private final org.apache.jackrabbit.oak.spi.query.Cursor pathCursor;\n\n        private final java.lang.String pathPrefix;\n\n        org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow currentRow;\n\n        private final org.apache.jackrabbit.oak.plugins.index.lucene.SizeEstimator sizeEstimator;\n\n        private long estimatedSize;\n\n        LucenePathCursor(final java.util.Iterator<org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LuceneResultRow> it, final org.apache.jackrabbit.oak.plugins.index.lucene.IndexPlan plan, org.apache.jackrabbit.oak.query.QueryEngineSettings settings, org.apache.jackrabbit.oak.plugins.index.lucene.SizeEstimator sizeEstimator) {\n            pathPrefix = plan.getPathPrefix();\n            this.sizeEstimator = sizeEstimator;\n            java.util.Iterator<java.lang.String> pathIterator = new java.util.Iterator<java.lang.String>() {\n                @java.lang.Override\n                public boolean hasNext() {\n                    return it.hasNext();\n                }\n\n                @java.lang.Override\n                public java.lang.String next() {\n                    currentRow = it.next();\n                    return currentRow.path;\n                }\n\n                @java.lang.Override\n                public void remove() {\n                    it.remove();\n                }\n            };\n            pathCursor = new org.apache.jackrabbit.oak.spi.query.Cursors.PathCursor(pathIterator, false, settings);\n        }\n\n        @java.lang.Override\n        public boolean hasNext() {\n            return pathCursor.hasNext();\n        }\n\n        @java.lang.Override\n        public void remove() {\n            pathCursor.remove();\n        }\n\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.spi.query.IndexRow next() {\n            final org.apache.jackrabbit.oak.spi.query.IndexRow pathRow = pathCursor.next();\n            return new org.apache.jackrabbit.oak.spi.query.IndexRow() {\n                @java.lang.Override\n                public boolean isVirtualRow() {\n                    return currentRow.isVirutal;\n                }\n\n                @java.lang.Override\n                public java.lang.String getPath() {\n                    java.lang.String sub = pathRow.getPath();\n                    if (org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(sub)) {\n                        return pathPrefix + sub;\n                    } else {\n                        return org.apache.jackrabbit.oak.commons.PathUtils.concat(pathPrefix, sub);\n                    }\n                }\n\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.api.PropertyValue getValue(java.lang.String columnName) {\n                    if (QueryImpl.JCR_SCORE.equals(columnName)) {\n                        return org.apache.jackrabbit.oak.spi.query.PropertyValues.newDouble(currentRow.score);\n                    }\n                    if (QueryImpl.REP_SPELLCHECK.equals(columnName) || QueryImpl.REP_SUGGEST.equals(columnName)) {\n                        return org.apache.jackrabbit.oak.spi.query.PropertyValues.newString(currentRow.suggestion);\n                    }\n                    if (QueryImpl.OAK_SCORE_EXPLANATION.equals(columnName)) {\n                        return org.apache.jackrabbit.oak.spi.query.PropertyValues.newString(currentRow.explanation);\n                    }\n                    if (QueryImpl.REP_EXCERPT.equals(columnName)) {\n                        return org.apache.jackrabbit.oak.spi.query.PropertyValues.newString(currentRow.excerpt);\n                    }\n                    if (columnName.startsWith(QueryImpl.REP_FACET)) {\n                        java.lang.String facetFieldName = org.apache.jackrabbit.oak.plugins.index.lucene.util.FacetHelper.parseFacetField(columnName);\n                        org.apache.lucene.facet.Facets facets = currentRow.facets;\n                        try {\n                            if (facets != null) {\n                                org.apache.lucene.facet.FacetResult topChildren = facets.getTopChildren(10, facetFieldName);\n                                if (topChildren != null) {\n                                    org.apache.jackrabbit.oak.commons.json.JsopWriter writer = new org.apache.jackrabbit.oak.commons.json.JsopBuilder();\n                                    writer.object();\n                                    for (org.apache.lucene.facet.LabelAndValue lav : topChildren.labelValues) {\n                                        writer.key(lav.label).value(lav.value.intValue());\n                                    }\n                                    writer.endObject();\n                                    return org.apache.jackrabbit.oak.spi.query.PropertyValues.newString(writer.toString());\n                                } else {\n                                    return null;\n                                }\n                            }\n                        } catch (java.lang.Exception e) {\n                            throw new java.lang.RuntimeException(e);\n                        }\n                    }\n                    return pathRow.getValue(columnName);\n                }\n            };\n        }\n\n        @java.lang.Override\n        public long getSize(org.apache.jackrabbit.oak.api.Result.SizePrecision precision, long max) {\n            if (estimatedSize != 0) {\n                return estimatedSize;\n            }\n            return estimatedSize = sizeEstimator.getSize();\n        }\n    }\n\n    private static class PathStoredFieldVisitor extends org.apache.lucene.index.StoredFieldVisitor {\n        private java.lang.String path;\n\n        private boolean pathVisited;\n\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.index.lucene.Status needsField(org.apache.lucene.index.FieldInfo fieldInfo) throws java.io.IOException {\n            if (org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.PATH.equals(fieldInfo.name)) {\n                return Status.YES;\n            }\n            return pathVisited ? Status.STOP : Status.NO;\n        }\n\n        @java.lang.Override\n        public void stringField(org.apache.lucene.index.FieldInfo fieldInfo, java.lang.String value) throws java.io.IOException {\n            if (org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.PATH.equals(fieldInfo.name)) {\n                path = value;\n                pathVisited = true;\n            }\n        }\n\n        public java.lang.String getPath() {\n            return path;\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "com.google.common.primitives.Chars.contains(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LUCENE_QUERY_OPERATORS, c)",
            "src_parent": "if (com.google.common.primitives.Chars.contains(org.apache.jackrabbit.oak.plugins.index.lucene.LucenePropertyIndex.LUCENE_QUERY_OPERATORS, c)) {\n    rewritten.append('\\\\').append(c);\n} else {\n    if (escaped) {\n        rewritten.append('\\\\');\n        escaped = false;\n    }\n    rewritten.append(c);\n}",
            "src_parent_type": "If",
            "src_type": "Invocation"
          }
        }
      ],
      "file_name": "LucenePropertyIndex"
    }
  ],
  "id": "jackrabbit-oak_4faf31e3"
}