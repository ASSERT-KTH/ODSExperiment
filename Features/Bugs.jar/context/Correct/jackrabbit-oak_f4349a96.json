{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static boolean waitForLeaseExpiry(org.apache.jackrabbit.oak.plugins.document.DocumentStore store, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument cdoc, long leaseEnd, java.lang.String machineId, java.lang.String instanceId) {\n    java.lang.String key = cdoc.getId();\n    org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((((((\"Found an existing possibly active cluster node info (\" + key) + \") for this instance: \") + machineId) + \"/\") + instanceId) + \", will try use it.\");\n    long waitUntil = leaseEnd + 2000;\n    while (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime() < waitUntil) {\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((((\"Waiting for cluster node \" + key) + \"'s lease to expire: \") + ((waitUntil - org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime()) / 1000)) + \"s left\");\n        try {\n            java.lang.Thread.sleep(5000);\n        } catch (java.lang.InterruptedException e) {\n        }\n        try {\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument reread = store.find(Collection.CLUSTER_NODES, key);\n            if (reread == null) {\n                org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((\"Cluster node info \" + key) + \": gone; continueing.\");\n                return true;\n            } else {\n                java.lang.Long newLeaseEnd = ((java.lang.Long) (reread.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY)));\n                if (newLeaseEnd == null) {\n                    org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((\"Cluster node \" + key) + \": lease end information missing, aborting.\");\n                    return false;\n                } else if (newLeaseEnd.longValue() != leaseEnd) {\n                    org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((((((\"Cluster node \" + key) + \" seems to be still active (lease end changed from \") + leaseEnd) + \" to \") + newLeaseEnd) + \", will not try to use it.\");\n                    return false;\n                }\n            }\n        } catch (org.apache.jackrabbit.oak.plugins.document.DocumentStoreException ex) {\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info(\"Error reading cluster node info for key \" + key, ex);\n            return false;\n        }\n    } \n    return true;\n}",
            "src_parent": "public class ClusterNodeInfo {\n    private static final java.lang.String LEASE_CHECK_FAILED_MSG = \"This oak instance failed to update \" + \"the lease in time and can therefore no longer access this DocumentNodeStore.\";\n\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.class);\n\n    private static final java.lang.String RANDOM_PREFIX = \"random:\";\n\n    private static final java.lang.String MACHINE_ID_KEY = \"machine\";\n\n    static final java.lang.String OAK_VERSION_KEY = \"oakVersion\";\n\n    private static final java.lang.String INSTANCE_ID_KEY = \"instance\";\n\n    public static final java.lang.String LEASE_END_KEY = \"leaseEnd\";\n\n    public static final java.lang.String LAST_WRITTEN_ROOT_REV_KEY = \"lastWrittenRootRev\";\n\n    public static final java.lang.String STATE = \"state\";\n\n    public static enum ClusterNodeState {\n\n        NONE,\n        ACTIVE;\n        static org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState fromString(java.lang.String state) {\n            if (state == null) {\n                return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.NONE;\n            }\n            return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.valueOf(state);\n        }\n    }\n\n    public static final java.lang.String REV_RECOVERY_LOCK = \"recoveryLock\";\n\n    public static enum RecoverLockState {\n\n        NONE,\n        ACQUIRED;\n        static org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RecoverLockState fromString(java.lang.String state) {\n            if (state == null) {\n                return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RecoverLockState.NONE;\n            }\n            return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RecoverLockState.valueOf(state);\n        }\n    }\n\n    public static final java.lang.String REV_RECOVERY_BY = \"recoveryBy\";\n\n    private static final java.lang.String INFO_KEY = \"info\";\n\n    private static final java.lang.String READ_WRITE_MODE_KEY = \"readWriteMode\";\n\n    private static final java.lang.String MACHINE_ID = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getMachineId();\n\n    private static final long PROCESS_ID = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getProcessId();\n\n    protected static java.lang.String WORKING_DIR = java.lang.System.getProperty(\"user.dir\", \"\");\n\n    private static org.apache.jackrabbit.oak.stats.Clock clock = org.apache.jackrabbit.oak.stats.Clock.SIMPLE;\n\n    public static final int DEFAULT_LEASE_DURATION_MILLIS = 1000 * 120;\n\n    public static final int DEFAULT_LEASE_UPDATE_INTERVAL_MILLIS = 1000 * 10;\n\n    public static final int DEFAULT_LEASE_FAILURE_MARGIN_MILLIS = 1000 * 20;\n\n    private static final int MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE = 5;\n\n    private static final java.lang.String OAK_VERSION = org.apache.jackrabbit.oak.util.OakVersion.getVersion();\n\n    private long leaseTime = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.DEFAULT_LEASE_DURATION_MILLIS;\n\n    private long leaseUpdateInterval = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.DEFAULT_LEASE_UPDATE_INTERVAL_MILLIS;\n\n    private long leaseFailureMargin = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.DEFAULT_LEASE_FAILURE_MARGIN_MILLIS;\n\n    private final int id;\n\n    private final java.lang.String machineId;\n\n    private final java.lang.String instanceId;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private final long startTime;\n\n    private final java.lang.String uuid = java.util.UUID.randomUUID().toString();\n\n    private volatile long leaseEndTime;\n\n    private long previousLeaseEndTime;\n\n    private java.lang.String readWriteMode;\n\n    private org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState state;\n\n    private boolean leaseCheckFailed = false;\n\n    private final boolean leaseCheckDisabled;\n\n    private boolean renewed;\n\n    private org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RecoverLockState revRecoveryLock;\n\n    private boolean newEntry;\n\n    private org.apache.jackrabbit.oak.plugins.document.LeaseFailureHandler leaseFailureHandler;\n\n    private ClusterNodeInfo(int id, org.apache.jackrabbit.oak.plugins.document.DocumentStore store, java.lang.String machineId, java.lang.String instanceId, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState state, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RecoverLockState revRecoveryLock, java.lang.Long leaseEnd, boolean newEntry) {\n        this.id = id;\n        this.startTime = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime();\n        if (leaseEnd == null) {\n            this.leaseEndTime = startTime;\n        } else {\n            this.leaseEndTime = leaseEnd;\n        }\n        this.renewed = false;\n        this.store = store;\n        this.machineId = machineId;\n        this.instanceId = instanceId;\n        this.state = state;\n        this.revRecoveryLock = revRecoveryLock;\n        this.newEntry = newEntry;\n        this.leaseCheckDisabled = java.lang.Boolean.valueOf(java.lang.System.getProperty(\"oak.documentMK.disableLeaseCheck\", \"false\"));\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public static org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo getInstance(org.apache.jackrabbit.oak.plugins.document.DocumentStore store, int configuredClusterId) {\n        return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getInstance(store, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.MACHINE_ID, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.WORKING_DIR, configuredClusterId, false);\n    }\n\n    public static org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo getInstance(org.apache.jackrabbit.oak.plugins.document.DocumentStore store, java.lang.String machineId, java.lang.String instanceId) {\n        return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getInstance(store, machineId, instanceId, 0, true);\n    }\n\n    public static org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo getInstance(org.apache.jackrabbit.oak.plugins.document.DocumentStore store, java.lang.String machineId, java.lang.String instanceId, int configuredClusterId, boolean updateLease) {\n        if (machineId == null) {\n            machineId = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.MACHINE_ID;\n        }\n        if (instanceId == null) {\n            instanceId = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.WORKING_DIR;\n        }\n        int retries = 10;\n        for (int i = 0; i < retries; i++) {\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo clusterNode = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.createInstance(store, machineId, instanceId, configuredClusterId, i == 0);\n            java.lang.String key = java.lang.String.valueOf(clusterNode.id);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp update = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(key, true);\n            update.set(org.apache.jackrabbit.oak.plugins.document.Document.ID, key);\n            update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.MACHINE_ID_KEY, clusterNode.machineId);\n            update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.INSTANCE_ID_KEY, clusterNode.instanceId);\n            if (updateLease) {\n                update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime() + clusterNode.leaseTime);\n            } else {\n                update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY, clusterNode.leaseEndTime);\n            }\n            update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.INFO_KEY, clusterNode.toString());\n            update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.STATE, clusterNode.state.name());\n            update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.REV_RECOVERY_LOCK, clusterNode.revRecoveryLock.name());\n            update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.OAK_VERSION_KEY, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.OAK_VERSION);\n            final boolean success;\n            if (clusterNode.newEntry) {\n                success = store.create(Collection.CLUSTER_NODES, java.util.Collections.singletonList(update));\n            } else {\n                store.createOrUpdate(Collection.CLUSTER_NODES, update);\n                success = true;\n            }\n            if (success) {\n                return clusterNode;\n            }\n        }\n        throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((\"Could not get cluster node info (retried \" + retries) + \" times)\");\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo createInstance(org.apache.jackrabbit.oak.plugins.document.DocumentStore store, java.lang.String machineId, java.lang.String instanceId, int configuredClusterId, boolean waitForLease) {\n        long now = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime();\n        int clusterNodeId = 0;\n        int maxId = 0;\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState state = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.NONE;\n        java.lang.Long prevLeaseEnd = null;\n        boolean newEntry = false;\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument alreadyExistingConfigured = null;\n        java.lang.String reuseFailureReason = \"\";\n        java.util.List<org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument> list = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument.all(store);\n        for (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument doc : list) {\n            java.lang.String key = doc.getId();\n            int id;\n            try {\n                id = doc.getClusterId();\n            } catch (java.lang.Exception e) {\n                org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(\"Skipping cluster node info document {} because ID is invalid\", key);\n                continue;\n            }\n            maxId = java.lang.Math.max(maxId, id);\n            if (configuredClusterId != 0) {\n                if (configuredClusterId != id) {\n                    continue;\n                } else {\n                    alreadyExistingConfigured = doc;\n                }\n            }\n            java.lang.Long leaseEnd = ((java.lang.Long) (doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY)));\n            java.lang.String mId = \"\" + doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.MACHINE_ID_KEY);\n            java.lang.String iId = \"\" + doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.INSTANCE_ID_KEY);\n            if ((leaseEnd != null) && (leaseEnd > now)) {\n                if (((waitForLease && ((leaseEnd - now) < (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.DEFAULT_LEASE_DURATION_MILLIS + 5000))) && mId.equals(machineId)) && iId.equals(instanceId)) {\n                    boolean worthRetrying = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.waitForLeaseExpiry(store, doc, leaseEnd.longValue(), machineId, instanceId);\n                    if (worthRetrying) {\n                        return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.createInstance(store, machineId, instanceId, configuredClusterId, false);\n                    }\n                }\n                reuseFailureReason = (((((\"leaseEnd \" + leaseEnd) + \" > \") + now) + \" - \") + (leaseEnd - now)) + \"ms in the future\";\n                continue;\n            }\n            if (mId.startsWith(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RANDOM_PREFIX) && (leaseEnd == null)) {\n                store.remove(Collection.CLUSTER_NODES, key);\n                org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(\"Cleaned up cluster node info for clusterNodeId {} [machineId: {}, leaseEnd: {}]\", id, mId, leaseEnd == null ? \"n/a\" : org.apache.jackrabbit.oak.plugins.document.util.Utils.timestampToString(leaseEnd));\n                if (alreadyExistingConfigured == doc) {\n                    alreadyExistingConfigured = null;\n                }\n                continue;\n            }\n            if ((!mId.equals(machineId)) || (!iId.equals(instanceId))) {\n                reuseFailureReason = ((((((\"machineId/instanceId do not match: \" + mId) + \"/\") + iId) + \" != \") + machineId) + \"/\") + instanceId;\n                continue;\n            }\n            if ((clusterNodeId == 0) || (id < clusterNodeId)) {\n                clusterNodeId = id;\n                state = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.fromString(((java.lang.String) (doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.STATE))));\n                prevLeaseEnd = leaseEnd;\n            }\n        }\n        if (clusterNodeId == 0) {\n            newEntry = true;\n            if (configuredClusterId != 0) {\n                if (alreadyExistingConfigured != null) {\n                    throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(((\"Configured cluster node id \" + configuredClusterId) + \" already in use: \") + reuseFailureReason);\n                }\n                clusterNodeId = configuredClusterId;\n            } else {\n                clusterNodeId = maxId + 1;\n            }\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo(clusterNodeId, store, machineId, instanceId, state, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RecoverLockState.NONE, prevLeaseEnd, newEntry);\n    }\n\n    private static boolean waitForLeaseExpiry(org.apache.jackrabbit.oak.plugins.document.DocumentStore store, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument cdoc, long leaseEnd, java.lang.String machineId, java.lang.String instanceId) {\n        java.lang.String key = cdoc.getId();\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((((((\"Found an existing possibly active cluster node info (\" + key) + \") for this instance: \") + machineId) + \"/\") + instanceId) + \", will try use it.\");\n        long waitUntil = leaseEnd + 2000;\n        while (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime() < waitUntil) {\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((((\"Waiting for cluster node \" + key) + \"'s lease to expire: \") + ((waitUntil - org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime()) / 1000)) + \"s left\");\n            try {\n                java.lang.Thread.sleep(5000);\n            } catch (java.lang.InterruptedException e) {\n            }\n            try {\n                org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument reread = store.find(Collection.CLUSTER_NODES, key);\n                if (reread == null) {\n                    org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((\"Cluster node info \" + key) + \": gone; continueing.\");\n                    return true;\n                } else {\n                    java.lang.Long newLeaseEnd = ((java.lang.Long) (reread.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY)));\n                    if (newLeaseEnd == null) {\n                        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((\"Cluster node \" + key) + \": lease end information missing, aborting.\");\n                        return false;\n                    } else if (newLeaseEnd.longValue() != leaseEnd) {\n                        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info((((((\"Cluster node \" + key) + \" seems to be still active (lease end changed from \") + leaseEnd) + \" to \") + newLeaseEnd) + \", will not try to use it.\");\n                        return false;\n                    }\n                }\n            } catch (org.apache.jackrabbit.oak.plugins.document.DocumentStoreException ex) {\n                org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info(\"Error reading cluster node info for key \" + key, ex);\n                return false;\n            }\n        } \n        return true;\n    }\n\n    public void performLeaseCheck() {\n        if (leaseCheckDisabled || (!renewed)) {\n            return;\n        }\n        if (leaseCheckFailed) {\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.error(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG);\n            throw new java.lang.AssertionError(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG);\n        }\n        long now = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime();\n        if (now < (leaseEndTime - leaseFailureMargin)) {\n            return;\n        }\n        synchronized(this) {\n            if (leaseCheckFailed) {\n                org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.error(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG);\n                throw new java.lang.AssertionError(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG);\n            }\n            for (int i = 0; i < org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE; i++) {\n                now = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime();\n                if (now < (leaseEndTime - leaseFailureMargin)) {\n                    return;\n                }\n                try {\n                    org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.info(((((((\"performLeaseCheck: lease within \" + leaseFailureMargin) + \"ms of failing (\") + (leaseEndTime - now)) + \" ms precisely) - \") + \"waiting 1sec to retry (up to another \") + ((org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.MAX_RETRY_SLEEPS_BEFORE_LEASE_FAILURE - 1) - i)) + \" times)...\");\n                    wait(1000);\n                } catch (java.lang.InterruptedException e) {\n                    org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.warn(\"performLeaseCheck: got interrupted - giving up: \" + e, e);\n                    break;\n                }\n            }\n            leaseCheckFailed = true;\n        }\n        final java.lang.String errorMsg = ((((((((((((org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG + \" (leaseEndTime: \") + leaseEndTime) + \", leaseTime: \") + leaseTime) + \", leaseFailureMargin: \") + leaseFailureMargin) + \", lease check end time (leaseEndTime-leaseFailureMargin): \") + (leaseEndTime - leaseFailureMargin)) + \", now: \") + now) + \", remaining: \") + ((leaseEndTime - leaseFailureMargin) - now)) + \") Need to stop oak-core/DocumentNodeStoreService.\";\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.error(errorMsg);\n        handleLeaseFailure(errorMsg);\n    }\n\n    private void handleLeaseFailure(final java.lang.String errorMsg) {\n        if (leaseFailureHandler != null) {\n            final java.lang.Runnable r = new java.lang.Runnable() {\n                @java.lang.Override\n                public void run() {\n                    if (leaseFailureHandler != null) {\n                        leaseFailureHandler.handleLeaseFailure();\n                    }\n                }\n            };\n            final java.lang.Thread th = new java.lang.Thread(r, \"LeaseFailureHandler-Thread\");\n            th.setDaemon(true);\n            th.start();\n        }\n        throw new java.lang.AssertionError(errorMsg);\n    }\n\n    public boolean renewLease() {\n        long now = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime();\n        if (now < ((leaseEndTime - leaseTime) + leaseUpdateInterval)) {\n            return false;\n        }\n        synchronized(this) {\n            if (leaseCheckFailed) {\n                org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.error(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG);\n                throw new java.lang.AssertionError(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG);\n            }\n            now = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime();\n            leaseEndTime = now + leaseTime;\n        }\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp update = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(\"\" + id, false);\n        update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY, leaseEndTime);\n        update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.STATE, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.ACTIVE.name());\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument doc = null;\n        if (renewed && (!leaseCheckDisabled)) {\n            update.setNew(false);\n            update.equals(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY, null, previousLeaseEndTime);\n            update.equals(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.STATE, null, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.ACTIVE.name());\n            doc = store.findAndUpdate(Collection.CLUSTER_NODES, update);\n        } else {\n            doc = store.findAndUpdate(Collection.CLUSTER_NODES, update);\n        }\n        if (doc == null) {\n            synchronized(this) {\n                if (leaseCheckFailed) {\n                    org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.error(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG);\n                    throw new java.lang.AssertionError(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG);\n                }\n                leaseCheckFailed = true;\n            }\n            final java.lang.String errorMsg = ((org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_CHECK_FAILED_MSG + \" (Could not update lease anymore, someone else in the cluster \") + \"must have noticed this instance' slowness already. \") + \"Going to invoke leaseFailureHandler!)\";\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.error(errorMsg);\n            handleLeaseFailure(errorMsg);\n            return false;\n        }\n        previousLeaseEndTime = leaseEndTime;\n        java.lang.String mode = ((java.lang.String) (doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.READ_WRITE_MODE_KEY)));\n        if ((mode != null) && (!mode.equals(readWriteMode))) {\n            readWriteMode = mode;\n            store.setReadWriteMode(mode);\n        }\n        renewed = true;\n        return true;\n    }\n\n    void setLeaseTime(long leaseTime) {\n        this.leaseTime = leaseTime;\n    }\n\n    void setLeaseUpdateInterval(long leaseUpdateInterval) {\n        this.leaseUpdateInterval = leaseUpdateInterval;\n    }\n\n    public long getLeaseTime() {\n        return leaseTime;\n    }\n\n    public void setLeaseFailureHandler(org.apache.jackrabbit.oak.plugins.document.LeaseFailureHandler leaseFailureHandler) {\n        this.leaseFailureHandler = leaseFailureHandler;\n    }\n\n    public void dispose() {\n        synchronized(this) {\n            if (leaseCheckFailed) {\n                org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.warn(\"dispose: lease check failed, thus not marking instance as cleanly shut down.\");\n                return;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp update = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(\"\" + id, true);\n        update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY, null);\n        update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.STATE, null);\n        update.set(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.REV_RECOVERY_LOCK, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RecoverLockState.NONE.name());\n        store.createOrUpdate(Collection.CLUSTER_NODES, update);\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return (((((((((((((((((((((((((((\"id: \" + id) + \",\\n\") + \"startTime: \") + startTime) + \",\\n\") + \"machineId: \") + machineId) + \",\\n\") + \"instanceId: \") + instanceId) + \",\\n\") + \"pid: \") + org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.PROCESS_ID) + \",\\n\") + \"uuid: \") + uuid) + \",\\n\") + \"readWriteMode: \") + readWriteMode) + \",\\n\") + \"state: \") + state) + \",\\n\") + \"revLock: \") + revRecoveryLock) + \",\\n\") + \"oakVersion: \") + org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.OAK_VERSION;\n    }\n\n    static void setClock(org.apache.jackrabbit.oak.stats.Clock c) {\n        com.google.common.base.Preconditions.checkNotNull(c);\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.clock = c;\n    }\n\n    static void resetClockToDefault() {\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.clock = org.apache.jackrabbit.oak.stats.Clock.SIMPLE;\n    }\n\n    private static long getProcessId() {\n        try {\n            java.lang.String name = java.lang.management.ManagementFactory.getRuntimeMXBean().getName();\n            return java.lang.Long.parseLong(name.substring(0, name.indexOf('@')));\n        } catch (java.lang.Exception e) {\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.warn(\"Could not get process id\", e);\n            return 0;\n        }\n    }\n\n    private static java.lang.String getHWAFromSystemProperty() {\n        java.lang.String pname = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.class.getName() + \".HWADDRESS\";\n        java.lang.String hwa = java.lang.System.getProperty(pname, \"\");\n        if (!\"\".equals(hwa)) {\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(((\"obtaining hardware address from system variable \" + pname) + \": \") + hwa);\n        }\n        return hwa;\n    }\n\n    private static java.lang.String getMachineId() {\n        java.lang.Exception exception = null;\n        try {\n            java.util.ArrayList<java.lang.String> macAddresses = new java.util.ArrayList<java.lang.String>();\n            java.util.ArrayList<java.lang.String> otherAddresses = new java.util.ArrayList<java.lang.String>();\n            java.lang.String hwaFromSysProp = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getHWAFromSystemProperty();\n            if (\"\".equals(hwaFromSysProp)) {\n                java.util.Enumeration<java.net.NetworkInterface> e = java.net.NetworkInterface.getNetworkInterfaces();\n                while (e.hasMoreElements()) {\n                    java.net.NetworkInterface ni = e.nextElement();\n                    try {\n                        byte[] hwa = ni.getHardwareAddress();\n                        if ((hwa != null) && (hwa.length != 0)) {\n                            java.lang.String str = org.apache.jackrabbit.oak.commons.StringUtils.convertBytesToHex(hwa);\n                            if (hwa.length == 6) {\n                                macAddresses.add(str);\n                            } else {\n                                otherAddresses.add(str);\n                            }\n                        }\n                    } catch (java.lang.Exception e2) {\n                        exception = e2;\n                    }\n                } \n            } else if (!\"(none)\".equals(hwaFromSysProp)) {\n                if (hwaFromSysProp.length() == 12) {\n                    macAddresses.add(hwaFromSysProp);\n                } else {\n                    otherAddresses.add(hwaFromSysProp);\n                }\n            }\n            if (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.isDebugEnabled()) {\n                org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(\"getMachineId(): discovered addresses: {} {}\", macAddresses, otherAddresses);\n            }\n            if (macAddresses.size() > 0) {\n                java.util.Collections.sort(macAddresses);\n                return \"mac:\" + macAddresses.get(0);\n            } else if (otherAddresses.size() > 0) {\n                java.util.Collections.sort(otherAddresses);\n                return \"hwa:\" + otherAddresses.get(0);\n            }\n        } catch (java.lang.Exception e) {\n            exception = e;\n        }\n        if (exception != null) {\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.warn(\"Error getting the machine id; using a UUID\", exception);\n        }\n        return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RANDOM_PREFIX + java.util.UUID.randomUUID().toString();\n    }\n\n    private static long getCurrentTime() {\n        return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.clock.getTime();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "boolean waitForLease",
            "src_parent": "private static org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo createInstance(org.apache.jackrabbit.oak.plugins.document.DocumentStore store, java.lang.String machineId, java.lang.String instanceId, int configuredClusterId, boolean waitForLease) {\n    long now = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getCurrentTime();\n    int clusterNodeId = 0;\n    int maxId = 0;\n    org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState state = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.NONE;\n    java.lang.Long prevLeaseEnd = null;\n    boolean newEntry = false;\n    org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument alreadyExistingConfigured = null;\n    java.lang.String reuseFailureReason = \"\";\n    java.util.List<org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument> list = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument.all(store);\n    for (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument doc : list) {\n        java.lang.String key = doc.getId();\n        int id;\n        try {\n            id = doc.getClusterId();\n        } catch (java.lang.Exception e) {\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(\"Skipping cluster node info document {} because ID is invalid\", key);\n            continue;\n        }\n        maxId = java.lang.Math.max(maxId, id);\n        if (configuredClusterId != 0) {\n            if (configuredClusterId != id) {\n                continue;\n            } else {\n                alreadyExistingConfigured = doc;\n            }\n        }\n        java.lang.Long leaseEnd = ((java.lang.Long) (doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY)));\n        java.lang.String mId = \"\" + doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.MACHINE_ID_KEY);\n        java.lang.String iId = \"\" + doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.INSTANCE_ID_KEY);\n        if ((leaseEnd != null) && (leaseEnd > now)) {\n            if (((waitForLease && ((leaseEnd - now) < (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.DEFAULT_LEASE_DURATION_MILLIS + 5000))) && mId.equals(machineId)) && iId.equals(instanceId)) {\n                boolean worthRetrying = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.waitForLeaseExpiry(store, doc, leaseEnd.longValue(), machineId, instanceId);\n                if (worthRetrying) {\n                    return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.createInstance(store, machineId, instanceId, configuredClusterId, false);\n                }\n            }\n            reuseFailureReason = (((((\"leaseEnd \" + leaseEnd) + \" > \") + now) + \" - \") + (leaseEnd - now)) + \"ms in the future\";\n            continue;\n        }\n        if (mId.startsWith(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RANDOM_PREFIX) && (leaseEnd == null)) {\n            store.remove(Collection.CLUSTER_NODES, key);\n            org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(\"Cleaned up cluster node info for clusterNodeId {} [machineId: {}, leaseEnd: {}]\", id, mId, leaseEnd == null ? \"n/a\" : org.apache.jackrabbit.oak.plugins.document.util.Utils.timestampToString(leaseEnd));\n            if (alreadyExistingConfigured == doc) {\n                alreadyExistingConfigured = null;\n            }\n            continue;\n        }\n        if ((!mId.equals(machineId)) || (!iId.equals(instanceId))) {\n            reuseFailureReason = ((((((\"machineId/instanceId do not match: \" + mId) + \"/\") + iId) + \" != \") + machineId) + \"/\") + instanceId;\n            continue;\n        }\n        if ((clusterNodeId == 0) || (id < clusterNodeId)) {\n            clusterNodeId = id;\n            state = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.fromString(((java.lang.String) (doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.STATE))));\n            prevLeaseEnd = leaseEnd;\n        }\n    }\n    if (clusterNodeId == 0) {\n        newEntry = true;\n        if (configuredClusterId != 0) {\n            if (alreadyExistingConfigured != null) {\n                throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(((\"Configured cluster node id \" + configuredClusterId) + \" already in use: \") + reuseFailureReason);\n            }\n            clusterNodeId = configuredClusterId;\n        } else {\n            clusterNodeId = maxId + 1;\n        }\n    }\n    return new org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo(clusterNodeId, store, machineId, instanceId, state, org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RecoverLockState.NONE, prevLeaseEnd, newEntry);\n}",
            "src_parent_type": "Method",
            "src_type": "Parameter"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "For",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "i == 0",
            "src_parent": "org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.createInstance(store, machineId, instanceId, configuredClusterId, i == 0)",
            "src_parent_type": "Invocation",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (((waitForLease && ((leaseEnd - now) < (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.DEFAULT_LEASE_DURATION_MILLIS + 5000))) && mId.equals(machineId)) && iId.equals(instanceId)) {\n    boolean worthRetrying = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.waitForLeaseExpiry(store, doc, leaseEnd.longValue(), machineId, instanceId);\n    if (worthRetrying) {\n        return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.createInstance(store, machineId, instanceId, configuredClusterId, false);\n    }\n}",
            "src_parent": "{\n    if (((waitForLease && ((leaseEnd - now) < (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.DEFAULT_LEASE_DURATION_MILLIS + 5000))) && mId.equals(machineId)) && iId.equals(instanceId)) {\n        boolean worthRetrying = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.waitForLeaseExpiry(store, doc, leaseEnd.longValue(), machineId, instanceId);\n        if (worthRetrying) {\n            return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.createInstance(store, machineId, instanceId, configuredClusterId, false);\n        }\n    }\n    reuseFailureReason = (((((\"leaseEnd \" + leaseEnd) + \" > \") + now) + \" - \") + (leaseEnd - now)) + \"ms in the future\";\n    continue;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if ((leaseEnd != null) && (leaseEnd > now)) {\n    if (((waitForLease && ((leaseEnd - now) < (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.DEFAULT_LEASE_DURATION_MILLIS + 5000))) && mId.equals(machineId)) && iId.equals(instanceId)) {\n        boolean worthRetrying = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.waitForLeaseExpiry(store, doc, leaseEnd.longValue(), machineId, instanceId);\n        if (worthRetrying) {\n            return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.createInstance(store, machineId, instanceId, configuredClusterId, false);\n        }\n    }\n    reuseFailureReason = (((((\"leaseEnd \" + leaseEnd) + \" > \") + now) + \" - \") + (leaseEnd - now)) + \"ms in the future\";\n    continue;\n}",
            "dst_parent": "{\n    java.lang.String key = doc.getId();\n    int id;\n    try {\n        id = doc.getClusterId();\n    } catch (java.lang.Exception e) {\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(\"Skipping cluster node info document {} because ID is invalid\", key);\n        continue;\n    }\n    maxId = java.lang.Math.max(maxId, id);\n    if (configuredClusterId != 0) {\n        if (configuredClusterId != id) {\n            continue;\n        } else {\n            alreadyExistingConfigured = doc;\n        }\n    }\n    java.lang.Long leaseEnd = ((java.lang.Long) (doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY)));\n    java.lang.String mId = \"\" + doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.MACHINE_ID_KEY);\n    java.lang.String iId = \"\" + doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.INSTANCE_ID_KEY);\n    if ((leaseEnd != null) && (leaseEnd > now)) {\n        if (((waitForLease && ((leaseEnd - now) < (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.DEFAULT_LEASE_DURATION_MILLIS + 5000))) && mId.equals(machineId)) && iId.equals(instanceId)) {\n            boolean worthRetrying = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.waitForLeaseExpiry(store, doc, leaseEnd.longValue(), machineId, instanceId);\n            if (worthRetrying) {\n                return org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.createInstance(store, machineId, instanceId, configuredClusterId, false);\n            }\n        }\n        reuseFailureReason = (((((\"leaseEnd \" + leaseEnd) + \" > \") + now) + \" - \") + (leaseEnd - now)) + \"ms in the future\";\n        continue;\n    }\n    if (mId.startsWith(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RANDOM_PREFIX) && (leaseEnd == null)) {\n        store.remove(Collection.CLUSTER_NODES, key);\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(\"Cleaned up cluster node info for clusterNodeId {} [machineId: {}, leaseEnd: {}]\", id, mId, leaseEnd == null ? \"n/a\" : org.apache.jackrabbit.oak.plugins.document.util.Utils.timestampToString(leaseEnd));\n        if (alreadyExistingConfigured == doc) {\n            alreadyExistingConfigured = null;\n        }\n        continue;\n    }\n    if ((!mId.equals(machineId)) || (!iId.equals(instanceId))) {\n        reuseFailureReason = ((((((\"machineId/instanceId do not match: \" + mId) + \"/\") + iId) + \" != \") + machineId) + \"/\") + instanceId;\n        continue;\n    }\n    if ((clusterNodeId == 0) || (id < clusterNodeId)) {\n        clusterNodeId = id;\n        state = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.fromString(((java.lang.String) (doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.STATE))));\n        prevLeaseEnd = leaseEnd;\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if ((leaseEnd != null) && (leaseEnd > now)) {\n    reuseFailureReason = (((((\"leaseEnd \" + leaseEnd) + \" > \") + now) + \" - \") + (leaseEnd - now)) + \"ms in the future\";\n    continue;\n}",
            "src_parent": "{\n    java.lang.String key = doc.getId();\n    int id;\n    try {\n        id = doc.getClusterId();\n    } catch (java.lang.Exception e) {\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(\"Skipping cluster node info document {} because ID is invalid\", key);\n        continue;\n    }\n    maxId = java.lang.Math.max(maxId, id);\n    if (configuredClusterId != 0) {\n        if (configuredClusterId != id) {\n            continue;\n        } else {\n            alreadyExistingConfigured = doc;\n        }\n    }\n    java.lang.Long leaseEnd = ((java.lang.Long) (doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LEASE_END_KEY)));\n    if ((leaseEnd != null) && (leaseEnd > now)) {\n        reuseFailureReason = (((((\"leaseEnd \" + leaseEnd) + \" > \") + now) + \" - \") + (leaseEnd - now)) + \"ms in the future\";\n        continue;\n    }\n    java.lang.String mId = \"\" + doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.MACHINE_ID_KEY);\n    java.lang.String iId = \"\" + doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.INSTANCE_ID_KEY);\n    if (mId.startsWith(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.RANDOM_PREFIX) && (leaseEnd == null)) {\n        store.remove(Collection.CLUSTER_NODES, key);\n        org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.LOG.debug(\"Cleaned up cluster node info for clusterNodeId {} [machineId: {}, leaseEnd: {}]\", id, mId, leaseEnd == null ? \"n/a\" : org.apache.jackrabbit.oak.plugins.document.util.Utils.timestampToString(leaseEnd));\n        if (alreadyExistingConfigured == doc) {\n            alreadyExistingConfigured = null;\n        }\n        continue;\n    }\n    if ((!mId.equals(machineId)) || (!iId.equals(instanceId))) {\n        reuseFailureReason = ((((((\"machineId/instanceId do not match: \" + mId) + \"/\") + iId) + \" != \") + machineId) + \"/\") + instanceId;\n        continue;\n    }\n    if ((clusterNodeId == 0) || (id < clusterNodeId)) {\n        clusterNodeId = id;\n        state = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.ClusterNodeState.fromString(((java.lang.String) (doc.get(org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.STATE))));\n        prevLeaseEnd = leaseEnd;\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        }
      ],
      "file_name": "ClusterNodeInfo"
    }
  ],
  "id": "jackrabbit-oak_f4349a96"
}