{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "if (java.lang.reflect.Modifier.isAbstract(method.getModifiers())) {\n    return false;\n}",
            "src_parent": "{\n    for (java.lang.reflect.Method excluded : org.apache.camel.component.bean.BeanInfo.EXCLUDED_METHODS) {\n        if (org.apache.camel.util.ObjectHelper.isOverridingMethod(excluded, method)) {\n            return false;\n        }\n    }\n    if (!java.lang.reflect.Modifier.isPublic(method.getModifiers())) {\n        return false;\n    }\n    if (java.lang.reflect.Modifier.isAbstract(method.getModifiers())) {\n        return false;\n    }\n    if (((method.getReturnType() != null) && org.apache.camel.Exchange.class.isAssignableFrom(method.getReturnType())) || method.isBridge()) {\n        return false;\n    }\n    return true;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private void removeAllAbstractMethods(java.util.List<org.apache.camel.component.bean.MethodInfo> methods) {\n    java.util.Iterator<org.apache.camel.component.bean.MethodInfo> it = methods.iterator();\n    while (it.hasNext()) {\n        org.apache.camel.component.bean.MethodInfo info = it.next();\n        if (java.lang.reflect.Modifier.isAbstract(info.getMethod().getModifiers())) {\n            it.remove();\n        }\n    } \n}",
            "src_parent": "public class BeanInfo {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.camel.component.bean.BeanInfo.class);\n\n    private static final java.lang.String CGLIB_CLASS_SEPARATOR = \"$$\";\n\n    private static final java.util.List<java.lang.reflect.Method> EXCLUDED_METHODS = new java.util.ArrayList<java.lang.reflect.Method>();\n\n    private final org.apache.camel.CamelContext camelContext;\n\n    private final org.apache.camel.component.bean.BeanComponent component;\n\n    private final java.lang.Class<?> type;\n\n    private final org.apache.camel.component.bean.ParameterMappingStrategy strategy;\n\n    private final org.apache.camel.component.bean.MethodInfo defaultMethod;\n\n    private java.util.Map<java.lang.String, java.util.List<org.apache.camel.component.bean.MethodInfo>> operations = new java.util.HashMap<java.lang.String, java.util.List<org.apache.camel.component.bean.MethodInfo>>();\n\n    private java.util.List<org.apache.camel.component.bean.MethodInfo> operationsWithBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n\n    private java.util.List<org.apache.camel.component.bean.MethodInfo> operationsWithNoBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n\n    private java.util.List<org.apache.camel.component.bean.MethodInfo> operationsWithCustomAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n\n    private java.util.List<org.apache.camel.component.bean.MethodInfo> operationsWithHandlerAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n\n    private java.util.Map<java.lang.reflect.Method, org.apache.camel.component.bean.MethodInfo> methodMap = new java.util.HashMap<java.lang.reflect.Method, org.apache.camel.component.bean.MethodInfo>();\n\n    static {\n        EXCLUDED_METHODS.addAll(java.util.Arrays.asList(java.lang.Object.class.getMethods()));\n        EXCLUDED_METHODS.addAll(java.util.Arrays.asList(java.lang.reflect.Proxy.class.getMethods()));\n        try {\n            EXCLUDED_METHODS.remove(java.lang.Object.class.getMethod(\"toString\"));\n            EXCLUDED_METHODS.remove(java.lang.reflect.Proxy.class.getMethod(\"toString\"));\n        } catch (java.lang.Throwable e) {\n        }\n    }\n\n    public BeanInfo(org.apache.camel.CamelContext camelContext, java.lang.Class<?> type) {\n        this(camelContext, type, org.apache.camel.component.bean.BeanInfo.createParameterMappingStrategy(camelContext));\n    }\n\n    public BeanInfo(org.apache.camel.CamelContext camelContext, java.lang.reflect.Method explicitMethod) {\n        this(camelContext, explicitMethod.getDeclaringClass(), explicitMethod, org.apache.camel.component.bean.BeanInfo.createParameterMappingStrategy(camelContext));\n    }\n\n    public BeanInfo(org.apache.camel.CamelContext camelContext, java.lang.Class<?> type, org.apache.camel.component.bean.ParameterMappingStrategy strategy) {\n        this(camelContext, type, null, strategy);\n    }\n\n    public BeanInfo(org.apache.camel.CamelContext camelContext, java.lang.Class<?> type, java.lang.reflect.Method explicitMethod, org.apache.camel.component.bean.ParameterMappingStrategy strategy) {\n        this.camelContext = camelContext;\n        this.type = type;\n        this.strategy = strategy;\n        this.component = camelContext.getComponent(\"bean\", org.apache.camel.component.bean.BeanComponent.class);\n        final org.apache.camel.component.bean.BeanInfoCacheKey key = new org.apache.camel.component.bean.BeanInfoCacheKey(type, explicitMethod);\n        org.apache.camel.component.bean.BeanInfo beanInfo = component.getBeanInfoFromCache(key);\n        if (beanInfo != null) {\n            defaultMethod = beanInfo.defaultMethod;\n            operations = beanInfo.operations;\n            operationsWithBody = beanInfo.operationsWithBody;\n            operationsWithNoBody = beanInfo.operationsWithNoBody;\n            operationsWithCustomAnnotation = beanInfo.operationsWithCustomAnnotation;\n            operationsWithHandlerAnnotation = beanInfo.operationsWithHandlerAnnotation;\n            methodMap = beanInfo.methodMap;\n            return;\n        }\n        if (explicitMethod != null) {\n            if (!isValidMethod(type, explicitMethod)) {\n                throw new java.lang.IllegalArgumentException((\"The method \" + explicitMethod) + \" is not valid (for example the method must be public)\");\n            }\n            introspect(getType(), explicitMethod);\n        } else {\n            introspect(getType());\n        }\n        org.apache.camel.component.bean.MethodInfo method = null;\n        if (operations.size() == 1) {\n            java.util.List<org.apache.camel.component.bean.MethodInfo> methods = operations.values().iterator().next();\n            if (methods.size() == 1) {\n                method = methods.get(0);\n            }\n        }\n        defaultMethod = method;\n        operations = java.util.Collections.unmodifiableMap(operations);\n        operationsWithBody = java.util.Collections.unmodifiableList(operationsWithBody);\n        operationsWithNoBody = java.util.Collections.unmodifiableList(operationsWithNoBody);\n        operationsWithCustomAnnotation = java.util.Collections.unmodifiableList(operationsWithCustomAnnotation);\n        operationsWithHandlerAnnotation = java.util.Collections.unmodifiableList(operationsWithHandlerAnnotation);\n        methodMap = java.util.Collections.unmodifiableMap(methodMap);\n        component.addBeanInfoToCache(key, this);\n    }\n\n    public java.lang.Class<?> getType() {\n        return type;\n    }\n\n    public org.apache.camel.CamelContext getCamelContext() {\n        return camelContext;\n    }\n\n    public static org.apache.camel.component.bean.ParameterMappingStrategy createParameterMappingStrategy(org.apache.camel.CamelContext camelContext) {\n        org.apache.camel.spi.Registry registry = camelContext.getRegistry();\n        org.apache.camel.component.bean.ParameterMappingStrategy answer = registry.lookupByNameAndType(BeanConstants.BEAN_PARAMETER_MAPPING_STRATEGY, org.apache.camel.component.bean.ParameterMappingStrategy.class);\n        if (answer == null) {\n            answer = new org.apache.camel.component.bean.DefaultParameterMappingStrategy();\n        }\n        return answer;\n    }\n\n    public org.apache.camel.component.bean.MethodInvocation createInvocation(java.lang.Object pojo, org.apache.camel.Exchange exchange) throws org.apache.camel.component.bean.AmbiguousMethodCallException, org.apache.camel.component.bean.MethodNotFoundException {\n        return createInvocation(pojo, exchange, null);\n    }\n\n    private org.apache.camel.component.bean.MethodInvocation createInvocation(java.lang.Object pojo, org.apache.camel.Exchange exchange, java.lang.reflect.Method explicitMethod) throws org.apache.camel.component.bean.AmbiguousMethodCallException, org.apache.camel.component.bean.MethodNotFoundException {\n        org.apache.camel.component.bean.MethodInfo methodInfo = null;\n        if (explicitMethod != null) {\n            java.util.Iterator<java.util.List<org.apache.camel.component.bean.MethodInfo>> it = operations.values().iterator();\n            while (it.hasNext()) {\n                java.util.List<org.apache.camel.component.bean.MethodInfo> infos = it.next();\n                for (org.apache.camel.component.bean.MethodInfo info : infos) {\n                    if (explicitMethod.equals(info.getMethod())) {\n                        return info.createMethodInvocation(pojo, exchange);\n                    }\n                }\n            } \n            throw new org.apache.camel.component.bean.MethodNotFoundException(exchange, pojo, explicitMethod.getName());\n        }\n        java.lang.String methodName = exchange.getIn().getHeader(Exchange.BEAN_METHOD_NAME, java.lang.String.class);\n        if (methodName != null) {\n            java.lang.String name = methodName;\n            if (methodName.contains(\"(\")) {\n                name = org.apache.camel.util.ObjectHelper.before(methodName, \"(\");\n            }\n            boolean emptyParameters = methodName.endsWith(\"()\");\n            if (\"class\".equals(name) || \"getClass\".equals(name)) {\n                try {\n                    java.lang.reflect.Method method = pojo.getClass().getMethod(\"getClass\");\n                    methodInfo = new org.apache.camel.component.bean.MethodInfo(exchange.getContext(), pojo.getClass(), method, java.util.Collections.<org.apache.camel.component.bean.ParameterInfo>emptyList(), java.util.Collections.<org.apache.camel.component.bean.ParameterInfo>emptyList(), false, false);\n                } catch (java.lang.NoSuchMethodException e) {\n                    throw new org.apache.camel.component.bean.MethodNotFoundException(exchange, pojo, \"getClass\");\n                }\n            } else if (\"length\".equals(name) && pojo.getClass().isArray()) {\n                try {\n                    java.lang.reflect.Method method = org.apache.camel.util.ObjectHelper.class.getMethod(\"arrayLength\", java.lang.Object[].class);\n                    org.apache.camel.component.bean.ParameterInfo pi = new org.apache.camel.component.bean.ParameterInfo(0, java.lang.Object[].class, null, org.apache.camel.builder.ExpressionBuilder.mandatoryBodyExpression(java.lang.Object[].class, true));\n                    java.util.List<org.apache.camel.component.bean.ParameterInfo> lpi = new java.util.ArrayList<org.apache.camel.component.bean.ParameterInfo>(1);\n                    lpi.add(pi);\n                    methodInfo = new org.apache.camel.component.bean.MethodInfo(exchange.getContext(), pojo.getClass(), method, lpi, lpi, false, false);\n                    exchange.getIn().setBody(pojo);\n                } catch (java.lang.NoSuchMethodException e) {\n                    throw new org.apache.camel.component.bean.MethodNotFoundException(exchange, pojo, \"getClass\");\n                }\n            } else {\n                java.util.List<org.apache.camel.component.bean.MethodInfo> methods = getOperations(name);\n                if ((methods != null) && (methods.size() == 1)) {\n                    methodInfo = methods.get(0);\n                    if (emptyParameters && methodInfo.hasParameters()) {\n                        throw new org.apache.camel.component.bean.MethodNotFoundException(exchange, pojo, methodName, \"(with no parameters)\");\n                    }\n                } else if (methods != null) {\n                    methodInfo = chooseMethod(pojo, exchange, methodName);\n                    if (emptyParameters) {\n                        if ((methodInfo == null) || methodInfo.hasParameters()) {\n                            throw new org.apache.camel.component.bean.MethodNotFoundException(exchange, pojo, methodName, \"(with no parameters)\");\n                        }\n                    }\n                    if ((methodInfo == null) || (!name.equals(methodInfo.getMethod().getName()))) {\n                        throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, methods);\n                    }\n                } else {\n                    throw new org.apache.camel.component.bean.MethodNotFoundException(exchange, pojo, methodName);\n                }\n            }\n        }\n        if (methodInfo == null) {\n            methodInfo = chooseMethod(pojo, exchange, null);\n        }\n        if (methodInfo == null) {\n            methodInfo = defaultMethod;\n        }\n        if (methodInfo != null) {\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Chosen method to invoke: {} on bean: {}\", methodInfo, pojo);\n            return methodInfo.createMethodInvocation(pojo, exchange);\n        }\n        org.apache.camel.component.bean.BeanInfo.LOG.debug(\"Cannot find suitable method to invoke on bean: {}\", pojo);\n        return null;\n    }\n\n    private void introspect(java.lang.Class<?> clazz) {\n        clazz = org.apache.camel.component.bean.BeanInfo.getTargetClass(clazz);\n        org.apache.camel.util.ObjectHelper.notNull(clazz, \"clazz\", this);\n        org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Introspecting class: {}\", clazz);\n        java.util.List<java.lang.reflect.Method> methods;\n        if (java.lang.reflect.Modifier.isPublic(clazz.getModifiers())) {\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Preferring class methods as class: {} is public accessible\", clazz);\n            methods = new java.util.ArrayList<java.lang.reflect.Method>(java.util.Arrays.asList(clazz.getDeclaredMethods()));\n        } else {\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Preferring interface methods as class: {} is not public accessible\", clazz);\n            methods = org.apache.camel.component.bean.BeanInfo.getInterfaceMethods(clazz);\n            java.util.List<java.lang.reflect.Method> extraMethods = java.util.Arrays.asList(clazz.getDeclaredMethods());\n            methods.addAll(extraMethods);\n        }\n        java.util.Set<java.lang.reflect.Method> overrides = new java.util.HashSet<java.lang.reflect.Method>();\n        boolean javaClass = clazz.getName().startsWith(\"java.\") || clazz.getName().startsWith(\"javax.\");\n        if (!javaClass) {\n            for (java.lang.reflect.Method source : methods) {\n                if (source.isBridge()) {\n                    continue;\n                }\n                for (java.lang.reflect.Method target : methods) {\n                    if (org.apache.camel.util.ObjectHelper.isOverridingMethod(source, target, true)) {\n                        continue;\n                    }\n                    if (org.apache.camel.util.ObjectHelper.isOverridingMethod(source, target, false)) {\n                        overrides.add(target);\n                    }\n                }\n            }\n            methods.removeAll(overrides);\n            overrides.clear();\n        }\n        if (java.lang.reflect.Modifier.isPublic(clazz.getModifiers())) {\n            java.util.List<java.lang.reflect.Method> extraMethods = org.apache.camel.component.bean.BeanInfo.getInterfaceMethods(clazz);\n            for (java.lang.reflect.Method target : extraMethods) {\n                for (java.lang.reflect.Method source : methods) {\n                    if (org.apache.camel.util.ObjectHelper.isOverridingMethod(source, target, false)) {\n                        overrides.add(target);\n                    }\n                }\n            }\n            extraMethods.removeAll(overrides);\n            methods.addAll(extraMethods);\n        }\n        for (java.lang.reflect.Method method : methods) {\n            boolean valid = isValidMethod(clazz, method);\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Method: {} is valid: {}\", method, valid);\n            if (valid) {\n                introspect(clazz, method);\n            }\n        }\n        java.lang.Class<?> superclass = clazz.getSuperclass();\n        if ((superclass != null) && (!superclass.equals(java.lang.Object.class))) {\n            introspect(superclass);\n        }\n    }\n\n    private org.apache.camel.component.bean.MethodInfo introspect(java.lang.Class<?> clazz, java.lang.reflect.Method method) {\n        org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Introspecting class: {}, method: {}\", clazz, method);\n        java.lang.String opName = method.getName();\n        org.apache.camel.component.bean.MethodInfo methodInfo = createMethodInfo(clazz, method);\n        org.apache.camel.component.bean.MethodInfo existingMethodInfo = overridesExistingMethod(methodInfo);\n        if (existingMethodInfo != null) {\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"This method is already overridden in a subclass, so the method from the sub class is preferred: {}\", existingMethodInfo);\n            return existingMethodInfo;\n        }\n        org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Adding operation: {} for method: {}\", opName, methodInfo);\n        if (hasMethod(opName)) {\n            java.util.List<org.apache.camel.component.bean.MethodInfo> existing = getOperations(opName);\n            existing.add(methodInfo);\n        } else {\n            java.util.List<org.apache.camel.component.bean.MethodInfo> methods = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n            methods.add(methodInfo);\n            operations.put(opName, methods);\n        }\n        if (methodInfo.hasCustomAnnotation()) {\n            operationsWithCustomAnnotation.add(methodInfo);\n        } else if (methodInfo.hasBodyParameter()) {\n            operationsWithBody.add(methodInfo);\n        } else {\n            operationsWithNoBody.add(methodInfo);\n        }\n        if (methodInfo.hasHandlerAnnotation()) {\n            operationsWithHandlerAnnotation.add(methodInfo);\n        }\n        methodMap.put(method, methodInfo);\n        return methodInfo;\n    }\n\n    public org.apache.camel.component.bean.MethodInfo getMethodInfo(java.lang.reflect.Method method) {\n        org.apache.camel.component.bean.MethodInfo answer = methodMap.get(method);\n        if (answer == null) {\n            for (java.lang.reflect.Method source : methodMap.keySet()) {\n                if (org.apache.camel.util.ObjectHelper.isOverridingMethod(source, method, false)) {\n                    answer = methodMap.get(source);\n                    break;\n                }\n            }\n        }\n        if (answer == null) {\n            if (type != java.lang.Object.class) {\n                java.lang.Class<?> superclass = type.getSuperclass();\n                if ((superclass != null) && (superclass != java.lang.Object.class)) {\n                    org.apache.camel.component.bean.BeanInfo superBeanInfo = new org.apache.camel.component.bean.BeanInfo(camelContext, superclass, strategy);\n                    return superBeanInfo.getMethodInfo(method);\n                }\n            }\n        }\n        return answer;\n    }\n\n    protected org.apache.camel.component.bean.MethodInfo createMethodInfo(java.lang.Class<?> clazz, java.lang.reflect.Method method) {\n        java.lang.Class<?>[] parameterTypes = method.getParameterTypes();\n        java.util.List<java.lang.annotation.Annotation>[] parametersAnnotations = collectParameterAnnotations(clazz, method);\n        java.util.List<org.apache.camel.component.bean.ParameterInfo> parameters = new java.util.ArrayList<org.apache.camel.component.bean.ParameterInfo>();\n        java.util.List<org.apache.camel.component.bean.ParameterInfo> bodyParameters = new java.util.ArrayList<org.apache.camel.component.bean.ParameterInfo>();\n        boolean hasCustomAnnotation = false;\n        boolean hasHandlerAnnotation = org.apache.camel.util.ObjectHelper.hasAnnotation(method.getAnnotations(), org.apache.camel.Handler.class);\n        int size = parameterTypes.length;\n        if (org.apache.camel.component.bean.BeanInfo.LOG.isTraceEnabled()) {\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Creating MethodInfo for class: {} method: {} having {} parameters\", new java.lang.Object[]{ clazz, method, size });\n        }\n        for (int i = 0; i < size; i++) {\n            java.lang.Class<?> parameterType = parameterTypes[i];\n            java.lang.annotation.Annotation[] parameterAnnotations = parametersAnnotations[i].toArray(new java.lang.annotation.Annotation[parametersAnnotations[i].size()]);\n            org.apache.camel.Expression expression = createParameterUnmarshalExpression(clazz, method, parameterType, parameterAnnotations);\n            hasCustomAnnotation |= expression != null;\n            org.apache.camel.component.bean.ParameterInfo parameterInfo = new org.apache.camel.component.bean.ParameterInfo(i, parameterType, parameterAnnotations, expression);\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Parameter #{}: {}\", i, parameterInfo);\n            parameters.add(parameterInfo);\n            if (expression == null) {\n                boolean bodyAnnotation = org.apache.camel.util.ObjectHelper.hasAnnotation(parameterAnnotations, org.apache.camel.Body.class);\n                org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Parameter #{} has @Body annotation\", i);\n                hasCustomAnnotation |= bodyAnnotation;\n                if (bodyParameters.isEmpty()) {\n                    if (org.apache.camel.Exchange.class.isAssignableFrom(parameterType)) {\n                        expression = org.apache.camel.builder.ExpressionBuilder.exchangeExpression();\n                    } else {\n                        expression = org.apache.camel.builder.ExpressionBuilder.mandatoryBodyExpression(parameterType, true);\n                    }\n                    org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Parameter #{} is the body parameter using expression {}\", i, expression);\n                    parameterInfo.setExpression(expression);\n                    bodyParameters.add(parameterInfo);\n                } else {\n                }\n            }\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Parameter #{} has parameter info: \", i, parameterInfo);\n        }\n        return new org.apache.camel.component.bean.MethodInfo(camelContext, clazz, method, parameters, bodyParameters, hasCustomAnnotation, hasHandlerAnnotation);\n    }\n\n    protected java.util.List<java.lang.annotation.Annotation>[] collectParameterAnnotations(java.lang.Class<?> c, java.lang.reflect.Method m) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.List<java.lang.annotation.Annotation>[] annotations = new java.util.List[m.getParameterTypes().length];\n        for (int i = 0; i < annotations.length; i++) {\n            annotations[i] = new java.util.ArrayList<java.lang.annotation.Annotation>();\n        }\n        collectParameterAnnotations(c, m, annotations);\n        return annotations;\n    }\n\n    protected void collectParameterAnnotations(java.lang.Class<?> c, java.lang.reflect.Method m, java.util.List<java.lang.annotation.Annotation>[] a) {\n        try {\n            java.lang.annotation.Annotation[][] pa = c.getDeclaredMethod(m.getName(), m.getParameterTypes()).getParameterAnnotations();\n            for (int i = 0; i < pa.length; i++) {\n                a[i].addAll(java.util.Arrays.asList(pa[i]));\n            }\n        } catch (java.lang.NoSuchMethodException e) {\n        }\n        for (java.lang.Class<?> i : c.getInterfaces()) {\n            collectParameterAnnotations(i, m, a);\n        }\n        if ((!c.isInterface()) && (c.getSuperclass() != null)) {\n            collectParameterAnnotations(c.getSuperclass(), m, a);\n        }\n    }\n\n    protected org.apache.camel.component.bean.MethodInfo chooseMethod(java.lang.Object pojo, org.apache.camel.Exchange exchange, java.lang.String name) throws org.apache.camel.component.bean.AmbiguousMethodCallException {\n        final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithBody);\n        final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithNoBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithNoBody);\n        final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithCustomAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithCustomAnnotation);\n        final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithHandlerAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithHandlerAnnotation);\n        removeAllAbstractMethods(localOperationsWithBody);\n        removeAllAbstractMethods(localOperationsWithNoBody);\n        removeAllAbstractMethods(localOperationsWithCustomAnnotation);\n        removeAllAbstractMethods(localOperationsWithHandlerAnnotation);\n        if (name != null) {\n            removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n            removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\n            removeNonMatchingMethods(localOperationsWithBody, name);\n            removeNonMatchingMethods(localOperationsWithNoBody, name);\n        } else {\n            org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\n            org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\n            org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithBody);\n            org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithNoBody);\n        }\n        if (localOperationsWithHandlerAnnotation.size() > 1) {\n            throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);\n        }\n        if (localOperationsWithHandlerAnnotation.size() == 1) {\n            return localOperationsWithHandlerAnnotation.get(0);\n        } else if (localOperationsWithCustomAnnotation.size() == 1) {\n            return localOperationsWithCustomAnnotation.get(0);\n        }\n        boolean noParameters = (name != null) && name.endsWith(\"()\");\n        if (noParameters && (localOperationsWithNoBody.size() == 1)) {\n            return localOperationsWithNoBody.get(0);\n        } else if (((!noParameters) && (localOperationsWithBody.size() == 1)) && localOperationsWithCustomAnnotation.isEmpty()) {\n            return localOperationsWithBody.get(0);\n        }\n        java.util.Collection<org.apache.camel.component.bean.MethodInfo> possibleOperations = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n        possibleOperations.addAll(localOperationsWithBody);\n        possibleOperations.addAll(localOperationsWithCustomAnnotation);\n        if (!possibleOperations.isEmpty()) {\n            org.apache.camel.component.bean.MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);\n            if ((answer == null) && (name != null)) {\n                java.lang.String parameters = org.apache.camel.util.ObjectHelper.between(name, \"(\", \")\");\n                if (parameters != null) {\n                    answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);\n                }\n            }\n            if ((answer == null) && (possibleOperations.size() > 1)) {\n                answer = getSingleCovariantMethod(possibleOperations);\n            }\n            if (answer == null) {\n                throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, possibleOperations);\n            } else {\n                return answer;\n            }\n        }\n        return null;\n    }\n\n    private org.apache.camel.component.bean.MethodInfo chooseMethodWithMatchingParameters(org.apache.camel.Exchange exchange, java.lang.String parameters, java.util.Collection<org.apache.camel.component.bean.MethodInfo> operationList) throws org.apache.camel.component.bean.AmbiguousMethodCallException {\n        java.util.Iterator<?> it = org.apache.camel.util.ObjectHelper.createIterator(parameters);\n        int count = 0;\n        while (it.hasNext()) {\n            it.next();\n            count++;\n        } \n        java.util.List<org.apache.camel.component.bean.MethodInfo> operations = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n        for (org.apache.camel.component.bean.MethodInfo info : operationList) {\n            if (info.getParameters().size() == count) {\n                operations.add(info);\n            }\n        }\n        if (operations.isEmpty()) {\n            return null;\n        } else if (operations.size() == 1) {\n            return operations.get(0);\n        }\n        java.util.List<org.apache.camel.component.bean.MethodInfo> candidates = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n        for (org.apache.camel.component.bean.MethodInfo info : operations) {\n            it = org.apache.camel.util.ObjectHelper.createIterator(parameters);\n            int index = 0;\n            boolean matches = true;\n            while (it.hasNext()) {\n                java.lang.String parameter = ((java.lang.String) (it.next()));\n                java.lang.Class<?> parameterType = org.apache.camel.component.bean.BeanHelper.getValidParameterType(parameter);\n                java.lang.Class<?> expectedType = info.getParameters().get(index).getType();\n                if ((parameterType != null) && (expectedType != null)) {\n                    if (!parameterType.isAssignableFrom(expectedType)) {\n                        matches = false;\n                        break;\n                    }\n                }\n                index++;\n            } \n            if (matches) {\n                candidates.add(info);\n            }\n        }\n        if (candidates.size() > 1) {\n            org.apache.camel.component.bean.MethodInfo answer = getSingleCovariantMethod(candidates);\n            if (answer == null) {\n                throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, candidates);\n            }\n            return answer;\n        }\n        return candidates.size() == 1 ? candidates.get(0) : null;\n    }\n\n    private org.apache.camel.component.bean.MethodInfo getSingleCovariantMethod(java.util.Collection<org.apache.camel.component.bean.MethodInfo> candidates) {\n        org.apache.camel.component.bean.MethodInfo firstCandidate = candidates.iterator().next();\n        for (org.apache.camel.component.bean.MethodInfo candidate : candidates) {\n            if (!firstCandidate.isCovariantWith(candidate)) {\n                return null;\n            }\n        }\n        return firstCandidate;\n    }\n\n    private org.apache.camel.component.bean.MethodInfo chooseMethodWithMatchingBody(org.apache.camel.Exchange exchange, java.util.Collection<org.apache.camel.component.bean.MethodInfo> operationList, java.util.List<org.apache.camel.component.bean.MethodInfo> operationsWithCustomAnnotation) throws org.apache.camel.component.bean.AmbiguousMethodCallException {\n        org.apache.camel.Message in = exchange.getIn();\n        java.lang.Object body = in.getBody();\n        if (body != null) {\n            java.lang.Class<?> bodyType = body.getClass();\n            if (org.apache.camel.component.bean.BeanInfo.LOG.isTraceEnabled()) {\n                org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Matching for method with a single parameter that matches type: {}\", bodyType.getCanonicalName());\n            }\n            java.util.List<org.apache.camel.component.bean.MethodInfo> possibles = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n            java.util.List<org.apache.camel.component.bean.MethodInfo> possiblesWithException = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n            for (org.apache.camel.component.bean.MethodInfo methodInfo : operationList) {\n                boolean out = exchange.getPattern().isOutCapable();\n                if (out && methodInfo.isReturnTypeVoid()) {\n                    continue;\n                }\n                if (methodInfo.bodyParameterMatches(bodyType)) {\n                    org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Found a possible method: {}\", methodInfo);\n                    if (methodInfo.hasExceptionParameter()) {\n                        possiblesWithException.add(methodInfo);\n                    } else {\n                        possibles.add(methodInfo);\n                    }\n                }\n            }\n            return chooseBestPossibleMethodInfo(exchange, operationList, body, possibles, possiblesWithException, operationsWithCustomAnnotation);\n        }\n        return null;\n    }\n\n    private org.apache.camel.component.bean.MethodInfo chooseBestPossibleMethodInfo(org.apache.camel.Exchange exchange, java.util.Collection<org.apache.camel.component.bean.MethodInfo> operationList, java.lang.Object body, java.util.List<org.apache.camel.component.bean.MethodInfo> possibles, java.util.List<org.apache.camel.component.bean.MethodInfo> possiblesWithException, java.util.List<org.apache.camel.component.bean.MethodInfo> possibleWithCustomAnnotation) throws org.apache.camel.component.bean.AmbiguousMethodCallException {\n        java.lang.Exception exception = org.apache.camel.builder.ExpressionBuilder.exchangeExceptionExpression().evaluate(exchange, java.lang.Exception.class);\n        if ((exception != null) && (possiblesWithException.size() == 1)) {\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Exchange has exception set so we prefer method that also has exception as parameter\");\n            return possiblesWithException.get(0);\n        } else if (possibles.size() == 1) {\n            return possibles.get(0);\n        } else if (possibles.isEmpty()) {\n            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"No possible methods so now trying to convert body to parameter types\");\n            java.lang.Object newBody = null;\n            org.apache.camel.component.bean.MethodInfo matched = null;\n            int matchCounter = 0;\n            for (org.apache.camel.component.bean.MethodInfo methodInfo : operationList) {\n                if (methodInfo.getBodyParameterType() != null) {\n                    if (methodInfo.getBodyParameterType().isInstance(body)) {\n                        return methodInfo;\n                    }\n                    java.lang.Object value = exchange.getContext().getTypeConverter().tryConvertTo(methodInfo.getBodyParameterType(), exchange, body);\n                    if (value != null) {\n                        if (org.apache.camel.component.bean.BeanInfo.LOG.isTraceEnabled()) {\n                            org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Converted body from: {} to: {}\", body.getClass().getCanonicalName(), methodInfo.getBodyParameterType().getCanonicalName());\n                        }\n                        matchCounter++;\n                        newBody = value;\n                        matched = methodInfo;\n                    }\n                }\n            }\n            if (matchCounter > 1) {\n                throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, java.util.Arrays.asList(matched, matched));\n            }\n            if (matched != null) {\n                org.apache.camel.component.bean.BeanInfo.LOG.trace(\"Setting converted body: {}\", body);\n                org.apache.camel.Message in = exchange.getIn();\n                in.setBody(newBody);\n                return matched;\n            }\n        } else {\n            if (possibleWithCustomAnnotation.size() == 1) {\n                org.apache.camel.component.bean.MethodInfo answer = possibleWithCustomAnnotation.get(0);\n                org.apache.camel.component.bean.BeanInfo.LOG.trace(\"There are only one method with annotations so we choose it: {}\", answer);\n                return answer;\n            }\n            org.apache.camel.component.bean.MethodInfo chosen = chooseMethodWithCustomAnnotations(exchange, possibles);\n            if (chosen != null) {\n                return chosen;\n            }\n            chosen = getSingleCovariantMethod(possibles);\n            if (chosen != null) {\n                return chosen;\n            }\n            throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, possibles);\n        }\n        return null;\n    }\n\n    protected boolean isValidMethod(java.lang.Class<?> clazz, java.lang.reflect.Method method) {\n        for (java.lang.reflect.Method excluded : org.apache.camel.component.bean.BeanInfo.EXCLUDED_METHODS) {\n            if (org.apache.camel.util.ObjectHelper.isOverridingMethod(excluded, method)) {\n                return false;\n            }\n        }\n        if (!java.lang.reflect.Modifier.isPublic(method.getModifiers())) {\n            return false;\n        }\n        if (((method.getReturnType() != null) && org.apache.camel.Exchange.class.isAssignableFrom(method.getReturnType())) || method.isBridge()) {\n            return false;\n        }\n        return true;\n    }\n\n    private org.apache.camel.component.bean.MethodInfo overridesExistingMethod(org.apache.camel.component.bean.MethodInfo methodInfo) {\n        for (org.apache.camel.component.bean.MethodInfo info : methodMap.values()) {\n            java.lang.reflect.Method source = info.getMethod();\n            java.lang.reflect.Method target = methodInfo.getMethod();\n            boolean override = org.apache.camel.util.ObjectHelper.isOverridingMethod(source, target);\n            if (override) {\n                return info;\n            }\n        }\n        return null;\n    }\n\n    private org.apache.camel.component.bean.MethodInfo chooseMethodWithCustomAnnotations(org.apache.camel.Exchange exchange, java.util.Collection<org.apache.camel.component.bean.MethodInfo> possibles) throws org.apache.camel.component.bean.AmbiguousMethodCallException {\n        org.apache.camel.component.bean.MethodInfo chosen = null;\n        for (org.apache.camel.component.bean.MethodInfo possible : possibles) {\n            if (possible.hasCustomAnnotation()) {\n                if (chosen != null) {\n                    chosen = null;\n                    break;\n                } else {\n                    chosen = possible;\n                }\n            }\n        }\n        return chosen;\n    }\n\n    private org.apache.camel.Expression createParameterUnmarshalExpression(java.lang.Class<?> clazz, java.lang.reflect.Method method, java.lang.Class<?> parameterType, java.lang.annotation.Annotation[] parameterAnnotation) {\n        for (java.lang.annotation.Annotation annotation : parameterAnnotation) {\n            org.apache.camel.Expression answer = createParameterUnmarshalExpressionForAnnotation(clazz, method, parameterType, annotation);\n            if (answer != null) {\n                return answer;\n            }\n        }\n        return strategy.getDefaultParameterTypeExpression(parameterType);\n    }\n\n    private org.apache.camel.Expression createParameterUnmarshalExpressionForAnnotation(java.lang.Class<?> clazz, java.lang.reflect.Method method, java.lang.Class<?> parameterType, java.lang.annotation.Annotation annotation) {\n        if (annotation instanceof org.apache.camel.Attachments) {\n            return org.apache.camel.builder.ExpressionBuilder.attachmentsExpression();\n        } else if (annotation instanceof org.apache.camel.Property) {\n            org.apache.camel.Property propertyAnnotation = ((org.apache.camel.Property) (annotation));\n            return org.apache.camel.builder.ExpressionBuilder.exchangePropertyExpression(propertyAnnotation.value());\n        } else if (annotation instanceof org.apache.camel.ExchangeProperty) {\n            org.apache.camel.ExchangeProperty propertyAnnotation = ((org.apache.camel.ExchangeProperty) (annotation));\n            return org.apache.camel.builder.ExpressionBuilder.exchangePropertyExpression(propertyAnnotation.value());\n        } else if (annotation instanceof org.apache.camel.Properties) {\n            return org.apache.camel.builder.ExpressionBuilder.propertiesExpression();\n        } else if (annotation instanceof org.apache.camel.Header) {\n            org.apache.camel.Header headerAnnotation = ((org.apache.camel.Header) (annotation));\n            return org.apache.camel.builder.ExpressionBuilder.headerExpression(headerAnnotation.value());\n        } else if (annotation instanceof org.apache.camel.Headers) {\n            return org.apache.camel.builder.ExpressionBuilder.headersExpression();\n        } else if (annotation instanceof org.apache.camel.OutHeaders) {\n            return org.apache.camel.builder.ExpressionBuilder.outHeadersExpression();\n        } else if (annotation instanceof org.apache.camel.ExchangeException) {\n            return org.apache.camel.builder.ExpressionBuilder.exchangeExceptionExpression(org.apache.camel.util.CastUtils.cast(parameterType, java.lang.Exception.class));\n        } else {\n            org.apache.camel.language.LanguageAnnotation languageAnnotation = annotation.annotationType().getAnnotation(org.apache.camel.language.LanguageAnnotation.class);\n            if (languageAnnotation != null) {\n                java.lang.Class<?> type = languageAnnotation.factory();\n                java.lang.Object object = camelContext.getInjector().newInstance(type);\n                if (object instanceof org.apache.camel.component.bean.AnnotationExpressionFactory) {\n                    org.apache.camel.component.bean.AnnotationExpressionFactory expressionFactory = ((org.apache.camel.component.bean.AnnotationExpressionFactory) (object));\n                    return expressionFactory.createExpression(camelContext, annotation, languageAnnotation, parameterType);\n                } else {\n                    org.apache.camel.component.bean.BeanInfo.LOG.warn(((((((\"Ignoring bad annotation: \" + languageAnnotation) + \"on method: \") + method) + \" which declares a factory: \") + type.getName()) + \" which does not implement \") + org.apache.camel.component.bean.AnnotationExpressionFactory.class.getName());\n                }\n            }\n        }\n        return null;\n    }\n\n    private static java.util.List<java.lang.reflect.Method> getInterfaceMethods(java.lang.Class<?> clazz) {\n        final java.util.List<java.lang.reflect.Method> answer = new java.util.ArrayList<java.lang.reflect.Method>();\n        while ((clazz != null) && (!clazz.equals(java.lang.Object.class))) {\n            for (java.lang.Class<?> interfaceClazz : clazz.getInterfaces()) {\n                for (java.lang.reflect.Method interfaceMethod : interfaceClazz.getDeclaredMethods()) {\n                    answer.add(interfaceMethod);\n                }\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return answer;\n    }\n\n    private static void removeAllSetterOrGetterMethods(java.util.List<org.apache.camel.component.bean.MethodInfo> methods) {\n        java.util.Iterator<org.apache.camel.component.bean.MethodInfo> it = methods.iterator();\n        while (it.hasNext()) {\n            org.apache.camel.component.bean.MethodInfo info = it.next();\n            if (org.apache.camel.util.IntrospectionSupport.isGetter(info.getMethod())) {\n                it.remove();\n            } else if (org.apache.camel.util.IntrospectionSupport.isSetter(info.getMethod())) {\n                it.remove();\n            }\n        } \n    }\n\n    private void removeNonMatchingMethods(java.util.List<org.apache.camel.component.bean.MethodInfo> methods, java.lang.String name) {\n        java.util.Iterator<org.apache.camel.component.bean.MethodInfo> it = methods.iterator();\n        while (it.hasNext()) {\n            org.apache.camel.component.bean.MethodInfo info = it.next();\n            if (!matchMethod(info.getMethod(), name)) {\n                it.remove();\n            }\n        } \n    }\n\n    private void removeAllAbstractMethods(java.util.List<org.apache.camel.component.bean.MethodInfo> methods) {\n        java.util.Iterator<org.apache.camel.component.bean.MethodInfo> it = methods.iterator();\n        while (it.hasNext()) {\n            org.apache.camel.component.bean.MethodInfo info = it.next();\n            if (java.lang.reflect.Modifier.isAbstract(info.getMethod().getModifiers())) {\n                it.remove();\n            }\n        } \n    }\n\n    private boolean matchMethod(java.lang.reflect.Method method, java.lang.String methodName) {\n        if (methodName == null) {\n            return true;\n        }\n        if (methodName.contains(\"(\") && (!methodName.endsWith(\")\"))) {\n            throw new java.lang.IllegalArgumentException(\"Name must have both starting and ending parenthesis, was: \" + methodName);\n        }\n        java.lang.String name = methodName;\n        if (name.contains(\"(\")) {\n            name = org.apache.camel.util.ObjectHelper.before(name, \"(\");\n        }\n        if (!name.equals(method.getName())) {\n            return false;\n        }\n        boolean noParameters = methodName.endsWith(\"()\");\n        if (noParameters) {\n            return method.getParameterTypes().length == 0;\n        }\n        java.lang.String types = org.apache.camel.util.ObjectHelper.between(methodName, \"(\", \")\");\n        if (org.apache.camel.util.ObjectHelper.isNotEmpty(types)) {\n            java.lang.String[] parameters = org.apache.camel.util.StringQuoteHelper.splitSafeQuote(types, ',');\n            java.util.Iterator<?> it = org.apache.camel.util.ObjectHelper.createIterator(parameters);\n            for (int i = 0; i < method.getParameterTypes().length; i++) {\n                if (it.hasNext()) {\n                    java.lang.Class<?> parameterType = method.getParameterTypes()[i];\n                    java.lang.String qualifyType = ((java.lang.String) (it.next()));\n                    if (org.apache.camel.util.ObjectHelper.isEmpty(qualifyType)) {\n                        continue;\n                    }\n                    qualifyType = qualifyType.trim();\n                    if (\"*\".equals(qualifyType)) {\n                        continue;\n                    }\n                    if (org.apache.camel.component.bean.BeanHelper.isValidParameterValue(qualifyType)) {\n                        continue;\n                    }\n                    java.lang.Boolean assignable = org.apache.camel.component.bean.BeanHelper.isAssignableToExpectedType(getCamelContext().getClassResolver(), qualifyType, parameterType);\n                    if ((assignable != null) && (!assignable)) {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n            if (it.hasNext()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static java.lang.Class<?> getTargetClass(java.lang.Class<?> clazz) {\n        if ((clazz != null) && clazz.getName().contains(org.apache.camel.component.bean.BeanInfo.CGLIB_CLASS_SEPARATOR)) {\n            java.lang.Class<?> superClass = clazz.getSuperclass();\n            if ((superClass != null) && (!java.lang.Object.class.equals(superClass))) {\n                return superClass;\n            }\n        }\n        return clazz;\n    }\n\n    public boolean hasMethod(java.lang.String methodName) {\n        return getOperations(methodName) != null;\n    }\n\n    public boolean hasStaticMethod(java.lang.String methodName) {\n        java.util.List<org.apache.camel.component.bean.MethodInfo> methods = getOperations(methodName);\n        if ((methods == null) || methods.isEmpty()) {\n            return false;\n        }\n        for (org.apache.camel.component.bean.MethodInfo method : methods) {\n            if (method.isStaticMethod()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public java.util.List<org.apache.camel.component.bean.MethodInfo> getMethods() {\n        if (operations.isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        java.util.List<org.apache.camel.component.bean.MethodInfo> methods = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n        for (java.util.Collection<org.apache.camel.component.bean.MethodInfo> col : operations.values()) {\n            methods.addAll(col);\n        }\n        java.util.Collections.sort(methods, new java.util.Comparator<org.apache.camel.component.bean.MethodInfo>() {\n            public int compare(org.apache.camel.component.bean.MethodInfo o1, org.apache.camel.component.bean.MethodInfo o2) {\n                return o1.getMethod().getName().compareTo(o2.getMethod().getName());\n            }\n        });\n        return methods;\n    }\n\n    private java.util.List<org.apache.camel.component.bean.MethodInfo> getOperations(java.lang.String methodName) {\n        if (methodName.contains(\"(\")) {\n            methodName = org.apache.camel.util.ObjectHelper.before(methodName, \"(\");\n        }\n        java.util.List<org.apache.camel.component.bean.MethodInfo> answer = operations.get(methodName);\n        if (answer != null) {\n            return answer;\n        }\n        for (java.lang.reflect.Method method : methodMap.keySet()) {\n            if (org.apache.camel.util.IntrospectionSupport.isGetter(method)) {\n                java.lang.String shorthandMethodName = org.apache.camel.util.IntrospectionSupport.getGetterShorthandName(method);\n                if (methodName.equals(shorthandMethodName)) {\n                    return operations.get(method.getName());\n                }\n            }\n        }\n        return null;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "removeAllAbstractMethods(localOperationsWithBody)",
            "src_parent": "{\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithBody);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithNoBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithNoBody);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithCustomAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithCustomAnnotation);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithHandlerAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithHandlerAnnotation);\n    removeAllAbstractMethods(localOperationsWithBody);\n    removeAllAbstractMethods(localOperationsWithNoBody);\n    removeAllAbstractMethods(localOperationsWithCustomAnnotation);\n    removeAllAbstractMethods(localOperationsWithHandlerAnnotation);\n    if (name != null) {\n        removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithBody, name);\n        removeNonMatchingMethods(localOperationsWithNoBody, name);\n    } else {\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithBody);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithNoBody);\n    }\n    if (localOperationsWithHandlerAnnotation.size() > 1) {\n        throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);\n    }\n    if (localOperationsWithHandlerAnnotation.size() == 1) {\n        return localOperationsWithHandlerAnnotation.get(0);\n    } else if (localOperationsWithCustomAnnotation.size() == 1) {\n        return localOperationsWithCustomAnnotation.get(0);\n    }\n    boolean noParameters = (name != null) && name.endsWith(\"()\");\n    if (noParameters && (localOperationsWithNoBody.size() == 1)) {\n        return localOperationsWithNoBody.get(0);\n    } else if (((!noParameters) && (localOperationsWithBody.size() == 1)) && localOperationsWithCustomAnnotation.isEmpty()) {\n        return localOperationsWithBody.get(0);\n    }\n    java.util.Collection<org.apache.camel.component.bean.MethodInfo> possibleOperations = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n    possibleOperations.addAll(localOperationsWithBody);\n    possibleOperations.addAll(localOperationsWithCustomAnnotation);\n    if (!possibleOperations.isEmpty()) {\n        org.apache.camel.component.bean.MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);\n        if ((answer == null) && (name != null)) {\n            java.lang.String parameters = org.apache.camel.util.ObjectHelper.between(name, \"(\", \")\");\n            if (parameters != null) {\n                answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);\n            }\n        }\n        if ((answer == null) && (possibleOperations.size() > 1)) {\n            answer = getSingleCovariantMethod(possibleOperations);\n        }\n        if (answer == null) {\n            throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, possibleOperations);\n        } else {\n            return answer;\n        }\n    }\n    return null;\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "removeAllAbstractMethods(localOperationsWithNoBody)",
            "src_parent": "{\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithBody);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithNoBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithNoBody);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithCustomAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithCustomAnnotation);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithHandlerAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithHandlerAnnotation);\n    removeAllAbstractMethods(localOperationsWithBody);\n    removeAllAbstractMethods(localOperationsWithNoBody);\n    removeAllAbstractMethods(localOperationsWithCustomAnnotation);\n    removeAllAbstractMethods(localOperationsWithHandlerAnnotation);\n    if (name != null) {\n        removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithBody, name);\n        removeNonMatchingMethods(localOperationsWithNoBody, name);\n    } else {\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithBody);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithNoBody);\n    }\n    if (localOperationsWithHandlerAnnotation.size() > 1) {\n        throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);\n    }\n    if (localOperationsWithHandlerAnnotation.size() == 1) {\n        return localOperationsWithHandlerAnnotation.get(0);\n    } else if (localOperationsWithCustomAnnotation.size() == 1) {\n        return localOperationsWithCustomAnnotation.get(0);\n    }\n    boolean noParameters = (name != null) && name.endsWith(\"()\");\n    if (noParameters && (localOperationsWithNoBody.size() == 1)) {\n        return localOperationsWithNoBody.get(0);\n    } else if (((!noParameters) && (localOperationsWithBody.size() == 1)) && localOperationsWithCustomAnnotation.isEmpty()) {\n        return localOperationsWithBody.get(0);\n    }\n    java.util.Collection<org.apache.camel.component.bean.MethodInfo> possibleOperations = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n    possibleOperations.addAll(localOperationsWithBody);\n    possibleOperations.addAll(localOperationsWithCustomAnnotation);\n    if (!possibleOperations.isEmpty()) {\n        org.apache.camel.component.bean.MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);\n        if ((answer == null) && (name != null)) {\n            java.lang.String parameters = org.apache.camel.util.ObjectHelper.between(name, \"(\", \")\");\n            if (parameters != null) {\n                answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);\n            }\n        }\n        if ((answer == null) && (possibleOperations.size() > 1)) {\n            answer = getSingleCovariantMethod(possibleOperations);\n        }\n        if (answer == null) {\n            throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, possibleOperations);\n        } else {\n            return answer;\n        }\n    }\n    return null;\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "removeAllAbstractMethods(localOperationsWithCustomAnnotation)",
            "src_parent": "{\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithBody);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithNoBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithNoBody);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithCustomAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithCustomAnnotation);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithHandlerAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithHandlerAnnotation);\n    removeAllAbstractMethods(localOperationsWithBody);\n    removeAllAbstractMethods(localOperationsWithNoBody);\n    removeAllAbstractMethods(localOperationsWithCustomAnnotation);\n    removeAllAbstractMethods(localOperationsWithHandlerAnnotation);\n    if (name != null) {\n        removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithBody, name);\n        removeNonMatchingMethods(localOperationsWithNoBody, name);\n    } else {\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithBody);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithNoBody);\n    }\n    if (localOperationsWithHandlerAnnotation.size() > 1) {\n        throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);\n    }\n    if (localOperationsWithHandlerAnnotation.size() == 1) {\n        return localOperationsWithHandlerAnnotation.get(0);\n    } else if (localOperationsWithCustomAnnotation.size() == 1) {\n        return localOperationsWithCustomAnnotation.get(0);\n    }\n    boolean noParameters = (name != null) && name.endsWith(\"()\");\n    if (noParameters && (localOperationsWithNoBody.size() == 1)) {\n        return localOperationsWithNoBody.get(0);\n    } else if (((!noParameters) && (localOperationsWithBody.size() == 1)) && localOperationsWithCustomAnnotation.isEmpty()) {\n        return localOperationsWithBody.get(0);\n    }\n    java.util.Collection<org.apache.camel.component.bean.MethodInfo> possibleOperations = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n    possibleOperations.addAll(localOperationsWithBody);\n    possibleOperations.addAll(localOperationsWithCustomAnnotation);\n    if (!possibleOperations.isEmpty()) {\n        org.apache.camel.component.bean.MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);\n        if ((answer == null) && (name != null)) {\n            java.lang.String parameters = org.apache.camel.util.ObjectHelper.between(name, \"(\", \")\");\n            if (parameters != null) {\n                answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);\n            }\n        }\n        if ((answer == null) && (possibleOperations.size() > 1)) {\n            answer = getSingleCovariantMethod(possibleOperations);\n        }\n        if (answer == null) {\n            throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, possibleOperations);\n        } else {\n            return answer;\n        }\n    }\n    return null;\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "removeAllAbstractMethods(localOperationsWithHandlerAnnotation)",
            "src_parent": "{\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithBody);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithNoBody = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithNoBody);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithCustomAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithCustomAnnotation);\n    final java.util.List<org.apache.camel.component.bean.MethodInfo> localOperationsWithHandlerAnnotation = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>(operationsWithHandlerAnnotation);\n    removeAllAbstractMethods(localOperationsWithBody);\n    removeAllAbstractMethods(localOperationsWithNoBody);\n    removeAllAbstractMethods(localOperationsWithCustomAnnotation);\n    removeAllAbstractMethods(localOperationsWithHandlerAnnotation);\n    if (name != null) {\n        removeNonMatchingMethods(localOperationsWithHandlerAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithCustomAnnotation, name);\n        removeNonMatchingMethods(localOperationsWithBody, name);\n        removeNonMatchingMethods(localOperationsWithNoBody, name);\n    } else {\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithHandlerAnnotation);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithCustomAnnotation);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithBody);\n        org.apache.camel.component.bean.BeanInfo.removeAllSetterOrGetterMethods(localOperationsWithNoBody);\n    }\n    if (localOperationsWithHandlerAnnotation.size() > 1) {\n        throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, localOperationsWithHandlerAnnotation);\n    }\n    if (localOperationsWithHandlerAnnotation.size() == 1) {\n        return localOperationsWithHandlerAnnotation.get(0);\n    } else if (localOperationsWithCustomAnnotation.size() == 1) {\n        return localOperationsWithCustomAnnotation.get(0);\n    }\n    boolean noParameters = (name != null) && name.endsWith(\"()\");\n    if (noParameters && (localOperationsWithNoBody.size() == 1)) {\n        return localOperationsWithNoBody.get(0);\n    } else if (((!noParameters) && (localOperationsWithBody.size() == 1)) && localOperationsWithCustomAnnotation.isEmpty()) {\n        return localOperationsWithBody.get(0);\n    }\n    java.util.Collection<org.apache.camel.component.bean.MethodInfo> possibleOperations = new java.util.ArrayList<org.apache.camel.component.bean.MethodInfo>();\n    possibleOperations.addAll(localOperationsWithBody);\n    possibleOperations.addAll(localOperationsWithCustomAnnotation);\n    if (!possibleOperations.isEmpty()) {\n        org.apache.camel.component.bean.MethodInfo answer = chooseMethodWithMatchingBody(exchange, possibleOperations, localOperationsWithCustomAnnotation);\n        if ((answer == null) && (name != null)) {\n            java.lang.String parameters = org.apache.camel.util.ObjectHelper.between(name, \"(\", \")\");\n            if (parameters != null) {\n                answer = chooseMethodWithMatchingParameters(exchange, parameters, possibleOperations);\n            }\n        }\n        if ((answer == null) && (possibleOperations.size() > 1)) {\n            answer = getSingleCovariantMethod(possibleOperations);\n        }\n        if (answer == null) {\n            throw new org.apache.camel.component.bean.AmbiguousMethodCallException(exchange, possibleOperations);\n        } else {\n            return answer;\n        }\n    }\n    return null;\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        }
      ],
      "file_name": "BeanInfo"
    }
  ],
  "id": "camel_108d94f7"
}