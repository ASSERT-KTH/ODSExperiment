{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "head = revNode.store(head, new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev))",
            "src_parent": "{\n    long oldRevision = headRevId;\n    long rev = headRevId + 1;\n    org.apache.jackrabbit.mk.simple.NodeImpl root = nodeMap.getRootId().getNode(nodeMap);\n    org.apache.jackrabbit.mk.simple.NodeImpl head = root.getNode(\"head\");\n    org.apache.jackrabbit.mk.simple.NodeImpl oldHead = head;\n    org.apache.jackrabbit.mk.simple.NodeImpl data = head.getNode(\"data\");\n    org.apache.jackrabbit.mk.json.JsopWriter diff = new org.apache.jackrabbit.mk.json.JsopStream();\n    while (true) {\n        int r = t.read();\n        if (r == org.apache.jackrabbit.mk.json.JsopTokenizer.END) {\n            break;\n        }\n        java.lang.String path = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, t.readString());\n        java.lang.String from = org.apache.jackrabbit.mk.util.PathUtils.relativize(\"/\", path);\n        switch (r) {\n            case '+' :\n                t.read(':');\n                diff.tag('+').key(path);\n                if (t.matches('{')) {\n                    org.apache.jackrabbit.mk.simple.NodeImpl n = org.apache.jackrabbit.mk.simple.NodeImpl.parse(nodeMap, t, rev);\n                    data = data.cloneAndAddChildNode(from, false, null, n, rev);\n                    n.append(diff, java.lang.Integer.MAX_VALUE, 0, java.lang.Integer.MAX_VALUE, false);\n                } else {\n                    java.lang.String value = t.readRawValue().trim();\n                    java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(from);\n                    java.lang.String propertyName = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                    if (data.getNode(nodeName).hasProperty(propertyName)) {\n                        throw org.apache.jackrabbit.mk.util.ExceptionFactory.get(\"Property already exists: \" + propertyName);\n                    }\n                    data = data.cloneAndSetProperty(from, value, rev);\n                    diff.encodedValue(value);\n                }\n                diff.newline();\n                break;\n            case '-' :\n                diff.tag('-').value(path).newline();\n                if (data.exists(from) || (!getRevisionDataRoot(revisionId).exists(from))) {\n                    data = data.cloneAndRemoveChildNode(from, rev);\n                }\n                break;\n            case '^' :\n                t.read(':');\n                boolean isConfigChange = from.startsWith(\":root/head/config/\");\n                java.lang.String value;\n                if (t.matches(JsopTokenizer.NULL)) {\n                    value = null;\n                    diff.tag('^').key(path).value(null);\n                } else {\n                    value = t.readRawValue().trim();\n                    java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(from);\n                    java.lang.String propertyName = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                    if (isConfigChange || data.getNode(nodeName).hasProperty(propertyName)) {\n                        diff.tag('^');\n                    } else {\n                        diff.tag('+');\n                    }\n                    diff.key(path).encodedValue(value);\n                }\n                if (isConfigChange) {\n                    java.lang.String p = org.apache.jackrabbit.mk.util.PathUtils.relativize(\":root/head\", from);\n                    if (!head.exists(\"config\")) {\n                        head = head.setChild(\"config\", new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev), rev);\n                    }\n                    head = head.cloneAndSetProperty(p, value, rev);\n                    applyConfig(head);\n                } else {\n                    data = data.cloneAndSetProperty(from, value, rev);\n                }\n                diff.newline();\n                break;\n            case '>' :\n                {\n                    t.read(':');\n                    diff.tag('>').key(path);\n                    java.lang.String name = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                    java.lang.String position;\n                    java.lang.String target;\n                    java.lang.String to;\n                    boolean rename;\n                    if (t.matches('{')) {\n                        rename = false;\n                        position = t.readString();\n                        t.read(':');\n                        target = t.readString();\n                        t.read('}');\n                        diff.object().key(position);\n                        if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(target)) {\n                            target = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, target);\n                        }\n                        diff.value(target).endObject();\n                    } else {\n                        rename = true;\n                        position = null;\n                        target = t.readString();\n                        if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(target)) {\n                            target = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, target);\n                        }\n                        diff.value(target);\n                    }\n                    diff.newline();\n                    boolean before = false;\n                    if (\"last\".equals(position)) {\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                        position = null;\n                    } else if (\"first\".equals(position)) {\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                        position = null;\n                        before = true;\n                    } else if (\"before\".equals(position)) {\n                        position = org.apache.jackrabbit.mk.util.PathUtils.getName(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                        before = true;\n                    } else if (\"after\".equals(position)) {\n                        position = org.apache.jackrabbit.mk.util.PathUtils.getName(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                    } else if (position == null) {\n                    } else {\n                        throw org.apache.jackrabbit.mk.util.ExceptionFactory.get(\"position: \" + position);\n                    }\n                    to = org.apache.jackrabbit.mk.util.PathUtils.relativize(\"/\", target);\n                    boolean inPlaceRename = false;\n                    if (rename) {\n                        if (org.apache.jackrabbit.mk.util.PathUtils.getParentPath(from).equals(org.apache.jackrabbit.mk.util.PathUtils.getParentPath(to))) {\n                            inPlaceRename = true;\n                            position = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                        }\n                    }\n                    org.apache.jackrabbit.mk.simple.NodeImpl node = data.getNode(from);\n                    if (!inPlaceRename) {\n                        data = data.cloneAndRemoveChildNode(from, rev);\n                    }\n                    data = data.cloneAndAddChildNode(to, before, position, node, rev);\n                    if (inPlaceRename) {\n                        data = data.cloneAndRemoveChildNode(from, rev);\n                    }\n                    break;\n                }\n            case '*' :\n                {\n                    t.read(':');\n                    java.lang.String target = t.readString();\n                    diff.tag('*').key(path).value(target);\n                    if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(target)) {\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, target);\n                    }\n                    org.apache.jackrabbit.mk.simple.NodeImpl node = data.getNode(from);\n                    java.lang.String to = org.apache.jackrabbit.mk.util.PathUtils.relativize(\"/\", target);\n                    data = data.cloneAndAddChildNode(to, false, null, node, rev);\n                    break;\n                }\n            default :\n                throw org.apache.jackrabbit.mk.util.ExceptionFactory.get(\"token: \" + ((char) (t.getTokenType())));\n        }\n    } \n    head = head.setChild(\"data\", data, rev);\n    org.apache.jackrabbit.mk.simple.Revision revNode = new org.apache.jackrabbit.mk.simple.Revision(rev, clock.nanoTime(), diff.toString(), message);\n    revisionCache.put(rev, revNode);\n    head = revNode.store(head, new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev));\n    root = root.setChild(\"head\", head, rev);\n    java.lang.String old = org.apache.jackrabbit.mk.simple.Revision.formatId(oldRevision);\n    org.apache.jackrabbit.mk.simple.NodeImpl oldRev = new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev);\n    oldRev.addChildNode(\"head\", oldHead);\n    java.lang.String lastRev = org.apache.jackrabbit.mk.simple.Revision.formatId(oldRevision - 1);\n    if (root.exists(lastRev)) {\n        org.apache.jackrabbit.mk.simple.NodeImpl lastRevNode = root.getNode(lastRev);\n        root = root.cloneAndRemoveChildNode(lastRev, rev);\n        oldRev.setChild(lastRev, lastRevNode, rev);\n        if ((oldRevision % org.apache.jackrabbit.mk.simple.SimpleKernelImpl.REV_SKIP_OFFSET) == 0) {\n            long skip = oldRevision - org.apache.jackrabbit.mk.simple.SimpleKernelImpl.REV_SKIP_OFFSET;\n            org.apache.jackrabbit.mk.simple.NodeImpl n = getRevisionNode(getRoot(), skip, skip);\n            if (n != null) {\n                oldRev.setChild(org.apache.jackrabbit.mk.simple.Revision.formatId(skip), n, rev);\n            }\n        }\n    }\n    root = root.setChild(old, oldRev, rev);\n    nodeMap.commit(root);\n    headRevId = rev;\n    headRevision = org.apache.jackrabbit.mk.simple.Revision.formatId(rev);\n    gate.commit(headRevision);\n    return headRevision;\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "@org.apache.jackrabbit.mk.simple.param\norg.apache.jackrabbit.mk.simple.rootPath the",
            "src_parent": "{\n    long oldRevision = headRevId;\n    long rev = headRevId + 1;\n    org.apache.jackrabbit.mk.simple.NodeImpl root = nodeMap.getRootId().getNode(nodeMap);\n    org.apache.jackrabbit.mk.simple.NodeImpl head = root.getNode(\"head\");\n    org.apache.jackrabbit.mk.simple.NodeImpl oldHead = head;\n    org.apache.jackrabbit.mk.simple.NodeImpl data = head.getNode(\"data\");\n    org.apache.jackrabbit.mk.json.JsopWriter diff = new org.apache.jackrabbit.mk.json.JsopStream();\n    while (true) {\n        int r = t.read();\n        if (r == org.apache.jackrabbit.mk.json.JsopTokenizer.END) {\n            break;\n        }\n        java.lang.String path = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, t.readString());\n        java.lang.String from = org.apache.jackrabbit.mk.util.PathUtils.relativize(\"/\", path);\n        switch (r) {\n            case '+' :\n                t.read(':');\n                diff.tag('+').key(path);\n                if (t.matches('{')) {\n                    org.apache.jackrabbit.mk.simple.NodeImpl n = org.apache.jackrabbit.mk.simple.NodeImpl.parse(nodeMap, t, rev);\n                    data = data.cloneAndAddChildNode(from, false, null, n, rev);\n                    n.append(diff, java.lang.Integer.MAX_VALUE, 0, java.lang.Integer.MAX_VALUE, false);\n                } else {\n                    java.lang.String value = t.readRawValue().trim();\n                    java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(from);\n                    java.lang.String propertyName = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                    if (data.getNode(nodeName).hasProperty(propertyName)) {\n                        throw org.apache.jackrabbit.mk.util.ExceptionFactory.get(\"Property already exists: \" + propertyName);\n                    }\n                    data = data.cloneAndSetProperty(from, value, rev);\n                    diff.encodedValue(value);\n                }\n                diff.newline();\n                break;\n            case '-' :\n                diff.tag('-').value(path).newline();\n                if (data.exists(from) || (!getRevisionDataRoot(revisionId).exists(from))) {\n                    data = data.cloneAndRemoveChildNode(from, rev);\n                }\n                break;\n            case '^' :\n                t.read(':');\n                boolean isConfigChange = from.startsWith(\":root/head/config/\");\n                java.lang.String value;\n                if (t.matches(JsopTokenizer.NULL)) {\n                    value = null;\n                    diff.tag('^').key(path).value(null);\n                } else {\n                    value = t.readRawValue().trim();\n                    java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(from);\n                    java.lang.String propertyName = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                    if (isConfigChange || data.getNode(nodeName).hasProperty(propertyName)) {\n                        diff.tag('^');\n                    } else {\n                        diff.tag('+');\n                    }\n                    diff.key(path).encodedValue(value);\n                }\n                if (isConfigChange) {\n                    java.lang.String p = org.apache.jackrabbit.mk.util.PathUtils.relativize(\":root/head\", from);\n                    if (!head.exists(\"config\")) {\n                        head = head.setChild(\"config\", new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev), rev);\n                    }\n                    head = head.cloneAndSetProperty(p, value, rev);\n                    applyConfig(head);\n                } else {\n                    data = data.cloneAndSetProperty(from, value, rev);\n                }\n                diff.newline();\n                break;\n            case '>' :\n                {\n                    t.read(':');\n                    diff.tag('>').key(path);\n                    java.lang.String name = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                    java.lang.String position;\n                    java.lang.String target;\n                    java.lang.String to;\n                    boolean rename;\n                    if (t.matches('{')) {\n                        rename = false;\n                        position = t.readString();\n                        t.read(':');\n                        target = t.readString();\n                        t.read('}');\n                        diff.object().key(position);\n                        if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(target)) {\n                            target = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, target);\n                        }\n                        diff.value(target).endObject();\n                    } else {\n                        rename = true;\n                        position = null;\n                        target = t.readString();\n                        if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(target)) {\n                            target = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, target);\n                        }\n                        diff.value(target);\n                    }\n                    diff.newline();\n                    boolean before = false;\n                    if (\"last\".equals(position)) {\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                        position = null;\n                    } else if (\"first\".equals(position)) {\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                        position = null;\n                        before = true;\n                    } else if (\"before\".equals(position)) {\n                        position = org.apache.jackrabbit.mk.util.PathUtils.getName(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                        before = true;\n                    } else if (\"after\".equals(position)) {\n                        position = org.apache.jackrabbit.mk.util.PathUtils.getName(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                    } else if (position == null) {\n                    } else {\n                        throw org.apache.jackrabbit.mk.util.ExceptionFactory.get(\"position: \" + position);\n                    }\n                    to = org.apache.jackrabbit.mk.util.PathUtils.relativize(\"/\", target);\n                    boolean inPlaceRename = false;\n                    if (rename) {\n                        if (org.apache.jackrabbit.mk.util.PathUtils.getParentPath(from).equals(org.apache.jackrabbit.mk.util.PathUtils.getParentPath(to))) {\n                            inPlaceRename = true;\n                            position = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                        }\n                    }\n                    org.apache.jackrabbit.mk.simple.NodeImpl node = data.getNode(from);\n                    if (!inPlaceRename) {\n                        data = data.cloneAndRemoveChildNode(from, rev);\n                    }\n                    data = data.cloneAndAddChildNode(to, before, position, node, rev);\n                    if (inPlaceRename) {\n                        data = data.cloneAndRemoveChildNode(from, rev);\n                    }\n                    break;\n                }\n            case '*' :\n                {\n                    t.read(':');\n                    java.lang.String target = t.readString();\n                    diff.tag('*').key(path).value(target);\n                    if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(target)) {\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, target);\n                    }\n                    org.apache.jackrabbit.mk.simple.NodeImpl node = data.getNode(from);\n                    java.lang.String to = org.apache.jackrabbit.mk.util.PathUtils.relativize(\"/\", target);\n                    data = data.cloneAndAddChildNode(to, false, null, node, rev);\n                    break;\n                }\n            default :\n                throw org.apache.jackrabbit.mk.util.ExceptionFactory.get(\"token: \" + ((char) (t.getTokenType())));\n        }\n    } \n    head = head.setChild(\"data\", data, rev);\n    org.apache.jackrabbit.mk.simple.Revision revNode = new org.apache.jackrabbit.mk.simple.Revision(rev, clock.nanoTime(), diff.toString(), message);\n    revisionCache.put(rev, revNode);\n    @org.apache.jackrabbit.mk.simple.param\n    org.apache.jackrabbit.mk.simple.rootPath the;\n    org.apache.jackrabbit.mk.simple.path head = revNode.store(head, new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev));\n    root = root.setChild(\"head\", head, rev);\n    java.lang.String old = org.apache.jackrabbit.mk.simple.Revision.formatId(oldRevision);\n    org.apache.jackrabbit.mk.simple.NodeImpl oldRev = new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev);\n    oldRev.addChildNode(\"head\", oldHead);\n    java.lang.String lastRev = org.apache.jackrabbit.mk.simple.Revision.formatId(oldRevision - 1);\n    if (root.exists(lastRev)) {\n        org.apache.jackrabbit.mk.simple.NodeImpl lastRevNode = root.getNode(lastRev);\n        root = root.cloneAndRemoveChildNode(lastRev, rev);\n        oldRev.setChild(lastRev, lastRevNode, rev);\n        java.lang.String target;\n        if ((oldRevision % org.apache.jackrabbit.mk.simple.SimpleKernelImpl.REV_SKIP_OFFSET) == 0) {\n            long skip = oldRevision - org.apache.jackrabbit.mk.simple.SimpleKernelImpl.REV_SKIP_OFFSET;\n            org.apache.jackrabbit.mk.simple.NodeImpl n = getRevisionNode(getRoot(), skip, skip);\n            if (n != null) {\n                oldRev.setChild(org.apache.jackrabbit.mk.simple.Revision.formatId(skip), n, rev);\n            }\n        }\n    }\n    root = root.setChild(old, oldRev, rev);\n    nodeMap.commit(root);\n    headRevId = rev;\n    headRevision = org.apache.jackrabbit.mk.simple.Revision.formatId(rev);\n    gate.commit(headRevision);\n    return headRevision;\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "org.apache.jackrabbit.mk.simple.path head = revNode.store(head, new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev))",
            "src_parent": "{\n    long oldRevision = headRevId;\n    long rev = headRevId + 1;\n    org.apache.jackrabbit.mk.simple.NodeImpl root = nodeMap.getRootId().getNode(nodeMap);\n    org.apache.jackrabbit.mk.simple.NodeImpl head = root.getNode(\"head\");\n    org.apache.jackrabbit.mk.simple.NodeImpl oldHead = head;\n    org.apache.jackrabbit.mk.simple.NodeImpl data = head.getNode(\"data\");\n    org.apache.jackrabbit.mk.json.JsopWriter diff = new org.apache.jackrabbit.mk.json.JsopStream();\n    while (true) {\n        int r = t.read();\n        if (r == org.apache.jackrabbit.mk.json.JsopTokenizer.END) {\n            break;\n        }\n        java.lang.String path = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, t.readString());\n        java.lang.String from = org.apache.jackrabbit.mk.util.PathUtils.relativize(\"/\", path);\n        switch (r) {\n            case '+' :\n                t.read(':');\n                diff.tag('+').key(path);\n                if (t.matches('{')) {\n                    org.apache.jackrabbit.mk.simple.NodeImpl n = org.apache.jackrabbit.mk.simple.NodeImpl.parse(nodeMap, t, rev);\n                    data = data.cloneAndAddChildNode(from, false, null, n, rev);\n                    n.append(diff, java.lang.Integer.MAX_VALUE, 0, java.lang.Integer.MAX_VALUE, false);\n                } else {\n                    java.lang.String value = t.readRawValue().trim();\n                    java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(from);\n                    java.lang.String propertyName = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                    if (data.getNode(nodeName).hasProperty(propertyName)) {\n                        throw org.apache.jackrabbit.mk.util.ExceptionFactory.get(\"Property already exists: \" + propertyName);\n                    }\n                    data = data.cloneAndSetProperty(from, value, rev);\n                    diff.encodedValue(value);\n                }\n                diff.newline();\n                break;\n            case '-' :\n                diff.tag('-').value(path).newline();\n                if (data.exists(from) || (!getRevisionDataRoot(revisionId).exists(from))) {\n                    data = data.cloneAndRemoveChildNode(from, rev);\n                }\n                break;\n            case '^' :\n                t.read(':');\n                boolean isConfigChange = from.startsWith(\":root/head/config/\");\n                java.lang.String value;\n                if (t.matches(JsopTokenizer.NULL)) {\n                    value = null;\n                    diff.tag('^').key(path).value(null);\n                } else {\n                    value = t.readRawValue().trim();\n                    java.lang.String nodeName = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(from);\n                    java.lang.String propertyName = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                    if (isConfigChange || data.getNode(nodeName).hasProperty(propertyName)) {\n                        diff.tag('^');\n                    } else {\n                        diff.tag('+');\n                    }\n                    diff.key(path).encodedValue(value);\n                }\n                if (isConfigChange) {\n                    java.lang.String p = org.apache.jackrabbit.mk.util.PathUtils.relativize(\":root/head\", from);\n                    if (!head.exists(\"config\")) {\n                        head = head.setChild(\"config\", new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev), rev);\n                    }\n                    head = head.cloneAndSetProperty(p, value, rev);\n                    applyConfig(head);\n                } else {\n                    data = data.cloneAndSetProperty(from, value, rev);\n                }\n                diff.newline();\n                break;\n            case '>' :\n                {\n                    t.read(':');\n                    diff.tag('>').key(path);\n                    java.lang.String name = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                    java.lang.String position;\n                    java.lang.String target;\n                    java.lang.String to;\n                    boolean rename;\n                    if (t.matches('{')) {\n                        rename = false;\n                        position = t.readString();\n                        t.read(':');\n                        target = t.readString();\n                        t.read('}');\n                        diff.object().key(position);\n                        if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(target)) {\n                            target = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, target);\n                        }\n                        diff.value(target).endObject();\n                    } else {\n                        rename = true;\n                        position = null;\n                        target = t.readString();\n                        if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(target)) {\n                            target = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, target);\n                        }\n                        diff.value(target);\n                    }\n                    diff.newline();\n                    boolean before = false;\n                    if (\"last\".equals(position)) {\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                        position = null;\n                    } else if (\"first\".equals(position)) {\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                        position = null;\n                        before = true;\n                    } else if (\"before\".equals(position)) {\n                        position = org.apache.jackrabbit.mk.util.PathUtils.getName(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                        before = true;\n                    } else if (\"after\".equals(position)) {\n                        position = org.apache.jackrabbit.mk.util.PathUtils.getName(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.getParentPath(target);\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(target, name);\n                    } else if (position == null) {\n                    } else {\n                        throw org.apache.jackrabbit.mk.util.ExceptionFactory.get(\"position: \" + position);\n                    }\n                    to = org.apache.jackrabbit.mk.util.PathUtils.relativize(\"/\", target);\n                    boolean inPlaceRename = false;\n                    if (rename) {\n                        if (org.apache.jackrabbit.mk.util.PathUtils.getParentPath(from).equals(org.apache.jackrabbit.mk.util.PathUtils.getParentPath(to))) {\n                            inPlaceRename = true;\n                            position = org.apache.jackrabbit.mk.util.PathUtils.getName(from);\n                        }\n                    }\n                    org.apache.jackrabbit.mk.simple.NodeImpl node = data.getNode(from);\n                    if (!inPlaceRename) {\n                        data = data.cloneAndRemoveChildNode(from, rev);\n                    }\n                    data = data.cloneAndAddChildNode(to, before, position, node, rev);\n                    if (inPlaceRename) {\n                        data = data.cloneAndRemoveChildNode(from, rev);\n                    }\n                    break;\n                }\n            case '*' :\n                {\n                    t.read(':');\n                    java.lang.String target = t.readString();\n                    diff.tag('*').key(path).value(target);\n                    if (!org.apache.jackrabbit.mk.util.PathUtils.isAbsolute(target)) {\n                        target = org.apache.jackrabbit.mk.util.PathUtils.concat(rootPath, target);\n                    }\n                    org.apache.jackrabbit.mk.simple.NodeImpl node = data.getNode(from);\n                    java.lang.String to = org.apache.jackrabbit.mk.util.PathUtils.relativize(\"/\", target);\n                    data = data.cloneAndAddChildNode(to, false, null, node, rev);\n                    break;\n                }\n            default :\n                throw org.apache.jackrabbit.mk.util.ExceptionFactory.get(\"token: \" + ((char) (t.getTokenType())));\n        }\n    } \n    head = head.setChild(\"data\", data, rev);\n    org.apache.jackrabbit.mk.simple.Revision revNode = new org.apache.jackrabbit.mk.simple.Revision(rev, clock.nanoTime(), diff.toString(), message);\n    revisionCache.put(rev, revNode);\n    @org.apache.jackrabbit.mk.simple.param\n    org.apache.jackrabbit.mk.simple.rootPath the;\n    org.apache.jackrabbit.mk.simple.path head = revNode.store(head, new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev));\n    root = root.setChild(\"head\", head, rev);\n    java.lang.String old = org.apache.jackrabbit.mk.simple.Revision.formatId(oldRevision);\n    org.apache.jackrabbit.mk.simple.NodeImpl oldRev = new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev);\n    oldRev.addChildNode(\"head\", oldHead);\n    java.lang.String lastRev = org.apache.jackrabbit.mk.simple.Revision.formatId(oldRevision - 1);\n    if (root.exists(lastRev)) {\n        org.apache.jackrabbit.mk.simple.NodeImpl lastRevNode = root.getNode(lastRev);\n        root = root.cloneAndRemoveChildNode(lastRev, rev);\n        oldRev.setChild(lastRev, lastRevNode, rev);\n        java.lang.String target;\n        if ((oldRevision % org.apache.jackrabbit.mk.simple.SimpleKernelImpl.REV_SKIP_OFFSET) == 0) {\n            long skip = oldRevision - org.apache.jackrabbit.mk.simple.SimpleKernelImpl.REV_SKIP_OFFSET;\n            org.apache.jackrabbit.mk.simple.NodeImpl n = getRevisionNode(getRoot(), skip, skip);\n            if (n != null) {\n                oldRev.setChild(org.apache.jackrabbit.mk.simple.Revision.formatId(skip), n, rev);\n            }\n        }\n    }\n    root = root.setChild(old, oldRev, rev);\n    nodeMap.commit(root);\n    headRevId = rev;\n    headRevision = org.apache.jackrabbit.mk.simple.Revision.formatId(rev);\n    gate.commit(headRevision);\n    return headRevision;\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "java.lang.String target",
            "src_parent": "{\n    org.apache.jackrabbit.mk.simple.NodeImpl lastRevNode = root.getNode(lastRev);\n    root = root.cloneAndRemoveChildNode(lastRev, rev);\n    oldRev.setChild(lastRev, lastRevNode, rev);\n    java.lang.String target;\n    if ((oldRevision % org.apache.jackrabbit.mk.simple.SimpleKernelImpl.REV_SKIP_OFFSET) == 0) {\n        long skip = oldRevision - org.apache.jackrabbit.mk.simple.SimpleKernelImpl.REV_SKIP_OFFSET;\n        org.apache.jackrabbit.mk.simple.NodeImpl n = getRevisionNode(getRoot(), skip, skip);\n        if (n != null) {\n            oldRev.setChild(org.apache.jackrabbit.mk.simple.Revision.formatId(skip), n, rev);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "revNode.store(head, new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev))",
            "dst_parent": "org.apache.jackrabbit.mk.simple.path head = revNode.store(head, new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev))",
            "dst_parent_type": "LocalVariable",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "revNode.store(head, new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev))",
            "src_parent": "head = revNode.store(head, new org.apache.jackrabbit.mk.simple.NodeImpl(nodeMap, rev))",
            "src_parent_type": "Assignment",
            "src_type": "Invocation"
          }
        }
      ],
      "file_name": "SimpleKernelImpl"
    }
  ],
  "id": "jackrabbit-oak_b62f1c26"
}