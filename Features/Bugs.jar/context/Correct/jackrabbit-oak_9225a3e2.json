{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "public int purgeUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false);\n    int purgeCount = 0;\n    for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n        if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n            if (r.getClusterId() == context.getClusterId()) {\n                purgeCount++;\n                op.removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, r);\n            }\n        }\n    }\n    if (op.hasChanges()) {\n        store.findAndUpdate(Collection.NODES, op);\n    }\n    return purgeCount;\n}",
            "dst_parent": "public final class NodeDocument extends org.apache.jackrabbit.oak.plugins.document.Document implements org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument {\n    public static final org.apache.jackrabbit.oak.plugins.document.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(new org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore());\n\n    static {\n        NULL.seal();\n    }\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.NodeDocument.class);\n\n    public static final java.lang.String MIN_ID_VALUE = \"0000000\";\n\n    public static final java.lang.String MAX_ID_VALUE = \";\";\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 8 * 1024;\n\n    static final int DOC_SIZE_THRESHOLD = 256 * 1024;\n\n    static final int NUM_REVS_THRESHOLD = 100;\n\n    static final float SPLIT_RATIO = 0.3F;\n\n    static final int PREV_SPLIT_FACTOR = 10;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    public static final java.lang.String MODIFIED_IN_SECS = \"_modified\";\n\n    static final int MODIFIED_IN_SECS_RESOLUTION = 5;\n\n    private static final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> EMPTY_RANGE_MAP = com.google.common.collect.Maps.unmodifiableNavigableMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>());\n\n    static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    public static final java.lang.String DELETED_ONCE = \"_deletedOnce\";\n\n    static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    private static final java.lang.String CHILDREN_FLAG = \"_children\";\n\n    public static final java.lang.String PATH = \"_path\";\n\n    public static final java.lang.String HAS_BINARY_FLAG = \"_bin\";\n\n    public static final java.lang.String SD_TYPE = \"_sdType\";\n\n    public static final java.lang.String SD_MAX_REV_TIME_IN_SECS = \"_sdMaxRevTime\";\n\n    public static long getModifiedInSecs(long timestamp) {\n        long timeInSec = java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(timestamp);\n        return timeInSec - (timeInSec % org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS_RESOLUTION);\n    }\n\n    public static enum SplitDocType {\n\n        NONE(-1),\n        DEFAULT(10),\n        @java.lang.Deprecated\n        DEFAULT_NO_CHILD(20),\n        @java.lang.Deprecated\n        PROP_COMMIT_ONLY(30),\n        INTERMEDIATE(40),\n        DEFAULT_LEAF(50),\n        COMMIT_ROOT_ONLY(60);\n        final int type;\n\n        private SplitDocType(int type) {\n            this.type = type;\n        }\n\n        public int typeCode() {\n            return type;\n        }\n\n        static org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType valueOf(java.lang.Integer type) {\n            if (type == null) {\n                return org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.NONE;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType docType : org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.values()) {\n                if (docType.type == type) {\n                    return docType;\n                }\n            }\n            throw new java.lang.IllegalArgumentException(\"Not a valid SplitDocType :\" + type);\n        }\n    }\n\n    static final java.util.Set<java.lang.String> IGNORE_ON_SPLIT = com.google.common.collect.ImmutableSet.of(org.apache.jackrabbit.oak.plugins.document.ID, org.apache.jackrabbit.oak.plugins.document.MOD_COUNT, org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PATH, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE, org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS);\n\n    public static final long HAS_BINARY_VAL = 1;\n\n    final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous;\n\n    private final java.util.concurrent.atomic.AtomicLong lastCheckTime = new java.util.concurrent.atomic.AtomicLong(java.lang.System.currentTimeMillis());\n\n    private final long creationTime;\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store) {\n        this(store, java.lang.System.currentTimeMillis());\n    }\n\n    public NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store, long creationTime) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n        this.creationTime = creationTime;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getValueMap(@javax.annotation.Nonnull\n    java.lang.String key) {\n        if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(key)) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, key);\n        }\n    }\n\n    @java.lang.Override\n    public long getCreated() {\n        return creationTime;\n    }\n\n    public boolean hasChildren() {\n        java.lang.Boolean childrenFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG)));\n        return (childrenFlag != null) && childrenFlag;\n    }\n\n    public boolean wasDeletedOnce() {\n        java.lang.Boolean deletedOnceFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE)));\n        return (deletedOnceFlag != null) && deletedOnceFlag;\n    }\n\n    public boolean hasBeenModifiedSince(long lastModifiedTime) {\n        java.lang.Long modified = ((java.lang.Long) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS)));\n        return (modified != null) && (modified > java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(lastModifiedTime));\n    }\n\n    public boolean hasAllRevisionLessThan(long maxRevisionTime) {\n        java.lang.Long maxRevTimeStamp = ((java.lang.Long) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_MAX_REV_TIME_IN_SECS)));\n        return (maxRevTimeStamp != null) && (maxRevTimeStamp < java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(maxRevisionTime));\n    }\n\n    public boolean isSplitDocument() {\n        return getSplitDocType() != org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.NONE;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType getSplitDocType() {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.valueOf(((java.lang.Integer) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_TYPE))));\n    }\n\n    @java.lang.Override\n    public void markUpToDate(long checkTime) {\n        lastCheckTime.set(checkTime);\n    }\n\n    @java.lang.Override\n    public boolean isUpToDate(long lastCheckTime) {\n        return lastCheckTime <= this.lastCheckTime.get();\n    }\n\n    @java.lang.Override\n    public long getLastCheckTime() {\n        return lastCheckTime.get();\n    }\n\n    public boolean hasBinary() {\n        java.lang.Number flag = ((java.lang.Number) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG)));\n        if (flag == null) {\n            return false;\n        }\n        return flag.intValue() == org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_VAL;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.String getMainPath() {\n        java.lang.String p = getPath();\n        if (p.startsWith(\"p\")) {\n            p = org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, 2);\n            if (p.length() == 1) {\n                return \"/\";\n            } else {\n                return p.substring(1);\n            }\n        } else {\n            return p;\n        }\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> map = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> e : valueMap.entrySet()) {\n            int clusterId = e.getKey().getClusterId();\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(e.getValue());\n            map.put(clusterId, rev);\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(revision);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : commitRootDoc.getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getLocalRevisions().containsKey(revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int purgeUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false);\n        int purgeCount = 0;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n                if (r.getClusterId() == context.getClusterId()) {\n                    purgeCount++;\n                    op.removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, r);\n                }\n            }\n        }\n        if (op.hasChanges()) {\n            store.findAndUpdate(Collection.NODES, op);\n        }\n        return purgeCount;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String depth = getCommitRootDepth(revision);\n        if (depth != null) {\n            return getPathAtDepth(depth);\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getNewestRevision(final org.apache.jackrabbit.oak.plugins.document.RevisionContext context, final org.apache.jackrabbit.oak.plugins.document.Revision changeRev, final org.apache.jackrabbit.oak.plugins.document.CollisionHandler handler) {\n        final java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions = com.google.common.collect.Maps.newHashMap();\n        com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.Revision> predicate = new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.Revision>() {\n            @java.lang.Override\n            public boolean apply(org.apache.jackrabbit.oak.plugins.document.Revision input) {\n                if (input.equals(changeRev)) {\n                    return false;\n                }\n                if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n                    return true;\n                }\n                handler.concurrentModification(input);\n                return false;\n            }\n        };\n        org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> revisions = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commitRoots = getLocalCommitRoot();\n        java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> it = com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.mergeSorted(com.google.common.collect.ImmutableList.of(revisions.keySet(), commitRoots.keySet()), revisions.comparator()), predicate).iterator();\n        if (it.hasNext()) {\n            newestRev = it.next();\n        } else {\n            it = com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.mergeSorted(com.google.common.collect.ImmutableList.of(getValueMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS).keySet(), getValueMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT).keySet()), revisions.comparator()), predicate).iterator();\n            if (it.hasNext()) {\n                newestRev = it.next();\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getLocalDeleted();\n        java.lang.String value = deleted.get(newestRev);\n        if ((value == null) && deleted.headMap(newestRev).isEmpty()) {\n            return newestRev;\n        }\n        if (value == null) {\n            value = getDeleted().get(newestRev);\n        }\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        if (validRevisions.containsKey(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, commitValue, readRevision)) {\n            validRevisions.put(rev, commitValue);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNodeAtRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision lastModified) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions = com.google.common.collect.Maps.newHashMap();\n        org.apache.jackrabbit.oak.plugins.document.Revision min = getLiveRevision(nodeStore, readRevision, validRevisions);\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = getPath();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = min;\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions);\n            if ((value != null) && (!getPreviousRanges().isEmpty())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision newest = getLocalMap(key).firstKey();\n                if (!value.revision.equals(newest)) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision newestPrev = getPreviousRanges().firstKey();\n                    if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n                        value = null;\n                    }\n                }\n            }\n            if ((value == null) && (!getPreviousRanges().isEmpty())) {\n                value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions);\n            }\n            java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.document.util.Utils.unescapePropertyName(key);\n            java.lang.String v = (value != null) ? value.value : null;\n            n.setProperty(propertyName, v);\n            if ((value != null) && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n                lastRevision = value.revision;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch branch = nodeStore.getBranches().getBranch(readRevision);\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        if (lastModified != null) {\n            lastRevs.put(nodeStore.getClusterId(), lastModified);\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision branchBase = null;\n        if (branch != null) {\n            branchBase = branch.getBase(readRevision);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : lastRevs.values()) {\n            if (isRevisionNewer(nodeStore, r, readRevision)) {\n                lastRevision = readRevision;\n                continue;\n            } else if ((branchBase != null) && isRevisionNewer(nodeStore, r, branchBase)) {\n                r = branchBase;\n            }\n            if (isRevisionNewer(nodeStore, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r.asBranchRevision();\n            }\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision maxRev, java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions);\n        if ((value == null) && (!getPreviousRanges().isEmpty())) {\n            value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions);\n        }\n        return (value != null) && \"false\".equals(value.value) ? value.revision : null;\n    }\n\n    boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision commitRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getLocalDeleted();\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : deleted.entrySet()) {\n            if (entry.getKey().equals(commitRevision)) {\n                continue;\n            }\n            if (isRevisionNewer(context, entry.getKey(), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> entry : op.getChanges().entrySet()) {\n            if (entry.getValue().type != Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            java.lang.String name = entry.getKey().getName();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.Revision rev : getValueMap(name).keySet()) {\n                if (rev.equals(commitRevision)) {\n                    continue;\n                }\n                if (isRevisionNewer(context, rev, baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        return org.apache.jackrabbit.oak.plugins.document.SplitOperations.forDocument(this, context);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.document.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>(StableRevisionComparator.REVERSE);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Range r = org.apache.jackrabbit.oak.plugins.document.Range.fromEntry(entry.getKey(), entry.getValue());\n                    transformed.put(r.high, r);\n                }\n                previous = com.google.common.collect.Maps.unmodifiableNavigableMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocs(@javax.annotation.Nonnull\n    final java.lang.String property, @javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getPreviousRanges().isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        if (revision == null) {\n            return new org.apache.jackrabbit.oak.plugins.document.PropertyHistory(this, property);\n        } else {\n            final java.lang.String mainPath = getMainPath();\n            java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> entry = getPreviousRanges().floorEntry(revision);\n            if (entry != null) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                int h = entry.getValue().height;\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(mainPath, r, h);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDocument(prevId);\n                if (prev != null) {\n                    if (prev.getValueMap(property).containsKey(revision)) {\n                        return java.util.Collections.singleton(prev);\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n            }\n            return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(getPreviousRanges().headMap(revision).entrySet(), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> input) {\n                    if (input.getValue().includes(revision)) {\n                        return getPreviousDoc(input.getKey(), input.getValue());\n                    }\n                    return null;\n                }\n            }), new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public boolean apply(@javax.annotation.Nullable\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument input) {\n                    return (input != null) && input.getValueMap(property).containsKey(revision);\n                }\n            });\n        }\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument getPreviousDocument(java.lang.String prevId) {\n        return store.find(Collection.NODES, prevId, java.lang.Integer.MAX_VALUE);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getAllPreviousDocs() {\n        if (getPreviousRanges().isEmpty()) {\n            return com.google.common.collect.Iterators.emptyIterator();\n        }\n        return new com.google.common.collect.AbstractIterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            private java.util.Queue<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>> previousRanges = com.google.common.collect.Queues.newArrayDeque(getPreviousRanges().entrySet());\n\n            @java.lang.Override\n            protected org.apache.jackrabbit.oak.plugins.document.NodeDocument computeNext() {\n                if (!previousRanges.isEmpty()) {\n                    java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> e = previousRanges.remove();\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDoc(e.getKey(), e.getValue());\n                    if (prev != null) {\n                        previousRanges.addAll(prev.getPreviousRanges().entrySet());\n                        return prev;\n                    }\n                }\n                return endOfData();\n            }\n        };\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getPreviousDoc(org.apache.jackrabbit.oak.plugins.document.Revision rev, org.apache.jackrabbit.oak.plugins.document.Range range) {\n        int h = range.height;\n        java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getMainPath(), rev, h);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDocument(prevId);\n        if (prev != null) {\n            return prev;\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n        }\n        return null;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>) (data.get(key)));\n        if (map == null) {\n            map = ValueMap.EMPTY;\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    public static void setChildrenFlag(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, boolean hasChildNode) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, hasChildNode);\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).max(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.getModifiedInSecs(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static boolean isRevisionsEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS.equals(name);\n    }\n\n    public static boolean isCommitRootEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT.equals(name);\n    }\n\n    public static void removeRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void addCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(true));\n    }\n\n    public static void removeCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, revision.getClusterId()), revision.toString());\n    }\n\n    public static boolean hasLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        return com.google.common.base.Preconditions.checkNotNull(op).getChanges().containsKey(new org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId)));\n    }\n\n    public static void unsetLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId));\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void removeCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision);\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, boolean deleted) {\n        if (deleted) {\n            com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE, java.lang.Boolean.TRUE);\n        }\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(deleted));\n    }\n\n    public static void removeDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, revision);\n    }\n\n    public static void setPrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Range range) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(range).high, range.getLowValue());\n    }\n\n    public static void removePrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Range range) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(range).high);\n    }\n\n    public static void setHasBinary(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_VAL);\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (getLocalRevisions().containsKey(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath;\n        java.lang.String depth = getLocalCommitRoot().get(rev);\n        if (depth != null) {\n            commitRootPath = getPathAtDepth(depth);\n        } else {\n            if (containsRevision(rev)) {\n                return this;\n            }\n            commitRootPath = getCommitRootPath(rev);\n            if (commitRootPath == null) {\n                return null;\n            }\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    @javax.annotation.Nonnull\n    private java.lang.String getPathAtDepth(@javax.annotation.Nonnull\n    java.lang.String depth) {\n        if (com.google.common.base.Preconditions.checkNotNull(depth).equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = getPath();\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitRootDepth(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n        java.lang.String depth = local.get(revision);\n        if (depth == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n                depth = prev.getCommitRootDepth(revision);\n                if (depth != null) {\n                    break;\n                }\n            }\n        }\n        return depth;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        if (commitValue == null) {\n            commitValue = getCommitValue(revision);\n        }\n        if (commitValue == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue);\n                return !isRevisionNewer(context, revision, readRevision);\n            } else if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String value = getLocalRevisions().get(revision);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n                value = prev.getCommitValue(revision);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision x, org.apache.jackrabbit.oak.plugins.document.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision propRev = entry.getKey();\n            if (isRevisionNewer(context, propRev, readRevision)) {\n                continue;\n            }\n            java.lang.String commitValue = validRevisions.get(propRev);\n            if (commitValue == null) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(propRev);\n                if (commitRoot == null) {\n                    continue;\n                }\n                commitValue = commitRoot.getCommitValue(propRev);\n                if (commitValue == null) {\n                    continue;\n                }\n            }\n            if ((min != null) && isRevisionNewer(context, min, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue))) {\n                continue;\n            }\n            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                return new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue), entry.getValue());\n            }\n        }\n        return null;\n    }\n\n    @java.lang.Override\n    public java.lang.String getPath() {\n        java.lang.String p = ((java.lang.String) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PATH)));\n        if (p != null) {\n            return p;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    static final class Children implements java.lang.Cloneable , org.apache.jackrabbit.oak.cache.CacheValue {\n        java.util.ArrayList<java.lang.String> childNames = new java.util.ArrayList<java.lang.String>();\n\n        boolean isComplete;\n\n        @java.lang.Override\n        public int getMemory() {\n            int size = 114;\n            for (java.lang.String name : childNames) {\n                size += (name.length() * 2) + 56;\n            }\n            return size;\n        }\n\n        @java.lang.SuppressWarnings(\"unchecked\")\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone() {\n            try {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children) (super.clone()));\n                clone.childNames = ((java.util.ArrayList<java.lang.String>) (childNames.clone()));\n                return clone;\n            } catch (java.lang.CloneNotSupportedException e) {\n                throw new java.lang.RuntimeException();\n            }\n        }\n    }\n\n    private static final class Value {\n        final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n        final java.lang.String value;\n\n        Value(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n        java.lang.String value) {\n            this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n            this.value = value;\n        }\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n    for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n        if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n            if (r.getClusterId() == context.getClusterId()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                revisions.put(r, b);\n            }\n        }\n    }\n    return revisions;\n}",
            "src_parent": "public final class NodeDocument extends org.apache.jackrabbit.oak.plugins.document.Document implements org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument {\n    public static final org.apache.jackrabbit.oak.plugins.document.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(new org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore());\n\n    static {\n        NULL.seal();\n    }\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.NodeDocument.class);\n\n    public static final java.lang.String MIN_ID_VALUE = \"0000000\";\n\n    public static final java.lang.String MAX_ID_VALUE = \";\";\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 8 * 1024;\n\n    static final int DOC_SIZE_THRESHOLD = 256 * 1024;\n\n    static final int NUM_REVS_THRESHOLD = 100;\n\n    static final float SPLIT_RATIO = 0.3F;\n\n    static final int PREV_SPLIT_FACTOR = 10;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    public static final java.lang.String MODIFIED_IN_SECS = \"_modified\";\n\n    static final int MODIFIED_IN_SECS_RESOLUTION = 5;\n\n    private static final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> EMPTY_RANGE_MAP = com.google.common.collect.Maps.unmodifiableNavigableMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>());\n\n    static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    public static final java.lang.String DELETED_ONCE = \"_deletedOnce\";\n\n    static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    private static final java.lang.String CHILDREN_FLAG = \"_children\";\n\n    public static final java.lang.String PATH = \"_path\";\n\n    public static final java.lang.String HAS_BINARY_FLAG = \"_bin\";\n\n    public static final java.lang.String SD_TYPE = \"_sdType\";\n\n    public static final java.lang.String SD_MAX_REV_TIME_IN_SECS = \"_sdMaxRevTime\";\n\n    public static long getModifiedInSecs(long timestamp) {\n        long timeInSec = java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(timestamp);\n        return timeInSec - (timeInSec % org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS_RESOLUTION);\n    }\n\n    public static enum SplitDocType {\n\n        NONE(-1),\n        DEFAULT(10),\n        @java.lang.Deprecated\n        DEFAULT_NO_CHILD(20),\n        @java.lang.Deprecated\n        PROP_COMMIT_ONLY(30),\n        INTERMEDIATE(40),\n        DEFAULT_LEAF(50),\n        COMMIT_ROOT_ONLY(60);\n        final int type;\n\n        private SplitDocType(int type) {\n            this.type = type;\n        }\n\n        public int typeCode() {\n            return type;\n        }\n\n        static org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType valueOf(java.lang.Integer type) {\n            if (type == null) {\n                return org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.NONE;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType docType : org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.values()) {\n                if (docType.type == type) {\n                    return docType;\n                }\n            }\n            throw new java.lang.IllegalArgumentException(\"Not a valid SplitDocType :\" + type);\n        }\n    }\n\n    static final java.util.Set<java.lang.String> IGNORE_ON_SPLIT = com.google.common.collect.ImmutableSet.of(org.apache.jackrabbit.oak.plugins.document.ID, org.apache.jackrabbit.oak.plugins.document.MOD_COUNT, org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PATH, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE, org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS);\n\n    public static final long HAS_BINARY_VAL = 1;\n\n    final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous;\n\n    private final java.util.concurrent.atomic.AtomicLong lastCheckTime = new java.util.concurrent.atomic.AtomicLong(java.lang.System.currentTimeMillis());\n\n    private final long creationTime;\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store) {\n        this(store, java.lang.System.currentTimeMillis());\n    }\n\n    public NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store, long creationTime) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n        this.creationTime = creationTime;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getValueMap(@javax.annotation.Nonnull\n    java.lang.String key) {\n        if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(key)) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, key);\n        }\n    }\n\n    @java.lang.Override\n    public long getCreated() {\n        return creationTime;\n    }\n\n    public boolean hasChildren() {\n        java.lang.Boolean childrenFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG)));\n        return (childrenFlag != null) && childrenFlag;\n    }\n\n    public boolean wasDeletedOnce() {\n        java.lang.Boolean deletedOnceFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE)));\n        return (deletedOnceFlag != null) && deletedOnceFlag;\n    }\n\n    public boolean hasBeenModifiedSince(long lastModifiedTime) {\n        java.lang.Long modified = ((java.lang.Long) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS)));\n        return (modified != null) && (modified > java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(lastModifiedTime));\n    }\n\n    public boolean hasAllRevisionLessThan(long maxRevisionTime) {\n        java.lang.Long maxRevTimeStamp = ((java.lang.Long) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_MAX_REV_TIME_IN_SECS)));\n        return (maxRevTimeStamp != null) && (maxRevTimeStamp < java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(maxRevisionTime));\n    }\n\n    public boolean isSplitDocument() {\n        return getSplitDocType() != org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.NONE;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType getSplitDocType() {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.valueOf(((java.lang.Integer) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_TYPE))));\n    }\n\n    @java.lang.Override\n    public void markUpToDate(long checkTime) {\n        lastCheckTime.set(checkTime);\n    }\n\n    @java.lang.Override\n    public boolean isUpToDate(long lastCheckTime) {\n        return lastCheckTime <= this.lastCheckTime.get();\n    }\n\n    @java.lang.Override\n    public long getLastCheckTime() {\n        return lastCheckTime.get();\n    }\n\n    public boolean hasBinary() {\n        java.lang.Number flag = ((java.lang.Number) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG)));\n        if (flag == null) {\n            return false;\n        }\n        return flag.intValue() == org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_VAL;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.String getMainPath() {\n        java.lang.String p = getPath();\n        if (p.startsWith(\"p\")) {\n            p = org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, 2);\n            if (p.length() == 1) {\n                return \"/\";\n            } else {\n                return p.substring(1);\n            }\n        } else {\n            return p;\n        }\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> map = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> e : valueMap.entrySet()) {\n            int clusterId = e.getKey().getClusterId();\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(e.getValue());\n            map.put(clusterId, rev);\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(revision);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : commitRootDoc.getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getLocalRevisions().containsKey(revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String depth = getCommitRootDepth(revision);\n        if (depth != null) {\n            return getPathAtDepth(depth);\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getNewestRevision(final org.apache.jackrabbit.oak.plugins.document.RevisionContext context, final org.apache.jackrabbit.oak.plugins.document.Revision changeRev, final org.apache.jackrabbit.oak.plugins.document.CollisionHandler handler) {\n        final java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions = com.google.common.collect.Maps.newHashMap();\n        com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.Revision> predicate = new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.Revision>() {\n            @java.lang.Override\n            public boolean apply(org.apache.jackrabbit.oak.plugins.document.Revision input) {\n                if (input.equals(changeRev)) {\n                    return false;\n                }\n                if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n                    return true;\n                }\n                handler.concurrentModification(input);\n                return false;\n            }\n        };\n        org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> revisions = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commitRoots = getLocalCommitRoot();\n        java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> it = com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.mergeSorted(com.google.common.collect.ImmutableList.of(revisions.keySet(), commitRoots.keySet()), revisions.comparator()), predicate).iterator();\n        if (it.hasNext()) {\n            newestRev = it.next();\n        } else {\n            it = com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.mergeSorted(com.google.common.collect.ImmutableList.of(getValueMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS).keySet(), getValueMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT).keySet()), revisions.comparator()), predicate).iterator();\n            if (it.hasNext()) {\n                newestRev = it.next();\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getLocalDeleted();\n        java.lang.String value = deleted.get(newestRev);\n        if ((value == null) && deleted.headMap(newestRev).isEmpty()) {\n            return newestRev;\n        }\n        if (value == null) {\n            value = getDeleted().get(newestRev);\n        }\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        if (validRevisions.containsKey(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, commitValue, readRevision)) {\n            validRevisions.put(rev, commitValue);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNodeAtRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision lastModified) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions = com.google.common.collect.Maps.newHashMap();\n        org.apache.jackrabbit.oak.plugins.document.Revision min = getLiveRevision(nodeStore, readRevision, validRevisions);\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = getPath();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = min;\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions);\n            if ((value != null) && (!getPreviousRanges().isEmpty())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision newest = getLocalMap(key).firstKey();\n                if (!value.revision.equals(newest)) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision newestPrev = getPreviousRanges().firstKey();\n                    if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n                        value = null;\n                    }\n                }\n            }\n            if ((value == null) && (!getPreviousRanges().isEmpty())) {\n                value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions);\n            }\n            java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.document.util.Utils.unescapePropertyName(key);\n            java.lang.String v = (value != null) ? value.value : null;\n            n.setProperty(propertyName, v);\n            if ((value != null) && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n                lastRevision = value.revision;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch branch = nodeStore.getBranches().getBranch(readRevision);\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        if (lastModified != null) {\n            lastRevs.put(nodeStore.getClusterId(), lastModified);\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision branchBase = null;\n        if (branch != null) {\n            branchBase = branch.getBase(readRevision);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : lastRevs.values()) {\n            if (isRevisionNewer(nodeStore, r, readRevision)) {\n                lastRevision = readRevision;\n                continue;\n            } else if ((branchBase != null) && isRevisionNewer(nodeStore, r, branchBase)) {\n                r = branchBase;\n            }\n            if (isRevisionNewer(nodeStore, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r.asBranchRevision();\n            }\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision maxRev, java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions);\n        if ((value == null) && (!getPreviousRanges().isEmpty())) {\n            value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions);\n        }\n        return (value != null) && \"false\".equals(value.value) ? value.revision : null;\n    }\n\n    boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision commitRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getLocalDeleted();\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : deleted.entrySet()) {\n            if (entry.getKey().equals(commitRevision)) {\n                continue;\n            }\n            if (isRevisionNewer(context, entry.getKey(), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> entry : op.getChanges().entrySet()) {\n            if (entry.getValue().type != Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            java.lang.String name = entry.getKey().getName();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.Revision rev : getValueMap(name).keySet()) {\n                if (rev.equals(commitRevision)) {\n                    continue;\n                }\n                if (isRevisionNewer(context, rev, baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        return org.apache.jackrabbit.oak.plugins.document.SplitOperations.forDocument(this, context);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.document.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>(StableRevisionComparator.REVERSE);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Range r = org.apache.jackrabbit.oak.plugins.document.Range.fromEntry(entry.getKey(), entry.getValue());\n                    transformed.put(r.high, r);\n                }\n                previous = com.google.common.collect.Maps.unmodifiableNavigableMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocs(@javax.annotation.Nonnull\n    final java.lang.String property, @javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getPreviousRanges().isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        if (revision == null) {\n            return new org.apache.jackrabbit.oak.plugins.document.PropertyHistory(this, property);\n        } else {\n            final java.lang.String mainPath = getMainPath();\n            java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> entry = getPreviousRanges().floorEntry(revision);\n            if (entry != null) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                int h = entry.getValue().height;\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(mainPath, r, h);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDocument(prevId);\n                if (prev != null) {\n                    if (prev.getValueMap(property).containsKey(revision)) {\n                        return java.util.Collections.singleton(prev);\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n            }\n            return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(getPreviousRanges().headMap(revision).entrySet(), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> input) {\n                    if (input.getValue().includes(revision)) {\n                        return getPreviousDoc(input.getKey(), input.getValue());\n                    }\n                    return null;\n                }\n            }), new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public boolean apply(@javax.annotation.Nullable\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument input) {\n                    return (input != null) && input.getValueMap(property).containsKey(revision);\n                }\n            });\n        }\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument getPreviousDocument(java.lang.String prevId) {\n        return store.find(Collection.NODES, prevId, java.lang.Integer.MAX_VALUE);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getAllPreviousDocs() {\n        if (getPreviousRanges().isEmpty()) {\n            return com.google.common.collect.Iterators.emptyIterator();\n        }\n        return new com.google.common.collect.AbstractIterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            private java.util.Queue<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>> previousRanges = com.google.common.collect.Queues.newArrayDeque(getPreviousRanges().entrySet());\n\n            @java.lang.Override\n            protected org.apache.jackrabbit.oak.plugins.document.NodeDocument computeNext() {\n                if (!previousRanges.isEmpty()) {\n                    java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> e = previousRanges.remove();\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDoc(e.getKey(), e.getValue());\n                    if (prev != null) {\n                        previousRanges.addAll(prev.getPreviousRanges().entrySet());\n                        return prev;\n                    }\n                }\n                return endOfData();\n            }\n        };\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getPreviousDoc(org.apache.jackrabbit.oak.plugins.document.Revision rev, org.apache.jackrabbit.oak.plugins.document.Range range) {\n        int h = range.height;\n        java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getMainPath(), rev, h);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDocument(prevId);\n        if (prev != null) {\n            return prev;\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n        }\n        return null;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>) (data.get(key)));\n        if (map == null) {\n            map = ValueMap.EMPTY;\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    public static void setChildrenFlag(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, boolean hasChildNode) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, hasChildNode);\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).max(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.getModifiedInSecs(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static boolean isRevisionsEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS.equals(name);\n    }\n\n    public static boolean isCommitRootEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT.equals(name);\n    }\n\n    public static void removeRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void addCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(true));\n    }\n\n    public static void removeCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, revision.getClusterId()), revision.toString());\n    }\n\n    public static boolean hasLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        return com.google.common.base.Preconditions.checkNotNull(op).getChanges().containsKey(new org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId)));\n    }\n\n    public static void unsetLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId));\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void removeCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision);\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, boolean deleted) {\n        if (deleted) {\n            com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE, java.lang.Boolean.TRUE);\n        }\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(deleted));\n    }\n\n    public static void removeDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, revision);\n    }\n\n    public static void setPrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Range range) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(range).high, range.getLowValue());\n    }\n\n    public static void removePrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Range range) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(range).high);\n    }\n\n    public static void setHasBinary(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_VAL);\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (getLocalRevisions().containsKey(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath;\n        java.lang.String depth = getLocalCommitRoot().get(rev);\n        if (depth != null) {\n            commitRootPath = getPathAtDepth(depth);\n        } else {\n            if (containsRevision(rev)) {\n                return this;\n            }\n            commitRootPath = getCommitRootPath(rev);\n            if (commitRootPath == null) {\n                return null;\n            }\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    @javax.annotation.Nonnull\n    private java.lang.String getPathAtDepth(@javax.annotation.Nonnull\n    java.lang.String depth) {\n        if (com.google.common.base.Preconditions.checkNotNull(depth).equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = getPath();\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitRootDepth(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n        java.lang.String depth = local.get(revision);\n        if (depth == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n                depth = prev.getCommitRootDepth(revision);\n                if (depth != null) {\n                    break;\n                }\n            }\n        }\n        return depth;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        if (commitValue == null) {\n            commitValue = getCommitValue(revision);\n        }\n        if (commitValue == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue);\n                return !isRevisionNewer(context, revision, readRevision);\n            } else if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String value = getLocalRevisions().get(revision);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n                value = prev.getCommitValue(revision);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision x, org.apache.jackrabbit.oak.plugins.document.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision propRev = entry.getKey();\n            if (isRevisionNewer(context, propRev, readRevision)) {\n                continue;\n            }\n            java.lang.String commitValue = validRevisions.get(propRev);\n            if (commitValue == null) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(propRev);\n                if (commitRoot == null) {\n                    continue;\n                }\n                commitValue = commitRoot.getCommitValue(propRev);\n                if (commitValue == null) {\n                    continue;\n                }\n            }\n            if ((min != null) && isRevisionNewer(context, min, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue))) {\n                continue;\n            }\n            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                return new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue), entry.getValue());\n            }\n        }\n        return null;\n    }\n\n    @java.lang.Override\n    public java.lang.String getPath() {\n        java.lang.String p = ((java.lang.String) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PATH)));\n        if (p != null) {\n            return p;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    static final class Children implements java.lang.Cloneable , org.apache.jackrabbit.oak.cache.CacheValue {\n        java.util.ArrayList<java.lang.String> childNames = new java.util.ArrayList<java.lang.String>();\n\n        boolean isComplete;\n\n        @java.lang.Override\n        public int getMemory() {\n            int size = 114;\n            for (java.lang.String name : childNames) {\n                size += (name.length() * 2) + 56;\n            }\n            return size;\n        }\n\n        @java.lang.SuppressWarnings(\"unchecked\")\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone() {\n            try {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children) (super.clone()));\n                clone.childNames = ((java.util.ArrayList<java.lang.String>) (childNames.clone()));\n                return clone;\n            } catch (java.lang.CloneNotSupportedException e) {\n                throw new java.lang.RuntimeException();\n            }\n        }\n    }\n\n    private static final class Value {\n        final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n        final java.lang.String value;\n\n        Value(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n        java.lang.String value) {\n            this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n            this.value = value;\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "TypeReference",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "int",
            "dst_parent": "public int purgeUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false);\n    int purgeCount = 0;\n    for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n        if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n            if (r.getClusterId() == context.getClusterId()) {\n                purgeCount++;\n                op.removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, r);\n            }\n        }\n    }\n    if (op.hasChanges()) {\n        store.findAndUpdate(Collection.NODES, op);\n    }\n    return purgeCount;\n}",
            "dst_parent_type": "Method",
            "dst_type": "TypeReference",
            "operator": "UPD",
            "src": "java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>",
            "src_parent": "public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n    for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n        if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n            if (r.getClusterId() == context.getClusterId()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                revisions.put(r, b);\n            }\n        }\n    }\n    return revisions;\n}",
            "src_parent_type": "Method",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false)",
            "dst_parent": "{\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false);\n    int purgeCount = 0;\n    for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n        if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n            if (r.getClusterId() == context.getClusterId()) {\n                purgeCount++;\n                op.removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, r);\n            }\n        }\n    }\n    if (op.hasChanges()) {\n        store.findAndUpdate(Collection.NODES, op);\n    }\n    return purgeCount;\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "UPD",
            "src": "java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator())",
            "src_parent": "{\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n    for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n        if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n            if (r.getClusterId() == context.getClusterId()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                revisions.put(r, b);\n            }\n        }\n    }\n    return revisions;\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.document.UpdateOp",
            "dst_parent": "org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false)",
            "dst_parent_type": "LocalVariable",
            "dst_type": "TypeReference",
            "operator": "UPD",
            "src": "java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>",
            "src_parent": "java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator())",
            "src_parent_type": "LocalVariable",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false)",
            "dst_parent": "org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false)",
            "dst_parent_type": "LocalVariable",
            "dst_type": "ConstructorCall",
            "operator": "UPD",
            "src": "new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator())",
            "src_parent": "java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator())",
            "src_parent_type": "LocalVariable",
            "src_type": "ConstructorCall"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "purgeCount",
            "dst_parent": "return purgeCount",
            "dst_parent_type": "Return",
            "dst_type": "VariableRead",
            "operator": "UPD",
            "src": "revisions",
            "src_parent": "return revisions",
            "src_parent_type": "Return",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "getId()",
            "dst_parent": "new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false)",
            "dst_parent_type": "ConstructorCall",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "context.getRevisionComparator()",
            "src_parent": "new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator())",
            "src_parent_type": "ConstructorCall",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "op.removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, r)",
            "dst_parent": "{\n    purgeCount++;\n    op.removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, r);\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "revisions.put(r, b)",
            "src_parent": "{\n    org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n    revisions.put(r, b);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "op",
            "dst_parent": "op.removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, r)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "UPD",
            "src": "revisions",
            "src_parent": "revisions.put(r, b)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue())",
            "src_parent": "{\n    org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n    revisions.put(r, b);\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "purgeCount++",
            "src_parent": "{\n    purgeCount++;\n    op.removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, r);\n}",
            "src_parent_type": "Block",
            "src_type": "UnaryOperator"
          }
        }
      ],
      "file_name": "NodeDocument"
    }
  ],
  "id": "jackrabbit-oak_9225a3e2"
}