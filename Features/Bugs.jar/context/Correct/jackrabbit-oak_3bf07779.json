{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private java.util.List<org.apache.jackrabbit.oak.api.PropertyState> propertiesModified = com.google.common.collect.Lists.newArrayList();",
            "src_parent": "public class LuceneIndexEditor implements org.apache.jackrabbit.oak.plugins.index.IndexEditor , org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.AggregateRoot {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.class);\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditorContext context;\n\n    private final java.lang.String name;\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor parent;\n\n    private java.lang.String path;\n\n    private boolean propertiesChanged = false;\n\n    private java.util.List<org.apache.jackrabbit.oak.api.PropertyState> propertiesModified = com.google.common.collect.Lists.newArrayList();\n\n    private final org.apache.jackrabbit.oak.spi.state.NodeState root;\n\n    private final boolean isDeleted;\n\n    private org.apache.jackrabbit.oak.api.Tree afterTree;\n\n    private org.apache.jackrabbit.oak.api.Tree beforeTree;\n\n    private IndexDefinition.IndexingRule indexingRule;\n\n    private java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> currentMatchers = java.util.Collections.emptyList();\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState matcherState;\n\n    private final PathFilter.Result pathFilterResult;\n\n    LuceneIndexEditor(org.apache.jackrabbit.oak.spi.state.NodeState root, org.apache.jackrabbit.oak.spi.state.NodeBuilder definition, org.apache.jackrabbit.oak.plugins.index.IndexUpdateCallback updateCallback, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier indexCopier) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        this.parent = null;\n        this.name = null;\n        this.path = \"/\";\n        this.context = new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditorContext(root, definition, updateCallback, indexCopier);\n        this.root = root;\n        this.isDeleted = false;\n        this.matcherState = org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState.NONE;\n        this.pathFilterResult = context.getDefinition().getPathFilter().doFiler(getPath());\n    }\n\n    private LuceneIndexEditor(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor parent, java.lang.String name, org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState matcherState, org.apache.jackrabbit.oak.plugins.index.PathFilter.Result pathFilterResult, boolean isDeleted) {\n        this.parent = parent;\n        this.name = name;\n        this.path = null;\n        this.context = parent.context;\n        this.root = parent.root;\n        this.isDeleted = isDeleted;\n        this.matcherState = matcherState;\n        this.pathFilterResult = pathFilterResult;\n    }\n\n    public java.lang.String getPath() {\n        if (path == null) {\n            path = concat(parent.getPath(), name);\n        }\n        return path;\n    }\n\n    @java.lang.Override\n    public void enter(org.apache.jackrabbit.oak.spi.state.NodeState before, org.apache.jackrabbit.oak.spi.state.NodeState after) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        if ((org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE == before) && (parent == null)) {\n            context.enableReindexMode();\n        }\n        if (parent == null) {\n            afterTree = org.apache.jackrabbit.oak.plugins.tree.TreeFactory.createReadOnlyTree(after);\n            beforeTree = org.apache.jackrabbit.oak.plugins.tree.TreeFactory.createReadOnlyTree(before);\n        } else {\n            afterTree = parent.afterTree.getChild(name);\n            beforeTree = parent.beforeTree.getChild(name);\n        }\n        if (pathFilterResult == PathFilter.Result.INCLUDE) {\n            org.apache.jackrabbit.oak.api.Tree current = (afterTree.exists()) ? afterTree : beforeTree;\n            indexingRule = getDefinition().getApplicableIndexingRule(current);\n            if (indexingRule != null) {\n                currentMatchers = indexingRule.getAggregate().createMatchers(this);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void leave(org.apache.jackrabbit.oak.spi.state.NodeState before, org.apache.jackrabbit.oak.spi.state.NodeState after) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        if (propertiesChanged || (!before.exists())) {\n            java.lang.String path = getPath();\n            if (addOrUpdate(path, after, before.exists())) {\n                long indexed = context.incIndexedNodes();\n                if ((indexed % 1000) == 0) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.debug(\"[{}] => Indexed {} nodes...\", getIndexName(), indexed);\n                }\n            }\n        }\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher m : matcherState.affectedMatchers) {\n            m.markRootDirty();\n        }\n        if (parent == null) {\n            try {\n                context.closeWriter();\n            } catch (java.io.IOException e) {\n                throw new org.apache.jackrabbit.oak.api.CommitFailedException(\"Lucene\", 4, \"Failed to close the Lucene index\", e);\n            }\n            if (context.getIndexedNodes() > 0) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.debug(\"[{}] => Indexed {} nodes, done.\", getIndexName(), context.getIndexedNodes());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void propertyAdded(org.apache.jackrabbit.oak.api.PropertyState after) {\n        markPropertyChanged(after.getName());\n        checkAggregates(after.getName());\n    }\n\n    @java.lang.Override\n    public void propertyChanged(org.apache.jackrabbit.oak.api.PropertyState before, org.apache.jackrabbit.oak.api.PropertyState after) {\n        markPropertyChanged(before.getName());\n        propertiesModified.add(before);\n        checkAggregates(before.getName());\n    }\n\n    @java.lang.Override\n    public void propertyDeleted(org.apache.jackrabbit.oak.api.PropertyState before) {\n        markPropertyChanged(before.getName());\n        propertiesModified.add(before);\n        checkAggregates(before.getName());\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.commit.Editor childNodeAdded(java.lang.String name, org.apache.jackrabbit.oak.spi.state.NodeState after) {\n        org.apache.jackrabbit.oak.plugins.index.PathFilter.Result filterResult = getPathFilterResult(name);\n        if (filterResult != PathFilter.Result.EXCLUDE) {\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor(this, name, getMatcherState(name, after), filterResult, false);\n        }\n        return null;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.commit.Editor childNodeChanged(java.lang.String name, org.apache.jackrabbit.oak.spi.state.NodeState before, org.apache.jackrabbit.oak.spi.state.NodeState after) {\n        org.apache.jackrabbit.oak.plugins.index.PathFilter.Result filterResult = getPathFilterResult(name);\n        if (filterResult != PathFilter.Result.EXCLUDE) {\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor(this, name, getMatcherState(name, after), filterResult, false);\n        }\n        return null;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.commit.Editor childNodeDeleted(java.lang.String name, org.apache.jackrabbit.oak.spi.state.NodeState before) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        org.apache.jackrabbit.oak.plugins.index.PathFilter.Result filterResult = getPathFilterResult(name);\n        if (filterResult == PathFilter.Result.EXCLUDE) {\n            return null;\n        }\n        if (!isDeleted) {\n            java.lang.String path = concat(getPath(), name);\n            try {\n                org.apache.lucene.index.IndexWriter writer = context.getWriter();\n                writer.deleteDocuments(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(path));\n                writer.deleteDocuments(new org.apache.lucene.search.PrefixQuery(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(path + \"/\")));\n                this.context.indexUpdate();\n            } catch (java.io.IOException e) {\n                throw new org.apache.jackrabbit.oak.api.CommitFailedException(\"Lucene\", 5, (\"Failed to remove the index entries of\" + \" the removed subtree \") + path, e);\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState ms = getMatcherState(name, before);\n        if (!ms.isEmpty()) {\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor(this, name, ms, filterResult, true);\n        }\n        return null;\n    }\n\n    private boolean addOrUpdate(java.lang.String path, org.apache.jackrabbit.oak.spi.state.NodeState state, boolean isUpdate) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        try {\n            org.apache.lucene.document.Document d = makeDocument(path, state, isUpdate);\n            if (d != null) {\n                if (org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.isTraceEnabled()) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.trace(\"[{}] Indexed document for {} is {}\", getIndexName(), path, d);\n                }\n                context.indexUpdate();\n                context.getWriter().updateDocument(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(path), d);\n                return true;\n            }\n        } catch (java.io.IOException e) {\n            throw new org.apache.jackrabbit.oak.api.CommitFailedException(\"Lucene\", 3, \"Failed to index the node \" + path, e);\n        } catch (java.lang.IllegalArgumentException ie) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.warn(\"Failed to index the node [{}]\", path, ie);\n        }\n        return false;\n    }\n\n    private org.apache.lucene.document.Document makeDocument(java.lang.String path, org.apache.jackrabbit.oak.spi.state.NodeState state, boolean isUpdate) {\n        if (!isIndexable()) {\n            return null;\n        }\n        java.util.List<org.apache.lucene.document.Field> fields = new java.util.ArrayList<org.apache.lucene.document.Field>();\n        boolean dirty = false;\n        for (org.apache.jackrabbit.oak.api.PropertyState property : state.getProperties()) {\n            java.lang.String pname = property.getName();\n            if (!org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.isVisible(pname)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = indexingRule.getConfig(pname);\n            if ((pd == null) || (!pd.index)) {\n                continue;\n            }\n            if (pd.ordered) {\n                dirty |= addTypedOrderedFields(fields, property, pname, pd);\n            }\n            dirty |= indexProperty(path, fields, state, property, pname, pd);\n        }\n        dirty |= indexAggregates(path, fields, state);\n        dirty |= indexNullCheckEnabledProps(path, fields, state);\n        dirty |= indexNotNullCheckEnabledProps(path, fields, state);\n        if (!dirty) {\n            dirty = indexIfSinglePropertyRemoved();\n        }\n        if (isUpdate && (!dirty)) {\n            return null;\n        }\n        if ((!indexingRule.isFulltextEnabled()) && (!dirty)) {\n            return null;\n        }\n        org.apache.lucene.document.Document document = new org.apache.lucene.document.Document();\n        document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newPathField(path));\n        java.lang.String name = getName(path);\n        if (indexingRule.isFulltextEnabled()) {\n            document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(name));\n        }\n        if (getDefinition().evaluatePathRestrictions()) {\n            document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newAncestorsField(org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(path)));\n            document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newDepthField(path));\n        }\n        org.apache.lucene.document.Field suggestField = null;\n        for (org.apache.lucene.document.Field f : fields) {\n            if (FieldNames.SUGGEST.endsWith(f.name())) {\n                if (suggestField == null) {\n                    suggestField = org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newSuggestField(f.stringValue());\n                } else {\n                    suggestField = org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newSuggestField(suggestField.stringValue(), f.stringValue());\n                }\n            } else {\n                document.add(f);\n            }\n        }\n        if (suggestField != null) {\n            document.add(suggestField);\n        }\n        return document;\n    }\n\n    private boolean indexProperty(java.lang.String path, java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.spi.state.NodeState state, org.apache.jackrabbit.oak.api.PropertyState property, java.lang.String pname, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        boolean includeTypeForFullText = indexingRule.includePropertyType(property.getType().tag());\n        if ((Type.BINARY.tag() == property.getType().tag()) && includeTypeForFullText) {\n            fields.addAll(newBinary(property, state, null, (path + \"@\") + pname));\n            return true;\n        } else {\n            boolean dirty = false;\n            if (pd.propertyIndex && pd.includePropertyType(property.getType().tag())) {\n                dirty |= addTypedFields(fields, property, pname);\n            }\n            if (pd.fulltextEnabled() && includeTypeForFullText) {\n                for (java.lang.String value : property.getValue(Type.STRINGS)) {\n                    if (pd.analyzed && pd.includePropertyType(property.getType().tag())) {\n                        java.lang.String analyzedPropName = constructAnalyzedPropertyName(pname);\n                        fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newPropertyField(analyzedPropName, value, !pd.skipTokenization(pname), pd.stored));\n                    }\n                    if (pd.useInSuggest) {\n                        fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newPropertyField(FieldNames.SUGGEST, value, true, true));\n                    }\n                    if (pd.useInSpellcheck) {\n                        fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newPropertyField(FieldNames.SPELLCHECK, value, true, false));\n                    }\n                    if (pd.nodeScopeIndex) {\n                        org.apache.lucene.document.Field field = org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(value);\n                        field.setBoost(pd.boost);\n                        fields.add(field);\n                    }\n                    dirty = true;\n                }\n            }\n            return dirty;\n        }\n    }\n\n    private java.lang.String constructAnalyzedPropertyName(java.lang.String pname) {\n        if (context.getDefinition().getVersion().isAtLeast(IndexFormatVersion.V2)) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.createAnalyzedFieldName(pname);\n        }\n        return pname;\n    }\n\n    private boolean addTypedFields(java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.api.PropertyState property, java.lang.String pname) {\n        int tag = property.getType().tag();\n        boolean fieldAdded = false;\n        for (int i = 0; i < property.count(); i++) {\n            org.apache.lucene.document.Field f;\n            if (tag == Type.LONG.tag()) {\n                f = new org.apache.lucene.document.LongField(pname, property.getValue(Type.LONG, i), Field.Store.NO);\n            } else if (tag == Type.DATE.tag()) {\n                java.lang.String date = property.getValue(Type.DATE, i);\n                f = new org.apache.lucene.document.LongField(pname, org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.dateToLong(date), Field.Store.NO);\n            } else if (tag == Type.DOUBLE.tag()) {\n                f = new org.apache.lucene.document.DoubleField(pname, property.getValue(Type.DOUBLE, i), Field.Store.NO);\n            } else if (tag == Type.BOOLEAN.tag()) {\n                f = new org.apache.lucene.document.StringField(pname, property.getValue(Type.BOOLEAN, i).toString(), Field.Store.NO);\n            } else {\n                f = new org.apache.lucene.document.StringField(pname, property.getValue(Type.STRING, i), Field.Store.NO);\n            }\n            fields.add(f);\n            fieldAdded = true;\n        }\n        return fieldAdded;\n    }\n\n    private boolean addTypedOrderedFields(java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.api.PropertyState property, java.lang.String pname, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        if (property.getType().isArray()) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.warn(\"[{}] Ignoring ordered property {} of type {} for path {} as multivalued ordered property not supported\", getIndexName(), pname, org.apache.jackrabbit.oak.api.Type.fromTag(property.getType().tag(), true), getPath());\n            return false;\n        }\n        int tag = property.getType().tag();\n        int idxDefinedTag = pd.getType();\n        if (tag != idxDefinedTag) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.debug(\"[{}] Ordered property defined with type {} differs from property {} with type {} in \" + \"path {}\", getIndexName(), org.apache.jackrabbit.oak.api.Type.fromTag(idxDefinedTag, false), property.toString(), org.apache.jackrabbit.oak.api.Type.fromTag(tag, false), getPath());\n            tag = idxDefinedTag;\n        }\n        java.lang.String name = org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.createDocValFieldName(pname);\n        boolean fieldAdded = false;\n        org.apache.lucene.document.Field f = null;\n        try {\n            if (tag == Type.LONG.tag()) {\n                f = new org.apache.lucene.document.NumericDocValuesField(name, property.getValue(Type.LONG));\n            } else if (tag == Type.DATE.tag()) {\n                java.lang.String date = property.getValue(Type.DATE);\n                f = new org.apache.lucene.document.NumericDocValuesField(name, org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.dateToLong(date));\n            } else if (tag == Type.DOUBLE.tag()) {\n                f = new org.apache.lucene.document.DoubleDocValuesField(name, property.getValue(Type.DOUBLE));\n            } else if (tag == Type.BOOLEAN.tag()) {\n                f = new org.apache.lucene.document.SortedDocValuesField(name, new org.apache.lucene.util.BytesRef(property.getValue(Type.BOOLEAN).toString()));\n            } else if (tag == Type.STRING.tag()) {\n                f = new org.apache.lucene.document.SortedDocValuesField(name, new org.apache.lucene.util.BytesRef(property.getValue(Type.STRING)));\n            }\n            if (f != null) {\n                fields.add(f);\n                fieldAdded = true;\n            }\n        } catch (java.lang.Exception e) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.warn(\"[{}] Ignoring ordered property. Could not convert property {} of type {} to type {} for path {}\", getIndexName(), pname, org.apache.jackrabbit.oak.api.Type.fromTag(property.getType().tag(), false), org.apache.jackrabbit.oak.api.Type.fromTag(tag, false), getPath(), e);\n        }\n        return fieldAdded;\n    }\n\n    private static boolean isVisible(java.lang.String name) {\n        return name.charAt(0) != ':';\n    }\n\n    private java.util.List<org.apache.lucene.document.Field> newBinary(org.apache.jackrabbit.oak.api.PropertyState property, org.apache.jackrabbit.oak.spi.state.NodeState state, java.lang.String nodePath, java.lang.String path) {\n        java.util.List<org.apache.lucene.document.Field> fields = new java.util.ArrayList<org.apache.lucene.document.Field>();\n        org.apache.tika.metadata.Metadata metadata = new org.apache.tika.metadata.Metadata();\n        java.lang.String type = state.getString(JcrConstants.JCR_MIMETYPE);\n        if ((type == null) || (!isSupportedMediaType(type))) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.trace(\"[{}] Ignoring binary content for node {} due to unsupported (or null) jcr:mimeType [{}]\", getIndexName(), path, type);\n            return fields;\n        }\n        metadata.set(Metadata.CONTENT_TYPE, type);\n        if (org.apache.jackrabbit.JcrConstants.JCR_DATA.equals(property.getName())) {\n            java.lang.String encoding = state.getString(JcrConstants.JCR_ENCODING);\n            if (encoding != null) {\n                metadata.set(Metadata.CONTENT_ENCODING, encoding);\n            }\n        }\n        for (org.apache.jackrabbit.oak.api.Blob v : property.getValue(Type.BINARIES)) {\n            if (nodePath != null) {\n                fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(nodePath, parseStringValue(v, metadata, path)));\n            } else {\n                fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(parseStringValue(v, metadata, path)));\n            }\n        }\n        return fields;\n    }\n\n    private boolean indexNotNullCheckEnabledProps(java.lang.String path, java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.spi.state.NodeState state) {\n        boolean fieldAdded = false;\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : indexingRule.getNotNullCheckEnabledProperties()) {\n            if (isPropertyNotNull(state, pd)) {\n                fields.add(new org.apache.lucene.document.StringField(FieldNames.NOT_NULL_PROPS, pd.name, Field.Store.NO));\n                fieldAdded = true;\n            }\n        }\n        return fieldAdded;\n    }\n\n    private boolean indexNullCheckEnabledProps(java.lang.String path, java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.spi.state.NodeState state) {\n        boolean fieldAdded = false;\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : indexingRule.getNullCheckEnabledProperties()) {\n            if (isPropertyNull(state, pd)) {\n                fields.add(new org.apache.lucene.document.StringField(FieldNames.NULL_PROPS, pd.name, Field.Store.NO));\n                fieldAdded = true;\n            }\n        }\n        return fieldAdded;\n    }\n\n    private boolean indexIfSinglePropertyRemoved() {\n        boolean dirty = false;\n        for (org.apache.jackrabbit.oak.api.PropertyState ps : propertiesModified) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = indexingRule.getConfig(ps.getName());\n            if (((pd != null) && pd.index) && (pd.includePropertyType(ps.getType().tag()) || indexingRule.includePropertyType(ps.getType().tag()))) {\n                dirty = true;\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    private boolean isPropertyNull(org.apache.jackrabbit.oak.spi.state.NodeState state, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        org.apache.jackrabbit.oak.spi.state.NodeState propertyNode = org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.getPropertyNode(state, pd);\n        if (!propertyNode.exists()) {\n            return false;\n        }\n        return !propertyNode.hasProperty(pd.nonRelativeName);\n    }\n\n    private boolean isPropertyNotNull(org.apache.jackrabbit.oak.spi.state.NodeState state, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        org.apache.jackrabbit.oak.spi.state.NodeState propertyNode = org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.getPropertyNode(state, pd);\n        if (!propertyNode.exists()) {\n            return false;\n        }\n        return propertyNode.hasProperty(pd.nonRelativeName);\n    }\n\n    private static org.apache.jackrabbit.oak.spi.state.NodeState getPropertyNode(org.apache.jackrabbit.oak.spi.state.NodeState nodeState, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        if (!pd.relative) {\n            return nodeState;\n        }\n        org.apache.jackrabbit.oak.spi.state.NodeState node = nodeState;\n        for (java.lang.String name : pd.ancestors) {\n            node = node.getChildNode(name);\n        }\n        return node;\n    }\n\n    @java.lang.Override\n    public void markDirty() {\n        propertiesChanged = true;\n    }\n\n    private org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState getMatcherState(java.lang.String name, org.apache.jackrabbit.oak.spi.state.NodeState after) {\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> matched = com.google.common.collect.Lists.newArrayList();\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> inherited = com.google.common.collect.Lists.newArrayList();\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher m : com.google.common.collect.Iterables.concat(matcherState.inherited, currentMatchers)) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher result = m.match(name, after);\n            if (result.getStatus() == Matcher.Status.MATCH_FOUND) {\n                matched.add(result);\n            }\n            if (result.getStatus() != Matcher.Status.FAIL) {\n                inherited.addAll(result.nextSet());\n            }\n        }\n        if ((!matched.isEmpty()) || (!inherited.isEmpty())) {\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState(matched, inherited);\n        }\n        return org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState.NONE;\n    }\n\n    private boolean indexAggregates(final java.lang.String path, final java.util.List<org.apache.lucene.document.Field> fields, final org.apache.jackrabbit.oak.spi.state.NodeState state) {\n        final java.util.concurrent.atomic.AtomicBoolean dirtyFlag = new java.util.concurrent.atomic.AtomicBoolean();\n        indexingRule.getAggregate().collectAggregates(state, new org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.ResultCollector() {\n            @java.lang.Override\n            public void onResult(org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.NodeIncludeResult result) {\n                boolean dirty = indexAggregatedNode(path, fields, result);\n                if (dirty) {\n                    dirtyFlag.set(true);\n                }\n            }\n\n            @java.lang.Override\n            public void onResult(org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.PropertyIncludeResult result) {\n                boolean dirty = false;\n                if (result.pd.ordered) {\n                    dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\n                }\n                dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, result.pd);\n                if (dirty) {\n                    dirtyFlag.set(true);\n                }\n            }\n        });\n        return dirtyFlag.get();\n    }\n\n    private boolean indexAggregatedNode(java.lang.String path, java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.NodeIncludeResult result) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule ruleAggNode = context.getDefinition().getApplicableIndexingRule(getPrimaryTypeName(result.nodeState));\n        boolean dirty = false;\n        for (org.apache.jackrabbit.oak.api.PropertyState property : result.nodeState.getProperties()) {\n            java.lang.String pname = property.getName();\n            if (!org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.isVisible(pname)) {\n                continue;\n            }\n            int type = property.getType().tag();\n            if (ruleAggNode != null) {\n                if (!ruleAggNode.includePropertyType(type)) {\n                    continue;\n                }\n            } else if (!indexingRule.includePropertyType(type)) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.api.Type.BINARY == property.getType()) {\n                java.lang.String aggreagtedNodePath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, result.nodePath);\n                java.lang.String nodePath = (result.isRelativeNode()) ? result.rootIncludePath : null;\n                fields.addAll(newBinary(property, result.nodeState, nodePath, (aggreagtedNodePath + \"@\") + pname));\n                dirty = true;\n            } else {\n                org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = null;\n                if (ruleAggNode != null) {\n                    pd = ruleAggNode.getConfig(pname);\n                }\n                if ((pd != null) && (!pd.nodeScopeIndex)) {\n                    continue;\n                }\n                for (java.lang.String value : property.getValue(Type.STRINGS)) {\n                    org.apache.lucene.document.Field field = (result.isRelativeNode()) ? org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(result.rootIncludePath, value) : org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(value);\n                    if (pd != null) {\n                        field.setBoost(pd.boost);\n                    }\n                    fields.add(field);\n                    dirty = true;\n                }\n            }\n        }\n        return dirty;\n    }\n\n    private void checkAggregates(java.lang.String name) {\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher m : matcherState.matched) {\n            if ((!matcherState.affectedMatchers.contains(m)) && m.aggregatesProperty(name)) {\n                matcherState.affectedMatchers.add(m);\n            }\n        }\n    }\n\n    private static class MatcherState {\n        static final org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState NONE = new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState(java.util.Collections.<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher>emptyList(), java.util.Collections.<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher>emptyList());\n\n        final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> matched;\n\n        final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> inherited;\n\n        final java.util.Set<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> affectedMatchers;\n\n        public MatcherState(java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> matched, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> inherited) {\n            this.matched = matched;\n            this.inherited = inherited;\n            if (matched.isEmpty()) {\n                affectedMatchers = java.util.Collections.emptySet();\n            } else {\n                affectedMatchers = com.google.common.collect.Sets.newIdentityHashSet();\n            }\n        }\n\n        public boolean isEmpty() {\n            return matched.isEmpty() && inherited.isEmpty();\n        }\n    }\n\n    private void markPropertyChanged(java.lang.String name) {\n        if ((isIndexable() && (!propertiesChanged)) && indexingRule.isIndexed(name)) {\n            propertiesChanged = true;\n        }\n    }\n\n    private org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition getDefinition() {\n        return context.getDefinition();\n    }\n\n    private boolean isIndexable() {\n        return indexingRule != null;\n    }\n\n    private PathFilter.Result getPathFilterResult(java.lang.String childNodeName) {\n        return context.getDefinition().getPathFilter().doFiler(concat(getPath(), childNodeName));\n    }\n\n    private boolean isSupportedMediaType(java.lang.String type) {\n        return context.isSupportedMediaType(type);\n    }\n\n    private java.lang.String parseStringValue(org.apache.jackrabbit.oak.api.Blob v, org.apache.tika.metadata.Metadata metadata, java.lang.String path) {\n        org.apache.tika.sax.WriteOutContentHandler handler = new org.apache.tika.sax.WriteOutContentHandler(context.getDefinition().getMaxExtractLength());\n        long start = java.lang.System.currentTimeMillis();\n        long size = 0;\n        try {\n            com.google.common.io.CountingInputStream stream = new com.google.common.io.CountingInputStream(new org.apache.jackrabbit.oak.commons.io.LazyInputStream(new org.apache.jackrabbit.oak.util.BlobByteSource(v)));\n            try {\n                context.getParser().parse(stream, handler, metadata, new org.apache.tika.parser.ParseContext());\n            } finally {\n                size = stream.getCount();\n                stream.close();\n            }\n        } catch (java.lang.LinkageError e) {\n        } catch (java.lang.Throwable t) {\n            if (!handler.isWriteLimitReached(t)) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.debug(\"[{}] Failed to extract text from a binary property: {}.\" + ((\" This is a fairly common case, and nothing to\" + \" worry about. The stack trace is included to\") + \" help improve the text extraction feature.\"), getIndexName(), path, t);\n                return \"TextExtractionError\";\n            }\n        }\n        java.lang.String result = handler.toString();\n        context.recordTextExtractionStats(java.lang.System.currentTimeMillis() - start, size);\n        return result;\n    }\n\n    private java.lang.String getIndexName() {\n        return context.getDefinition().getIndexName();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean indexIfSinglePropertyRemoved() {\n    boolean dirty = false;\n    for (org.apache.jackrabbit.oak.api.PropertyState ps : propertiesModified) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = indexingRule.getConfig(ps.getName());\n        if (((pd != null) && pd.index) && (pd.includePropertyType(ps.getType().tag()) || indexingRule.includePropertyType(ps.getType().tag()))) {\n            dirty = true;\n            break;\n        }\n    }\n    return dirty;\n}",
            "src_parent": "public class LuceneIndexEditor implements org.apache.jackrabbit.oak.plugins.index.IndexEditor , org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.AggregateRoot {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.class);\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditorContext context;\n\n    private final java.lang.String name;\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor parent;\n\n    private java.lang.String path;\n\n    private boolean propertiesChanged = false;\n\n    private java.util.List<org.apache.jackrabbit.oak.api.PropertyState> propertiesModified = com.google.common.collect.Lists.newArrayList();\n\n    private final org.apache.jackrabbit.oak.spi.state.NodeState root;\n\n    private final boolean isDeleted;\n\n    private org.apache.jackrabbit.oak.api.Tree afterTree;\n\n    private org.apache.jackrabbit.oak.api.Tree beforeTree;\n\n    private IndexDefinition.IndexingRule indexingRule;\n\n    private java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> currentMatchers = java.util.Collections.emptyList();\n\n    private final org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState matcherState;\n\n    private final PathFilter.Result pathFilterResult;\n\n    LuceneIndexEditor(org.apache.jackrabbit.oak.spi.state.NodeState root, org.apache.jackrabbit.oak.spi.state.NodeBuilder definition, org.apache.jackrabbit.oak.plugins.index.IndexUpdateCallback updateCallback, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier indexCopier) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        this.parent = null;\n        this.name = null;\n        this.path = \"/\";\n        this.context = new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditorContext(root, definition, updateCallback, indexCopier);\n        this.root = root;\n        this.isDeleted = false;\n        this.matcherState = org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState.NONE;\n        this.pathFilterResult = context.getDefinition().getPathFilter().doFiler(getPath());\n    }\n\n    private LuceneIndexEditor(org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor parent, java.lang.String name, org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState matcherState, org.apache.jackrabbit.oak.plugins.index.PathFilter.Result pathFilterResult, boolean isDeleted) {\n        this.parent = parent;\n        this.name = name;\n        this.path = null;\n        this.context = parent.context;\n        this.root = parent.root;\n        this.isDeleted = isDeleted;\n        this.matcherState = matcherState;\n        this.pathFilterResult = pathFilterResult;\n    }\n\n    public java.lang.String getPath() {\n        if (path == null) {\n            path = concat(parent.getPath(), name);\n        }\n        return path;\n    }\n\n    @java.lang.Override\n    public void enter(org.apache.jackrabbit.oak.spi.state.NodeState before, org.apache.jackrabbit.oak.spi.state.NodeState after) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        if ((org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.MISSING_NODE == before) && (parent == null)) {\n            context.enableReindexMode();\n        }\n        if (parent == null) {\n            afterTree = org.apache.jackrabbit.oak.plugins.tree.TreeFactory.createReadOnlyTree(after);\n            beforeTree = org.apache.jackrabbit.oak.plugins.tree.TreeFactory.createReadOnlyTree(before);\n        } else {\n            afterTree = parent.afterTree.getChild(name);\n            beforeTree = parent.beforeTree.getChild(name);\n        }\n        if (pathFilterResult == PathFilter.Result.INCLUDE) {\n            org.apache.jackrabbit.oak.api.Tree current = (afterTree.exists()) ? afterTree : beforeTree;\n            indexingRule = getDefinition().getApplicableIndexingRule(current);\n            if (indexingRule != null) {\n                currentMatchers = indexingRule.getAggregate().createMatchers(this);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void leave(org.apache.jackrabbit.oak.spi.state.NodeState before, org.apache.jackrabbit.oak.spi.state.NodeState after) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        if (propertiesChanged || (!before.exists())) {\n            java.lang.String path = getPath();\n            if (addOrUpdate(path, after, before.exists())) {\n                long indexed = context.incIndexedNodes();\n                if ((indexed % 1000) == 0) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.debug(\"[{}] => Indexed {} nodes...\", getIndexName(), indexed);\n                }\n            }\n        }\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher m : matcherState.affectedMatchers) {\n            m.markRootDirty();\n        }\n        if (parent == null) {\n            try {\n                context.closeWriter();\n            } catch (java.io.IOException e) {\n                throw new org.apache.jackrabbit.oak.api.CommitFailedException(\"Lucene\", 4, \"Failed to close the Lucene index\", e);\n            }\n            if (context.getIndexedNodes() > 0) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.debug(\"[{}] => Indexed {} nodes, done.\", getIndexName(), context.getIndexedNodes());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void propertyAdded(org.apache.jackrabbit.oak.api.PropertyState after) {\n        markPropertyChanged(after.getName());\n        checkAggregates(after.getName());\n    }\n\n    @java.lang.Override\n    public void propertyChanged(org.apache.jackrabbit.oak.api.PropertyState before, org.apache.jackrabbit.oak.api.PropertyState after) {\n        markPropertyChanged(before.getName());\n        propertiesModified.add(before);\n        checkAggregates(before.getName());\n    }\n\n    @java.lang.Override\n    public void propertyDeleted(org.apache.jackrabbit.oak.api.PropertyState before) {\n        markPropertyChanged(before.getName());\n        propertiesModified.add(before);\n        checkAggregates(before.getName());\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.commit.Editor childNodeAdded(java.lang.String name, org.apache.jackrabbit.oak.spi.state.NodeState after) {\n        org.apache.jackrabbit.oak.plugins.index.PathFilter.Result filterResult = getPathFilterResult(name);\n        if (filterResult != PathFilter.Result.EXCLUDE) {\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor(this, name, getMatcherState(name, after), filterResult, false);\n        }\n        return null;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.commit.Editor childNodeChanged(java.lang.String name, org.apache.jackrabbit.oak.spi.state.NodeState before, org.apache.jackrabbit.oak.spi.state.NodeState after) {\n        org.apache.jackrabbit.oak.plugins.index.PathFilter.Result filterResult = getPathFilterResult(name);\n        if (filterResult != PathFilter.Result.EXCLUDE) {\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor(this, name, getMatcherState(name, after), filterResult, false);\n        }\n        return null;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.commit.Editor childNodeDeleted(java.lang.String name, org.apache.jackrabbit.oak.spi.state.NodeState before) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        org.apache.jackrabbit.oak.plugins.index.PathFilter.Result filterResult = getPathFilterResult(name);\n        if (filterResult == PathFilter.Result.EXCLUDE) {\n            return null;\n        }\n        if (!isDeleted) {\n            java.lang.String path = concat(getPath(), name);\n            try {\n                org.apache.lucene.index.IndexWriter writer = context.getWriter();\n                writer.deleteDocuments(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(path));\n                writer.deleteDocuments(new org.apache.lucene.search.PrefixQuery(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(path + \"/\")));\n                this.context.indexUpdate();\n            } catch (java.io.IOException e) {\n                throw new org.apache.jackrabbit.oak.api.CommitFailedException(\"Lucene\", 5, (\"Failed to remove the index entries of\" + \" the removed subtree \") + path, e);\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState ms = getMatcherState(name, before);\n        if (!ms.isEmpty()) {\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor(this, name, ms, filterResult, true);\n        }\n        return null;\n    }\n\n    private boolean addOrUpdate(java.lang.String path, org.apache.jackrabbit.oak.spi.state.NodeState state, boolean isUpdate) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        try {\n            org.apache.lucene.document.Document d = makeDocument(path, state, isUpdate);\n            if (d != null) {\n                if (org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.isTraceEnabled()) {\n                    org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.trace(\"[{}] Indexed document for {} is {}\", getIndexName(), path, d);\n                }\n                context.indexUpdate();\n                context.getWriter().updateDocument(org.apache.jackrabbit.oak.plugins.index.lucene.TermFactory.newPathTerm(path), d);\n                return true;\n            }\n        } catch (java.io.IOException e) {\n            throw new org.apache.jackrabbit.oak.api.CommitFailedException(\"Lucene\", 3, \"Failed to index the node \" + path, e);\n        } catch (java.lang.IllegalArgumentException ie) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.warn(\"Failed to index the node [{}]\", path, ie);\n        }\n        return false;\n    }\n\n    private org.apache.lucene.document.Document makeDocument(java.lang.String path, org.apache.jackrabbit.oak.spi.state.NodeState state, boolean isUpdate) {\n        if (!isIndexable()) {\n            return null;\n        }\n        java.util.List<org.apache.lucene.document.Field> fields = new java.util.ArrayList<org.apache.lucene.document.Field>();\n        boolean dirty = false;\n        for (org.apache.jackrabbit.oak.api.PropertyState property : state.getProperties()) {\n            java.lang.String pname = property.getName();\n            if (!org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.isVisible(pname)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = indexingRule.getConfig(pname);\n            if ((pd == null) || (!pd.index)) {\n                continue;\n            }\n            if (pd.ordered) {\n                dirty |= addTypedOrderedFields(fields, property, pname, pd);\n            }\n            dirty |= indexProperty(path, fields, state, property, pname, pd);\n        }\n        dirty |= indexAggregates(path, fields, state);\n        dirty |= indexNullCheckEnabledProps(path, fields, state);\n        dirty |= indexNotNullCheckEnabledProps(path, fields, state);\n        if (!dirty) {\n            dirty = indexIfSinglePropertyRemoved();\n        }\n        if (isUpdate && (!dirty)) {\n            return null;\n        }\n        if ((!indexingRule.isFulltextEnabled()) && (!dirty)) {\n            return null;\n        }\n        org.apache.lucene.document.Document document = new org.apache.lucene.document.Document();\n        document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newPathField(path));\n        java.lang.String name = getName(path);\n        if (indexingRule.isFulltextEnabled()) {\n            document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(name));\n        }\n        if (getDefinition().evaluatePathRestrictions()) {\n            document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newAncestorsField(org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(path)));\n            document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newDepthField(path));\n        }\n        org.apache.lucene.document.Field suggestField = null;\n        for (org.apache.lucene.document.Field f : fields) {\n            if (FieldNames.SUGGEST.endsWith(f.name())) {\n                if (suggestField == null) {\n                    suggestField = org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newSuggestField(f.stringValue());\n                } else {\n                    suggestField = org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newSuggestField(suggestField.stringValue(), f.stringValue());\n                }\n            } else {\n                document.add(f);\n            }\n        }\n        if (suggestField != null) {\n            document.add(suggestField);\n        }\n        return document;\n    }\n\n    private boolean indexProperty(java.lang.String path, java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.spi.state.NodeState state, org.apache.jackrabbit.oak.api.PropertyState property, java.lang.String pname, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        boolean includeTypeForFullText = indexingRule.includePropertyType(property.getType().tag());\n        if ((Type.BINARY.tag() == property.getType().tag()) && includeTypeForFullText) {\n            fields.addAll(newBinary(property, state, null, (path + \"@\") + pname));\n            return true;\n        } else {\n            boolean dirty = false;\n            if (pd.propertyIndex && pd.includePropertyType(property.getType().tag())) {\n                dirty |= addTypedFields(fields, property, pname);\n            }\n            if (pd.fulltextEnabled() && includeTypeForFullText) {\n                for (java.lang.String value : property.getValue(Type.STRINGS)) {\n                    if (pd.analyzed && pd.includePropertyType(property.getType().tag())) {\n                        java.lang.String analyzedPropName = constructAnalyzedPropertyName(pname);\n                        fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newPropertyField(analyzedPropName, value, !pd.skipTokenization(pname), pd.stored));\n                    }\n                    if (pd.useInSuggest) {\n                        fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newPropertyField(FieldNames.SUGGEST, value, true, true));\n                    }\n                    if (pd.useInSpellcheck) {\n                        fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newPropertyField(FieldNames.SPELLCHECK, value, true, false));\n                    }\n                    if (pd.nodeScopeIndex) {\n                        org.apache.lucene.document.Field field = org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(value);\n                        field.setBoost(pd.boost);\n                        fields.add(field);\n                    }\n                    dirty = true;\n                }\n            }\n            return dirty;\n        }\n    }\n\n    private java.lang.String constructAnalyzedPropertyName(java.lang.String pname) {\n        if (context.getDefinition().getVersion().isAtLeast(IndexFormatVersion.V2)) {\n            return org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.createAnalyzedFieldName(pname);\n        }\n        return pname;\n    }\n\n    private boolean addTypedFields(java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.api.PropertyState property, java.lang.String pname) {\n        int tag = property.getType().tag();\n        boolean fieldAdded = false;\n        for (int i = 0; i < property.count(); i++) {\n            org.apache.lucene.document.Field f;\n            if (tag == Type.LONG.tag()) {\n                f = new org.apache.lucene.document.LongField(pname, property.getValue(Type.LONG, i), Field.Store.NO);\n            } else if (tag == Type.DATE.tag()) {\n                java.lang.String date = property.getValue(Type.DATE, i);\n                f = new org.apache.lucene.document.LongField(pname, org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.dateToLong(date), Field.Store.NO);\n            } else if (tag == Type.DOUBLE.tag()) {\n                f = new org.apache.lucene.document.DoubleField(pname, property.getValue(Type.DOUBLE, i), Field.Store.NO);\n            } else if (tag == Type.BOOLEAN.tag()) {\n                f = new org.apache.lucene.document.StringField(pname, property.getValue(Type.BOOLEAN, i).toString(), Field.Store.NO);\n            } else {\n                f = new org.apache.lucene.document.StringField(pname, property.getValue(Type.STRING, i), Field.Store.NO);\n            }\n            fields.add(f);\n            fieldAdded = true;\n        }\n        return fieldAdded;\n    }\n\n    private boolean addTypedOrderedFields(java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.api.PropertyState property, java.lang.String pname, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        if (property.getType().isArray()) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.warn(\"[{}] Ignoring ordered property {} of type {} for path {} as multivalued ordered property not supported\", getIndexName(), pname, org.apache.jackrabbit.oak.api.Type.fromTag(property.getType().tag(), true), getPath());\n            return false;\n        }\n        int tag = property.getType().tag();\n        int idxDefinedTag = pd.getType();\n        if (tag != idxDefinedTag) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.debug(\"[{}] Ordered property defined with type {} differs from property {} with type {} in \" + \"path {}\", getIndexName(), org.apache.jackrabbit.oak.api.Type.fromTag(idxDefinedTag, false), property.toString(), org.apache.jackrabbit.oak.api.Type.fromTag(tag, false), getPath());\n            tag = idxDefinedTag;\n        }\n        java.lang.String name = org.apache.jackrabbit.oak.plugins.index.lucene.FieldNames.createDocValFieldName(pname);\n        boolean fieldAdded = false;\n        org.apache.lucene.document.Field f = null;\n        try {\n            if (tag == Type.LONG.tag()) {\n                f = new org.apache.lucene.document.NumericDocValuesField(name, property.getValue(Type.LONG));\n            } else if (tag == Type.DATE.tag()) {\n                java.lang.String date = property.getValue(Type.DATE);\n                f = new org.apache.lucene.document.NumericDocValuesField(name, org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.dateToLong(date));\n            } else if (tag == Type.DOUBLE.tag()) {\n                f = new org.apache.lucene.document.DoubleDocValuesField(name, property.getValue(Type.DOUBLE));\n            } else if (tag == Type.BOOLEAN.tag()) {\n                f = new org.apache.lucene.document.SortedDocValuesField(name, new org.apache.lucene.util.BytesRef(property.getValue(Type.BOOLEAN).toString()));\n            } else if (tag == Type.STRING.tag()) {\n                f = new org.apache.lucene.document.SortedDocValuesField(name, new org.apache.lucene.util.BytesRef(property.getValue(Type.STRING)));\n            }\n            if (f != null) {\n                fields.add(f);\n                fieldAdded = true;\n            }\n        } catch (java.lang.Exception e) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.warn(\"[{}] Ignoring ordered property. Could not convert property {} of type {} to type {} for path {}\", getIndexName(), pname, org.apache.jackrabbit.oak.api.Type.fromTag(property.getType().tag(), false), org.apache.jackrabbit.oak.api.Type.fromTag(tag, false), getPath(), e);\n        }\n        return fieldAdded;\n    }\n\n    private static boolean isVisible(java.lang.String name) {\n        return name.charAt(0) != ':';\n    }\n\n    private java.util.List<org.apache.lucene.document.Field> newBinary(org.apache.jackrabbit.oak.api.PropertyState property, org.apache.jackrabbit.oak.spi.state.NodeState state, java.lang.String nodePath, java.lang.String path) {\n        java.util.List<org.apache.lucene.document.Field> fields = new java.util.ArrayList<org.apache.lucene.document.Field>();\n        org.apache.tika.metadata.Metadata metadata = new org.apache.tika.metadata.Metadata();\n        java.lang.String type = state.getString(JcrConstants.JCR_MIMETYPE);\n        if ((type == null) || (!isSupportedMediaType(type))) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.trace(\"[{}] Ignoring binary content for node {} due to unsupported (or null) jcr:mimeType [{}]\", getIndexName(), path, type);\n            return fields;\n        }\n        metadata.set(Metadata.CONTENT_TYPE, type);\n        if (org.apache.jackrabbit.JcrConstants.JCR_DATA.equals(property.getName())) {\n            java.lang.String encoding = state.getString(JcrConstants.JCR_ENCODING);\n            if (encoding != null) {\n                metadata.set(Metadata.CONTENT_ENCODING, encoding);\n            }\n        }\n        for (org.apache.jackrabbit.oak.api.Blob v : property.getValue(Type.BINARIES)) {\n            if (nodePath != null) {\n                fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(nodePath, parseStringValue(v, metadata, path)));\n            } else {\n                fields.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(parseStringValue(v, metadata, path)));\n            }\n        }\n        return fields;\n    }\n\n    private boolean indexNotNullCheckEnabledProps(java.lang.String path, java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.spi.state.NodeState state) {\n        boolean fieldAdded = false;\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : indexingRule.getNotNullCheckEnabledProperties()) {\n            if (isPropertyNotNull(state, pd)) {\n                fields.add(new org.apache.lucene.document.StringField(FieldNames.NOT_NULL_PROPS, pd.name, Field.Store.NO));\n                fieldAdded = true;\n            }\n        }\n        return fieldAdded;\n    }\n\n    private boolean indexNullCheckEnabledProps(java.lang.String path, java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.spi.state.NodeState state) {\n        boolean fieldAdded = false;\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd : indexingRule.getNullCheckEnabledProperties()) {\n            if (isPropertyNull(state, pd)) {\n                fields.add(new org.apache.lucene.document.StringField(FieldNames.NULL_PROPS, pd.name, Field.Store.NO));\n                fieldAdded = true;\n            }\n        }\n        return fieldAdded;\n    }\n\n    private boolean indexIfSinglePropertyRemoved() {\n        boolean dirty = false;\n        for (org.apache.jackrabbit.oak.api.PropertyState ps : propertiesModified) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = indexingRule.getConfig(ps.getName());\n            if (((pd != null) && pd.index) && (pd.includePropertyType(ps.getType().tag()) || indexingRule.includePropertyType(ps.getType().tag()))) {\n                dirty = true;\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    private boolean isPropertyNull(org.apache.jackrabbit.oak.spi.state.NodeState state, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        org.apache.jackrabbit.oak.spi.state.NodeState propertyNode = org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.getPropertyNode(state, pd);\n        if (!propertyNode.exists()) {\n            return false;\n        }\n        return !propertyNode.hasProperty(pd.nonRelativeName);\n    }\n\n    private boolean isPropertyNotNull(org.apache.jackrabbit.oak.spi.state.NodeState state, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        org.apache.jackrabbit.oak.spi.state.NodeState propertyNode = org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.getPropertyNode(state, pd);\n        if (!propertyNode.exists()) {\n            return false;\n        }\n        return propertyNode.hasProperty(pd.nonRelativeName);\n    }\n\n    private static org.apache.jackrabbit.oak.spi.state.NodeState getPropertyNode(org.apache.jackrabbit.oak.spi.state.NodeState nodeState, org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd) {\n        if (!pd.relative) {\n            return nodeState;\n        }\n        org.apache.jackrabbit.oak.spi.state.NodeState node = nodeState;\n        for (java.lang.String name : pd.ancestors) {\n            node = node.getChildNode(name);\n        }\n        return node;\n    }\n\n    @java.lang.Override\n    public void markDirty() {\n        propertiesChanged = true;\n    }\n\n    private org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState getMatcherState(java.lang.String name, org.apache.jackrabbit.oak.spi.state.NodeState after) {\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> matched = com.google.common.collect.Lists.newArrayList();\n        java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> inherited = com.google.common.collect.Lists.newArrayList();\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher m : com.google.common.collect.Iterables.concat(matcherState.inherited, currentMatchers)) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher result = m.match(name, after);\n            if (result.getStatus() == Matcher.Status.MATCH_FOUND) {\n                matched.add(result);\n            }\n            if (result.getStatus() != Matcher.Status.FAIL) {\n                inherited.addAll(result.nextSet());\n            }\n        }\n        if ((!matched.isEmpty()) || (!inherited.isEmpty())) {\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState(matched, inherited);\n        }\n        return org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState.NONE;\n    }\n\n    private boolean indexAggregates(final java.lang.String path, final java.util.List<org.apache.lucene.document.Field> fields, final org.apache.jackrabbit.oak.spi.state.NodeState state) {\n        final java.util.concurrent.atomic.AtomicBoolean dirtyFlag = new java.util.concurrent.atomic.AtomicBoolean();\n        indexingRule.getAggregate().collectAggregates(state, new org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.ResultCollector() {\n            @java.lang.Override\n            public void onResult(org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.NodeIncludeResult result) {\n                boolean dirty = indexAggregatedNode(path, fields, result);\n                if (dirty) {\n                    dirtyFlag.set(true);\n                }\n            }\n\n            @java.lang.Override\n            public void onResult(org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.PropertyIncludeResult result) {\n                boolean dirty = false;\n                if (result.pd.ordered) {\n                    dirty |= addTypedOrderedFields(fields, result.propertyState, result.propertyPath, result.pd);\n                }\n                dirty |= indexProperty(path, fields, state, result.propertyState, result.propertyPath, result.pd);\n                if (dirty) {\n                    dirtyFlag.set(true);\n                }\n            }\n        });\n        return dirtyFlag.get();\n    }\n\n    private boolean indexAggregatedNode(java.lang.String path, java.util.List<org.apache.lucene.document.Field> fields, org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.NodeIncludeResult result) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition.IndexingRule ruleAggNode = context.getDefinition().getApplicableIndexingRule(getPrimaryTypeName(result.nodeState));\n        boolean dirty = false;\n        for (org.apache.jackrabbit.oak.api.PropertyState property : result.nodeState.getProperties()) {\n            java.lang.String pname = property.getName();\n            if (!org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.isVisible(pname)) {\n                continue;\n            }\n            int type = property.getType().tag();\n            if (ruleAggNode != null) {\n                if (!ruleAggNode.includePropertyType(type)) {\n                    continue;\n                }\n            } else if (!indexingRule.includePropertyType(type)) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.api.Type.BINARY == property.getType()) {\n                java.lang.String aggreagtedNodePath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, result.nodePath);\n                java.lang.String nodePath = (result.isRelativeNode()) ? result.rootIncludePath : null;\n                fields.addAll(newBinary(property, result.nodeState, nodePath, (aggreagtedNodePath + \"@\") + pname));\n                dirty = true;\n            } else {\n                org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = null;\n                if (ruleAggNode != null) {\n                    pd = ruleAggNode.getConfig(pname);\n                }\n                if ((pd != null) && (!pd.nodeScopeIndex)) {\n                    continue;\n                }\n                for (java.lang.String value : property.getValue(Type.STRINGS)) {\n                    org.apache.lucene.document.Field field = (result.isRelativeNode()) ? org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(result.rootIncludePath, value) : org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(value);\n                    if (pd != null) {\n                        field.setBoost(pd.boost);\n                    }\n                    fields.add(field);\n                    dirty = true;\n                }\n            }\n        }\n        return dirty;\n    }\n\n    private void checkAggregates(java.lang.String name) {\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher m : matcherState.matched) {\n            if ((!matcherState.affectedMatchers.contains(m)) && m.aggregatesProperty(name)) {\n                matcherState.affectedMatchers.add(m);\n            }\n        }\n    }\n\n    private static class MatcherState {\n        static final org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState NONE = new org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.MatcherState(java.util.Collections.<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher>emptyList(), java.util.Collections.<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher>emptyList());\n\n        final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> matched;\n\n        final java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> inherited;\n\n        final java.util.Set<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> affectedMatchers;\n\n        public MatcherState(java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> matched, java.util.List<org.apache.jackrabbit.oak.plugins.index.lucene.Aggregate.Matcher> inherited) {\n            this.matched = matched;\n            this.inherited = inherited;\n            if (matched.isEmpty()) {\n                affectedMatchers = java.util.Collections.emptySet();\n            } else {\n                affectedMatchers = com.google.common.collect.Sets.newIdentityHashSet();\n            }\n        }\n\n        public boolean isEmpty() {\n            return matched.isEmpty() && inherited.isEmpty();\n        }\n    }\n\n    private void markPropertyChanged(java.lang.String name) {\n        if ((isIndexable() && (!propertiesChanged)) && indexingRule.isIndexed(name)) {\n            propertiesChanged = true;\n        }\n    }\n\n    private org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition getDefinition() {\n        return context.getDefinition();\n    }\n\n    private boolean isIndexable() {\n        return indexingRule != null;\n    }\n\n    private PathFilter.Result getPathFilterResult(java.lang.String childNodeName) {\n        return context.getDefinition().getPathFilter().doFiler(concat(getPath(), childNodeName));\n    }\n\n    private boolean isSupportedMediaType(java.lang.String type) {\n        return context.isSupportedMediaType(type);\n    }\n\n    private java.lang.String parseStringValue(org.apache.jackrabbit.oak.api.Blob v, org.apache.tika.metadata.Metadata metadata, java.lang.String path) {\n        org.apache.tika.sax.WriteOutContentHandler handler = new org.apache.tika.sax.WriteOutContentHandler(context.getDefinition().getMaxExtractLength());\n        long start = java.lang.System.currentTimeMillis();\n        long size = 0;\n        try {\n            com.google.common.io.CountingInputStream stream = new com.google.common.io.CountingInputStream(new org.apache.jackrabbit.oak.commons.io.LazyInputStream(new org.apache.jackrabbit.oak.util.BlobByteSource(v)));\n            try {\n                context.getParser().parse(stream, handler, metadata, new org.apache.tika.parser.ParseContext());\n            } finally {\n                size = stream.getCount();\n                stream.close();\n            }\n        } catch (java.lang.LinkageError e) {\n        } catch (java.lang.Throwable t) {\n            if (!handler.isWriteLimitReached(t)) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.log.debug(\"[{}] Failed to extract text from a binary property: {}.\" + ((\" This is a fairly common case, and nothing to\" + \" worry about. The stack trace is included to\") + \" help improve the text extraction feature.\"), getIndexName(), path, t);\n                return \"TextExtractionError\";\n            }\n        }\n        java.lang.String result = handler.toString();\n        context.recordTextExtractionStats(java.lang.System.currentTimeMillis() - start, size);\n        return result;\n    }\n\n    private java.lang.String getIndexName() {\n        return context.getDefinition().getIndexName();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "propertiesModified.add(before)",
            "src_parent": "{\n    markPropertyChanged(before.getName());\n    propertiesModified.add(before);\n    checkAggregates(before.getName());\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "propertiesModified.add(before)",
            "src_parent": "{\n    markPropertyChanged(before.getName());\n    propertiesModified.add(before);\n    checkAggregates(before.getName());\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (!dirty) {\n    dirty = indexIfSinglePropertyRemoved();\n}",
            "src_parent": "{\n    if (!isIndexable()) {\n        return null;\n    }\n    java.util.List<org.apache.lucene.document.Field> fields = new java.util.ArrayList<org.apache.lucene.document.Field>();\n    boolean dirty = false;\n    for (org.apache.jackrabbit.oak.api.PropertyState property : state.getProperties()) {\n        java.lang.String pname = property.getName();\n        if (!org.apache.jackrabbit.oak.plugins.index.lucene.LuceneIndexEditor.isVisible(pname)) {\n            continue;\n        }\n        org.apache.jackrabbit.oak.plugins.index.lucene.PropertyDefinition pd = indexingRule.getConfig(pname);\n        if ((pd == null) || (!pd.index)) {\n            continue;\n        }\n        if (pd.ordered) {\n            dirty |= addTypedOrderedFields(fields, property, pname, pd);\n        }\n        dirty |= indexProperty(path, fields, state, property, pname, pd);\n    }\n    dirty |= indexAggregates(path, fields, state);\n    dirty |= indexNullCheckEnabledProps(path, fields, state);\n    dirty |= indexNotNullCheckEnabledProps(path, fields, state);\n    if (!dirty) {\n        dirty = indexIfSinglePropertyRemoved();\n    }\n    if (isUpdate && (!dirty)) {\n        return null;\n    }\n    if ((!indexingRule.isFulltextEnabled()) && (!dirty)) {\n        return null;\n    }\n    org.apache.lucene.document.Document document = new org.apache.lucene.document.Document();\n    document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newPathField(path));\n    java.lang.String name = getName(path);\n    if (indexingRule.isFulltextEnabled()) {\n        document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newFulltextField(name));\n    }\n    if (getDefinition().evaluatePathRestrictions()) {\n        document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newAncestorsField(org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(path)));\n        document.add(org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newDepthField(path));\n    }\n    org.apache.lucene.document.Field suggestField = null;\n    for (org.apache.lucene.document.Field f : fields) {\n        if (FieldNames.SUGGEST.endsWith(f.name())) {\n            if (suggestField == null) {\n                suggestField = org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newSuggestField(f.stringValue());\n            } else {\n                suggestField = org.apache.jackrabbit.oak.plugins.index.lucene.FieldFactory.newSuggestField(suggestField.stringValue(), f.stringValue());\n            }\n        } else {\n            document.add(f);\n        }\n    }\n    if (suggestField != null) {\n        document.add(suggestField);\n    }\n    return document;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        }
      ],
      "file_name": "LuceneIndexEditor"
    }
  ],
  "id": "jackrabbit-oak_3bf07779"
}