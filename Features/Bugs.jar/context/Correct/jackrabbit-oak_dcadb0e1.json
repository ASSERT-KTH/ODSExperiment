{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private final org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver idLookup;",
            "dst_parent": "public class ImporterImpl implements org.apache.jackrabbit.oak.spi.xml.Importer {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.class);\n\n    private final org.apache.jackrabbit.oak.api.Tree importTargetTree;\n\n    private final org.apache.jackrabbit.oak.api.Tree ntTypesRoot;\n\n    private final int uuidBehavior;\n\n    private final java.lang.String userID;\n\n    private final org.apache.jackrabbit.oak.jcr.security.AccessManager accessManager;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.DefinitionProvider definitionProvider;\n\n    private final org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver idLookup;\n\n    private final java.util.Stack<org.apache.jackrabbit.oak.api.Tree> parents;\n\n    private final org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker refTracker;\n\n    private final java.util.List<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter> pItemImporters = new java.util.ArrayList<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter>();\n\n    private org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pnImporter;\n\n    public ImporterImpl(java.lang.String absPath, org.apache.jackrabbit.oak.jcr.session.SessionContext sessionContext, org.apache.jackrabbit.oak.api.Root root, int uuidBehavior, boolean isWorkspaceImport) throws javax.jcr.RepositoryException {\n        java.lang.String oakPath = sessionContext.getOakPath(absPath);\n        if (oakPath == null) {\n            throw new javax.jcr.RepositoryException(\"Invalid name or path: \" + absPath);\n        }\n        if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(oakPath)) {\n            throw new javax.jcr.RepositoryException(\"Not an absolute path: \" + absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate sd = sessionContext.getSessionDelegate();\n        if (isWorkspaceImport && sd.hasPendingChanges()) {\n            throw new javax.jcr.RepositoryException(\"Pending changes on session. Cannot run workspace import.\");\n        }\n        this.uuidBehavior = uuidBehavior;\n        userID = sd.getAuthInfo().getUserID();\n        importTargetTree = root.getTree(oakPath);\n        if (!importTargetTree.exists()) {\n            throw new javax.jcr.PathNotFoundException(absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.session.WorkspaceImpl wsp = sessionContext.getWorkspace();\n        javax.jcr.version.VersionManager vMgr = wsp.getVersionManager();\n        if (!vMgr.isCheckedOut(absPath)) {\n            throw new javax.jcr.version.VersionException(\"Target node is checked in.\");\n        }\n        if ((importTargetTree.getStatus() != Tree.Status.NEW) && wsp.getLockManager().isLocked(absPath)) {\n            throw new javax.jcr.lock.LockException(\"Target node is locked.\");\n        }\n        effectiveNodeTypeProvider = wsp.getNodeTypeManager();\n        definitionProvider = wsp.getNodeTypeManager();\n        ntTypesRoot = root.getTree(org.apache.jackrabbit.oak.jcr.xml.NODE_TYPES_PATH);\n        accessManager = sessionContext.getAccessManager();\n        idLookup = new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver(root, sd.getContentSession());\n        refTracker = new org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker();\n        parents = new java.util.Stack<org.apache.jackrabbit.oak.api.Tree>();\n        parents.push(importTargetTree);\n        pItemImporters.clear();\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {\n            if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {\n                pItemImporters.add(importer);\n            }\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree createTree(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree parent, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.xml.NodeInfo nInfo, @javax.annotation.CheckForNull\n    java.lang.String uuid) throws javax.jcr.RepositoryException {\n        java.lang.String ntName = nInfo.getPrimaryTypeName();\n        org.apache.jackrabbit.oak.api.Tree child = org.apache.jackrabbit.oak.util.TreeUtil.addChild(parent, nInfo.getName(), ntName, ntTypesRoot, userID);\n        if (ntName != null) {\n            accessManager.checkPermissions(child, child.getProperty(JcrConstants.JCR_PRIMARYTYPE), Permissions.NODE_TYPE_MANAGEMENT);\n        }\n        if (uuid != null) {\n            child.setProperty(JcrConstants.JCR_UUID, uuid);\n        }\n        for (java.lang.String mixin : nInfo.getMixinTypeNames()) {\n            org.apache.jackrabbit.oak.util.TreeUtil.addMixin(child, mixin, ntTypesRoot, userID);\n        }\n        return child;\n    }\n\n    private void createProperty(org.apache.jackrabbit.oak.api.Tree tree, org.apache.jackrabbit.oak.spi.xml.PropInfo pInfo, javax.jcr.nodetype.PropertyDefinition def) throws javax.jcr.RepositoryException {\n        java.util.List<javax.jcr.Value> values = pInfo.getValues(pInfo.getTargetType(def));\n        org.apache.jackrabbit.oak.api.PropertyState propertyState;\n        java.lang.String name = pInfo.getName();\n        int type = pInfo.getType();\n        if ((values.size() == 1) && (!def.isMultiple())) {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values.get(0));\n        } else {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values);\n        }\n        tree.setProperty(propertyState);\n        if ((type == javax.jcr.PropertyType.REFERENCE) || (type == javax.jcr.PropertyType.WEAKREFERENCE)) {\n            refTracker.processedReference(new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference(tree, name));\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree resolveUUIDConflict(org.apache.jackrabbit.oak.api.Tree parent, org.apache.jackrabbit.oak.api.Tree conflicting, java.lang.String conflictingId, org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree tree;\n        if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n            tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n            }\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW) {\n            java.lang.String msg = (\"a node with uuid \" + nodeInfo.getUUID()) + \" already exists!\";\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.ItemExistsException(msg);\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be removed\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (importTargetTree.getPath().startsWith(conflicting.getPath())) {\n                java.lang.String msg = \"cannot remove ancestor node\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.nodetype.ConstraintViolationException(msg);\n            }\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (conflicting.isRoot()) {\n                java.lang.String msg = \"root node cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            parent = conflicting.getParent();\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else {\n            java.lang.String msg = \"unknown uuidBehavior: \" + uuidBehavior;\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.RepositoryException(msg);\n        }\n        return tree;\n    }\n\n    private void importProperties(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree tree, @javax.annotation.Nonnull\n    java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos, boolean ignoreRegular) throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.PropInfo pi : propInfos) {\n            javax.jcr.nodetype.PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\n            if (def.isProtected()) {\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property \" + pi.getName());\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n                    if (ppi.handlePropInfo(tree, pi, def)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                        break;\n                    }\n                }\n            } else if (!ignoreRegular) {\n                createProperty(tree, pi, def);\n            }\n        }\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n            ppi.propertiesCompleted(tree);\n        }\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter> getPropertyImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter> getNodeImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    @java.lang.Override\n    public void start() throws javax.jcr.RepositoryException {\n    }\n\n    @java.lang.Override\n    public void startNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo, java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.peek();\n        org.apache.jackrabbit.oak.api.Tree tree = null;\n        java.lang.String id = nodeInfo.getUUID();\n        java.lang.String nodeName = nodeInfo.getName();\n        java.lang.String ntName = nodeInfo.getPrimaryTypeName();\n        if (parent == null) {\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping node: \" + nodeName);\n            parents.push(null);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n        javax.jcr.nodetype.NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            parents.push(null);\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + nodeName);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    }\n                }\n            }\n            return;\n        }\n        if (parent.hasChild(nodeName)) {\n            org.apache.jackrabbit.oak.api.Tree existing = parent.getChild(nodeName);\n            javax.jcr.nodetype.NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    tree = existing;\n                } else {\n                    java.lang.String existingIdentifier = org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id) && ((uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) || (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING)))) {\n                        throw new javax.jcr.ItemExistsException(\"Node with the same UUID exists:\" + existing);\n                    }\n                }\n            }\n        }\n        if (tree == null) {\n            if (id == null) {\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n                org.apache.jackrabbit.oak.api.Tree conflicting = idLookup.getConflictingTree(id);\n                if ((conflicting != null) && conflicting.exists()) {\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        parents.push(null);\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n        importProperties(tree, propInfos, false);\n        parents.push(tree);\n    }\n\n    @java.lang.Override\n    public void endNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.pop();\n        if (parent == null) {\n            if (pnImporter != null) {\n                pnImporter.endChildInfo();\n            }\n        } else if (getDefinition(parent).isProtected()) {\n            if (pnImporter != null) {\n                pnImporter.end(parent);\n                pnImporter = null;\n            }\n        }\n        idLookup.rememberImportedUUIDs(parent);\n    }\n\n    @java.lang.Override\n    public void end() throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter ppi : pItemImporters) {\n            ppi.processReferences();\n        }\n        java.util.Iterator<java.lang.Object> iter = refTracker.getProcessedReferences();\n        while (iter.hasNext()) {\n            java.lang.Object ref = iter.next();\n            if (!(ref instanceof org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference reference = ((org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference) (ref));\n            if (reference.isMultiple()) {\n                java.lang.Iterable<java.lang.String> values = reference.property.getValue(Type.STRINGS);\n                java.util.List<java.lang.String> newValues = com.google.common.collect.Lists.newArrayList();\n                for (java.lang.String original : values) {\n                    java.lang.String adjusted = refTracker.get(original);\n                    if (adjusted != null) {\n                        newValues.add(adjusted);\n                    } else {\n                        newValues.add(original);\n                    }\n                }\n                reference.setProperty(newValues);\n            } else {\n                java.lang.String original = reference.property.getValue(Type.STRING);\n                java.lang.String adjusted = refTracker.get(original);\n                if (adjusted != null) {\n                    reference.setProperty(adjusted);\n                }\n            }\n        } \n        refTracker.clear();\n    }\n\n    private boolean isNodeType(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String ntName) throws javax.jcr.RepositoryException {\n        return effectiveNodeTypeProvider.isNodeType(tree, ntName);\n    }\n\n    private javax.jcr.nodetype.NodeDefinition getDefinition(org.apache.jackrabbit.oak.api.Tree tree) throws javax.jcr.RepositoryException {\n        if (tree.isRoot()) {\n            return definitionProvider.getRootDefinition();\n        } else {\n            return definitionProvider.getDefinition(tree.getParent(), tree);\n        }\n    }\n\n    private static final class Reference {\n        private final org.apache.jackrabbit.oak.api.Tree tree;\n\n        private final org.apache.jackrabbit.oak.api.PropertyState property;\n\n        private Reference(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String propertyName) {\n            this.tree = tree;\n            this.property = tree.getProperty(propertyName);\n        }\n\n        private boolean isMultiple() {\n            return property.isArray();\n        }\n\n        private void setProperty(java.lang.String newValue) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());\n            tree.setProperty(prop);\n        }\n\n        private void setProperty(java.lang.Iterable<java.lang.String> newValues) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValues, property.getType());\n            tree.setProperty(prop);\n        }\n    }\n\n    private static final class IdResolver {\n        private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n        private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n        private final java.util.Set<java.lang.String> importedUUIDs;\n\n        private IdResolver(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.api.Root root, @javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.api.ContentSession contentSession) {\n            currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n            baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(contentSession.getLatestRoot());\n            if (!root.hasPendingChanges()) {\n                importedUUIDs = new java.util.HashSet<java.lang.String>();\n            } else {\n                importedUUIDs = null;\n            }\n        }\n\n        @javax.annotation.CheckForNull\n        private org.apache.jackrabbit.oak.api.Tree getConflictingTree(@javax.annotation.Nonnull\n        java.lang.String id) {\n            org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n            if ((conflicting == null) && (importedUUIDs != null)) {\n                if (importedUUIDs.contains(id)) {\n                    conflicting = currentStateIdManager.getTree(id);\n                }\n            } else {\n                conflicting = currentStateIdManager.getTree(id);\n            }\n            return conflicting;\n        }\n\n        private void rememberImportedUUIDs(@javax.annotation.CheckForNull\n        org.apache.jackrabbit.oak.api.Tree tree) {\n            if ((tree == null) || (importedUUIDs == null)) {\n                return;\n            }\n            java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n            if (uuid != null) {\n                importedUUIDs.add(uuid);\n            }\n            for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n                rememberImportedUUIDs(child);\n            }\n        }\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Field",
            "operator": "UPD",
            "src": "private final java.util.Set<java.lang.String> uuids = new java.util.HashSet<java.lang.String>();",
            "src_parent": "public class ImporterImpl implements org.apache.jackrabbit.oak.spi.xml.Importer {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.class);\n\n    private final org.apache.jackrabbit.oak.api.Tree importTargetTree;\n\n    private final org.apache.jackrabbit.oak.api.Tree ntTypesRoot;\n\n    private final int uuidBehavior;\n\n    private final java.lang.String userID;\n\n    private final org.apache.jackrabbit.oak.jcr.security.AccessManager accessManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.DefinitionProvider definitionProvider;\n\n    private final java.util.Set<java.lang.String> uuids = new java.util.HashSet<java.lang.String>();\n\n    private final java.util.Stack<org.apache.jackrabbit.oak.api.Tree> parents;\n\n    private final org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker refTracker;\n\n    private final java.util.List<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter> pItemImporters = new java.util.ArrayList<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter>();\n\n    private org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pnImporter;\n\n    public ImporterImpl(java.lang.String absPath, org.apache.jackrabbit.oak.jcr.session.SessionContext sessionContext, org.apache.jackrabbit.oak.api.Root root, int uuidBehavior, boolean isWorkspaceImport) throws javax.jcr.RepositoryException {\n        java.lang.String oakPath = sessionContext.getOakPath(absPath);\n        if (oakPath == null) {\n            throw new javax.jcr.RepositoryException(\"Invalid name or path: \" + absPath);\n        }\n        if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(oakPath)) {\n            throw new javax.jcr.RepositoryException(\"Not an absolute path: \" + absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate sd = sessionContext.getSessionDelegate();\n        if (isWorkspaceImport && sd.hasPendingChanges()) {\n            throw new javax.jcr.RepositoryException(\"Pending changes on session. Cannot run workspace import.\");\n        }\n        this.uuidBehavior = uuidBehavior;\n        userID = sd.getAuthInfo().getUserID();\n        importTargetTree = root.getTree(oakPath);\n        if (!importTargetTree.exists()) {\n            throw new javax.jcr.PathNotFoundException(absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.session.WorkspaceImpl wsp = sessionContext.getWorkspace();\n        javax.jcr.version.VersionManager vMgr = wsp.getVersionManager();\n        if (!vMgr.isCheckedOut(absPath)) {\n            throw new javax.jcr.version.VersionException(\"Target node is checked in.\");\n        }\n        if ((importTargetTree.getStatus() != Tree.Status.NEW) && wsp.getLockManager().isLocked(absPath)) {\n            throw new javax.jcr.lock.LockException(\"Target node is locked.\");\n        }\n        effectiveNodeTypeProvider = wsp.getNodeTypeManager();\n        definitionProvider = wsp.getNodeTypeManager();\n        ntTypesRoot = root.getTree(org.apache.jackrabbit.oak.jcr.xml.NODE_TYPES_PATH);\n        accessManager = sessionContext.getAccessManager();\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot());\n        refTracker = new org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker();\n        parents = new java.util.Stack<org.apache.jackrabbit.oak.api.Tree>();\n        parents.push(importTargetTree);\n        pItemImporters.clear();\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {\n            if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {\n                pItemImporters.add(importer);\n            }\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree createTree(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree parent, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.xml.NodeInfo nInfo, @javax.annotation.CheckForNull\n    java.lang.String uuid) throws javax.jcr.RepositoryException {\n        java.lang.String ntName = nInfo.getPrimaryTypeName();\n        org.apache.jackrabbit.oak.api.Tree child = org.apache.jackrabbit.oak.util.TreeUtil.addChild(parent, nInfo.getName(), ntName, ntTypesRoot, userID);\n        if (ntName != null) {\n            accessManager.checkPermissions(child, child.getProperty(JcrConstants.JCR_PRIMARYTYPE), Permissions.NODE_TYPE_MANAGEMENT);\n        }\n        if (uuid != null) {\n            child.setProperty(JcrConstants.JCR_UUID, uuid);\n        }\n        for (java.lang.String mixin : nInfo.getMixinTypeNames()) {\n            org.apache.jackrabbit.oak.util.TreeUtil.addMixin(child, mixin, ntTypesRoot, userID);\n        }\n        return child;\n    }\n\n    private void createProperty(org.apache.jackrabbit.oak.api.Tree tree, org.apache.jackrabbit.oak.spi.xml.PropInfo pInfo, javax.jcr.nodetype.PropertyDefinition def) throws javax.jcr.RepositoryException {\n        java.util.List<javax.jcr.Value> values = pInfo.getValues(pInfo.getTargetType(def));\n        org.apache.jackrabbit.oak.api.PropertyState propertyState;\n        java.lang.String name = pInfo.getName();\n        int type = pInfo.getType();\n        if ((values.size() == 1) && (!def.isMultiple())) {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values.get(0));\n        } else {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values);\n        }\n        tree.setProperty(propertyState);\n        if ((type == javax.jcr.PropertyType.REFERENCE) || (type == javax.jcr.PropertyType.WEAKREFERENCE)) {\n            refTracker.processedReference(new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference(tree, name));\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree resolveUUIDConflict(org.apache.jackrabbit.oak.api.Tree parent, org.apache.jackrabbit.oak.api.Tree conflicting, java.lang.String conflictingId, org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree tree;\n        if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n            tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n            }\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW) {\n            java.lang.String msg = (\"a node with uuid \" + nodeInfo.getUUID()) + \" already exists!\";\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.ItemExistsException(msg);\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be removed\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (importTargetTree.getPath().startsWith(conflicting.getPath())) {\n                java.lang.String msg = \"cannot remove ancestor node\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.nodetype.ConstraintViolationException(msg);\n            }\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (conflicting.isRoot()) {\n                java.lang.String msg = \"root node cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            parent = conflicting.getParent();\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else {\n            java.lang.String msg = \"unknown uuidBehavior: \" + uuidBehavior;\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.RepositoryException(msg);\n        }\n        return tree;\n    }\n\n    private void importProperties(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree tree, @javax.annotation.Nonnull\n    java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos, boolean ignoreRegular) throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.PropInfo pi : propInfos) {\n            javax.jcr.nodetype.PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\n            if (def.isProtected()) {\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property \" + pi.getName());\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n                    if (ppi.handlePropInfo(tree, pi, def)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                        break;\n                    }\n                }\n            } else if (!ignoreRegular) {\n                createProperty(tree, pi, def);\n            }\n        }\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n            ppi.propertiesCompleted(tree);\n        }\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter> getPropertyImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter> getNodeImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    @java.lang.Override\n    public void start() throws javax.jcr.RepositoryException {\n    }\n\n    @java.lang.Override\n    public void startNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo, java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.peek();\n        org.apache.jackrabbit.oak.api.Tree tree = null;\n        java.lang.String id = nodeInfo.getUUID();\n        java.lang.String nodeName = nodeInfo.getName();\n        java.lang.String ntName = nodeInfo.getPrimaryTypeName();\n        if (parent == null) {\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping node: \" + nodeName);\n            parents.push(null);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n        javax.jcr.nodetype.NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            parents.push(null);\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + nodeName);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    }\n                }\n            }\n            return;\n        }\n        if (parent.hasChild(nodeName)) {\n            org.apache.jackrabbit.oak.api.Tree existing = parent.getChild(nodeName);\n            javax.jcr.nodetype.NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    tree = existing;\n                } else {\n                    java.lang.String existingIdentifier = org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id) && ((uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) || (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING)))) {\n                        throw new javax.jcr.ItemExistsException(\"Node with the same UUID exists:\" + existing);\n                    }\n                }\n            }\n        }\n        if (tree == null) {\n            if (id == null) {\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n                org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n                if (conflicting == null) {\n                    if (uuids.contains(id)) {\n                        conflicting = currentStateIdManager.getTree(id);\n                    }\n                } else {\n                    conflicting = currentStateIdManager.getTree(id);\n                }\n                if ((conflicting != null) && conflicting.exists()) {\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        parents.push(null);\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n        importProperties(tree, propInfos, false);\n        parents.push(tree);\n    }\n\n    @java.lang.Override\n    public void endNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.pop();\n        if (parent == null) {\n            if (pnImporter != null) {\n                pnImporter.endChildInfo();\n            }\n        } else if (getDefinition(parent).isProtected()) {\n            if (pnImporter != null) {\n                pnImporter.end(parent);\n                pnImporter = null;\n            }\n        }\n        collectUUIDs(parent);\n    }\n\n    private void collectUUIDs(org.apache.jackrabbit.oak.api.Tree tree) {\n        if (tree == null) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            uuids.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            collectUUIDs(child);\n        }\n    }\n\n    @java.lang.Override\n    public void end() throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter ppi : pItemImporters) {\n            ppi.processReferences();\n        }\n        java.util.Iterator<java.lang.Object> iter = refTracker.getProcessedReferences();\n        while (iter.hasNext()) {\n            java.lang.Object ref = iter.next();\n            if (!(ref instanceof org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference reference = ((org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference) (ref));\n            if (reference.isMultiple()) {\n                java.lang.Iterable<java.lang.String> values = reference.property.getValue(Type.STRINGS);\n                java.util.List<java.lang.String> newValues = com.google.common.collect.Lists.newArrayList();\n                for (java.lang.String original : values) {\n                    java.lang.String adjusted = refTracker.get(original);\n                    if (adjusted != null) {\n                        newValues.add(adjusted);\n                    } else {\n                        newValues.add(original);\n                    }\n                }\n                reference.setProperty(newValues);\n            } else {\n                java.lang.String original = reference.property.getValue(Type.STRING);\n                java.lang.String adjusted = refTracker.get(original);\n                if (adjusted != null) {\n                    reference.setProperty(adjusted);\n                }\n            }\n        } \n        refTracker.clear();\n    }\n\n    private boolean isNodeType(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String ntName) throws javax.jcr.RepositoryException {\n        return effectiveNodeTypeProvider.isNodeType(tree, ntName);\n    }\n\n    private javax.jcr.nodetype.NodeDefinition getDefinition(org.apache.jackrabbit.oak.api.Tree tree) throws javax.jcr.RepositoryException {\n        if (tree.isRoot()) {\n            return definitionProvider.getRootDefinition();\n        } else {\n            return definitionProvider.getDefinition(tree.getParent(), tree);\n        }\n    }\n\n    private static final class Reference {\n        private final org.apache.jackrabbit.oak.api.Tree tree;\n\n        private final org.apache.jackrabbit.oak.api.PropertyState property;\n\n        private Reference(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String propertyName) {\n            this.tree = tree;\n            this.property = tree.getProperty(propertyName);\n        }\n\n        private boolean isMultiple() {\n            return property.isArray();\n        }\n\n        private void setProperty(java.lang.String newValue) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());\n            tree.setProperty(prop);\n        }\n\n        private void setProperty(java.lang.Iterable<java.lang.String> newValues) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValues, property.getType());\n            tree.setProperty(prop);\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Field",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "TypeReference",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver",
            "dst_parent": "private final org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver idLookup;",
            "dst_parent_type": "Field",
            "dst_type": "TypeReference",
            "operator": "UPD",
            "src": "java.util.Set<java.lang.String>",
            "src_parent": "private final java.util.Set<java.lang.String> uuids = new java.util.HashSet<java.lang.String>();",
            "src_parent_type": "Field",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "idLookup.rememberImportedUUIDs(parent)",
            "dst_parent": "{\n    org.apache.jackrabbit.oak.api.Tree parent = parents.pop();\n    if (parent == null) {\n        if (pnImporter != null) {\n            pnImporter.endChildInfo();\n        }\n    } else if (getDefinition(parent).isProtected()) {\n        if (pnImporter != null) {\n            pnImporter.end(parent);\n            pnImporter = null;\n        }\n    }\n    idLookup.rememberImportedUUIDs(parent);\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "collectUUIDs(parent)",
            "src_parent": "{\n    org.apache.jackrabbit.oak.api.Tree parent = parents.pop();\n    if (parent == null) {\n        if (pnImporter != null) {\n            pnImporter.endChildInfo();\n        }\n    } else if (getDefinition(parent).isProtected()) {\n        if (pnImporter != null) {\n            pnImporter.end(parent);\n            pnImporter = null;\n        }\n    }\n    collectUUIDs(parent);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private void rememberImportedUUIDs(@javax.annotation.CheckForNull\norg.apache.jackrabbit.oak.api.Tree tree) {\n    if ((tree == null) || (importedUUIDs == null)) {\n        return;\n    }\n    java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n    if (uuid != null) {\n        importedUUIDs.add(uuid);\n    }\n    for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n        rememberImportedUUIDs(child);\n    }\n}",
            "dst_parent": "private static final class IdResolver {\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final java.util.Set<java.lang.String> importedUUIDs;\n\n    private IdResolver(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Root root, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.ContentSession contentSession) {\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(contentSession.getLatestRoot());\n        if (!root.hasPendingChanges()) {\n            importedUUIDs = new java.util.HashSet<java.lang.String>();\n        } else {\n            importedUUIDs = null;\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.api.Tree getConflictingTree(@javax.annotation.Nonnull\n    java.lang.String id) {\n        org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n        if ((conflicting == null) && (importedUUIDs != null)) {\n            if (importedUUIDs.contains(id)) {\n                conflicting = currentStateIdManager.getTree(id);\n            }\n        } else {\n            conflicting = currentStateIdManager.getTree(id);\n        }\n        return conflicting;\n    }\n\n    private void rememberImportedUUIDs(@javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.api.Tree tree) {\n        if ((tree == null) || (importedUUIDs == null)) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            importedUUIDs.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            rememberImportedUUIDs(child);\n        }\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "private void collectUUIDs(org.apache.jackrabbit.oak.api.Tree tree) {\n    if (tree == null) {\n        return;\n    }\n    java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n    if (uuid != null) {\n        uuids.add(uuid);\n    }\n    for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n        collectUUIDs(child);\n    }\n}",
            "src_parent": "public class ImporterImpl implements org.apache.jackrabbit.oak.spi.xml.Importer {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.class);\n\n    private final org.apache.jackrabbit.oak.api.Tree importTargetTree;\n\n    private final org.apache.jackrabbit.oak.api.Tree ntTypesRoot;\n\n    private final int uuidBehavior;\n\n    private final java.lang.String userID;\n\n    private final org.apache.jackrabbit.oak.jcr.security.AccessManager accessManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.DefinitionProvider definitionProvider;\n\n    private final java.util.Set<java.lang.String> uuids = new java.util.HashSet<java.lang.String>();\n\n    private final java.util.Stack<org.apache.jackrabbit.oak.api.Tree> parents;\n\n    private final org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker refTracker;\n\n    private final java.util.List<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter> pItemImporters = new java.util.ArrayList<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter>();\n\n    private org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pnImporter;\n\n    public ImporterImpl(java.lang.String absPath, org.apache.jackrabbit.oak.jcr.session.SessionContext sessionContext, org.apache.jackrabbit.oak.api.Root root, int uuidBehavior, boolean isWorkspaceImport) throws javax.jcr.RepositoryException {\n        java.lang.String oakPath = sessionContext.getOakPath(absPath);\n        if (oakPath == null) {\n            throw new javax.jcr.RepositoryException(\"Invalid name or path: \" + absPath);\n        }\n        if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(oakPath)) {\n            throw new javax.jcr.RepositoryException(\"Not an absolute path: \" + absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate sd = sessionContext.getSessionDelegate();\n        if (isWorkspaceImport && sd.hasPendingChanges()) {\n            throw new javax.jcr.RepositoryException(\"Pending changes on session. Cannot run workspace import.\");\n        }\n        this.uuidBehavior = uuidBehavior;\n        userID = sd.getAuthInfo().getUserID();\n        importTargetTree = root.getTree(oakPath);\n        if (!importTargetTree.exists()) {\n            throw new javax.jcr.PathNotFoundException(absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.session.WorkspaceImpl wsp = sessionContext.getWorkspace();\n        javax.jcr.version.VersionManager vMgr = wsp.getVersionManager();\n        if (!vMgr.isCheckedOut(absPath)) {\n            throw new javax.jcr.version.VersionException(\"Target node is checked in.\");\n        }\n        if ((importTargetTree.getStatus() != Tree.Status.NEW) && wsp.getLockManager().isLocked(absPath)) {\n            throw new javax.jcr.lock.LockException(\"Target node is locked.\");\n        }\n        effectiveNodeTypeProvider = wsp.getNodeTypeManager();\n        definitionProvider = wsp.getNodeTypeManager();\n        ntTypesRoot = root.getTree(org.apache.jackrabbit.oak.jcr.xml.NODE_TYPES_PATH);\n        accessManager = sessionContext.getAccessManager();\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot());\n        refTracker = new org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker();\n        parents = new java.util.Stack<org.apache.jackrabbit.oak.api.Tree>();\n        parents.push(importTargetTree);\n        pItemImporters.clear();\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {\n            if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {\n                pItemImporters.add(importer);\n            }\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree createTree(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree parent, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.xml.NodeInfo nInfo, @javax.annotation.CheckForNull\n    java.lang.String uuid) throws javax.jcr.RepositoryException {\n        java.lang.String ntName = nInfo.getPrimaryTypeName();\n        org.apache.jackrabbit.oak.api.Tree child = org.apache.jackrabbit.oak.util.TreeUtil.addChild(parent, nInfo.getName(), ntName, ntTypesRoot, userID);\n        if (ntName != null) {\n            accessManager.checkPermissions(child, child.getProperty(JcrConstants.JCR_PRIMARYTYPE), Permissions.NODE_TYPE_MANAGEMENT);\n        }\n        if (uuid != null) {\n            child.setProperty(JcrConstants.JCR_UUID, uuid);\n        }\n        for (java.lang.String mixin : nInfo.getMixinTypeNames()) {\n            org.apache.jackrabbit.oak.util.TreeUtil.addMixin(child, mixin, ntTypesRoot, userID);\n        }\n        return child;\n    }\n\n    private void createProperty(org.apache.jackrabbit.oak.api.Tree tree, org.apache.jackrabbit.oak.spi.xml.PropInfo pInfo, javax.jcr.nodetype.PropertyDefinition def) throws javax.jcr.RepositoryException {\n        java.util.List<javax.jcr.Value> values = pInfo.getValues(pInfo.getTargetType(def));\n        org.apache.jackrabbit.oak.api.PropertyState propertyState;\n        java.lang.String name = pInfo.getName();\n        int type = pInfo.getType();\n        if ((values.size() == 1) && (!def.isMultiple())) {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values.get(0));\n        } else {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values);\n        }\n        tree.setProperty(propertyState);\n        if ((type == javax.jcr.PropertyType.REFERENCE) || (type == javax.jcr.PropertyType.WEAKREFERENCE)) {\n            refTracker.processedReference(new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference(tree, name));\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree resolveUUIDConflict(org.apache.jackrabbit.oak.api.Tree parent, org.apache.jackrabbit.oak.api.Tree conflicting, java.lang.String conflictingId, org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree tree;\n        if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n            tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n            }\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW) {\n            java.lang.String msg = (\"a node with uuid \" + nodeInfo.getUUID()) + \" already exists!\";\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.ItemExistsException(msg);\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be removed\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (importTargetTree.getPath().startsWith(conflicting.getPath())) {\n                java.lang.String msg = \"cannot remove ancestor node\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.nodetype.ConstraintViolationException(msg);\n            }\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (conflicting.isRoot()) {\n                java.lang.String msg = \"root node cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            parent = conflicting.getParent();\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else {\n            java.lang.String msg = \"unknown uuidBehavior: \" + uuidBehavior;\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.RepositoryException(msg);\n        }\n        return tree;\n    }\n\n    private void importProperties(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree tree, @javax.annotation.Nonnull\n    java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos, boolean ignoreRegular) throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.PropInfo pi : propInfos) {\n            javax.jcr.nodetype.PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\n            if (def.isProtected()) {\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property \" + pi.getName());\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n                    if (ppi.handlePropInfo(tree, pi, def)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                        break;\n                    }\n                }\n            } else if (!ignoreRegular) {\n                createProperty(tree, pi, def);\n            }\n        }\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n            ppi.propertiesCompleted(tree);\n        }\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter> getPropertyImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter> getNodeImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    @java.lang.Override\n    public void start() throws javax.jcr.RepositoryException {\n    }\n\n    @java.lang.Override\n    public void startNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo, java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.peek();\n        org.apache.jackrabbit.oak.api.Tree tree = null;\n        java.lang.String id = nodeInfo.getUUID();\n        java.lang.String nodeName = nodeInfo.getName();\n        java.lang.String ntName = nodeInfo.getPrimaryTypeName();\n        if (parent == null) {\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping node: \" + nodeName);\n            parents.push(null);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n        javax.jcr.nodetype.NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            parents.push(null);\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + nodeName);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    }\n                }\n            }\n            return;\n        }\n        if (parent.hasChild(nodeName)) {\n            org.apache.jackrabbit.oak.api.Tree existing = parent.getChild(nodeName);\n            javax.jcr.nodetype.NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    tree = existing;\n                } else {\n                    java.lang.String existingIdentifier = org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id) && ((uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) || (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING)))) {\n                        throw new javax.jcr.ItemExistsException(\"Node with the same UUID exists:\" + existing);\n                    }\n                }\n            }\n        }\n        if (tree == null) {\n            if (id == null) {\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n                org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n                if (conflicting == null) {\n                    if (uuids.contains(id)) {\n                        conflicting = currentStateIdManager.getTree(id);\n                    }\n                } else {\n                    conflicting = currentStateIdManager.getTree(id);\n                }\n                if ((conflicting != null) && conflicting.exists()) {\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        parents.push(null);\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n        importProperties(tree, propInfos, false);\n        parents.push(tree);\n    }\n\n    @java.lang.Override\n    public void endNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.pop();\n        if (parent == null) {\n            if (pnImporter != null) {\n                pnImporter.endChildInfo();\n            }\n        } else if (getDefinition(parent).isProtected()) {\n            if (pnImporter != null) {\n                pnImporter.end(parent);\n                pnImporter = null;\n            }\n        }\n        collectUUIDs(parent);\n    }\n\n    private void collectUUIDs(org.apache.jackrabbit.oak.api.Tree tree) {\n        if (tree == null) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            uuids.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            collectUUIDs(child);\n        }\n    }\n\n    @java.lang.Override\n    public void end() throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter ppi : pItemImporters) {\n            ppi.processReferences();\n        }\n        java.util.Iterator<java.lang.Object> iter = refTracker.getProcessedReferences();\n        while (iter.hasNext()) {\n            java.lang.Object ref = iter.next();\n            if (!(ref instanceof org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference reference = ((org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference) (ref));\n            if (reference.isMultiple()) {\n                java.lang.Iterable<java.lang.String> values = reference.property.getValue(Type.STRINGS);\n                java.util.List<java.lang.String> newValues = com.google.common.collect.Lists.newArrayList();\n                for (java.lang.String original : values) {\n                    java.lang.String adjusted = refTracker.get(original);\n                    if (adjusted != null) {\n                        newValues.add(adjusted);\n                    } else {\n                        newValues.add(original);\n                    }\n                }\n                reference.setProperty(newValues);\n            } else {\n                java.lang.String original = reference.property.getValue(Type.STRING);\n                java.lang.String adjusted = refTracker.get(original);\n                if (adjusted != null) {\n                    reference.setProperty(adjusted);\n                }\n            }\n        } \n        refTracker.clear();\n    }\n\n    private boolean isNodeType(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String ntName) throws javax.jcr.RepositoryException {\n        return effectiveNodeTypeProvider.isNodeType(tree, ntName);\n    }\n\n    private javax.jcr.nodetype.NodeDefinition getDefinition(org.apache.jackrabbit.oak.api.Tree tree) throws javax.jcr.RepositoryException {\n        if (tree.isRoot()) {\n            return definitionProvider.getRootDefinition();\n        } else {\n            return definitionProvider.getDefinition(tree.getParent(), tree);\n        }\n    }\n\n    private static final class Reference {\n        private final org.apache.jackrabbit.oak.api.Tree tree;\n\n        private final org.apache.jackrabbit.oak.api.PropertyState property;\n\n        private Reference(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String propertyName) {\n            this.tree = tree;\n            this.property = tree.getProperty(propertyName);\n        }\n\n        private boolean isMultiple() {\n            return property.isArray();\n        }\n\n        private void setProperty(java.lang.String newValue) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());\n            tree.setProperty(prop);\n        }\n\n        private void setProperty(java.lang.Iterable<java.lang.String> newValues) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValues, property.getType());\n            tree.setProperty(prop);\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "idLookup",
            "dst_parent": "idLookup = new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver(root, sd.getContentSession())",
            "dst_parent_type": "Assignment",
            "dst_type": "FieldWrite",
            "operator": "UPD",
            "src": "currentStateIdManager",
            "src_parent": "currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root)",
            "src_parent_type": "Assignment",
            "src_type": "FieldWrite"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver(root, sd.getContentSession())",
            "dst_parent": "idLookup = new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver(root, sd.getContentSession())",
            "dst_parent_type": "Assignment",
            "dst_type": "ConstructorCall",
            "operator": "UPD",
            "src": "new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot())",
            "src_parent": "baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot())",
            "src_parent_type": "Assignment",
            "src_type": "ConstructorCall"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "rememberImportedUUIDs(child)",
            "dst_parent": "{\n    rememberImportedUUIDs(child);\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "collectUUIDs(child)",
            "src_parent": "{\n    collectUUIDs(child);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver",
            "dst_parent": "",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "UPD",
            "src": "org.apache.jackrabbit.oak.jcr.xml.ImporterImpl",
            "src_parent": "",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "importedUUIDs",
            "dst_parent": "importedUUIDs.add(uuid)",
            "dst_parent_type": "Invocation",
            "dst_type": "FieldRead",
            "operator": "UPD",
            "src": "uuids",
            "src_parent": "uuids.add(uuid)",
            "src_parent_type": "Invocation",
            "src_type": "FieldRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver",
            "dst_parent": "",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "UPD",
            "src": "org.apache.jackrabbit.oak.jcr.xml.ImporterImpl",
            "src_parent": "",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "idLookup.getConflictingTree(id)",
            "dst_parent": "org.apache.jackrabbit.oak.api.Tree conflicting = idLookup.getConflictingTree(id)",
            "dst_parent_type": "LocalVariable",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "baseStateIdManager.getTree(id)",
            "src_parent": "org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id)",
            "src_parent_type": "LocalVariable",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "idLookup",
            "dst_parent": "idLookup.getConflictingTree(id)",
            "dst_parent_type": "Invocation",
            "dst_type": "FieldRead",
            "operator": "UPD",
            "src": "baseStateIdManager",
            "src_parent": "baseStateIdManager.getTree(id)",
            "src_parent_type": "Invocation",
            "src_type": "FieldRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot())",
            "src_parent": "{\n    java.lang.String oakPath = sessionContext.getOakPath(absPath);\n    if (oakPath == null) {\n        throw new javax.jcr.RepositoryException(\"Invalid name or path: \" + absPath);\n    }\n    if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(oakPath)) {\n        throw new javax.jcr.RepositoryException(\"Not an absolute path: \" + absPath);\n    }\n    org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate sd = sessionContext.getSessionDelegate();\n    if (isWorkspaceImport && sd.hasPendingChanges()) {\n        throw new javax.jcr.RepositoryException(\"Pending changes on session. Cannot run workspace import.\");\n    }\n    this.uuidBehavior = uuidBehavior;\n    userID = sd.getAuthInfo().getUserID();\n    importTargetTree = root.getTree(oakPath);\n    if (!importTargetTree.exists()) {\n        throw new javax.jcr.PathNotFoundException(absPath);\n    }\n    org.apache.jackrabbit.oak.jcr.session.WorkspaceImpl wsp = sessionContext.getWorkspace();\n    javax.jcr.version.VersionManager vMgr = wsp.getVersionManager();\n    if (!vMgr.isCheckedOut(absPath)) {\n        throw new javax.jcr.version.VersionException(\"Target node is checked in.\");\n    }\n    if ((importTargetTree.getStatus() != Tree.Status.NEW) && wsp.getLockManager().isLocked(absPath)) {\n        throw new javax.jcr.lock.LockException(\"Target node is locked.\");\n    }\n    effectiveNodeTypeProvider = wsp.getNodeTypeManager();\n    definitionProvider = wsp.getNodeTypeManager();\n    ntTypesRoot = root.getTree(org.apache.jackrabbit.oak.jcr.xml.NODE_TYPES_PATH);\n    accessManager = sessionContext.getAccessManager();\n    currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n    baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot());\n    refTracker = new org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker();\n    parents = new java.util.Stack<org.apache.jackrabbit.oak.api.Tree>();\n    parents.push(importTargetTree);\n    pItemImporters.clear();\n    for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {\n        if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {\n            pItemImporters.add(importer);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "if (conflicting == null) {\n    if (uuids.contains(id)) {\n        conflicting = currentStateIdManager.getTree(id);\n    }\n} else {\n    conflicting = currentStateIdManager.getTree(id);\n}",
            "src_parent": "{\n    org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n    if (conflicting == null) {\n        if (uuids.contains(id)) {\n            conflicting = currentStateIdManager.getTree(id);\n        }\n    } else {\n        conflicting = currentStateIdManager.getTree(id);\n    }\n    if ((conflicting != null) && conflicting.exists()) {\n        tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n        if (tree == null) {\n            parents.push(null);\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping existing node \" + nodeInfo.getName());\n            return;\n        }\n    } else {\n        tree = createTree(parent, nodeInfo, id);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static final class IdResolver {\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final java.util.Set<java.lang.String> importedUUIDs;\n\n    private IdResolver(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Root root, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.ContentSession contentSession) {\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(contentSession.getLatestRoot());\n        if (!root.hasPendingChanges()) {\n            importedUUIDs = new java.util.HashSet<java.lang.String>();\n        } else {\n            importedUUIDs = null;\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.api.Tree getConflictingTree(@javax.annotation.Nonnull\n    java.lang.String id) {\n        org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n        if ((conflicting == null) && (importedUUIDs != null)) {\n            if (importedUUIDs.contains(id)) {\n                conflicting = currentStateIdManager.getTree(id);\n            }\n        } else {\n            conflicting = currentStateIdManager.getTree(id);\n        }\n        return conflicting;\n    }\n\n    private void rememberImportedUUIDs(@javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.api.Tree tree) {\n        if ((tree == null) || (importedUUIDs == null)) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            importedUUIDs.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            rememberImportedUUIDs(child);\n        }\n    }\n}",
            "src_parent": "public class ImporterImpl implements org.apache.jackrabbit.oak.spi.xml.Importer {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.class);\n\n    private final org.apache.jackrabbit.oak.api.Tree importTargetTree;\n\n    private final org.apache.jackrabbit.oak.api.Tree ntTypesRoot;\n\n    private final int uuidBehavior;\n\n    private final java.lang.String userID;\n\n    private final org.apache.jackrabbit.oak.jcr.security.AccessManager accessManager;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.DefinitionProvider definitionProvider;\n\n    private final org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver idLookup;\n\n    private final java.util.Stack<org.apache.jackrabbit.oak.api.Tree> parents;\n\n    private final org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker refTracker;\n\n    private final java.util.List<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter> pItemImporters = new java.util.ArrayList<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter>();\n\n    private org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pnImporter;\n\n    public ImporterImpl(java.lang.String absPath, org.apache.jackrabbit.oak.jcr.session.SessionContext sessionContext, org.apache.jackrabbit.oak.api.Root root, int uuidBehavior, boolean isWorkspaceImport) throws javax.jcr.RepositoryException {\n        java.lang.String oakPath = sessionContext.getOakPath(absPath);\n        if (oakPath == null) {\n            throw new javax.jcr.RepositoryException(\"Invalid name or path: \" + absPath);\n        }\n        if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(oakPath)) {\n            throw new javax.jcr.RepositoryException(\"Not an absolute path: \" + absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate sd = sessionContext.getSessionDelegate();\n        if (isWorkspaceImport && sd.hasPendingChanges()) {\n            throw new javax.jcr.RepositoryException(\"Pending changes on session. Cannot run workspace import.\");\n        }\n        this.uuidBehavior = uuidBehavior;\n        userID = sd.getAuthInfo().getUserID();\n        importTargetTree = root.getTree(oakPath);\n        if (!importTargetTree.exists()) {\n            throw new javax.jcr.PathNotFoundException(absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.session.WorkspaceImpl wsp = sessionContext.getWorkspace();\n        javax.jcr.version.VersionManager vMgr = wsp.getVersionManager();\n        if (!vMgr.isCheckedOut(absPath)) {\n            throw new javax.jcr.version.VersionException(\"Target node is checked in.\");\n        }\n        if ((importTargetTree.getStatus() != Tree.Status.NEW) && wsp.getLockManager().isLocked(absPath)) {\n            throw new javax.jcr.lock.LockException(\"Target node is locked.\");\n        }\n        effectiveNodeTypeProvider = wsp.getNodeTypeManager();\n        definitionProvider = wsp.getNodeTypeManager();\n        ntTypesRoot = root.getTree(org.apache.jackrabbit.oak.jcr.xml.NODE_TYPES_PATH);\n        accessManager = sessionContext.getAccessManager();\n        idLookup = new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver(root, sd.getContentSession());\n        refTracker = new org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker();\n        parents = new java.util.Stack<org.apache.jackrabbit.oak.api.Tree>();\n        parents.push(importTargetTree);\n        pItemImporters.clear();\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {\n            if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {\n                pItemImporters.add(importer);\n            }\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree createTree(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree parent, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.xml.NodeInfo nInfo, @javax.annotation.CheckForNull\n    java.lang.String uuid) throws javax.jcr.RepositoryException {\n        java.lang.String ntName = nInfo.getPrimaryTypeName();\n        org.apache.jackrabbit.oak.api.Tree child = org.apache.jackrabbit.oak.util.TreeUtil.addChild(parent, nInfo.getName(), ntName, ntTypesRoot, userID);\n        if (ntName != null) {\n            accessManager.checkPermissions(child, child.getProperty(JcrConstants.JCR_PRIMARYTYPE), Permissions.NODE_TYPE_MANAGEMENT);\n        }\n        if (uuid != null) {\n            child.setProperty(JcrConstants.JCR_UUID, uuid);\n        }\n        for (java.lang.String mixin : nInfo.getMixinTypeNames()) {\n            org.apache.jackrabbit.oak.util.TreeUtil.addMixin(child, mixin, ntTypesRoot, userID);\n        }\n        return child;\n    }\n\n    private void createProperty(org.apache.jackrabbit.oak.api.Tree tree, org.apache.jackrabbit.oak.spi.xml.PropInfo pInfo, javax.jcr.nodetype.PropertyDefinition def) throws javax.jcr.RepositoryException {\n        java.util.List<javax.jcr.Value> values = pInfo.getValues(pInfo.getTargetType(def));\n        org.apache.jackrabbit.oak.api.PropertyState propertyState;\n        java.lang.String name = pInfo.getName();\n        int type = pInfo.getType();\n        if ((values.size() == 1) && (!def.isMultiple())) {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values.get(0));\n        } else {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values);\n        }\n        tree.setProperty(propertyState);\n        if ((type == javax.jcr.PropertyType.REFERENCE) || (type == javax.jcr.PropertyType.WEAKREFERENCE)) {\n            refTracker.processedReference(new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference(tree, name));\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree resolveUUIDConflict(org.apache.jackrabbit.oak.api.Tree parent, org.apache.jackrabbit.oak.api.Tree conflicting, java.lang.String conflictingId, org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree tree;\n        if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n            tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n            }\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW) {\n            java.lang.String msg = (\"a node with uuid \" + nodeInfo.getUUID()) + \" already exists!\";\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.ItemExistsException(msg);\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be removed\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (importTargetTree.getPath().startsWith(conflicting.getPath())) {\n                java.lang.String msg = \"cannot remove ancestor node\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.nodetype.ConstraintViolationException(msg);\n            }\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (conflicting.isRoot()) {\n                java.lang.String msg = \"root node cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            parent = conflicting.getParent();\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else {\n            java.lang.String msg = \"unknown uuidBehavior: \" + uuidBehavior;\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.RepositoryException(msg);\n        }\n        return tree;\n    }\n\n    private void importProperties(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree tree, @javax.annotation.Nonnull\n    java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos, boolean ignoreRegular) throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.PropInfo pi : propInfos) {\n            javax.jcr.nodetype.PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\n            if (def.isProtected()) {\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property \" + pi.getName());\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n                    if (ppi.handlePropInfo(tree, pi, def)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                        break;\n                    }\n                }\n            } else if (!ignoreRegular) {\n                createProperty(tree, pi, def);\n            }\n        }\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n            ppi.propertiesCompleted(tree);\n        }\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter> getPropertyImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter> getNodeImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    @java.lang.Override\n    public void start() throws javax.jcr.RepositoryException {\n    }\n\n    @java.lang.Override\n    public void startNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo, java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.peek();\n        org.apache.jackrabbit.oak.api.Tree tree = null;\n        java.lang.String id = nodeInfo.getUUID();\n        java.lang.String nodeName = nodeInfo.getName();\n        java.lang.String ntName = nodeInfo.getPrimaryTypeName();\n        if (parent == null) {\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping node: \" + nodeName);\n            parents.push(null);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n        javax.jcr.nodetype.NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            parents.push(null);\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + nodeName);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    }\n                }\n            }\n            return;\n        }\n        if (parent.hasChild(nodeName)) {\n            org.apache.jackrabbit.oak.api.Tree existing = parent.getChild(nodeName);\n            javax.jcr.nodetype.NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    tree = existing;\n                } else {\n                    java.lang.String existingIdentifier = org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id) && ((uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) || (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING)))) {\n                        throw new javax.jcr.ItemExistsException(\"Node with the same UUID exists:\" + existing);\n                    }\n                }\n            }\n        }\n        if (tree == null) {\n            if (id == null) {\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n                org.apache.jackrabbit.oak.api.Tree conflicting = idLookup.getConflictingTree(id);\n                if ((conflicting != null) && conflicting.exists()) {\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        parents.push(null);\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n        importProperties(tree, propInfos, false);\n        parents.push(tree);\n    }\n\n    @java.lang.Override\n    public void endNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.pop();\n        if (parent == null) {\n            if (pnImporter != null) {\n                pnImporter.endChildInfo();\n            }\n        } else if (getDefinition(parent).isProtected()) {\n            if (pnImporter != null) {\n                pnImporter.end(parent);\n                pnImporter = null;\n            }\n        }\n        idLookup.rememberImportedUUIDs(parent);\n    }\n\n    @java.lang.Override\n    public void end() throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter ppi : pItemImporters) {\n            ppi.processReferences();\n        }\n        java.util.Iterator<java.lang.Object> iter = refTracker.getProcessedReferences();\n        while (iter.hasNext()) {\n            java.lang.Object ref = iter.next();\n            if (!(ref instanceof org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference reference = ((org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference) (ref));\n            if (reference.isMultiple()) {\n                java.lang.Iterable<java.lang.String> values = reference.property.getValue(Type.STRINGS);\n                java.util.List<java.lang.String> newValues = com.google.common.collect.Lists.newArrayList();\n                for (java.lang.String original : values) {\n                    java.lang.String adjusted = refTracker.get(original);\n                    if (adjusted != null) {\n                        newValues.add(adjusted);\n                    } else {\n                        newValues.add(original);\n                    }\n                }\n                reference.setProperty(newValues);\n            } else {\n                java.lang.String original = reference.property.getValue(Type.STRING);\n                java.lang.String adjusted = refTracker.get(original);\n                if (adjusted != null) {\n                    reference.setProperty(adjusted);\n                }\n            }\n        } \n        refTracker.clear();\n    }\n\n    private boolean isNodeType(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String ntName) throws javax.jcr.RepositoryException {\n        return effectiveNodeTypeProvider.isNodeType(tree, ntName);\n    }\n\n    private javax.jcr.nodetype.NodeDefinition getDefinition(org.apache.jackrabbit.oak.api.Tree tree) throws javax.jcr.RepositoryException {\n        if (tree.isRoot()) {\n            return definitionProvider.getRootDefinition();\n        } else {\n            return definitionProvider.getDefinition(tree.getParent(), tree);\n        }\n    }\n\n    private static final class Reference {\n        private final org.apache.jackrabbit.oak.api.Tree tree;\n\n        private final org.apache.jackrabbit.oak.api.PropertyState property;\n\n        private Reference(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String propertyName) {\n            this.tree = tree;\n            this.property = tree.getProperty(propertyName);\n        }\n\n        private boolean isMultiple() {\n            return property.isArray();\n        }\n\n        private void setProperty(java.lang.String newValue) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());\n            tree.setProperty(prop);\n        }\n\n        private void setProperty(java.lang.Iterable<java.lang.String> newValues) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValues, property.getType());\n            tree.setProperty(prop);\n        }\n    }\n\n    private static final class IdResolver {\n        private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n        private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n        private final java.util.Set<java.lang.String> importedUUIDs;\n\n        private IdResolver(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.api.Root root, @javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.api.ContentSession contentSession) {\n            currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n            baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(contentSession.getLatestRoot());\n            if (!root.hasPendingChanges()) {\n                importedUUIDs = new java.util.HashSet<java.lang.String>();\n            } else {\n                importedUUIDs = null;\n            }\n        }\n\n        @javax.annotation.CheckForNull\n        private org.apache.jackrabbit.oak.api.Tree getConflictingTree(@javax.annotation.Nonnull\n        java.lang.String id) {\n            org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n            if ((conflicting == null) && (importedUUIDs != null)) {\n                if (importedUUIDs.contains(id)) {\n                    conflicting = currentStateIdManager.getTree(id);\n                }\n            } else {\n                conflicting = currentStateIdManager.getTree(id);\n            }\n            return conflicting;\n        }\n\n        private void rememberImportedUUIDs(@javax.annotation.CheckForNull\n        org.apache.jackrabbit.oak.api.Tree tree) {\n            if ((tree == null) || (importedUUIDs == null)) {\n                return;\n            }\n            java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n            if (uuid != null) {\n                importedUUIDs.add(uuid);\n            }\n            for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n                rememberImportedUUIDs(child);\n            }\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Class"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Parameter",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "@javax.annotation.CheckForNull",
            "src_parent": "@javax.annotation.CheckForNull\norg.apache.jackrabbit.oak.api.Tree tree",
            "src_parent_type": "Parameter",
            "src_type": "Annotation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "(tree == null) || (importedUUIDs == null)",
            "src_parent": "if ((tree == null) || (importedUUIDs == null)) {\n    return;\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;",
            "dst_parent": "private static final class IdResolver {\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final java.util.Set<java.lang.String> importedUUIDs;\n\n    private IdResolver(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Root root, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.ContentSession contentSession) {\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(contentSession.getLatestRoot());\n        if (!root.hasPendingChanges()) {\n            importedUUIDs = new java.util.HashSet<java.lang.String>();\n        } else {\n            importedUUIDs = null;\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.api.Tree getConflictingTree(@javax.annotation.Nonnull\n    java.lang.String id) {\n        org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n        if ((conflicting == null) && (importedUUIDs != null)) {\n            if (importedUUIDs.contains(id)) {\n                conflicting = currentStateIdManager.getTree(id);\n            }\n        } else {\n            conflicting = currentStateIdManager.getTree(id);\n        }\n        return conflicting;\n    }\n\n    private void rememberImportedUUIDs(@javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.api.Tree tree) {\n        if ((tree == null) || (importedUUIDs == null)) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            importedUUIDs.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            rememberImportedUUIDs(child);\n        }\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Field",
            "operator": "MOV",
            "src": "private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;",
            "src_parent": "public class ImporterImpl implements org.apache.jackrabbit.oak.spi.xml.Importer {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.class);\n\n    private final org.apache.jackrabbit.oak.api.Tree importTargetTree;\n\n    private final org.apache.jackrabbit.oak.api.Tree ntTypesRoot;\n\n    private final int uuidBehavior;\n\n    private final java.lang.String userID;\n\n    private final org.apache.jackrabbit.oak.jcr.security.AccessManager accessManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.DefinitionProvider definitionProvider;\n\n    private final java.util.Set<java.lang.String> uuids = new java.util.HashSet<java.lang.String>();\n\n    private final java.util.Stack<org.apache.jackrabbit.oak.api.Tree> parents;\n\n    private final org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker refTracker;\n\n    private final java.util.List<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter> pItemImporters = new java.util.ArrayList<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter>();\n\n    private org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pnImporter;\n\n    public ImporterImpl(java.lang.String absPath, org.apache.jackrabbit.oak.jcr.session.SessionContext sessionContext, org.apache.jackrabbit.oak.api.Root root, int uuidBehavior, boolean isWorkspaceImport) throws javax.jcr.RepositoryException {\n        java.lang.String oakPath = sessionContext.getOakPath(absPath);\n        if (oakPath == null) {\n            throw new javax.jcr.RepositoryException(\"Invalid name or path: \" + absPath);\n        }\n        if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(oakPath)) {\n            throw new javax.jcr.RepositoryException(\"Not an absolute path: \" + absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate sd = sessionContext.getSessionDelegate();\n        if (isWorkspaceImport && sd.hasPendingChanges()) {\n            throw new javax.jcr.RepositoryException(\"Pending changes on session. Cannot run workspace import.\");\n        }\n        this.uuidBehavior = uuidBehavior;\n        userID = sd.getAuthInfo().getUserID();\n        importTargetTree = root.getTree(oakPath);\n        if (!importTargetTree.exists()) {\n            throw new javax.jcr.PathNotFoundException(absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.session.WorkspaceImpl wsp = sessionContext.getWorkspace();\n        javax.jcr.version.VersionManager vMgr = wsp.getVersionManager();\n        if (!vMgr.isCheckedOut(absPath)) {\n            throw new javax.jcr.version.VersionException(\"Target node is checked in.\");\n        }\n        if ((importTargetTree.getStatus() != Tree.Status.NEW) && wsp.getLockManager().isLocked(absPath)) {\n            throw new javax.jcr.lock.LockException(\"Target node is locked.\");\n        }\n        effectiveNodeTypeProvider = wsp.getNodeTypeManager();\n        definitionProvider = wsp.getNodeTypeManager();\n        ntTypesRoot = root.getTree(org.apache.jackrabbit.oak.jcr.xml.NODE_TYPES_PATH);\n        accessManager = sessionContext.getAccessManager();\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot());\n        refTracker = new org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker();\n        parents = new java.util.Stack<org.apache.jackrabbit.oak.api.Tree>();\n        parents.push(importTargetTree);\n        pItemImporters.clear();\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {\n            if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {\n                pItemImporters.add(importer);\n            }\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree createTree(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree parent, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.xml.NodeInfo nInfo, @javax.annotation.CheckForNull\n    java.lang.String uuid) throws javax.jcr.RepositoryException {\n        java.lang.String ntName = nInfo.getPrimaryTypeName();\n        org.apache.jackrabbit.oak.api.Tree child = org.apache.jackrabbit.oak.util.TreeUtil.addChild(parent, nInfo.getName(), ntName, ntTypesRoot, userID);\n        if (ntName != null) {\n            accessManager.checkPermissions(child, child.getProperty(JcrConstants.JCR_PRIMARYTYPE), Permissions.NODE_TYPE_MANAGEMENT);\n        }\n        if (uuid != null) {\n            child.setProperty(JcrConstants.JCR_UUID, uuid);\n        }\n        for (java.lang.String mixin : nInfo.getMixinTypeNames()) {\n            org.apache.jackrabbit.oak.util.TreeUtil.addMixin(child, mixin, ntTypesRoot, userID);\n        }\n        return child;\n    }\n\n    private void createProperty(org.apache.jackrabbit.oak.api.Tree tree, org.apache.jackrabbit.oak.spi.xml.PropInfo pInfo, javax.jcr.nodetype.PropertyDefinition def) throws javax.jcr.RepositoryException {\n        java.util.List<javax.jcr.Value> values = pInfo.getValues(pInfo.getTargetType(def));\n        org.apache.jackrabbit.oak.api.PropertyState propertyState;\n        java.lang.String name = pInfo.getName();\n        int type = pInfo.getType();\n        if ((values.size() == 1) && (!def.isMultiple())) {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values.get(0));\n        } else {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values);\n        }\n        tree.setProperty(propertyState);\n        if ((type == javax.jcr.PropertyType.REFERENCE) || (type == javax.jcr.PropertyType.WEAKREFERENCE)) {\n            refTracker.processedReference(new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference(tree, name));\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree resolveUUIDConflict(org.apache.jackrabbit.oak.api.Tree parent, org.apache.jackrabbit.oak.api.Tree conflicting, java.lang.String conflictingId, org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree tree;\n        if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n            tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n            }\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW) {\n            java.lang.String msg = (\"a node with uuid \" + nodeInfo.getUUID()) + \" already exists!\";\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.ItemExistsException(msg);\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be removed\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (importTargetTree.getPath().startsWith(conflicting.getPath())) {\n                java.lang.String msg = \"cannot remove ancestor node\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.nodetype.ConstraintViolationException(msg);\n            }\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (conflicting.isRoot()) {\n                java.lang.String msg = \"root node cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            parent = conflicting.getParent();\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else {\n            java.lang.String msg = \"unknown uuidBehavior: \" + uuidBehavior;\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.RepositoryException(msg);\n        }\n        return tree;\n    }\n\n    private void importProperties(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree tree, @javax.annotation.Nonnull\n    java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos, boolean ignoreRegular) throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.PropInfo pi : propInfos) {\n            javax.jcr.nodetype.PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\n            if (def.isProtected()) {\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property \" + pi.getName());\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n                    if (ppi.handlePropInfo(tree, pi, def)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                        break;\n                    }\n                }\n            } else if (!ignoreRegular) {\n                createProperty(tree, pi, def);\n            }\n        }\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n            ppi.propertiesCompleted(tree);\n        }\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter> getPropertyImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter> getNodeImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    @java.lang.Override\n    public void start() throws javax.jcr.RepositoryException {\n    }\n\n    @java.lang.Override\n    public void startNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo, java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.peek();\n        org.apache.jackrabbit.oak.api.Tree tree = null;\n        java.lang.String id = nodeInfo.getUUID();\n        java.lang.String nodeName = nodeInfo.getName();\n        java.lang.String ntName = nodeInfo.getPrimaryTypeName();\n        if (parent == null) {\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping node: \" + nodeName);\n            parents.push(null);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n        javax.jcr.nodetype.NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            parents.push(null);\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + nodeName);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    }\n                }\n            }\n            return;\n        }\n        if (parent.hasChild(nodeName)) {\n            org.apache.jackrabbit.oak.api.Tree existing = parent.getChild(nodeName);\n            javax.jcr.nodetype.NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    tree = existing;\n                } else {\n                    java.lang.String existingIdentifier = org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id) && ((uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) || (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING)))) {\n                        throw new javax.jcr.ItemExistsException(\"Node with the same UUID exists:\" + existing);\n                    }\n                }\n            }\n        }\n        if (tree == null) {\n            if (id == null) {\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n                org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n                if (conflicting == null) {\n                    if (uuids.contains(id)) {\n                        conflicting = currentStateIdManager.getTree(id);\n                    }\n                } else {\n                    conflicting = currentStateIdManager.getTree(id);\n                }\n                if ((conflicting != null) && conflicting.exists()) {\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        parents.push(null);\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n        importProperties(tree, propInfos, false);\n        parents.push(tree);\n    }\n\n    @java.lang.Override\n    public void endNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.pop();\n        if (parent == null) {\n            if (pnImporter != null) {\n                pnImporter.endChildInfo();\n            }\n        } else if (getDefinition(parent).isProtected()) {\n            if (pnImporter != null) {\n                pnImporter.end(parent);\n                pnImporter = null;\n            }\n        }\n        collectUUIDs(parent);\n    }\n\n    private void collectUUIDs(org.apache.jackrabbit.oak.api.Tree tree) {\n        if (tree == null) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            uuids.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            collectUUIDs(child);\n        }\n    }\n\n    @java.lang.Override\n    public void end() throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter ppi : pItemImporters) {\n            ppi.processReferences();\n        }\n        java.util.Iterator<java.lang.Object> iter = refTracker.getProcessedReferences();\n        while (iter.hasNext()) {\n            java.lang.Object ref = iter.next();\n            if (!(ref instanceof org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference reference = ((org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference) (ref));\n            if (reference.isMultiple()) {\n                java.lang.Iterable<java.lang.String> values = reference.property.getValue(Type.STRINGS);\n                java.util.List<java.lang.String> newValues = com.google.common.collect.Lists.newArrayList();\n                for (java.lang.String original : values) {\n                    java.lang.String adjusted = refTracker.get(original);\n                    if (adjusted != null) {\n                        newValues.add(adjusted);\n                    } else {\n                        newValues.add(original);\n                    }\n                }\n                reference.setProperty(newValues);\n            } else {\n                java.lang.String original = reference.property.getValue(Type.STRING);\n                java.lang.String adjusted = refTracker.get(original);\n                if (adjusted != null) {\n                    reference.setProperty(adjusted);\n                }\n            }\n        } \n        refTracker.clear();\n    }\n\n    private boolean isNodeType(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String ntName) throws javax.jcr.RepositoryException {\n        return effectiveNodeTypeProvider.isNodeType(tree, ntName);\n    }\n\n    private javax.jcr.nodetype.NodeDefinition getDefinition(org.apache.jackrabbit.oak.api.Tree tree) throws javax.jcr.RepositoryException {\n        if (tree.isRoot()) {\n            return definitionProvider.getRootDefinition();\n        } else {\n            return definitionProvider.getDefinition(tree.getParent(), tree);\n        }\n    }\n\n    private static final class Reference {\n        private final org.apache.jackrabbit.oak.api.Tree tree;\n\n        private final org.apache.jackrabbit.oak.api.PropertyState property;\n\n        private Reference(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String propertyName) {\n            this.tree = tree;\n            this.property = tree.getProperty(propertyName);\n        }\n\n        private boolean isMultiple() {\n            return property.isArray();\n        }\n\n        private void setProperty(java.lang.String newValue) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());\n            tree.setProperty(prop);\n        }\n\n        private void setProperty(java.lang.Iterable<java.lang.String> newValues) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValues, property.getType());\n            tree.setProperty(prop);\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;",
            "dst_parent": "private static final class IdResolver {\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final java.util.Set<java.lang.String> importedUUIDs;\n\n    private IdResolver(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Root root, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.ContentSession contentSession) {\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(contentSession.getLatestRoot());\n        if (!root.hasPendingChanges()) {\n            importedUUIDs = new java.util.HashSet<java.lang.String>();\n        } else {\n            importedUUIDs = null;\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.api.Tree getConflictingTree(@javax.annotation.Nonnull\n    java.lang.String id) {\n        org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n        if ((conflicting == null) && (importedUUIDs != null)) {\n            if (importedUUIDs.contains(id)) {\n                conflicting = currentStateIdManager.getTree(id);\n            }\n        } else {\n            conflicting = currentStateIdManager.getTree(id);\n        }\n        return conflicting;\n    }\n\n    private void rememberImportedUUIDs(@javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.api.Tree tree) {\n        if ((tree == null) || (importedUUIDs == null)) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            importedUUIDs.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            rememberImportedUUIDs(child);\n        }\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Field",
            "operator": "MOV",
            "src": "private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;",
            "src_parent": "public class ImporterImpl implements org.apache.jackrabbit.oak.spi.xml.Importer {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.class);\n\n    private final org.apache.jackrabbit.oak.api.Tree importTargetTree;\n\n    private final org.apache.jackrabbit.oak.api.Tree ntTypesRoot;\n\n    private final int uuidBehavior;\n\n    private final java.lang.String userID;\n\n    private final org.apache.jackrabbit.oak.jcr.security.AccessManager accessManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.DefinitionProvider definitionProvider;\n\n    private final java.util.Set<java.lang.String> uuids = new java.util.HashSet<java.lang.String>();\n\n    private final java.util.Stack<org.apache.jackrabbit.oak.api.Tree> parents;\n\n    private final org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker refTracker;\n\n    private final java.util.List<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter> pItemImporters = new java.util.ArrayList<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter>();\n\n    private org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pnImporter;\n\n    public ImporterImpl(java.lang.String absPath, org.apache.jackrabbit.oak.jcr.session.SessionContext sessionContext, org.apache.jackrabbit.oak.api.Root root, int uuidBehavior, boolean isWorkspaceImport) throws javax.jcr.RepositoryException {\n        java.lang.String oakPath = sessionContext.getOakPath(absPath);\n        if (oakPath == null) {\n            throw new javax.jcr.RepositoryException(\"Invalid name or path: \" + absPath);\n        }\n        if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(oakPath)) {\n            throw new javax.jcr.RepositoryException(\"Not an absolute path: \" + absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate sd = sessionContext.getSessionDelegate();\n        if (isWorkspaceImport && sd.hasPendingChanges()) {\n            throw new javax.jcr.RepositoryException(\"Pending changes on session. Cannot run workspace import.\");\n        }\n        this.uuidBehavior = uuidBehavior;\n        userID = sd.getAuthInfo().getUserID();\n        importTargetTree = root.getTree(oakPath);\n        if (!importTargetTree.exists()) {\n            throw new javax.jcr.PathNotFoundException(absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.session.WorkspaceImpl wsp = sessionContext.getWorkspace();\n        javax.jcr.version.VersionManager vMgr = wsp.getVersionManager();\n        if (!vMgr.isCheckedOut(absPath)) {\n            throw new javax.jcr.version.VersionException(\"Target node is checked in.\");\n        }\n        if ((importTargetTree.getStatus() != Tree.Status.NEW) && wsp.getLockManager().isLocked(absPath)) {\n            throw new javax.jcr.lock.LockException(\"Target node is locked.\");\n        }\n        effectiveNodeTypeProvider = wsp.getNodeTypeManager();\n        definitionProvider = wsp.getNodeTypeManager();\n        ntTypesRoot = root.getTree(org.apache.jackrabbit.oak.jcr.xml.NODE_TYPES_PATH);\n        accessManager = sessionContext.getAccessManager();\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot());\n        refTracker = new org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker();\n        parents = new java.util.Stack<org.apache.jackrabbit.oak.api.Tree>();\n        parents.push(importTargetTree);\n        pItemImporters.clear();\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {\n            if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {\n                pItemImporters.add(importer);\n            }\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree createTree(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree parent, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.xml.NodeInfo nInfo, @javax.annotation.CheckForNull\n    java.lang.String uuid) throws javax.jcr.RepositoryException {\n        java.lang.String ntName = nInfo.getPrimaryTypeName();\n        org.apache.jackrabbit.oak.api.Tree child = org.apache.jackrabbit.oak.util.TreeUtil.addChild(parent, nInfo.getName(), ntName, ntTypesRoot, userID);\n        if (ntName != null) {\n            accessManager.checkPermissions(child, child.getProperty(JcrConstants.JCR_PRIMARYTYPE), Permissions.NODE_TYPE_MANAGEMENT);\n        }\n        if (uuid != null) {\n            child.setProperty(JcrConstants.JCR_UUID, uuid);\n        }\n        for (java.lang.String mixin : nInfo.getMixinTypeNames()) {\n            org.apache.jackrabbit.oak.util.TreeUtil.addMixin(child, mixin, ntTypesRoot, userID);\n        }\n        return child;\n    }\n\n    private void createProperty(org.apache.jackrabbit.oak.api.Tree tree, org.apache.jackrabbit.oak.spi.xml.PropInfo pInfo, javax.jcr.nodetype.PropertyDefinition def) throws javax.jcr.RepositoryException {\n        java.util.List<javax.jcr.Value> values = pInfo.getValues(pInfo.getTargetType(def));\n        org.apache.jackrabbit.oak.api.PropertyState propertyState;\n        java.lang.String name = pInfo.getName();\n        int type = pInfo.getType();\n        if ((values.size() == 1) && (!def.isMultiple())) {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values.get(0));\n        } else {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values);\n        }\n        tree.setProperty(propertyState);\n        if ((type == javax.jcr.PropertyType.REFERENCE) || (type == javax.jcr.PropertyType.WEAKREFERENCE)) {\n            refTracker.processedReference(new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference(tree, name));\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree resolveUUIDConflict(org.apache.jackrabbit.oak.api.Tree parent, org.apache.jackrabbit.oak.api.Tree conflicting, java.lang.String conflictingId, org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree tree;\n        if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n            tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n            }\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW) {\n            java.lang.String msg = (\"a node with uuid \" + nodeInfo.getUUID()) + \" already exists!\";\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.ItemExistsException(msg);\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be removed\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (importTargetTree.getPath().startsWith(conflicting.getPath())) {\n                java.lang.String msg = \"cannot remove ancestor node\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.nodetype.ConstraintViolationException(msg);\n            }\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (conflicting.isRoot()) {\n                java.lang.String msg = \"root node cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            parent = conflicting.getParent();\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else {\n            java.lang.String msg = \"unknown uuidBehavior: \" + uuidBehavior;\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.RepositoryException(msg);\n        }\n        return tree;\n    }\n\n    private void importProperties(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree tree, @javax.annotation.Nonnull\n    java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos, boolean ignoreRegular) throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.PropInfo pi : propInfos) {\n            javax.jcr.nodetype.PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\n            if (def.isProtected()) {\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property \" + pi.getName());\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n                    if (ppi.handlePropInfo(tree, pi, def)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                        break;\n                    }\n                }\n            } else if (!ignoreRegular) {\n                createProperty(tree, pi, def);\n            }\n        }\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n            ppi.propertiesCompleted(tree);\n        }\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter> getPropertyImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter> getNodeImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    @java.lang.Override\n    public void start() throws javax.jcr.RepositoryException {\n    }\n\n    @java.lang.Override\n    public void startNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo, java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.peek();\n        org.apache.jackrabbit.oak.api.Tree tree = null;\n        java.lang.String id = nodeInfo.getUUID();\n        java.lang.String nodeName = nodeInfo.getName();\n        java.lang.String ntName = nodeInfo.getPrimaryTypeName();\n        if (parent == null) {\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping node: \" + nodeName);\n            parents.push(null);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n        javax.jcr.nodetype.NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            parents.push(null);\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + nodeName);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    }\n                }\n            }\n            return;\n        }\n        if (parent.hasChild(nodeName)) {\n            org.apache.jackrabbit.oak.api.Tree existing = parent.getChild(nodeName);\n            javax.jcr.nodetype.NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    tree = existing;\n                } else {\n                    java.lang.String existingIdentifier = org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id) && ((uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) || (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING)))) {\n                        throw new javax.jcr.ItemExistsException(\"Node with the same UUID exists:\" + existing);\n                    }\n                }\n            }\n        }\n        if (tree == null) {\n            if (id == null) {\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n                org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n                if (conflicting == null) {\n                    if (uuids.contains(id)) {\n                        conflicting = currentStateIdManager.getTree(id);\n                    }\n                } else {\n                    conflicting = currentStateIdManager.getTree(id);\n                }\n                if ((conflicting != null) && conflicting.exists()) {\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        parents.push(null);\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n        importProperties(tree, propInfos, false);\n        parents.push(tree);\n    }\n\n    @java.lang.Override\n    public void endNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.pop();\n        if (parent == null) {\n            if (pnImporter != null) {\n                pnImporter.endChildInfo();\n            }\n        } else if (getDefinition(parent).isProtected()) {\n            if (pnImporter != null) {\n                pnImporter.end(parent);\n                pnImporter = null;\n            }\n        }\n        collectUUIDs(parent);\n    }\n\n    private void collectUUIDs(org.apache.jackrabbit.oak.api.Tree tree) {\n        if (tree == null) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            uuids.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            collectUUIDs(child);\n        }\n    }\n\n    @java.lang.Override\n    public void end() throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter ppi : pItemImporters) {\n            ppi.processReferences();\n        }\n        java.util.Iterator<java.lang.Object> iter = refTracker.getProcessedReferences();\n        while (iter.hasNext()) {\n            java.lang.Object ref = iter.next();\n            if (!(ref instanceof org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference reference = ((org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference) (ref));\n            if (reference.isMultiple()) {\n                java.lang.Iterable<java.lang.String> values = reference.property.getValue(Type.STRINGS);\n                java.util.List<java.lang.String> newValues = com.google.common.collect.Lists.newArrayList();\n                for (java.lang.String original : values) {\n                    java.lang.String adjusted = refTracker.get(original);\n                    if (adjusted != null) {\n                        newValues.add(adjusted);\n                    } else {\n                        newValues.add(original);\n                    }\n                }\n                reference.setProperty(newValues);\n            } else {\n                java.lang.String original = reference.property.getValue(Type.STRING);\n                java.lang.String adjusted = refTracker.get(original);\n                if (adjusted != null) {\n                    reference.setProperty(adjusted);\n                }\n            }\n        } \n        refTracker.clear();\n    }\n\n    private boolean isNodeType(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String ntName) throws javax.jcr.RepositoryException {\n        return effectiveNodeTypeProvider.isNodeType(tree, ntName);\n    }\n\n    private javax.jcr.nodetype.NodeDefinition getDefinition(org.apache.jackrabbit.oak.api.Tree tree) throws javax.jcr.RepositoryException {\n        if (tree.isRoot()) {\n            return definitionProvider.getRootDefinition();\n        } else {\n            return definitionProvider.getDefinition(tree.getParent(), tree);\n        }\n    }\n\n    private static final class Reference {\n        private final org.apache.jackrabbit.oak.api.Tree tree;\n\n        private final org.apache.jackrabbit.oak.api.PropertyState property;\n\n        private Reference(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String propertyName) {\n            this.tree = tree;\n            this.property = tree.getProperty(propertyName);\n        }\n\n        private boolean isMultiple() {\n            return property.isArray();\n        }\n\n        private void setProperty(java.lang.String newValue) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());\n            tree.setProperty(prop);\n        }\n\n        private void setProperty(java.lang.Iterable<java.lang.String> newValues) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValues, property.getType());\n            tree.setProperty(prop);\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private void rememberImportedUUIDs(@javax.annotation.CheckForNull\norg.apache.jackrabbit.oak.api.Tree tree) {\n    if ((tree == null) || (importedUUIDs == null)) {\n        return;\n    }\n    java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n    if (uuid != null) {\n        importedUUIDs.add(uuid);\n    }\n    for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n        rememberImportedUUIDs(child);\n    }\n}",
            "dst_parent": "private static final class IdResolver {\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final java.util.Set<java.lang.String> importedUUIDs;\n\n    private IdResolver(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Root root, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.ContentSession contentSession) {\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(contentSession.getLatestRoot());\n        if (!root.hasPendingChanges()) {\n            importedUUIDs = new java.util.HashSet<java.lang.String>();\n        } else {\n            importedUUIDs = null;\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.api.Tree getConflictingTree(@javax.annotation.Nonnull\n    java.lang.String id) {\n        org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n        if ((conflicting == null) && (importedUUIDs != null)) {\n            if (importedUUIDs.contains(id)) {\n                conflicting = currentStateIdManager.getTree(id);\n            }\n        } else {\n            conflicting = currentStateIdManager.getTree(id);\n        }\n        return conflicting;\n    }\n\n    private void rememberImportedUUIDs(@javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.api.Tree tree) {\n        if ((tree == null) || (importedUUIDs == null)) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            importedUUIDs.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            rememberImportedUUIDs(child);\n        }\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "MOV",
            "src": "private void collectUUIDs(org.apache.jackrabbit.oak.api.Tree tree) {\n    if (tree == null) {\n        return;\n    }\n    java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n    if (uuid != null) {\n        uuids.add(uuid);\n    }\n    for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n        collectUUIDs(child);\n    }\n}",
            "src_parent": "public class ImporterImpl implements org.apache.jackrabbit.oak.spi.xml.Importer {\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.class);\n\n    private final org.apache.jackrabbit.oak.api.Tree importTargetTree;\n\n    private final org.apache.jackrabbit.oak.api.Tree ntTypesRoot;\n\n    private final int uuidBehavior;\n\n    private final java.lang.String userID;\n\n    private final org.apache.jackrabbit.oak.jcr.security.AccessManager accessManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager currentStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager baseStateIdManager;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.EffectiveNodeTypeProvider effectiveNodeTypeProvider;\n\n    private final org.apache.jackrabbit.oak.plugins.nodetype.DefinitionProvider definitionProvider;\n\n    private final java.util.Set<java.lang.String> uuids = new java.util.HashSet<java.lang.String>();\n\n    private final java.util.Stack<org.apache.jackrabbit.oak.api.Tree> parents;\n\n    private final org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker refTracker;\n\n    private final java.util.List<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter> pItemImporters = new java.util.ArrayList<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter>();\n\n    private org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pnImporter;\n\n    public ImporterImpl(java.lang.String absPath, org.apache.jackrabbit.oak.jcr.session.SessionContext sessionContext, org.apache.jackrabbit.oak.api.Root root, int uuidBehavior, boolean isWorkspaceImport) throws javax.jcr.RepositoryException {\n        java.lang.String oakPath = sessionContext.getOakPath(absPath);\n        if (oakPath == null) {\n            throw new javax.jcr.RepositoryException(\"Invalid name or path: \" + absPath);\n        }\n        if (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(oakPath)) {\n            throw new javax.jcr.RepositoryException(\"Not an absolute path: \" + absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.delegate.SessionDelegate sd = sessionContext.getSessionDelegate();\n        if (isWorkspaceImport && sd.hasPendingChanges()) {\n            throw new javax.jcr.RepositoryException(\"Pending changes on session. Cannot run workspace import.\");\n        }\n        this.uuidBehavior = uuidBehavior;\n        userID = sd.getAuthInfo().getUserID();\n        importTargetTree = root.getTree(oakPath);\n        if (!importTargetTree.exists()) {\n            throw new javax.jcr.PathNotFoundException(absPath);\n        }\n        org.apache.jackrabbit.oak.jcr.session.WorkspaceImpl wsp = sessionContext.getWorkspace();\n        javax.jcr.version.VersionManager vMgr = wsp.getVersionManager();\n        if (!vMgr.isCheckedOut(absPath)) {\n            throw new javax.jcr.version.VersionException(\"Target node is checked in.\");\n        }\n        if ((importTargetTree.getStatus() != Tree.Status.NEW) && wsp.getLockManager().isLocked(absPath)) {\n            throw new javax.jcr.lock.LockException(\"Target node is locked.\");\n        }\n        effectiveNodeTypeProvider = wsp.getNodeTypeManager();\n        definitionProvider = wsp.getNodeTypeManager();\n        ntTypesRoot = root.getTree(org.apache.jackrabbit.oak.jcr.xml.NODE_TYPES_PATH);\n        accessManager = sessionContext.getAccessManager();\n        currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root);\n        baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot());\n        refTracker = new org.apache.jackrabbit.oak.spi.xml.ReferenceChangeTracker();\n        parents = new java.util.Stack<org.apache.jackrabbit.oak.api.Tree>();\n        parents.push(importTargetTree);\n        pItemImporters.clear();\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer : sessionContext.getProtectedItemImporters()) {\n            if (importer.init(sessionContext.getSession(), root, sessionContext, isWorkspaceImport, uuidBehavior, refTracker, sessionContext.getSecurityProvider())) {\n                pItemImporters.add(importer);\n            }\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree createTree(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree parent, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.xml.NodeInfo nInfo, @javax.annotation.CheckForNull\n    java.lang.String uuid) throws javax.jcr.RepositoryException {\n        java.lang.String ntName = nInfo.getPrimaryTypeName();\n        org.apache.jackrabbit.oak.api.Tree child = org.apache.jackrabbit.oak.util.TreeUtil.addChild(parent, nInfo.getName(), ntName, ntTypesRoot, userID);\n        if (ntName != null) {\n            accessManager.checkPermissions(child, child.getProperty(JcrConstants.JCR_PRIMARYTYPE), Permissions.NODE_TYPE_MANAGEMENT);\n        }\n        if (uuid != null) {\n            child.setProperty(JcrConstants.JCR_UUID, uuid);\n        }\n        for (java.lang.String mixin : nInfo.getMixinTypeNames()) {\n            org.apache.jackrabbit.oak.util.TreeUtil.addMixin(child, mixin, ntTypesRoot, userID);\n        }\n        return child;\n    }\n\n    private void createProperty(org.apache.jackrabbit.oak.api.Tree tree, org.apache.jackrabbit.oak.spi.xml.PropInfo pInfo, javax.jcr.nodetype.PropertyDefinition def) throws javax.jcr.RepositoryException {\n        java.util.List<javax.jcr.Value> values = pInfo.getValues(pInfo.getTargetType(def));\n        org.apache.jackrabbit.oak.api.PropertyState propertyState;\n        java.lang.String name = pInfo.getName();\n        int type = pInfo.getType();\n        if ((values.size() == 1) && (!def.isMultiple())) {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values.get(0));\n        } else {\n            propertyState = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(name, values);\n        }\n        tree.setProperty(propertyState);\n        if ((type == javax.jcr.PropertyType.REFERENCE) || (type == javax.jcr.PropertyType.WEAKREFERENCE)) {\n            refTracker.processedReference(new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference(tree, name));\n        }\n    }\n\n    private org.apache.jackrabbit.oak.api.Tree resolveUUIDConflict(org.apache.jackrabbit.oak.api.Tree parent, org.apache.jackrabbit.oak.api.Tree conflicting, java.lang.String conflictingId, org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree tree;\n        if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n            tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n            if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n            }\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_THROW) {\n            java.lang.String msg = (\"a node with uuid \" + nodeInfo.getUUID()) + \" already exists!\";\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.ItemExistsException(msg);\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be removed\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (importTargetTree.getPath().startsWith(conflicting.getPath())) {\n                java.lang.String msg = \"cannot remove ancestor node\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.nodetype.ConstraintViolationException(msg);\n            }\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING) {\n            if (conflicting == null) {\n                java.lang.String msg = (\"node with uuid \" + conflictingId) + \" cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            if (conflicting.isRoot()) {\n                java.lang.String msg = \"root node cannot be replaced\";\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n                throw new javax.jcr.RepositoryException(msg);\n            }\n            parent = conflicting.getParent();\n            conflicting.remove();\n            tree = createTree(parent, nodeInfo, nodeInfo.getUUID());\n        } else {\n            java.lang.String msg = \"unknown uuidBehavior: \" + uuidBehavior;\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(msg);\n            throw new javax.jcr.RepositoryException(msg);\n        }\n        return tree;\n    }\n\n    private void importProperties(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.api.Tree tree, @javax.annotation.Nonnull\n    java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos, boolean ignoreRegular) throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.PropInfo pi : propInfos) {\n            javax.jcr.nodetype.PropertyDefinition def = pi.getPropertyDef(effectiveNodeTypeProvider.getEffectiveNodeType(tree));\n            if (def.isProtected()) {\n                org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property \" + pi.getName());\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n                    if (ppi.handlePropInfo(tree, pi, def)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                        break;\n                    }\n                }\n            } else if (!ignoreRegular) {\n                createProperty(tree, pi, def);\n            }\n        }\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter ppi : getPropertyImporters()) {\n            ppi.propertiesCompleted(tree);\n        }\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter> getPropertyImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedPropertyImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    private java.lang.Iterable<org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter> getNodeImporters() {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(pItemImporters, new com.google.common.base.Function<org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter, org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter importer) {\n                if (importer instanceof org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) {\n                    return ((org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter) (importer));\n                } else {\n                    return null;\n                }\n            }\n        }), com.google.common.base.Predicates.notNull());\n    }\n\n    @java.lang.Override\n    public void start() throws javax.jcr.RepositoryException {\n    }\n\n    @java.lang.Override\n    public void startNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo, java.util.List<org.apache.jackrabbit.oak.spi.xml.PropInfo> propInfos) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.peek();\n        org.apache.jackrabbit.oak.api.Tree tree = null;\n        java.lang.String id = nodeInfo.getUUID();\n        java.lang.String nodeName = nodeInfo.getName();\n        java.lang.String ntName = nodeInfo.getPrimaryTypeName();\n        if (parent == null) {\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping node: \" + nodeName);\n            parents.push(null);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n        javax.jcr.nodetype.NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            parents.push(null);\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + nodeName);\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                for (org.apache.jackrabbit.oak.spi.xml.ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    }\n                }\n            }\n            return;\n        }\n        if (parent.hasChild(nodeName)) {\n            org.apache.jackrabbit.oak.api.Tree existing = parent.getChild(nodeName);\n            javax.jcr.nodetype.NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    tree = existing;\n                } else {\n                    java.lang.String existingIdentifier = org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id) && ((uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING) || (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING)))) {\n                        throw new javax.jcr.ItemExistsException(\"Node with the same UUID exists:\" + existing);\n                    }\n                }\n            }\n        }\n        if (tree == null) {\n            if (id == null) {\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == javax.jcr.ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                tree = createTree(parent, nodeInfo, java.util.UUID.randomUUID().toString());\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n                org.apache.jackrabbit.oak.api.Tree conflicting = baseStateIdManager.getTree(id);\n                if (conflicting == null) {\n                    if (uuids.contains(id)) {\n                        conflicting = currentStateIdManager.getTree(id);\n                    }\n                } else {\n                    conflicting = currentStateIdManager.getTree(id);\n                }\n                if ((conflicting != null) && conflicting.exists()) {\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        parents.push(null);\n                        org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n        importProperties(tree, propInfos, false);\n        parents.push(tree);\n    }\n\n    @java.lang.Override\n    public void endNode(org.apache.jackrabbit.oak.spi.xml.NodeInfo nodeInfo) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.api.Tree parent = parents.pop();\n        if (parent == null) {\n            if (pnImporter != null) {\n                pnImporter.endChildInfo();\n            }\n        } else if (getDefinition(parent).isProtected()) {\n            if (pnImporter != null) {\n                pnImporter.end(parent);\n                pnImporter = null;\n            }\n        }\n        collectUUIDs(parent);\n    }\n\n    private void collectUUIDs(org.apache.jackrabbit.oak.api.Tree tree) {\n        if (tree == null) {\n            return;\n        }\n        java.lang.String uuid = org.apache.jackrabbit.oak.util.TreeUtil.getString(tree, JcrConstants.JCR_UUID);\n        if (uuid != null) {\n            uuids.add(uuid);\n        }\n        for (org.apache.jackrabbit.oak.api.Tree child : tree.getChildren()) {\n            collectUUIDs(child);\n        }\n    }\n\n    @java.lang.Override\n    public void end() throws javax.jcr.RepositoryException {\n        for (org.apache.jackrabbit.oak.spi.xml.ProtectedItemImporter ppi : pItemImporters) {\n            ppi.processReferences();\n        }\n        java.util.Iterator<java.lang.Object> iter = refTracker.getProcessedReferences();\n        while (iter.hasNext()) {\n            java.lang.Object ref = iter.next();\n            if (!(ref instanceof org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference reference = ((org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.Reference) (ref));\n            if (reference.isMultiple()) {\n                java.lang.Iterable<java.lang.String> values = reference.property.getValue(Type.STRINGS);\n                java.util.List<java.lang.String> newValues = com.google.common.collect.Lists.newArrayList();\n                for (java.lang.String original : values) {\n                    java.lang.String adjusted = refTracker.get(original);\n                    if (adjusted != null) {\n                        newValues.add(adjusted);\n                    } else {\n                        newValues.add(original);\n                    }\n                }\n                reference.setProperty(newValues);\n            } else {\n                java.lang.String original = reference.property.getValue(Type.STRING);\n                java.lang.String adjusted = refTracker.get(original);\n                if (adjusted != null) {\n                    reference.setProperty(adjusted);\n                }\n            }\n        } \n        refTracker.clear();\n    }\n\n    private boolean isNodeType(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String ntName) throws javax.jcr.RepositoryException {\n        return effectiveNodeTypeProvider.isNodeType(tree, ntName);\n    }\n\n    private javax.jcr.nodetype.NodeDefinition getDefinition(org.apache.jackrabbit.oak.api.Tree tree) throws javax.jcr.RepositoryException {\n        if (tree.isRoot()) {\n            return definitionProvider.getRootDefinition();\n        } else {\n            return definitionProvider.getDefinition(tree.getParent(), tree);\n        }\n    }\n\n    private static final class Reference {\n        private final org.apache.jackrabbit.oak.api.Tree tree;\n\n        private final org.apache.jackrabbit.oak.api.PropertyState property;\n\n        private Reference(org.apache.jackrabbit.oak.api.Tree tree, java.lang.String propertyName) {\n            this.tree = tree;\n            this.property = tree.getProperty(propertyName);\n        }\n\n        private boolean isMultiple() {\n            return property.isArray();\n        }\n\n        private void setProperty(java.lang.String newValue) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());\n            tree.setProperty(prop);\n        }\n\n        private void setProperty(java.lang.Iterable<java.lang.String> newValues) {\n            org.apache.jackrabbit.oak.api.PropertyState prop = org.apache.jackrabbit.oak.plugins.memory.PropertyStates.createProperty(property.getName(), newValues, property.getType());\n            tree.setProperty(prop);\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver(root, sd.getContentSession())",
            "dst_parent": "idLookup = new org.apache.jackrabbit.oak.jcr.xml.ImporterImpl.IdResolver(root, sd.getContentSession())",
            "dst_parent_type": "Assignment",
            "dst_type": "ConstructorCall",
            "operator": "MOV",
            "src": "new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot())",
            "src_parent": "baseStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(sd.getContentSession().getLatestRoot())",
            "src_parent_type": "Assignment",
            "src_type": "ConstructorCall"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Assignment",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root)",
            "dst_parent": "currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root)",
            "dst_parent_type": "Assignment",
            "dst_type": "ConstructorCall",
            "operator": "MOV",
            "src": "new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root)",
            "src_parent": "currentStateIdManager = new org.apache.jackrabbit.oak.plugins.identifier.IdentifierManager(root)",
            "src_parent_type": "Assignment",
            "src_type": "ConstructorCall"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "(conflicting == null)",
            "dst_parent": "(conflicting == null) && (importedUUIDs != null)",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "BinaryOperator",
            "operator": "MOV",
            "src": "conflicting == null",
            "src_parent": "if (conflicting == null) {\n    if (uuids.contains(id)) {\n        conflicting = currentStateIdManager.getTree(id);\n    }\n} else {\n    conflicting = currentStateIdManager.getTree(id);\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "(tree == null)",
            "dst_parent": "(tree == null) || (importedUUIDs == null)",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "BinaryOperator",
            "operator": "MOV",
            "src": "tree == null",
            "src_parent": "if (tree == null) {\n    return;\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        }
      ],
      "file_name": "ImporterImpl"
    }
  ],
  "id": "jackrabbit-oak_dcadb0e1"
}