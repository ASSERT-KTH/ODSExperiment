{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private <IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInputs(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1TypeInfo, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2TypeInfo) {\n    java.lang.reflect.Type matReturnTypeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n    if (!(matReturnTypeVar instanceof java.lang.reflect.TypeVariable)) {\n        return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n    } else {\n        returnTypeVar = ((java.lang.reflect.TypeVariable<?>) (matReturnTypeVar));\n    }\n    org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n    if (in1TypeInfo != null) {\n        java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n        java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n        info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo);\n    }\n    if ((info == null) && (in2TypeInfo != null)) {\n        java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n        java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n        info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo);\n    }\n    if (info != null) {\n        return info;\n    }\n    return null;\n}",
            "dst_parent": "public class TypeExtractor {\n    private java.util.Set<java.lang.Class<?>> alreadySeen;\n\n    private TypeExtractor() {\n        alreadySeen = new java.util.HashSet<java.lang.Class<?>>();\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapInterface)), org.apache.flink.api.common.functions.MapFunction.class, false, false, inType);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (flatMapInterface)), org.apache.flink.api.common.functions.FlatMapFunction.class, false, true, inType);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapPartitionInterface)), org.apache.flink.api.common.functions.MapPartitionFunction.class, true, true, inType);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (groupReduceInterface)), org.apache.flink.api.common.functions.GroupReduceFunction.class, true, true, inType);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.FlatJoinFunction.class, false, true, in1Type, in2Type);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.JoinFunction.class, false, false, in1Type, in2Type);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (coGroupInterface)), org.apache.flink.api.common.functions.CoGroupFunction.class, true, true, in1Type, in2Type);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (crossInterface)), org.apache.flink.api.common.functions.CrossFunction.class, false, false, in1Type, in2Type);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (selectorInterface)), org.apache.flink.api.java.functions.KeySelector.class, false, false, inType);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN> org.apache.flink.api.common.typeinfo.TypeInformation<IN> getInputFormatTypes(org.apache.flink.api.common.io.InputFormat<IN, ?> inputFormatInterface) {\n        if (inputFormatInterface instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n            return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<IN>) (inputFormatInterface)).getProducedType();\n        }\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.io.InputFormat.class, inputFormatInterface.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getUnaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterable, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n        if (m != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n            final int paramLen = m.getGenericParameterTypes().length - 1;\n            final java.lang.reflect.Type input = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterable ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input) : input, inType);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), inType, null);\n        } else {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, inType);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null);\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getBinaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterables, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n        if (m != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n            final int paramLen = m.getGenericParameterTypes().length - 1;\n            final java.lang.reflect.Type input1 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1];\n            final java.lang.reflect.Type input2 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input1) : input1, in1Type);\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input2) : input2, in2Type);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), in1Type, in2Type);\n        } else {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, in1Type);\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 1, in2Type);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type);\n        }\n    }\n\n    public static org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfo(java.lang.reflect.Type t) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(t);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, clazz, returnParamPos, in1Type, in2Type);\n    }\n\n    private org.apache.flink.api.common.typeinfo.TypeInformation<?> privateCreateTypeInfo(java.lang.reflect.Type t) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        typeHierarchy.add(t);\n        return createTypeInfoWithTypeHierarchy(typeHierarchy, t, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type returnType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = null;\n        if (returnType instanceof java.lang.reflect.TypeVariable<?>) {\n            typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)));\n            if (typeInfo != null) {\n                return typeInfo;\n            }\n        }\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.reflect.Type returnType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfoWithTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (((t instanceof java.lang.Class<?>) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (t)))) || ((t instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()))))) {\n            java.lang.reflect.Type curT = t;\n            if ((curT instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (curT)).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n            }\n            while ((!((curT instanceof java.lang.reflect.ParameterizedType) && ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType())).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) && (!((curT instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (curT)).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class)))) {\n                typeHierarchy.add(curT);\n                if (curT instanceof java.lang.reflect.ParameterizedType) {\n                    curT = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType())).getGenericSuperclass();\n                } else {\n                    curT = ((java.lang.Class<?>) (curT)).getGenericSuperclass();\n                }\n            } \n            if (curT instanceof java.lang.Class<?>) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n            }\n            java.lang.reflect.ParameterizedType tupleChild = ((java.lang.reflect.ParameterizedType) (curT));\n            java.lang.reflect.Type[] subtypes = new java.lang.reflect.Type[tupleChild.getActualTypeArguments().length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (tupleChild.getActualTypeArguments()[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    subtypes[i] = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleChild.getActualTypeArguments()[i])));\n                } else {\n                    subtypes[i] = tupleChild.getActualTypeArguments()[i];\n                }\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] tupleSubTypes = new org.apache.flink.api.common.typeinfo.TypeInformation<?>[subtypes.length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (subtypes[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    tupleSubTypes[i] = createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type);\n                    if (tupleSubTypes[i] == null) {\n                        throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                    }\n                } else {\n                    tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n                }\n            }\n            if (t instanceof java.lang.Class<?>) {\n                return new org.apache.flink.api.java.typeutils.TupleTypeInfo(((java.lang.Class<? extends org.apache.flink.api.java.tuple.Tuple>) (t)), tupleSubTypes);\n            } else if (t instanceof java.lang.reflect.ParameterizedType) {\n                return new org.apache.flink.api.java.typeutils.TupleTypeInfo(((java.lang.Class<? extends org.apache.flink.api.java.tuple.Tuple>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), tupleSubTypes);\n            }\n        } else if (t instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.Type typeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (t)));\n            if (!(typeVar instanceof java.lang.reflect.TypeVariable)) {\n                return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n            } else {\n                org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)));\n                if (typeInfo != null) {\n                    return typeInfo;\n                } else {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (t)).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (t)).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            }\n        } else if (t instanceof java.lang.reflect.GenericArrayType) {\n            java.lang.reflect.GenericArrayType genericArray = ((java.lang.reflect.GenericArrayType) (t));\n            java.lang.reflect.Type componentType = genericArray.getGenericComponentType();\n            if (componentType instanceof java.lang.Class) {\n                java.lang.Class<?> componentClass = ((java.lang.Class<?>) (componentType));\n                java.lang.String className;\n                if (componentClass.isPrimitive()) {\n                    className = org.apache.flink.api.java.typeutils.TypeExtractor.encodePrimitiveClass(componentClass);\n                } else {\n                    className = (\"L\" + componentClass.getName()) + \";\";\n                }\n                java.lang.Class<OUT> classArray = null;\n                try {\n                    classArray = ((java.lang.Class<OUT>) (java.lang.Class.forName(\"[\" + className)));\n                } catch (java.lang.ClassNotFoundException e) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n                }\n                return org.apache.flink.api.java.typeutils.TypeExtractor.getForClass(classArray);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n            return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return privateGetForClass(((java.lang.Class<OUT>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())));\n        } else if (t instanceof java.lang.Class) {\n            return privateGetForClass(((java.lang.Class<OUT>) (t)));\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type Information could not be created.\");\n    }\n\n    private <IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInputs(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1TypeInfo, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2TypeInfo) {\n        java.lang.reflect.Type matReturnTypeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n        if (!(matReturnTypeVar instanceof java.lang.reflect.TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n        } else {\n            returnTypeVar = ((java.lang.reflect.TypeVariable<?>) (matReturnTypeVar));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (in1TypeInfo != null) {\n            java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n            java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n            info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo);\n        }\n        if ((info == null) && (in2TypeInfo != null)) {\n            java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n            java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n            info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo);\n        }\n        if (info != null) {\n            return info;\n        }\n        return null;\n    }\n\n    private <IN1> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInput(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, java.lang.reflect.Type inType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> inTypeInfo) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (inType instanceof java.lang.reflect.TypeVariable) {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (inType)));\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo);\n        } else if ((inType instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (inType)).getRawType())))) {\n            java.lang.reflect.Type[] tupleElements = ((java.lang.reflect.ParameterizedType) (inType)).getActualTypeArguments();\n            for (int i = 0; i < tupleElements.length; i++) {\n                if (tupleElements[i] instanceof java.lang.reflect.TypeVariable) {\n                    inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleElements[i])));\n                    info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (inTypeInfo)).getTypeAt(i));\n                    if (info != null) {\n                        break;\n                    }\n                }\n            }\n        }\n        return info;\n    }\n\n    public static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int pos) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, null, clazz, pos);\n    }\n\n    private static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.Class<?> clazz, int pos) {\n        java.lang.reflect.Type[] interfaceTypes = clazz.getGenericInterfaces();\n        for (java.lang.reflect.Type t : interfaceTypes) {\n            java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n            if (parameter != null) {\n                return parameter;\n            }\n        }\n        java.lang.reflect.Type t = clazz.getGenericSuperclass();\n        java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n        if (parameter != null) {\n            return parameter;\n        }\n        throw new java.lang.IllegalArgumentException(((\"The types of the interface \" + baseClass.getName()) + \" could not be inferred. \") + \"Support for synthetic interfaces, lambdas, and generic types is limited at this point.\");\n    }\n\n    private static java.lang.reflect.Type getParameterTypeFromGenericType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, int pos) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.equals(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            java.lang.reflect.ParameterizedType baseClassChild = ((java.lang.reflect.ParameterizedType) (t));\n            return baseClassChild.getActualTypeArguments()[pos];\n        } else if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), pos);\n        } else if ((t instanceof java.lang.Class<?>) && baseClass.isAssignableFrom(((java.lang.Class<?>) (t)))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (t)), pos);\n        }\n        return null;\n    }\n\n    private static void validateInputType(java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, t, inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    private static void validateInputType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int inputParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static void validateInfo(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> typeInfo) {\n        if (type == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. Type is null.\");\n        }\n        if (typeInfo == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\n        }\n        if (!(type instanceof java.lang.reflect.TypeVariable<?>)) {\n            if (typeInfo.isBasicType()) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual = null;\n                if ((!(type instanceof java.lang.Class<?>)) || ((actual = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(((java.lang.Class<?>) (type)))) == null)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Basic type expected.\");\n                }\n                if (!typeInfo.equals(actual)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Basic type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo.isTupleType()) {\n                if ((!((type instanceof java.lang.Class<?>) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (type))))) && (!((type instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple type expected.\");\n                }\n                if ((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Concrete subclass of Tuple expected.\");\n                }\n                while ((!((type instanceof java.lang.reflect.ParameterizedType) && ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) && (!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class)))) {\n                    typeHierarchy.add(type);\n                    if (type instanceof java.lang.reflect.ParameterizedType) {\n                        type = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())).getGenericSuperclass();\n                    } else {\n                        type = ((java.lang.Class<?>) (type)).getGenericSuperclass();\n                    }\n                } \n                if (type instanceof java.lang.Class<?>) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Parameterized Tuple type expected.\");\n                }\n                org.apache.flink.api.java.typeutils.TupleTypeInfo<?> tti = ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo));\n                java.lang.reflect.Type[] subTypes = ((java.lang.reflect.ParameterizedType) (type)).getActualTypeArguments();\n                if (subTypes.length != tti.getArity()) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Tuple arity '\" + tti.getArity()) + \"' expected but was '\") + subTypes.length) + \"'.\");\n                }\n                for (int i = 0; i < subTypes.length; i++) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subTypes[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo)).getTypeAt(i));\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.hadoop.io.Writable.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Writable type expected.\");\n                }\n                java.lang.Class<?> clazz = null;\n                if (((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass() != (clazz = ((java.lang.Class<?>) (type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Writable type '\" + ((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) {\n                java.lang.reflect.Type component = null;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) {\n                if ((!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray())) && (!(type instanceof java.lang.reflect.GenericArrayType))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object array type expected.\");\n                }\n                java.lang.reflect.Type component = null;\n                if (type instanceof java.lang.Class<?>) {\n                    component = ((java.lang.Class<?>) (type)).getComponentType();\n                } else {\n                    component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType();\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.flink.types.Value.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Value type expected.\");\n                }\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual = null;\n                if (!((org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) (typeInfo)).equals(actual = org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(((java.lang.Class<? extends org.apache.flink.types.Value>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Value type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n                java.lang.Class<?> clazz = null;\n                if ((!((type instanceof java.lang.Class<?>) && (((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = ((java.lang.Class<?>) (type)))))) && (!((type instanceof java.lang.reflect.ParameterizedType) && ((clazz = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType()))) == ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass())))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"POJO type '\" + ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) {\n                java.lang.Class<?> clazz = null;\n                if ((!((type instanceof java.lang.Class<?>) && (((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = ((java.lang.Class<?>) (type)))))) && (!((type instanceof java.lang.reflect.ParameterizedType) && ((clazz = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType()))) == ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass())))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Generic object type '\" + ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            }\n        } else {\n            type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type)));\n            if (!(type instanceof java.lang.reflect.TypeVariable)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, type, typeInfo);\n            }\n        }\n    }\n\n    private static java.lang.reflect.Type removeGenericWrapper(java.lang.reflect.Type t) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && (org.apache.flink.util.Collector.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()))) || java.lang.Iterable.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()))))) {\n            return ((java.lang.reflect.ParameterizedType) (t)).getActualTypeArguments()[0];\n        }\n        return t;\n    }\n\n    private static void validateLambdaGenericParameters(java.lang.reflect.Method m) {\n        for (java.lang.reflect.Type t : m.getGenericParameterTypes()) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(t);\n        }\n        org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(m.getGenericReturnType());\n    }\n\n    private static void validateLambdaGenericParameter(java.lang.reflect.Type t) {\n        if (!(t instanceof java.lang.Class)) {\n            return;\n        }\n        final java.lang.Class<?> clazz = ((java.lang.Class<?>) (t));\n        if (clazz.getTypeParameters().length > 0) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(((((\"The generic type parameters of '\" + clazz.getSimpleName()) + \"\\' are missing. \\n\") + \"It seems that your compiler has not stored them into the .class file. \\n\") + \"Currently, only the Eclipse JDT compiler preserves the type information necessary to use the lambdas feature type-safely. \\n\") + \"See the documentation for more information about how to compile jobs containing lambda expressions.\");\n        }\n    }\n\n    private static java.lang.String encodePrimitiveClass(java.lang.Class<?> primitiveClass) {\n        final java.lang.String name = primitiveClass.getName();\n        if (name.equals(\"boolean\")) {\n            return \"Z\";\n        } else if (name.equals(\"byte\")) {\n            return \"B\";\n        } else if (name.equals(\"char\")) {\n            return \"C\";\n        } else if (name.equals(\"double\")) {\n            return \"D\";\n        } else if (name.equals(\"float\")) {\n            return \"F\";\n        } else if (name.equals(\"int\")) {\n            return \"I\";\n        } else if (name.equals(\"long\")) {\n            return \"J\";\n        } else if (name.equals(\"short\")) {\n            return \"S\";\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException();\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> findCorrespondingInfo(java.lang.reflect.TypeVariable<?> typeVar, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> corrInfo) {\n        if (type instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.TypeVariable<?> variable = ((java.lang.reflect.TypeVariable<?>) (type));\n            if (variable.getName().equals(typeVar.getName()) && variable.getGenericDeclaration().equals(typeVar.getGenericDeclaration())) {\n                return corrInfo;\n            }\n        } else if ((type instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))) {\n            java.lang.reflect.ParameterizedType tuple = ((java.lang.reflect.ParameterizedType) (type));\n            java.lang.reflect.Type[] args = tuple.getActualTypeArguments();\n            for (int i = 0; i < args.length; i++) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, args[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (corrInfo)).getTypeAt(i));\n                if (info != null) {\n                    return info;\n                }\n            }\n        }\n        return null;\n    }\n\n    private static java.lang.reflect.Type materializeTypeVariable(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.TypeVariable<?> typeVar) {\n        java.lang.reflect.TypeVariable<?> inTypeTypeVar = typeVar;\n        for (int i = typeHierarchy.size() - 1; i >= 0; i--) {\n            java.lang.reflect.Type curT = typeHierarchy.get(i);\n            if (curT instanceof java.lang.reflect.ParameterizedType) {\n                java.lang.Class<?> rawType = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType()));\n                for (int paramIndex = 0; paramIndex < rawType.getTypeParameters().length; paramIndex++) {\n                    java.lang.reflect.TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex];\n                    if (curVarOfCurT.getName().equals(inTypeTypeVar.getName()) && curVarOfCurT.getGenericDeclaration().equals(inTypeTypeVar.getGenericDeclaration())) {\n                        java.lang.reflect.Type curVarType = ((java.lang.reflect.ParameterizedType) (curT)).getActualTypeArguments()[paramIndex];\n                        if (curVarType instanceof java.lang.reflect.TypeVariable<?>) {\n                            inTypeTypeVar = ((java.lang.reflect.TypeVariable<?>) (curVarType));\n                        } else {\n                            return curVarType;\n                        }\n                    }\n                }\n            }\n        }\n        return inTypeTypeVar;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForClass(java.lang.Class<X> clazz) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForClass(clazz);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForClass(java.lang.Class<X> clazz) {\n        org.apache.commons.lang3.Validate.notNull(clazz);\n        if ((!clazz.isPrimitive()) && (java.lang.reflect.Modifier.isInterface(clazz.getModifiers()) || (java.lang.reflect.Modifier.isAbstract(clazz.getModifiers()) && (!clazz.isArray())))) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Interfaces and abstract classes are not valid types: \" + clazz);\n        }\n        if (clazz.equals(java.lang.Object.class)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object is not a valid type.\");\n        }\n        if (clazz.isArray()) {\n            org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo<X> primitiveArrayInfo = org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo.getInfoFor(clazz);\n            if (primitiveArrayInfo != null) {\n                return primitiveArrayInfo;\n            }\n            org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<X, ?> basicArrayInfo = org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo.getInfoFor(clazz);\n            if (basicArrayInfo != null) {\n                return basicArrayInfo;\n            } else {\n                return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(clazz);\n            }\n        }\n        if (org.apache.hadoop.io.Writable.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (org.apache.flink.api.java.typeutils.WritableTypeInfo.getWritableTypeInfo(((java.lang.Class<? extends org.apache.hadoop.io.Writable>) (clazz)))));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<X> basicTypeInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(clazz);\n        if (basicTypeInfo != null) {\n            return basicTypeInfo;\n        }\n        if (org.apache.flink.types.Value.class.isAssignableFrom(clazz)) {\n            java.lang.Class<? extends org.apache.flink.types.Value> valueClass = clazz.asSubclass(org.apache.flink.types.Value.class);\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(valueClass)));\n        }\n        if (org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(clazz)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n        }\n        if (alreadySeen.contains(clazz)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n        }\n        alreadySeen.add(clazz);\n        if (clazz.equals(java.lang.Class.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n        }\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n    }\n\n    @java.lang.SuppressWarnings(\"unused\")\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> analyzePojo(java.lang.Class<X> clazz) {\n        java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz);\n        java.util.List<org.apache.flink.api.java.typeutils.PojoField> pojoFields = new java.util.ArrayList<org.apache.flink.api.java.typeutils.PojoField>();\n        for (java.lang.reflect.Field field : fields) {\n            try {\n                if ((!java.lang.reflect.Modifier.isTransient(field.getModifiers())) && (!java.lang.reflect.Modifier.isStatic(field.getModifiers()))) {\n                    pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, privateCreateTypeInfo(field.getType())));\n                }\n            } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n                return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n            }\n        }\n        org.apache.flink.api.java.typeutils.PojoTypeInfo<X> pojoType = new org.apache.flink.api.java.typeutils.PojoTypeInfo<X>(clazz, pojoFields);\n        java.util.List<java.lang.reflect.Method> methods = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredMethods(clazz);\n        boolean containsReadObjectOrWriteObject = false;\n        for (java.lang.reflect.Method method : methods) {\n            if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n                containsReadObjectOrWriteObject = true;\n                break;\n            }\n        }\n        boolean hasDefaultCtor = true;\n        try {\n            clazz.getDeclaredConstructor();\n        } catch (java.lang.NoSuchMethodException e) {\n            hasDefaultCtor = false;\n        }\n        if ((!containsReadObjectOrWriteObject) && hasDefaultCtor) {\n            return pojoType;\n        }\n        return null;\n    }\n\n    private static java.util.List<java.lang.reflect.Field> getAllDeclaredFields(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Field> result = new java.util.ArrayList<java.lang.reflect.Field>();\n        while (clazz != null) {\n            java.lang.reflect.Field[] fields = clazz.getDeclaredFields();\n            for (java.lang.reflect.Field field : fields) {\n                result.add(field);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    private static java.util.List<java.lang.reflect.Method> getAllDeclaredMethods(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Method> result = new java.util.ArrayList<java.lang.reflect.Method>();\n        while (clazz != null) {\n            java.lang.reflect.Method[] methods = clazz.getDeclaredMethods();\n            for (java.lang.reflect.Method method : methods) {\n                result.add(method);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForObject(X value) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForObject(value);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForObject(X value) {\n        org.apache.commons.lang3.Validate.notNull(value);\n        if (value instanceof org.apache.flink.api.java.tuple.Tuple) {\n            org.apache.flink.api.java.tuple.Tuple t = ((org.apache.flink.api.java.tuple.Tuple) (value));\n            int numFields = t.getArity();\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] infos = new org.apache.flink.api.common.typeinfo.TypeInformation[numFields];\n            for (int i = 0; i < numFields; i++) {\n                java.lang.Object field = t.getField(i);\n                if (field == null) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Automatic type extraction is not possible on candidates with null values. \" + \"Please specify the types directly.\");\n                }\n                infos[i] = privateGetForObject(field);\n            }\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (new org.apache.flink.api.java.typeutils.TupleTypeInfo(value.getClass(), infos)));\n        } else {\n            return privateGetForClass(((java.lang.Class<X>) (value.getClass())));\n        }\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "private <IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInput(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1TypeInfo, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2TypeInfo) {\n    java.lang.reflect.Type matReturnTypeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n    if (!(matReturnTypeVar instanceof java.lang.reflect.TypeVariable)) {\n        return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n    } else {\n        returnTypeVar = ((java.lang.reflect.TypeVariable<?>) (matReturnTypeVar));\n    }\n    org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n    if (in1TypeInfo != null) {\n        java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n        java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n        if (in1Type instanceof java.lang.reflect.TypeVariable) {\n            in1Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in1Type)));\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n        }\n    }\n    if ((info == null) && (in2TypeInfo != null)) {\n        java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n        java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n        if (in2Type instanceof java.lang.reflect.TypeVariable) {\n            in2Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in2Type)));\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n        }\n    }\n    if (info != null) {\n        return info;\n    }\n    return null;\n}",
            "src_parent": "public class TypeExtractor {\n    private java.util.Set<java.lang.Class<?>> alreadySeen;\n\n    private TypeExtractor() {\n        alreadySeen = new java.util.HashSet<java.lang.Class<?>>();\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapInterface)), org.apache.flink.api.common.functions.MapFunction.class, false, false, inType);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (flatMapInterface)), org.apache.flink.api.common.functions.FlatMapFunction.class, false, true, inType);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapPartitionInterface)), org.apache.flink.api.common.functions.MapPartitionFunction.class, true, true, inType);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (groupReduceInterface)), org.apache.flink.api.common.functions.GroupReduceFunction.class, true, true, inType);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.FlatJoinFunction.class, false, true, in1Type, in2Type);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.JoinFunction.class, false, false, in1Type, in2Type);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (coGroupInterface)), org.apache.flink.api.common.functions.CoGroupFunction.class, true, true, in1Type, in2Type);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (crossInterface)), org.apache.flink.api.common.functions.CrossFunction.class, false, false, in1Type, in2Type);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (selectorInterface)), org.apache.flink.api.java.functions.KeySelector.class, false, false, inType);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN> org.apache.flink.api.common.typeinfo.TypeInformation<IN> getInputFormatTypes(org.apache.flink.api.common.io.InputFormat<IN, ?> inputFormatInterface) {\n        if (inputFormatInterface instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n            return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<IN>) (inputFormatInterface)).getProducedType();\n        }\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.io.InputFormat.class, inputFormatInterface.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getUnaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterable, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n        if (m != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n            final int paramLen = m.getGenericParameterTypes().length - 1;\n            final java.lang.reflect.Type input = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterable ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input) : input, inType);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), inType, null);\n        } else {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, inType);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null);\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getBinaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterables, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n        if (m != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n            final int paramLen = m.getGenericParameterTypes().length - 1;\n            final java.lang.reflect.Type input1 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1];\n            final java.lang.reflect.Type input2 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input1) : input1, in1Type);\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input2) : input2, in2Type);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), in1Type, in2Type);\n        } else {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, in1Type);\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 1, in2Type);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type);\n        }\n    }\n\n    public static org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfo(java.lang.reflect.Type t) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(t);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, clazz, returnParamPos, in1Type, in2Type);\n    }\n\n    private org.apache.flink.api.common.typeinfo.TypeInformation<?> privateCreateTypeInfo(java.lang.reflect.Type t) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        typeHierarchy.add(t);\n        return createTypeInfoWithTypeHierarchy(typeHierarchy, t, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type returnType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = null;\n        if (returnType instanceof java.lang.reflect.TypeVariable<?>) {\n            typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInput(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)));\n            if (typeInfo != null) {\n                return typeInfo;\n            }\n        }\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.reflect.Type returnType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfoWithTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (((t instanceof java.lang.Class<?>) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (t)))) || ((t instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()))))) {\n            java.lang.reflect.Type curT = t;\n            if ((curT instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (curT)).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n            }\n            while ((!((curT instanceof java.lang.reflect.ParameterizedType) && ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType())).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) && (!((curT instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (curT)).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class)))) {\n                typeHierarchy.add(curT);\n                if (curT instanceof java.lang.reflect.ParameterizedType) {\n                    curT = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType())).getGenericSuperclass();\n                } else {\n                    curT = ((java.lang.Class<?>) (curT)).getGenericSuperclass();\n                }\n            } \n            if (curT instanceof java.lang.Class<?>) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n            }\n            java.lang.reflect.ParameterizedType tupleChild = ((java.lang.reflect.ParameterizedType) (curT));\n            java.lang.reflect.Type[] subtypes = new java.lang.reflect.Type[tupleChild.getActualTypeArguments().length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (tupleChild.getActualTypeArguments()[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    subtypes[i] = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleChild.getActualTypeArguments()[i])));\n                } else {\n                    subtypes[i] = tupleChild.getActualTypeArguments()[i];\n                }\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] tupleSubTypes = new org.apache.flink.api.common.typeinfo.TypeInformation<?>[subtypes.length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (subtypes[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    tupleSubTypes[i] = createTypeInfoFromInput(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type);\n                    if (tupleSubTypes[i] == null) {\n                        throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                    }\n                } else {\n                    tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n                }\n            }\n            if (t instanceof java.lang.Class<?>) {\n                return new org.apache.flink.api.java.typeutils.TupleTypeInfo(((java.lang.Class<? extends org.apache.flink.api.java.tuple.Tuple>) (t)), tupleSubTypes);\n            } else if (t instanceof java.lang.reflect.ParameterizedType) {\n                return new org.apache.flink.api.java.typeutils.TupleTypeInfo(((java.lang.Class<? extends org.apache.flink.api.java.tuple.Tuple>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), tupleSubTypes);\n            }\n        } else if (t instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.Type typeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (t)));\n            if (!(typeVar instanceof java.lang.reflect.TypeVariable)) {\n                return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n            } else {\n                org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInput(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)));\n                if (typeInfo != null) {\n                    return typeInfo;\n                } else {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (t)).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (t)).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            }\n        } else if (t instanceof java.lang.reflect.GenericArrayType) {\n            java.lang.reflect.GenericArrayType genericArray = ((java.lang.reflect.GenericArrayType) (t));\n            java.lang.reflect.Type componentType = genericArray.getGenericComponentType();\n            if (componentType instanceof java.lang.Class) {\n                java.lang.Class<?> componentClass = ((java.lang.Class<?>) (componentType));\n                java.lang.String className;\n                if (componentClass.isPrimitive()) {\n                    className = org.apache.flink.api.java.typeutils.TypeExtractor.encodePrimitiveClass(componentClass);\n                } else {\n                    className = (\"L\" + componentClass.getName()) + \";\";\n                }\n                java.lang.Class<OUT> classArray = null;\n                try {\n                    classArray = ((java.lang.Class<OUT>) (java.lang.Class.forName(\"[\" + className)));\n                } catch (java.lang.ClassNotFoundException e) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n                }\n                return org.apache.flink.api.java.typeutils.TypeExtractor.getForClass(classArray);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n            return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return privateGetForClass(((java.lang.Class<OUT>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())));\n        } else if (t instanceof java.lang.Class) {\n            return privateGetForClass(((java.lang.Class<OUT>) (t)));\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type Information could not be created.\");\n    }\n\n    private <IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInput(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1TypeInfo, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2TypeInfo) {\n        java.lang.reflect.Type matReturnTypeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n        if (!(matReturnTypeVar instanceof java.lang.reflect.TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n        } else {\n            returnTypeVar = ((java.lang.reflect.TypeVariable<?>) (matReturnTypeVar));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (in1TypeInfo != null) {\n            java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n            java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n            if (in1Type instanceof java.lang.reflect.TypeVariable) {\n                in1Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in1Type)));\n                info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n            }\n        }\n        if ((info == null) && (in2TypeInfo != null)) {\n            java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n            java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n            if (in2Type instanceof java.lang.reflect.TypeVariable) {\n                in2Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in2Type)));\n                info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n            }\n        }\n        if (info != null) {\n            return info;\n        }\n        return null;\n    }\n\n    public static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int pos) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, null, clazz, pos);\n    }\n\n    private static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.Class<?> clazz, int pos) {\n        java.lang.reflect.Type[] interfaceTypes = clazz.getGenericInterfaces();\n        for (java.lang.reflect.Type t : interfaceTypes) {\n            java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n            if (parameter != null) {\n                return parameter;\n            }\n        }\n        java.lang.reflect.Type t = clazz.getGenericSuperclass();\n        java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n        if (parameter != null) {\n            return parameter;\n        }\n        throw new java.lang.IllegalArgumentException(((\"The types of the interface \" + baseClass.getName()) + \" could not be inferred. \") + \"Support for synthetic interfaces, lambdas, and generic types is limited at this point.\");\n    }\n\n    private static java.lang.reflect.Type getParameterTypeFromGenericType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, int pos) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.equals(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            java.lang.reflect.ParameterizedType baseClassChild = ((java.lang.reflect.ParameterizedType) (t));\n            return baseClassChild.getActualTypeArguments()[pos];\n        } else if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), pos);\n        } else if ((t instanceof java.lang.Class<?>) && baseClass.isAssignableFrom(((java.lang.Class<?>) (t)))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (t)), pos);\n        }\n        return null;\n    }\n\n    private static void validateInputType(java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, t, inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    private static void validateInputType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int inputParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static void validateInfo(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> typeInfo) {\n        if (type == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. Type is null.\");\n        }\n        if (typeInfo == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\n        }\n        if (!(type instanceof java.lang.reflect.TypeVariable<?>)) {\n            if (typeInfo.isBasicType()) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual = null;\n                if ((!(type instanceof java.lang.Class<?>)) || ((actual = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(((java.lang.Class<?>) (type)))) == null)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Basic type expected.\");\n                }\n                if (!typeInfo.equals(actual)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Basic type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo.isTupleType()) {\n                if ((!((type instanceof java.lang.Class<?>) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (type))))) && (!((type instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple type expected.\");\n                }\n                if ((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Concrete subclass of Tuple expected.\");\n                }\n                while ((!((type instanceof java.lang.reflect.ParameterizedType) && ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) && (!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class)))) {\n                    typeHierarchy.add(type);\n                    if (type instanceof java.lang.reflect.ParameterizedType) {\n                        type = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())).getGenericSuperclass();\n                    } else {\n                        type = ((java.lang.Class<?>) (type)).getGenericSuperclass();\n                    }\n                } \n                if (type instanceof java.lang.Class<?>) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Parameterized Tuple type expected.\");\n                }\n                org.apache.flink.api.java.typeutils.TupleTypeInfo<?> tti = ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo));\n                java.lang.reflect.Type[] subTypes = ((java.lang.reflect.ParameterizedType) (type)).getActualTypeArguments();\n                if (subTypes.length != tti.getArity()) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Tuple arity '\" + tti.getArity()) + \"' expected but was '\") + subTypes.length) + \"'.\");\n                }\n                for (int i = 0; i < subTypes.length; i++) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subTypes[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo)).getTypeAt(i));\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.hadoop.io.Writable.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Writable type expected.\");\n                }\n                java.lang.Class<?> clazz = null;\n                if (((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass() != (clazz = ((java.lang.Class<?>) (type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Writable type '\" + ((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) {\n                java.lang.reflect.Type component = null;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) {\n                if ((!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray())) && (!(type instanceof java.lang.reflect.GenericArrayType))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object array type expected.\");\n                }\n                java.lang.reflect.Type component = null;\n                if (type instanceof java.lang.Class<?>) {\n                    component = ((java.lang.Class<?>) (type)).getComponentType();\n                } else {\n                    component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType();\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.flink.types.Value.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Value type expected.\");\n                }\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual = null;\n                if (!((org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) (typeInfo)).equals(actual = org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(((java.lang.Class<? extends org.apache.flink.types.Value>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Value type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n                java.lang.Class<?> clazz = null;\n                if ((!((type instanceof java.lang.Class<?>) && (((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = ((java.lang.Class<?>) (type)))))) && (!((type instanceof java.lang.reflect.ParameterizedType) && ((clazz = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType()))) == ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass())))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"POJO type '\" + ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) {\n                java.lang.Class<?> clazz = null;\n                if ((!((type instanceof java.lang.Class<?>) && (((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = ((java.lang.Class<?>) (type)))))) && (!((type instanceof java.lang.reflect.ParameterizedType) && ((clazz = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType()))) == ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass())))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Generic object type '\" + ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            }\n        } else {\n            type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type)));\n            if (!(type instanceof java.lang.reflect.TypeVariable)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, type, typeInfo);\n            }\n        }\n    }\n\n    private static java.lang.reflect.Type removeGenericWrapper(java.lang.reflect.Type t) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && (org.apache.flink.util.Collector.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()))) || java.lang.Iterable.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()))))) {\n            return ((java.lang.reflect.ParameterizedType) (t)).getActualTypeArguments()[0];\n        }\n        return t;\n    }\n\n    private static void validateLambdaGenericParameters(java.lang.reflect.Method m) {\n        for (java.lang.reflect.Type t : m.getGenericParameterTypes()) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(t);\n        }\n        org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(m.getGenericReturnType());\n    }\n\n    private static void validateLambdaGenericParameter(java.lang.reflect.Type t) {\n        if (!(t instanceof java.lang.Class)) {\n            return;\n        }\n        final java.lang.Class<?> clazz = ((java.lang.Class<?>) (t));\n        if (clazz.getTypeParameters().length > 0) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(((((\"The generic type parameters of '\" + clazz.getSimpleName()) + \"\\' are missing. \\n\") + \"It seems that your compiler has not stored them into the .class file. \\n\") + \"Currently, only the Eclipse JDT compiler preserves the type information necessary to use the lambdas feature type-safely. \\n\") + \"See the documentation for more information about how to compile jobs containing lambda expressions.\");\n        }\n    }\n\n    private static java.lang.String encodePrimitiveClass(java.lang.Class<?> primitiveClass) {\n        final java.lang.String name = primitiveClass.getName();\n        if (name.equals(\"boolean\")) {\n            return \"Z\";\n        } else if (name.equals(\"byte\")) {\n            return \"B\";\n        } else if (name.equals(\"char\")) {\n            return \"C\";\n        } else if (name.equals(\"double\")) {\n            return \"D\";\n        } else if (name.equals(\"float\")) {\n            return \"F\";\n        } else if (name.equals(\"int\")) {\n            return \"I\";\n        } else if (name.equals(\"long\")) {\n            return \"J\";\n        } else if (name.equals(\"short\")) {\n            return \"S\";\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException();\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> findCorrespondingInfo(java.lang.reflect.TypeVariable<?> typeVar, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> corrInfo) {\n        if (type instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.TypeVariable<?> variable = ((java.lang.reflect.TypeVariable<?>) (type));\n            if (variable.getName().equals(typeVar.getName()) && variable.getGenericDeclaration().equals(typeVar.getGenericDeclaration())) {\n                return corrInfo;\n            }\n        } else if ((type instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))) {\n            java.lang.reflect.ParameterizedType tuple = ((java.lang.reflect.ParameterizedType) (type));\n            java.lang.reflect.Type[] args = tuple.getActualTypeArguments();\n            for (int i = 0; i < args.length; i++) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, args[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (corrInfo)).getTypeAt(i));\n                if (info != null) {\n                    return info;\n                }\n            }\n        }\n        return null;\n    }\n\n    private static java.lang.reflect.Type materializeTypeVariable(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.TypeVariable<?> typeVar) {\n        java.lang.reflect.TypeVariable<?> inTypeTypeVar = typeVar;\n        for (int i = typeHierarchy.size() - 1; i >= 0; i--) {\n            java.lang.reflect.Type curT = typeHierarchy.get(i);\n            if (curT instanceof java.lang.reflect.ParameterizedType) {\n                java.lang.Class<?> rawType = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType()));\n                for (int paramIndex = 0; paramIndex < rawType.getTypeParameters().length; paramIndex++) {\n                    java.lang.reflect.TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex];\n                    if (curVarOfCurT.getName().equals(inTypeTypeVar.getName()) && curVarOfCurT.getGenericDeclaration().equals(inTypeTypeVar.getGenericDeclaration())) {\n                        java.lang.reflect.Type curVarType = ((java.lang.reflect.ParameterizedType) (curT)).getActualTypeArguments()[paramIndex];\n                        if (curVarType instanceof java.lang.reflect.TypeVariable<?>) {\n                            inTypeTypeVar = ((java.lang.reflect.TypeVariable<?>) (curVarType));\n                        } else {\n                            return curVarType;\n                        }\n                    }\n                }\n            }\n        }\n        return inTypeTypeVar;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForClass(java.lang.Class<X> clazz) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForClass(clazz);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForClass(java.lang.Class<X> clazz) {\n        org.apache.commons.lang3.Validate.notNull(clazz);\n        if ((!clazz.isPrimitive()) && (java.lang.reflect.Modifier.isInterface(clazz.getModifiers()) || (java.lang.reflect.Modifier.isAbstract(clazz.getModifiers()) && (!clazz.isArray())))) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Interfaces and abstract classes are not valid types: \" + clazz);\n        }\n        if (clazz.equals(java.lang.Object.class)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object is not a valid type.\");\n        }\n        if (clazz.isArray()) {\n            org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo<X> primitiveArrayInfo = org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo.getInfoFor(clazz);\n            if (primitiveArrayInfo != null) {\n                return primitiveArrayInfo;\n            }\n            org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<X, ?> basicArrayInfo = org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo.getInfoFor(clazz);\n            if (basicArrayInfo != null) {\n                return basicArrayInfo;\n            } else {\n                return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(clazz);\n            }\n        }\n        if (org.apache.hadoop.io.Writable.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (org.apache.flink.api.java.typeutils.WritableTypeInfo.getWritableTypeInfo(((java.lang.Class<? extends org.apache.hadoop.io.Writable>) (clazz)))));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<X> basicTypeInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(clazz);\n        if (basicTypeInfo != null) {\n            return basicTypeInfo;\n        }\n        if (org.apache.flink.types.Value.class.isAssignableFrom(clazz)) {\n            java.lang.Class<? extends org.apache.flink.types.Value> valueClass = clazz.asSubclass(org.apache.flink.types.Value.class);\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(valueClass)));\n        }\n        if (org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(clazz)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n        }\n        if (alreadySeen.contains(clazz)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n        }\n        alreadySeen.add(clazz);\n        if (clazz.equals(java.lang.Class.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n        }\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n    }\n\n    @java.lang.SuppressWarnings(\"unused\")\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> analyzePojo(java.lang.Class<X> clazz) {\n        java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz);\n        java.util.List<org.apache.flink.api.java.typeutils.PojoField> pojoFields = new java.util.ArrayList<org.apache.flink.api.java.typeutils.PojoField>();\n        for (java.lang.reflect.Field field : fields) {\n            try {\n                if ((!java.lang.reflect.Modifier.isTransient(field.getModifiers())) && (!java.lang.reflect.Modifier.isStatic(field.getModifiers()))) {\n                    pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, privateCreateTypeInfo(field.getType())));\n                }\n            } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n                return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n            }\n        }\n        org.apache.flink.api.java.typeutils.PojoTypeInfo<X> pojoType = new org.apache.flink.api.java.typeutils.PojoTypeInfo<X>(clazz, pojoFields);\n        java.util.List<java.lang.reflect.Method> methods = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredMethods(clazz);\n        boolean containsReadObjectOrWriteObject = false;\n        for (java.lang.reflect.Method method : methods) {\n            if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n                containsReadObjectOrWriteObject = true;\n                break;\n            }\n        }\n        boolean hasDefaultCtor = true;\n        try {\n            clazz.getDeclaredConstructor();\n        } catch (java.lang.NoSuchMethodException e) {\n            hasDefaultCtor = false;\n        }\n        if ((!containsReadObjectOrWriteObject) && hasDefaultCtor) {\n            return pojoType;\n        }\n        return null;\n    }\n\n    private static java.util.List<java.lang.reflect.Field> getAllDeclaredFields(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Field> result = new java.util.ArrayList<java.lang.reflect.Field>();\n        while (clazz != null) {\n            java.lang.reflect.Field[] fields = clazz.getDeclaredFields();\n            for (java.lang.reflect.Field field : fields) {\n                result.add(field);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    private static java.util.List<java.lang.reflect.Method> getAllDeclaredMethods(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Method> result = new java.util.ArrayList<java.lang.reflect.Method>();\n        while (clazz != null) {\n            java.lang.reflect.Method[] methods = clazz.getDeclaredMethods();\n            for (java.lang.reflect.Method method : methods) {\n                result.add(method);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForObject(X value) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForObject(value);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForObject(X value) {\n        org.apache.commons.lang3.Validate.notNull(value);\n        if (value instanceof org.apache.flink.api.java.tuple.Tuple) {\n            org.apache.flink.api.java.tuple.Tuple t = ((org.apache.flink.api.java.tuple.Tuple) (value));\n            int numFields = t.getArity();\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] infos = new org.apache.flink.api.common.typeinfo.TypeInformation[numFields];\n            for (int i = 0; i < numFields; i++) {\n                java.lang.Object field = t.getField(i);\n                if (field == null) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Automatic type extraction is not possible on candidates with null values. \" + \"Please specify the types directly.\");\n                }\n                infos[i] = privateGetForObject(field);\n            }\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (new org.apache.flink.api.java.typeutils.TupleTypeInfo(value.getClass(), infos)));\n        } else {\n            return privateGetForClass(((java.lang.Class<X>) (value.getClass())));\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)))",
            "dst_parent": "typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)))",
            "dst_parent_type": "Assignment",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInput(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)))",
            "src_parent": "typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInput(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)))",
            "src_parent_type": "Assignment",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo)",
            "dst_parent": "info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo)",
            "dst_parent_type": "Assignment",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo)",
            "src_parent": "info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo)",
            "src_parent_type": "Assignment",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo)",
            "dst_parent": "info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo)",
            "dst_parent_type": "Assignment",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo)",
            "src_parent": "info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo)",
            "src_parent_type": "Assignment",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type)",
            "dst_parent": "tupleSubTypes[i] = createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type)",
            "dst_parent_type": "Assignment",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "createTypeInfoFromInput(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type)",
            "src_parent": "tupleSubTypes[i] = createTypeInfoFromInput(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type)",
            "src_parent_type": "Assignment",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)))",
            "dst_parent": "org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)))",
            "dst_parent_type": "LocalVariable",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInput(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)))",
            "src_parent": "org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInput(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)))",
            "src_parent_type": "LocalVariable",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "in1Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in1Type)))",
            "src_parent": "{\n    in1Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in1Type)));\n    info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "in2Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in2Type)))",
            "src_parent": "{\n    in2Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in2Type)));\n    info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private <IN1> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInput(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, java.lang.reflect.Type inType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> inTypeInfo) {\n    org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n    if (inType instanceof java.lang.reflect.TypeVariable) {\n        inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (inType)));\n        info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo);\n    } else if ((inType instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (inType)).getRawType())))) {\n        java.lang.reflect.Type[] tupleElements = ((java.lang.reflect.ParameterizedType) (inType)).getActualTypeArguments();\n        for (int i = 0; i < tupleElements.length; i++) {\n            if (tupleElements[i] instanceof java.lang.reflect.TypeVariable) {\n                inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleElements[i])));\n                info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (inTypeInfo)).getTypeAt(i));\n                if (info != null) {\n                    break;\n                }\n            }\n        }\n    }\n    return info;\n}",
            "src_parent": "public class TypeExtractor {\n    private java.util.Set<java.lang.Class<?>> alreadySeen;\n\n    private TypeExtractor() {\n        alreadySeen = new java.util.HashSet<java.lang.Class<?>>();\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapInterface)), org.apache.flink.api.common.functions.MapFunction.class, false, false, inType);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (flatMapInterface)), org.apache.flink.api.common.functions.FlatMapFunction.class, false, true, inType);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapPartitionInterface)), org.apache.flink.api.common.functions.MapPartitionFunction.class, true, true, inType);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (groupReduceInterface)), org.apache.flink.api.common.functions.GroupReduceFunction.class, true, true, inType);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.FlatJoinFunction.class, false, true, in1Type, in2Type);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.JoinFunction.class, false, false, in1Type, in2Type);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (coGroupInterface)), org.apache.flink.api.common.functions.CoGroupFunction.class, true, true, in1Type, in2Type);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (crossInterface)), org.apache.flink.api.common.functions.CrossFunction.class, false, false, in1Type, in2Type);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (selectorInterface)), org.apache.flink.api.java.functions.KeySelector.class, false, false, inType);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN> org.apache.flink.api.common.typeinfo.TypeInformation<IN> getInputFormatTypes(org.apache.flink.api.common.io.InputFormat<IN, ?> inputFormatInterface) {\n        if (inputFormatInterface instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n            return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<IN>) (inputFormatInterface)).getProducedType();\n        }\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.io.InputFormat.class, inputFormatInterface.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getUnaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterable, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n        if (m != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n            final int paramLen = m.getGenericParameterTypes().length - 1;\n            final java.lang.reflect.Type input = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterable ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input) : input, inType);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), inType, null);\n        } else {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, inType);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null);\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getBinaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterables, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n        if (m != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n            final int paramLen = m.getGenericParameterTypes().length - 1;\n            final java.lang.reflect.Type input1 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1];\n            final java.lang.reflect.Type input2 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input1) : input1, in1Type);\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input2) : input2, in2Type);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), in1Type, in2Type);\n        } else {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, in1Type);\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 1, in2Type);\n            if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n            }\n            return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type);\n        }\n    }\n\n    public static org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfo(java.lang.reflect.Type t) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(t);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, clazz, returnParamPos, in1Type, in2Type);\n    }\n\n    private org.apache.flink.api.common.typeinfo.TypeInformation<?> privateCreateTypeInfo(java.lang.reflect.Type t) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        typeHierarchy.add(t);\n        return createTypeInfoWithTypeHierarchy(typeHierarchy, t, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type returnType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = null;\n        if (returnType instanceof java.lang.reflect.TypeVariable<?>) {\n            typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)));\n            if (typeInfo != null) {\n                return typeInfo;\n            }\n        }\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.reflect.Type returnType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfoWithTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (((t instanceof java.lang.Class<?>) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (t)))) || ((t instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()))))) {\n            java.lang.reflect.Type curT = t;\n            if ((curT instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (curT)).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n            }\n            while ((!((curT instanceof java.lang.reflect.ParameterizedType) && ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType())).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) && (!((curT instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (curT)).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class)))) {\n                typeHierarchy.add(curT);\n                if (curT instanceof java.lang.reflect.ParameterizedType) {\n                    curT = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType())).getGenericSuperclass();\n                } else {\n                    curT = ((java.lang.Class<?>) (curT)).getGenericSuperclass();\n                }\n            } \n            if (curT instanceof java.lang.Class<?>) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n            }\n            java.lang.reflect.ParameterizedType tupleChild = ((java.lang.reflect.ParameterizedType) (curT));\n            java.lang.reflect.Type[] subtypes = new java.lang.reflect.Type[tupleChild.getActualTypeArguments().length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (tupleChild.getActualTypeArguments()[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    subtypes[i] = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleChild.getActualTypeArguments()[i])));\n                } else {\n                    subtypes[i] = tupleChild.getActualTypeArguments()[i];\n                }\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] tupleSubTypes = new org.apache.flink.api.common.typeinfo.TypeInformation<?>[subtypes.length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (subtypes[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    tupleSubTypes[i] = createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type);\n                    if (tupleSubTypes[i] == null) {\n                        throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                    }\n                } else {\n                    tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n                }\n            }\n            if (t instanceof java.lang.Class<?>) {\n                return new org.apache.flink.api.java.typeutils.TupleTypeInfo(((java.lang.Class<? extends org.apache.flink.api.java.tuple.Tuple>) (t)), tupleSubTypes);\n            } else if (t instanceof java.lang.reflect.ParameterizedType) {\n                return new org.apache.flink.api.java.typeutils.TupleTypeInfo(((java.lang.Class<? extends org.apache.flink.api.java.tuple.Tuple>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), tupleSubTypes);\n            }\n        } else if (t instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.Type typeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (t)));\n            if (!(typeVar instanceof java.lang.reflect.TypeVariable)) {\n                return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n            } else {\n                org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)));\n                if (typeInfo != null) {\n                    return typeInfo;\n                } else {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (t)).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (t)).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            }\n        } else if (t instanceof java.lang.reflect.GenericArrayType) {\n            java.lang.reflect.GenericArrayType genericArray = ((java.lang.reflect.GenericArrayType) (t));\n            java.lang.reflect.Type componentType = genericArray.getGenericComponentType();\n            if (componentType instanceof java.lang.Class) {\n                java.lang.Class<?> componentClass = ((java.lang.Class<?>) (componentType));\n                java.lang.String className;\n                if (componentClass.isPrimitive()) {\n                    className = org.apache.flink.api.java.typeutils.TypeExtractor.encodePrimitiveClass(componentClass);\n                } else {\n                    className = (\"L\" + componentClass.getName()) + \";\";\n                }\n                java.lang.Class<OUT> classArray = null;\n                try {\n                    classArray = ((java.lang.Class<OUT>) (java.lang.Class.forName(\"[\" + className)));\n                } catch (java.lang.ClassNotFoundException e) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n                }\n                return org.apache.flink.api.java.typeutils.TypeExtractor.getForClass(classArray);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n            return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return privateGetForClass(((java.lang.Class<OUT>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())));\n        } else if (t instanceof java.lang.Class) {\n            return privateGetForClass(((java.lang.Class<OUT>) (t)));\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type Information could not be created.\");\n    }\n\n    private <IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInputs(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1TypeInfo, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2TypeInfo) {\n        java.lang.reflect.Type matReturnTypeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n        if (!(matReturnTypeVar instanceof java.lang.reflect.TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n        } else {\n            returnTypeVar = ((java.lang.reflect.TypeVariable<?>) (matReturnTypeVar));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (in1TypeInfo != null) {\n            java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n            java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n            info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo);\n        }\n        if ((info == null) && (in2TypeInfo != null)) {\n            java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n            java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n            info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo);\n        }\n        if (info != null) {\n            return info;\n        }\n        return null;\n    }\n\n    private <IN1> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInput(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, java.lang.reflect.Type inType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> inTypeInfo) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (inType instanceof java.lang.reflect.TypeVariable) {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (inType)));\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo);\n        } else if ((inType instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (inType)).getRawType())))) {\n            java.lang.reflect.Type[] tupleElements = ((java.lang.reflect.ParameterizedType) (inType)).getActualTypeArguments();\n            for (int i = 0; i < tupleElements.length; i++) {\n                if (tupleElements[i] instanceof java.lang.reflect.TypeVariable) {\n                    inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleElements[i])));\n                    info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (inTypeInfo)).getTypeAt(i));\n                    if (info != null) {\n                        break;\n                    }\n                }\n            }\n        }\n        return info;\n    }\n\n    public static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int pos) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, null, clazz, pos);\n    }\n\n    private static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.Class<?> clazz, int pos) {\n        java.lang.reflect.Type[] interfaceTypes = clazz.getGenericInterfaces();\n        for (java.lang.reflect.Type t : interfaceTypes) {\n            java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n            if (parameter != null) {\n                return parameter;\n            }\n        }\n        java.lang.reflect.Type t = clazz.getGenericSuperclass();\n        java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n        if (parameter != null) {\n            return parameter;\n        }\n        throw new java.lang.IllegalArgumentException(((\"The types of the interface \" + baseClass.getName()) + \" could not be inferred. \") + \"Support for synthetic interfaces, lambdas, and generic types is limited at this point.\");\n    }\n\n    private static java.lang.reflect.Type getParameterTypeFromGenericType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, int pos) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.equals(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            java.lang.reflect.ParameterizedType baseClassChild = ((java.lang.reflect.ParameterizedType) (t));\n            return baseClassChild.getActualTypeArguments()[pos];\n        } else if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), pos);\n        } else if ((t instanceof java.lang.Class<?>) && baseClass.isAssignableFrom(((java.lang.Class<?>) (t)))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (t)), pos);\n        }\n        return null;\n    }\n\n    private static void validateInputType(java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, t, inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    private static void validateInputType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int inputParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, inputParamPos), inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static void validateInfo(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> typeInfo) {\n        if (type == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. Type is null.\");\n        }\n        if (typeInfo == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\n        }\n        if (!(type instanceof java.lang.reflect.TypeVariable<?>)) {\n            if (typeInfo.isBasicType()) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual = null;\n                if ((!(type instanceof java.lang.Class<?>)) || ((actual = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(((java.lang.Class<?>) (type)))) == null)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Basic type expected.\");\n                }\n                if (!typeInfo.equals(actual)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Basic type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo.isTupleType()) {\n                if ((!((type instanceof java.lang.Class<?>) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (type))))) && (!((type instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple type expected.\");\n                }\n                if ((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Concrete subclass of Tuple expected.\");\n                }\n                while ((!((type instanceof java.lang.reflect.ParameterizedType) && ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) && (!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class)))) {\n                    typeHierarchy.add(type);\n                    if (type instanceof java.lang.reflect.ParameterizedType) {\n                        type = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())).getGenericSuperclass();\n                    } else {\n                        type = ((java.lang.Class<?>) (type)).getGenericSuperclass();\n                    }\n                } \n                if (type instanceof java.lang.Class<?>) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Parameterized Tuple type expected.\");\n                }\n                org.apache.flink.api.java.typeutils.TupleTypeInfo<?> tti = ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo));\n                java.lang.reflect.Type[] subTypes = ((java.lang.reflect.ParameterizedType) (type)).getActualTypeArguments();\n                if (subTypes.length != tti.getArity()) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Tuple arity '\" + tti.getArity()) + \"' expected but was '\") + subTypes.length) + \"'.\");\n                }\n                for (int i = 0; i < subTypes.length; i++) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subTypes[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo)).getTypeAt(i));\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.hadoop.io.Writable.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Writable type expected.\");\n                }\n                java.lang.Class<?> clazz = null;\n                if (((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass() != (clazz = ((java.lang.Class<?>) (type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Writable type '\" + ((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) {\n                java.lang.reflect.Type component = null;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) {\n                if ((!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray())) && (!(type instanceof java.lang.reflect.GenericArrayType))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object array type expected.\");\n                }\n                java.lang.reflect.Type component = null;\n                if (type instanceof java.lang.Class<?>) {\n                    component = ((java.lang.Class<?>) (type)).getComponentType();\n                } else {\n                    component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType();\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.flink.types.Value.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Value type expected.\");\n                }\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual = null;\n                if (!((org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) (typeInfo)).equals(actual = org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(((java.lang.Class<? extends org.apache.flink.types.Value>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Value type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n                java.lang.Class<?> clazz = null;\n                if ((!((type instanceof java.lang.Class<?>) && (((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = ((java.lang.Class<?>) (type)))))) && (!((type instanceof java.lang.reflect.ParameterizedType) && ((clazz = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType()))) == ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass())))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"POJO type '\" + ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) {\n                java.lang.Class<?> clazz = null;\n                if ((!((type instanceof java.lang.Class<?>) && (((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = ((java.lang.Class<?>) (type)))))) && (!((type instanceof java.lang.reflect.ParameterizedType) && ((clazz = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType()))) == ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass())))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Generic object type '\" + ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            }\n        } else {\n            type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type)));\n            if (!(type instanceof java.lang.reflect.TypeVariable)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, type, typeInfo);\n            }\n        }\n    }\n\n    private static java.lang.reflect.Type removeGenericWrapper(java.lang.reflect.Type t) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && (org.apache.flink.util.Collector.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()))) || java.lang.Iterable.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()))))) {\n            return ((java.lang.reflect.ParameterizedType) (t)).getActualTypeArguments()[0];\n        }\n        return t;\n    }\n\n    private static void validateLambdaGenericParameters(java.lang.reflect.Method m) {\n        for (java.lang.reflect.Type t : m.getGenericParameterTypes()) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(t);\n        }\n        org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(m.getGenericReturnType());\n    }\n\n    private static void validateLambdaGenericParameter(java.lang.reflect.Type t) {\n        if (!(t instanceof java.lang.Class)) {\n            return;\n        }\n        final java.lang.Class<?> clazz = ((java.lang.Class<?>) (t));\n        if (clazz.getTypeParameters().length > 0) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(((((\"The generic type parameters of '\" + clazz.getSimpleName()) + \"\\' are missing. \\n\") + \"It seems that your compiler has not stored them into the .class file. \\n\") + \"Currently, only the Eclipse JDT compiler preserves the type information necessary to use the lambdas feature type-safely. \\n\") + \"See the documentation for more information about how to compile jobs containing lambda expressions.\");\n        }\n    }\n\n    private static java.lang.String encodePrimitiveClass(java.lang.Class<?> primitiveClass) {\n        final java.lang.String name = primitiveClass.getName();\n        if (name.equals(\"boolean\")) {\n            return \"Z\";\n        } else if (name.equals(\"byte\")) {\n            return \"B\";\n        } else if (name.equals(\"char\")) {\n            return \"C\";\n        } else if (name.equals(\"double\")) {\n            return \"D\";\n        } else if (name.equals(\"float\")) {\n            return \"F\";\n        } else if (name.equals(\"int\")) {\n            return \"I\";\n        } else if (name.equals(\"long\")) {\n            return \"J\";\n        } else if (name.equals(\"short\")) {\n            return \"S\";\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException();\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> findCorrespondingInfo(java.lang.reflect.TypeVariable<?> typeVar, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> corrInfo) {\n        if (type instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.TypeVariable<?> variable = ((java.lang.reflect.TypeVariable<?>) (type));\n            if (variable.getName().equals(typeVar.getName()) && variable.getGenericDeclaration().equals(typeVar.getGenericDeclaration())) {\n                return corrInfo;\n            }\n        } else if ((type instanceof java.lang.reflect.ParameterizedType) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))) {\n            java.lang.reflect.ParameterizedType tuple = ((java.lang.reflect.ParameterizedType) (type));\n            java.lang.reflect.Type[] args = tuple.getActualTypeArguments();\n            for (int i = 0; i < args.length; i++) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, args[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (corrInfo)).getTypeAt(i));\n                if (info != null) {\n                    return info;\n                }\n            }\n        }\n        return null;\n    }\n\n    private static java.lang.reflect.Type materializeTypeVariable(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.TypeVariable<?> typeVar) {\n        java.lang.reflect.TypeVariable<?> inTypeTypeVar = typeVar;\n        for (int i = typeHierarchy.size() - 1; i >= 0; i--) {\n            java.lang.reflect.Type curT = typeHierarchy.get(i);\n            if (curT instanceof java.lang.reflect.ParameterizedType) {\n                java.lang.Class<?> rawType = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType()));\n                for (int paramIndex = 0; paramIndex < rawType.getTypeParameters().length; paramIndex++) {\n                    java.lang.reflect.TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex];\n                    if (curVarOfCurT.getName().equals(inTypeTypeVar.getName()) && curVarOfCurT.getGenericDeclaration().equals(inTypeTypeVar.getGenericDeclaration())) {\n                        java.lang.reflect.Type curVarType = ((java.lang.reflect.ParameterizedType) (curT)).getActualTypeArguments()[paramIndex];\n                        if (curVarType instanceof java.lang.reflect.TypeVariable<?>) {\n                            inTypeTypeVar = ((java.lang.reflect.TypeVariable<?>) (curVarType));\n                        } else {\n                            return curVarType;\n                        }\n                    }\n                }\n            }\n        }\n        return inTypeTypeVar;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForClass(java.lang.Class<X> clazz) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForClass(clazz);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForClass(java.lang.Class<X> clazz) {\n        org.apache.commons.lang3.Validate.notNull(clazz);\n        if ((!clazz.isPrimitive()) && (java.lang.reflect.Modifier.isInterface(clazz.getModifiers()) || (java.lang.reflect.Modifier.isAbstract(clazz.getModifiers()) && (!clazz.isArray())))) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Interfaces and abstract classes are not valid types: \" + clazz);\n        }\n        if (clazz.equals(java.lang.Object.class)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object is not a valid type.\");\n        }\n        if (clazz.isArray()) {\n            org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo<X> primitiveArrayInfo = org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo.getInfoFor(clazz);\n            if (primitiveArrayInfo != null) {\n                return primitiveArrayInfo;\n            }\n            org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<X, ?> basicArrayInfo = org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo.getInfoFor(clazz);\n            if (basicArrayInfo != null) {\n                return basicArrayInfo;\n            } else {\n                return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(clazz);\n            }\n        }\n        if (org.apache.hadoop.io.Writable.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (org.apache.flink.api.java.typeutils.WritableTypeInfo.getWritableTypeInfo(((java.lang.Class<? extends org.apache.hadoop.io.Writable>) (clazz)))));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<X> basicTypeInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(clazz);\n        if (basicTypeInfo != null) {\n            return basicTypeInfo;\n        }\n        if (org.apache.flink.types.Value.class.isAssignableFrom(clazz)) {\n            java.lang.Class<? extends org.apache.flink.types.Value> valueClass = clazz.asSubclass(org.apache.flink.types.Value.class);\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(valueClass)));\n        }\n        if (org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(clazz)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n        }\n        if (alreadySeen.contains(clazz)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n        }\n        alreadySeen.add(clazz);\n        if (clazz.equals(java.lang.Class.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n        }\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n    }\n\n    @java.lang.SuppressWarnings(\"unused\")\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> analyzePojo(java.lang.Class<X> clazz) {\n        java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz);\n        java.util.List<org.apache.flink.api.java.typeutils.PojoField> pojoFields = new java.util.ArrayList<org.apache.flink.api.java.typeutils.PojoField>();\n        for (java.lang.reflect.Field field : fields) {\n            try {\n                if ((!java.lang.reflect.Modifier.isTransient(field.getModifiers())) && (!java.lang.reflect.Modifier.isStatic(field.getModifiers()))) {\n                    pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, privateCreateTypeInfo(field.getType())));\n                }\n            } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n                return new org.apache.flink.api.java.typeutils.GenericTypeInfo<X>(clazz);\n            }\n        }\n        org.apache.flink.api.java.typeutils.PojoTypeInfo<X> pojoType = new org.apache.flink.api.java.typeutils.PojoTypeInfo<X>(clazz, pojoFields);\n        java.util.List<java.lang.reflect.Method> methods = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredMethods(clazz);\n        boolean containsReadObjectOrWriteObject = false;\n        for (java.lang.reflect.Method method : methods) {\n            if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n                containsReadObjectOrWriteObject = true;\n                break;\n            }\n        }\n        boolean hasDefaultCtor = true;\n        try {\n            clazz.getDeclaredConstructor();\n        } catch (java.lang.NoSuchMethodException e) {\n            hasDefaultCtor = false;\n        }\n        if ((!containsReadObjectOrWriteObject) && hasDefaultCtor) {\n            return pojoType;\n        }\n        return null;\n    }\n\n    private static java.util.List<java.lang.reflect.Field> getAllDeclaredFields(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Field> result = new java.util.ArrayList<java.lang.reflect.Field>();\n        while (clazz != null) {\n            java.lang.reflect.Field[] fields = clazz.getDeclaredFields();\n            for (java.lang.reflect.Field field : fields) {\n                result.add(field);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    private static java.util.List<java.lang.reflect.Method> getAllDeclaredMethods(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Method> result = new java.util.ArrayList<java.lang.reflect.Method>();\n        while (clazz != null) {\n            java.lang.reflect.Method[] methods = clazz.getDeclaredMethods();\n            for (java.lang.reflect.Method method : methods) {\n                result.add(method);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForObject(X value) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForObject(value);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForObject(X value) {\n        org.apache.commons.lang3.Validate.notNull(value);\n        if (value instanceof org.apache.flink.api.java.tuple.Tuple) {\n            org.apache.flink.api.java.tuple.Tuple t = ((org.apache.flink.api.java.tuple.Tuple) (value));\n            int numFields = t.getArity();\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] infos = new org.apache.flink.api.common.typeinfo.TypeInformation[numFields];\n            for (int i = 0; i < numFields; i++) {\n                java.lang.Object field = t.getField(i);\n                if (field == null) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Automatic type extraction is not possible on candidates with null values. \" + \"Please specify the types directly.\");\n                }\n                infos[i] = privateGetForObject(field);\n            }\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (new org.apache.flink.api.java.typeutils.TupleTypeInfo(value.getClass(), infos)));\n        } else {\n            return privateGetForClass(((java.lang.Class<X>) (value.getClass())));\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "in1TypeInfo != null",
            "dst_parent": "if (in1TypeInfo != null) {\n    java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n    java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n    info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo);\n}",
            "dst_parent_type": "If",
            "dst_type": "BinaryOperator",
            "operator": "MOV",
            "src": "in1TypeInfo != null",
            "src_parent": "if (in1TypeInfo != null) {\n    java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n    java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n    if (in1Type instanceof java.lang.reflect.TypeVariable) {\n        in1Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in1Type)));\n        info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n    }\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n    java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n    info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo);\n}",
            "dst_parent": "if (in1TypeInfo != null) {\n    java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n    java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n    info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in1Type, in1TypeInfo);\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    in1Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in1Type)));\n    info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n}",
            "src_parent": "if (in1Type instanceof java.lang.reflect.TypeVariable) {\n    in1Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in1Type)));\n    info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in1Type, in1TypeInfo);\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "(info == null) && (in2TypeInfo != null)",
            "dst_parent": "if ((info == null) && (in2TypeInfo != null)) {\n    java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n    java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n    info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo);\n}",
            "dst_parent_type": "If",
            "dst_type": "BinaryOperator",
            "operator": "MOV",
            "src": "(info == null) && (in2TypeInfo != null)",
            "src_parent": "if ((info == null) && (in2TypeInfo != null)) {\n    java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n    java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n    if (in2Type instanceof java.lang.reflect.TypeVariable) {\n        in2Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in2Type)));\n        info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n    }\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n    java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n    info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo);\n}",
            "dst_parent": "if ((info == null) && (in2TypeInfo != null)) {\n    java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (returnTypeHierarchy.get(returnTypeHierarchy.size() - 1)));\n    java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n    info = createTypeInfoFromInput(returnTypeVar, returnTypeHierarchy, in2Type, in2TypeInfo);\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    in2Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in2Type)));\n    info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n}",
            "src_parent": "if (in2Type instanceof java.lang.reflect.TypeVariable) {\n    in2Type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (in2Type)));\n    info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, in2Type, in2TypeInfo);\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        }
      ],
      "file_name": "TypeExtractor"
    }
  ],
  "id": "flink_27e40205"
}