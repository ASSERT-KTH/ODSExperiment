{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "isConflicting(before, op)",
            "src_parent": "(op.isDelete() || (!op.isNew())) && isConflicting(before, op)",
            "src_parent_type": "BinaryOperator",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean allowConcurrentAddRemove(@javax.annotation.Nullable\norg.apache.jackrabbit.oak.plugins.document.NodeDocument before, @javax.annotation.Nonnull\norg.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n    return nodeStore.getEnableConcurrentAddRemove() && (!isConflicting(before, op));\n}",
            "src_parent": "public class Commit {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.Commit.class);\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch;\n\n    private final org.apache.jackrabbit.oak.plugins.document.Revision baseRevision;\n\n    private final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n    private final java.util.HashMap<java.lang.String, org.apache.jackrabbit.oak.plugins.document.UpdateOp> operations = new java.util.LinkedHashMap<java.lang.String, org.apache.jackrabbit.oak.plugins.document.UpdateOp>();\n\n    private final org.apache.jackrabbit.oak.commons.json.JsopWriter diff = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n\n    private final java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> collisions = new java.util.LinkedHashSet<org.apache.jackrabbit.oak.plugins.document.Revision>();\n\n    private org.apache.jackrabbit.oak.plugins.document.Branch b;\n\n    private java.util.HashSet<java.lang.String> modifiedNodes = new java.util.HashSet<java.lang.String>();\n\n    private java.util.HashSet<java.lang.String> addedNodes = new java.util.HashSet<java.lang.String>();\n\n    private java.util.HashSet<java.lang.String> removedNodes = new java.util.HashSet<java.lang.String>();\n\n    private java.util.HashSet<java.lang.String> nodesWithBinaries = com.google.common.collect.Sets.newHashSet();\n\n    Commit(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch) {\n        this.nodeStore = com.google.common.base.Preconditions.checkNotNull(nodeStore);\n        this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n        this.baseRevision = baseRevision;\n        this.branch = branch;\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp getUpdateOperationForNode(java.lang.String path) {\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = operations.get(path);\n        if (op == null) {\n            java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(path);\n            op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(op, revision);\n            operations.put(path, op);\n        }\n        return op;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision getRevision() {\n        return revision;\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.Revision getBaseRevision() {\n        return baseRevision;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<java.lang.String> getModifiedPaths() {\n        return modifiedNodes;\n    }\n\n    void addNodeDiff(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n) {\n        diff.tag('+').key(n.getPath());\n        diff.object();\n        n.append(diff, false);\n        diff.endObject();\n        diff.newline();\n    }\n\n    void updateProperty(java.lang.String path, java.lang.String propertyName, java.lang.String value) {\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = getUpdateOperationForNode(path);\n        java.lang.String key = org.apache.jackrabbit.oak.plugins.document.util.Utils.escapePropertyName(propertyName);\n        op.setMapEntry(key, revision, value);\n    }\n\n    void markNodeHavingBinary(java.lang.String path) {\n        this.nodesWithBinaries.add(path);\n    }\n\n    void addNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n) {\n        java.lang.String path = n.getPath();\n        if (operations.containsKey(path)) {\n            java.lang.String msg = \"Node already added: \" + path;\n            org.apache.jackrabbit.oak.plugins.document.Commit.LOG.error(msg);\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(msg);\n        }\n        operations.put(path, n.asOperation(true));\n        addedNodes.add(path);\n    }\n\n    boolean isEmpty() {\n        return operations.isEmpty();\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision apply() throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Revision baseRev = getBaseRevision();\n        boolean isBranch = (baseRev != null) && baseRev.isBranch();\n        org.apache.jackrabbit.oak.plugins.document.Revision rev = getRevision();\n        if (isBranch && (!nodeStore.isDisableBranches())) {\n            rev = rev.asBranchRevision();\n            org.apache.jackrabbit.oak.plugins.document.Branch b = nodeStore.getBranches().getBranch(baseRev);\n            if (b == null) {\n                b = nodeStore.getBranches().create(baseRev.asTrunkRevision(), rev, branch);\n                org.apache.jackrabbit.oak.plugins.document.Commit.LOG.debug(\"Branch created with base revision {} and \" + \"modifications on {}\", baseRevision, operations.keySet());\n                if (org.apache.jackrabbit.oak.plugins.document.Commit.LOG.isTraceEnabled()) {\n                    org.apache.jackrabbit.oak.plugins.document.Commit.LOG.trace(\"Branch created\", new java.lang.Exception());\n                }\n            } else {\n                b.addCommit(rev);\n            }\n            try {\n                prepare(baseRev);\n                success = true;\n            } finally {\n                if (!success) {\n                    b.removeCommit(rev);\n                    if (!b.hasCommits()) {\n                        nodeStore.getBranches().remove(b);\n                    }\n                }\n            }\n        } else {\n            applyInternal();\n        }\n        if (isBranch) {\n            rev = rev.asBranchRevision();\n        }\n        return rev;\n    }\n\n    private void applyInternal() {\n        if (!operations.isEmpty()) {\n            updateParentChildStatus();\n            updateBinaryStatus();\n            applyToDocumentStore();\n        }\n    }\n\n    private void prepare(org.apache.jackrabbit.oak.plugins.document.Revision baseRevision) {\n        if (!operations.isEmpty()) {\n            updateParentChildStatus();\n            updateBinaryStatus();\n            applyToDocumentStore(baseRevision);\n        }\n    }\n\n    private void updateBinaryStatus() {\n        org.apache.jackrabbit.oak.plugins.document.DocumentStore store = this.nodeStore.getDocumentStore();\n        for (java.lang.String path : this.nodesWithBinaries) {\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument nd = store.getIfCached(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(path));\n            if ((nd == null) || (!nd.hasBinary())) {\n                org.apache.jackrabbit.oak.plugins.document.UpdateOp updateParentOp = getUpdateOperationForNode(path);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.setHasBinary(updateParentOp);\n            }\n        }\n    }\n\n    void applyToDocumentStore() {\n        applyToDocumentStore(null);\n    }\n\n    private void applyToDocumentStore(org.apache.jackrabbit.oak.plugins.document.Revision baseBranchRevision) {\n        java.lang.String commitValue = (baseBranchRevision != null) ? baseBranchRevision.toString() : \"c\";\n        org.apache.jackrabbit.oak.plugins.document.DocumentStore store = nodeStore.getDocumentStore();\n        java.lang.String commitRootPath = null;\n        if (baseBranchRevision != null) {\n            commitRootPath = \"/\";\n        }\n        java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp> newNodes = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp>();\n        java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp> changedNodes = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp>();\n        java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp> opLog = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp>();\n        for (java.lang.String p : operations.keySet()) {\n            markChanged(p);\n            if (commitRootPath == null) {\n                commitRootPath = p;\n            } else {\n                while (!org.apache.jackrabbit.oak.commons.PathUtils.isAncestor(commitRootPath, p)) {\n                    commitRootPath = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(commitRootPath);\n                    if (denotesRoot(commitRootPath)) {\n                        break;\n                    }\n                } \n            }\n        }\n        if (baseBranchRevision != null) {\n            org.apache.jackrabbit.oak.plugins.document.JournalEntry doc = org.apache.jackrabbit.oak.plugins.document.Collection.JOURNAL.newDocument(store);\n            doc.modified(modifiedNodes);\n            org.apache.jackrabbit.oak.plugins.document.Revision r = revision.asBranchRevision();\n            store.create(org.apache.jackrabbit.oak.plugins.document.Collection.JOURNAL, java.util.Collections.singletonList(doc.asUpdateOp(r)));\n        }\n        int commitRootDepth = org.apache.jackrabbit.oak.commons.PathUtils.getDepth(commitRootPath);\n        boolean commitRootHasChanges = operations.containsKey(commitRootPath);\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp commitRoot = getUpdateOperationForNode(commitRootPath);\n        for (java.lang.String p : operations.keySet()) {\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = operations.get(p);\n            if (op.isNew()) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.setDeleted(op, revision, false);\n            }\n            if (op == commitRoot) {\n                if ((!op.isNew()) && commitRootHasChanges) {\n                    changedNodes.add(op);\n                }\n            } else {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n                if (op.isNew()) {\n                    newNodes.add(op);\n                } else {\n                    changedNodes.add(op);\n                }\n            }\n        }\n        if ((changedNodes.size() == 0) && commitRoot.isNew()) {\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setRevision(commitRoot, revision, commitValue);\n            newNodes.add(commitRoot);\n        }\n        boolean success = false;\n        try {\n            if (newNodes.size() > 0) {\n                if (!store.create(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, newNodes)) {\n                    for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : newNodes) {\n                        if (op == commitRoot) {\n                            org.apache.jackrabbit.oak.plugins.document.NodeDocument.unsetRevision(commitRoot, revision);\n                        }\n                        changedNodes.add(op);\n                    }\n                    newNodes.clear();\n                }\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : changedNodes) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.setCommitRoot(op, revision, commitRootDepth);\n                opLog.add(op);\n                createOrUpdateNode(store, op);\n            }\n            if ((changedNodes.size() > 0) || (!commitRoot.isNew())) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.setRevision(commitRoot, revision, commitValue);\n                if (commitRootHasChanges) {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCommitRoot(commitRoot, revision);\n                }\n                opLog.add(commitRoot);\n                if (baseBranchRevision == null) {\n                    org.apache.jackrabbit.oak.plugins.document.UpdateOp commit = commitRoot.copy();\n                    commit.setNew(false);\n                    commit.containsMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, revision, false);\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument before = nodeStore.updateCommitRoot(commit);\n                    if (before == null) {\n                        java.lang.String msg = (\"Conflicting concurrent change. \" + \"Update operation failed: \") + commitRoot;\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = store.find(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, commitRoot.getId());\n                        org.apache.jackrabbit.oak.plugins.document.DocumentStoreException dse;\n                        if (commitRootDoc == null) {\n                            dse = new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(msg);\n                        } else {\n                            dse = new org.apache.jackrabbit.oak.plugins.document.ConflictException(msg, commitRootDoc.getMostRecentConflictFor(java.util.Collections.singleton(revision), nodeStore));\n                        }\n                        throw dse;\n                    } else {\n                        success = true;\n                        checkConflicts(commitRoot, before);\n                        checkSplitCandidate(before);\n                    }\n                } else {\n                    createOrUpdateNode(store, commitRoot);\n                }\n                operations.put(commitRootPath, commitRoot);\n            }\n        } catch (org.apache.jackrabbit.oak.plugins.document.DocumentStoreException e) {\n            if (success) {\n                org.apache.jackrabbit.oak.plugins.document.Commit.LOG.error(\"Exception occurred after commit. Rollback will be suppressed.\", e);\n            } else {\n                rollback(newNodes, opLog, commitRoot);\n                throw e;\n            }\n        }\n    }\n\n    private void updateParentChildStatus() {\n        final java.util.Set<java.lang.String> processedParents = com.google.common.collect.Sets.newHashSet();\n        for (java.lang.String path : addedNodes) {\n            if (denotesRoot(path)) {\n                continue;\n            }\n            java.lang.String parentPath = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(path);\n            if (processedParents.contains(parentPath)) {\n                continue;\n            }\n            processedParents.add(parentPath);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = getUpdateOperationForNode(parentPath);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setChildrenFlag(op, true);\n        }\n    }\n\n    private void rollback(java.util.List<org.apache.jackrabbit.oak.plugins.document.UpdateOp> newDocuments, java.util.List<org.apache.jackrabbit.oak.plugins.document.UpdateOp> changed, org.apache.jackrabbit.oak.plugins.document.UpdateOp commitRoot) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentStore store = nodeStore.getDocumentStore();\n        for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : changed) {\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp reverse = op.getReverseOperation();\n            if (op.isNew()) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.setDeletedOnce(reverse);\n            }\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, reverse);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : newDocuments) {\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp reverse = op.getReverseOperation();\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setDeletedOnce(reverse);\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, reverse);\n        }\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp removeCollision = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(commitRoot.getId(), false);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(removeCollision, revision);\n        store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, removeCollision);\n    }\n\n    private void createOrUpdateNode(org.apache.jackrabbit.oak.plugins.document.DocumentStore store, org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.createOrUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, op);\n        checkConflicts(op, doc);\n        checkSplitCandidate(doc);\n    }\n\n    private void checkSplitCandidate(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument doc) {\n        if ((doc != null) && (doc.getMemory() > org.apache.jackrabbit.oak.plugins.document.NodeDocument.SPLIT_CANDIDATE_THRESHOLD)) {\n            nodeStore.addSplitCandidate(doc.getId());\n        }\n    }\n\n    private void checkConflicts(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument before) throws org.apache.jackrabbit.oak.plugins.document.ConflictException {\n        org.apache.jackrabbit.oak.plugins.document.DocumentStore store = nodeStore.getDocumentStore();\n        collisions.clear();\n        if (baseRevision != null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n            if (before != null) {\n                org.apache.jackrabbit.oak.plugins.document.Revision base = baseRevision;\n                if (nodeStore.isDisableBranches()) {\n                    base = base.asTrunkRevision();\n                }\n                newestRev = before.getNewestRevision(nodeStore, base, revision, getBranch(), collisions);\n            }\n            java.lang.String conflictMessage = null;\n            org.apache.jackrabbit.oak.plugins.document.Revision conflictRevision = newestRev;\n            if (newestRev == null) {\n                if ((op.isDelete() || (!op.isNew())) && (!allowConcurrentAddRemove(before, op))) {\n                    conflictMessage = (\"The node \" + op.getId()) + \" does not exist or is already deleted\";\n                    if ((before != null) && (!before.getLocalDeleted().isEmpty())) {\n                        conflictRevision = before.getLocalDeleted().firstKey();\n                    }\n                }\n            } else if (op.isNew() && (!allowConcurrentAddRemove(before, op))) {\n                conflictMessage = ((\"The node \" + op.getId()) + \" was already added in revision\\n\") + formatConflictRevision(newestRev);\n            } else if (nodeStore.isRevisionNewer(newestRev, baseRevision) && (op.isDelete() || isConflicting(before, op))) {\n                conflictMessage = ((((\"The node \" + op.getId()) + \" was changed in revision\\n\") + formatConflictRevision(newestRev)) + \", which was applied after the base revision\\n\") + baseRevision;\n            }\n            if (conflictMessage == null) {\n                if ((!collisions.isEmpty()) && isConflicting(before, op)) {\n                    for (org.apache.jackrabbit.oak.plugins.document.Revision r : collisions) {\n                        org.apache.jackrabbit.oak.plugins.document.Collision c = new org.apache.jackrabbit.oak.plugins.document.Collision(before, r, op, revision);\n                        if (c.mark(store).equals(revision)) {\n                            if (baseRevision.isBranch()) {\n                            } else {\n                                conflictMessage = ((((\"The node \" + op.getId()) + \" was changed in revision\\n\") + formatConflictRevision(r)) + \", which was applied after the base revision\\n\") + baseRevision;\n                                conflictRevision = r;\n                            }\n                        }\n                    }\n                }\n            }\n            if (conflictMessage != null) {\n                conflictMessage += \", before\\n\" + revision;\n                if (org.apache.jackrabbit.oak.plugins.document.Commit.LOG.isDebugEnabled()) {\n                    org.apache.jackrabbit.oak.plugins.document.Commit.LOG.debug((((conflictMessage + \"; document:\\n\") + (before == null ? \"\" : before.format())) + \",\\nrevision order:\\n\") + nodeStore.getRevisionComparator());\n                }\n                throw new org.apache.jackrabbit.oak.plugins.document.ConflictException(conflictMessage, conflictRevision);\n            }\n        }\n    }\n\n    private java.lang.String formatConflictRevision(org.apache.jackrabbit.oak.plugins.document.Revision r) {\n        if (isRevisionNewer(nodeStore, r, nodeStore.getHeadRevision())) {\n            return r + \" (not yet visible)\";\n        } else {\n            return r.toString();\n        }\n    }\n\n    private boolean isConflicting(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument doc, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        if ((baseRevision == null) || (doc == null)) {\n            return false;\n        }\n        return doc.isConflicting(op, baseRevision, revision, nodeStore, nodeStore.getEnableConcurrentAddRemove());\n    }\n\n    private boolean allowConcurrentAddRemove(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument before, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        return nodeStore.getEnableConcurrentAddRemove() && (!isConflicting(before, op));\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.Branch getBranch() {\n        if ((baseRevision == null) || (!baseRevision.isBranch())) {\n            return null;\n        }\n        if (b == null) {\n            b = nodeStore.getBranches().getBranch(revision);\n        }\n        return b;\n    }\n\n    public void applyToCache(org.apache.jackrabbit.oak.plugins.document.Revision before, boolean isBranchCommit) {\n        java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>> nodesWithChangedChildren = new java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>();\n        for (java.lang.String p : modifiedNodes) {\n            if (denotesRoot(p)) {\n                continue;\n            }\n            java.lang.String parent = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(p);\n            java.util.ArrayList<java.lang.String> list = nodesWithChangedChildren.get(parent);\n            if (list == null) {\n                list = new java.util.ArrayList<java.lang.String>();\n                nodesWithChangedChildren.put(parent, list);\n            }\n            list.add(p);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DiffCache.Entry cacheEntry = nodeStore.getDiffCache().newEntry(before, revision, true);\n        org.apache.jackrabbit.oak.plugins.document.LastRevTracker tracker = nodeStore.createTracker(revision, isBranchCommit);\n        java.util.List<java.lang.String> added = new java.util.ArrayList<java.lang.String>();\n        java.util.List<java.lang.String> removed = new java.util.ArrayList<java.lang.String>();\n        java.util.List<java.lang.String> changed = new java.util.ArrayList<java.lang.String>();\n        for (java.lang.String path : modifiedNodes) {\n            added.clear();\n            removed.clear();\n            changed.clear();\n            java.util.ArrayList<java.lang.String> changes = nodesWithChangedChildren.get(path);\n            if (changes != null) {\n                for (java.lang.String s : changes) {\n                    if (addedNodes.contains(s)) {\n                        added.add(s);\n                    } else if (removedNodes.contains(s)) {\n                        removed.add(s);\n                    } else {\n                        changed.add(s);\n                    }\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = operations.get(path);\n            boolean isNew = (op != null) && op.isNew();\n            if (((op == null) || (!org.apache.jackrabbit.oak.plugins.document.Commit.hasContentChanges(op))) || denotesRoot(path)) {\n                tracker.track(path);\n            }\n            nodeStore.applyChanges(revision, path, isNew, added, removed, changed, cacheEntry);\n        }\n        cacheEntry.done();\n    }\n\n    public void moveNode(java.lang.String sourcePath, java.lang.String targetPath) {\n        diff.tag('>').key(sourcePath).value(targetPath);\n    }\n\n    public void copyNode(java.lang.String sourcePath, java.lang.String targetPath) {\n        diff.tag('*').key(sourcePath).value(targetPath);\n    }\n\n    private void markChanged(java.lang.String path) {\n        if ((!denotesRoot(path)) && (!org.apache.jackrabbit.oak.commons.PathUtils.isAbsolute(path))) {\n            throw new java.lang.IllegalArgumentException(\"path: \" + path);\n        }\n        while (true) {\n            if (!modifiedNodes.add(path)) {\n                break;\n            }\n            if (denotesRoot(path)) {\n                break;\n            }\n            path = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(path);\n        } \n    }\n\n    public void updatePropertyDiff(java.lang.String path, java.lang.String propertyName, java.lang.String value) {\n        diff.tag('^').key(org.apache.jackrabbit.oak.commons.PathUtils.concat(path, propertyName)).value(value);\n    }\n\n    public void removeNodeDiff(java.lang.String path) {\n        diff.tag('-').value(path).newline();\n    }\n\n    public void removeNode(java.lang.String path) {\n        removedNodes.add(path);\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = getUpdateOperationForNode(path);\n        op.setDelete(true);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.setDeleted(op, revision, true);\n    }\n\n    private static final com.google.common.base.Function<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, java.lang.String> KEY_TO_NAME = new com.google.common.base.Function<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, java.lang.String>() {\n        @java.lang.Override\n        public java.lang.String apply(org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key input) {\n            return input.getName();\n        }\n    };\n\n    private static boolean hasContentChanges(org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(op.getChanges().keySet(), org.apache.jackrabbit.oak.plugins.document.Commit.KEY_TO_NAME), Utils.PROPERTY_OR_DELETED).iterator().hasNext();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "(!allowConcurrentAddRemove(before, op))",
            "src_parent": "(op.isDelete() || (!op.isNew())) && (!allowConcurrentAddRemove(before, op))",
            "src_parent_type": "BinaryOperator",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "(!allowConcurrentAddRemove(before, op))",
            "src_parent": "op.isNew() && (!allowConcurrentAddRemove(before, op))",
            "src_parent_type": "BinaryOperator",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "isConflicting(before, op)",
            "dst_parent": "(!isConflicting(before, op))",
            "dst_parent_type": "UnaryOperator",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "isConflicting(before, op)",
            "src_parent": "op.isNew() && isConflicting(before, op)",
            "src_parent_type": "BinaryOperator",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.document.Commit",
            "dst_parent": "",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "MOV",
            "src": "org.apache.jackrabbit.oak.plugins.document.Commit",
            "src_parent": "",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "before",
            "dst_parent": "allowConcurrentAddRemove(before, op)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "before",
            "src_parent": "isConflicting(before, op)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "op",
            "dst_parent": "allowConcurrentAddRemove(before, op)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "op",
            "src_parent": "isConflicting(before, op)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        }
      ],
      "file_name": "Commit"
    }
  ],
  "id": "jackrabbit-oak_a5ff019e"
}