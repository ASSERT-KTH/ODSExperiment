{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static long revisionPurgeMillis() {\n    return org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS;\n}",
            "src_parent": "public final class DocumentNodeStore implements org.apache.jackrabbit.oak.plugins.document.RevisionContext , org.apache.jackrabbit.oak.spi.commit.Observable , org.apache.jackrabbit.oak.spi.state.NodeStore {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.class);\n\n    static final int NUM_CHILDREN_CACHE_LIMIT = java.lang.Integer.getInteger(\"oak.documentMK.childrenCacheLimit\", 16 * 1024);\n\n    private static final int WARN_REVISION_AGE = java.lang.Integer.getInteger(\"oak.documentMK.revisionAge\", 60 * 1000);\n\n    static final int REMEMBER_REVISION_ORDER_MILLIS = (60 * 60) * 1000;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState missing;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.CommitQueue commitQueue;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue batchCommitQueue;\n\n    protected final org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher dispatcher;\n\n    protected int asyncDelay = 1000;\n\n    protected int maxBackOffMillis = asyncDelay * 2;\n\n    private final java.util.concurrent.atomic.AtomicBoolean isDisposed = new java.util.concurrent.atomic.AtomicBoolean();\n\n    private final org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo clusterNodeInfo;\n\n    private final int clusterId;\n\n    private final java.util.concurrent.ConcurrentMap<java.lang.Integer, java.lang.Long> inactiveClusterNodes = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, java.lang.Long>();\n\n    private final Revision.RevisionComparator revisionComparator;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnmergedBranches branches;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnsavedModifications unsavedLastRevisions = new org.apache.jackrabbit.oak.plugins.document.UnsavedModifications();\n\n    private final java.util.Map<java.lang.String, java.lang.String> splitCandidates = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastKnownRevision = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision>();\n\n    private volatile org.apache.jackrabbit.oak.plugins.document.Revision headRevision;\n\n    private java.lang.Thread backgroundThread;\n\n    private java.lang.Thread leaseUpdateThread;\n\n    private final java.util.concurrent.locks.ReadWriteLock backgroundOperationLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private final java.util.concurrent.locks.ReadWriteLock mergeLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private java.util.concurrent.atomic.AtomicInteger simpleRevisionCounter;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> nodeCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children> nodeChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeChildrenCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.util.StringValue, org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children> docChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats docChildrenCacheStats;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DiffCache diffCache;\n\n    private final org.apache.jackrabbit.oak.spi.blob.BlobStore blobStore;\n\n    private final org.apache.jackrabbit.oak.kernel.BlobSerializer blobSerializer = new org.apache.jackrabbit.oak.kernel.BlobSerializer() {\n        @java.lang.Override\n        public java.lang.String serialize(org.apache.jackrabbit.oak.api.Blob blob) {\n            if (blob instanceof org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) {\n                return ((org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) (blob)).getBlobId();\n            }\n            java.lang.String id;\n            java.lang.String reference = blob.getReference();\n            if (reference != null) {\n                id = blobStore.getBlobId(reference);\n                if (id != null) {\n                    return id;\n                }\n            }\n            try {\n                id = createBlob(blob.getNewStream()).getBlobId();\n            } catch (java.io.IOException e) {\n                throw new java.lang.IllegalStateException(e);\n            }\n            return id;\n        }\n    };\n\n    private final org.apache.jackrabbit.oak.stats.Clock clock;\n\n    private final org.apache.jackrabbit.oak.plugins.document.Checkpoints checkpoints;\n\n    private final org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector versionGarbageCollector;\n\n    private final java.util.concurrent.Executor executor;\n\n    private final org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent lastRevRecoveryAgent;\n\n    private final boolean disableBranches;\n\n    private org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache;\n\n    public DocumentNodeStore(org.apache.jackrabbit.oak.plugins.document.DocumentMK.Builder builder) {\n        this.blobStore = builder.getBlobStore();\n        if (builder.isUseSimpleRevision()) {\n            this.simpleRevisionCounter = new java.util.concurrent.atomic.AtomicInteger(0);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentStore s = builder.getDocumentStore();\n        if (builder.getTiming()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.TimingDocumentStoreWrapper(s);\n        }\n        if (builder.getLogging()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.LoggingDocumentStoreWrapper(s);\n        }\n        this.store = s;\n        this.executor = builder.getExecutor();\n        this.clock = builder.getClock();\n        int cid = builder.getClusterId();\n        cid = java.lang.Integer.getInteger(\"oak.documentMK.clusterId\", cid);\n        if (cid == 0) {\n            clusterNodeInfo = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getInstance(store);\n            cid = clusterNodeInfo.getId();\n        } else {\n            clusterNodeInfo = null;\n        }\n        this.clusterId = cid;\n        this.revisionComparator = new org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator(clusterId);\n        this.branches = new org.apache.jackrabbit.oak.plugins.document.UnmergedBranches(getRevisionComparator());\n        this.asyncDelay = builder.getAsyncDelay();\n        this.versionGarbageCollector = new org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector(this);\n        this.lastRevRecoveryAgent = new org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent(this);\n        this.disableBranches = builder.isDisableBranches();\n        this.missing = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"MISSING\", new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, 0)) {\n            @java.lang.Override\n            public int getMemory() {\n                return 8;\n            }\n        };\n        nodeCache = builder.buildNodeCache(this);\n        nodeCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeCache, \"Document-NodeState\", builder.getWeigher(), builder.getNodeCacheSize());\n        nodeChildrenCache = builder.buildChildrenCache();\n        nodeChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeChildrenCache, \"Document-NodeChildren\", builder.getWeigher(), builder.getChildrenCacheSize());\n        docChildrenCache = builder.buildDocChildrenCache();\n        docChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(docChildrenCache, \"Document-DocChildren\", builder.getWeigher(), builder.getDocChildrenCacheSize());\n        diffCache = builder.getDiffCache();\n        checkpoints = new org.apache.jackrabbit.oak.plugins.document.Checkpoints(this);\n        if (store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\")) == null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision();\n            org.apache.jackrabbit.oak.plugins.document.Commit commit = new org.apache.jackrabbit.oak.plugins.document.Commit(this, null, head);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"/\", head);\n            commit.addNode(n);\n            commit.applyToDocumentStore();\n            commit.applyToCache(new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId), false);\n            setHeadRevision(commit.getRevision());\n            backgroundWrite();\n        } else {\n            branches.init(store, this);\n            backgroundRead(false);\n            if (headRevision == null) {\n                setHeadRevision(newRevision());\n            }\n        }\n        getRevisionComparator().add(headRevision, org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0));\n        dispatcher = new org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher(getRoot());\n        commitQueue = new org.apache.jackrabbit.oak.plugins.document.CommitQueue(this, dispatcher);\n        batchCommitQueue = new org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue(store, revisionComparator);\n        backgroundThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundOperation(this, isDisposed), \"DocumentNodeStore background thread\");\n        backgroundThread.setDaemon(true);\n        checkLastRevRecovery();\n        renewClusterIdLease();\n        backgroundThread.start();\n        if (clusterNodeInfo != null) {\n            leaseUpdateThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundLeaseUpdate(this, isDisposed), \"DocumentNodeStore lease update thread\");\n            leaseUpdateThread.setDaemon(true);\n            leaseUpdateThread.start();\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Initialized DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    }\n\n    private void checkLastRevRecovery() {\n        lastRevRecoveryAgent.recover(clusterId);\n    }\n\n    public void dispose() {\n        runBackgroundOperations();\n        if (!isDisposed.getAndSet(true)) {\n            synchronized(isDisposed) {\n                isDisposed.notifyAll();\n            }\n            try {\n                backgroundThread.join();\n            } catch (java.lang.InterruptedException e) {\n            }\n            if (leaseUpdateThread != null) {\n                try {\n                    leaseUpdateThread.join();\n                } catch (java.lang.InterruptedException e) {\n                }\n            }\n            if (clusterNodeInfo != null) {\n                clusterNodeInfo.dispose();\n            }\n            store.dispose();\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n            if (blobStore instanceof java.io.Closeable) {\n                try {\n                    ((java.io.Closeable) (blobStore)).close();\n                } catch (java.io.IOException ex) {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n                }\n            }\n        }\n        if (persistentCache != null) {\n            persistentCache.close();\n        }\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision getHeadRevision() {\n        return headRevision;\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.Revision setHeadRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newHead) {\n        com.google.common.base.Preconditions.checkArgument(!newHead.isBranch());\n        org.apache.jackrabbit.oak.plugins.document.Revision previous = headRevision;\n        if (!com.google.common.base.Preconditions.checkNotNull(newHead).equals(previous)) {\n            headRevision = newHead;\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentStore getDocumentStore() {\n        return store;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newRevision() {\n        if (simpleRevisionCounter != null) {\n            return new org.apache.jackrabbit.oak.plugins.document.Revision(simpleRevisionCounter.getAndIncrement(), 0, clusterId);\n        }\n        return org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(clusterId);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit newCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.Commit(this, base, commitQueue.createRevision());\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.MergeCommit newMergeCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base, int numBranchCommits) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    void done(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit c, boolean isBranch, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) {\n        try {\n            commitQueue.done(c, isBranch, info);\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    void canceled(org.apache.jackrabbit.oak.plugins.document.Commit c) {\n        try {\n            commitQueue.canceled(c.getRevision());\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    public void setAsyncDelay(int delay) {\n        this.asyncDelay = delay;\n    }\n\n    public int getAsyncDelay() {\n        return asyncDelay;\n    }\n\n    public void setMaxBackOffMillis(int time) {\n        maxBackOffMillis = time;\n    }\n\n    public int getMaxBackOffMillis() {\n        return maxBackOffMillis;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo getClusterInfo() {\n        return clusterNodeInfo;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeCacheStats() {\n        return nodeCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeChildrenCacheStats() {\n        return nodeChildrenCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getDocChildrenCacheStats() {\n        return docChildrenCacheStats;\n    }\n\n    void invalidateDocChildrenCache() {\n        docChildrenCache.invalidateAll();\n    }\n\n    void invalidateNodeCache(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        nodeCache.invalidate(new org.apache.jackrabbit.oak.plugins.document.PathRev(path, revision));\n    }\n\n    public int getPendingWriteCount() {\n        return unsavedLastRevisions.getPaths().size();\n    }\n\n    public boolean isDisableBranches() {\n        return disableBranches;\n    }\n\n    boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    void addSplitCandidate(java.lang.String id) {\n        splitCandidates.put(id, id);\n    }\n\n    void copyNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(false, source, targetPath, commit);\n    }\n\n    void moveNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(true, source, targetPath, commit);\n    }\n\n    void markAsDeleted(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, org.apache.jackrabbit.oak.plugins.document.Commit commit, boolean subTreeAlso) {\n        commit.removeNode(node.getPath());\n        if (subTreeAlso) {\n            for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(node, null, java.lang.Integer.MAX_VALUE)) {\n                markAsDeleted(child, commit, true);\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNode(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        checkRevisionAge(com.google.common.base.Preconditions.checkNotNull(rev), com.google.common.base.Preconditions.checkNotNull(path));\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = new org.apache.jackrabbit.oak.plugins.document.PathRev(path, rev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node = nodeCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState call() throws java.lang.Exception {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = readNode(path, rev);\n                    if (n == null) {\n                        n = missing;\n                    }\n                    return n;\n                }\n            });\n            return (node == missing) || node.equals(missing) ? null : node;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        }\n    }\n\n    DocumentNodeState.Children getChildren(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return DocumentNodeState.NO_CHILDREN;\n        }\n        final java.lang.String path = com.google.common.base.Preconditions.checkNotNull(parent).getPath();\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, readRevision, name);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children children = nodeChildrenCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children>() {\n                @java.lang.Override\n                public DocumentNodeState.Children call() throws java.lang.Exception {\n                    return readChildren(parent, name, limit);\n                }\n            });\n            if ((children.children.size() < limit) && children.hasMore) {\n                children = readChildren(parent, name, limit);\n                nodeChildrenCache.put(key, children);\n            }\n            return children;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        }\n    }\n\n    DocumentNodeState.Children readChildren(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, java.lang.String name, int limit) {\n        java.lang.String path = parent.getPath();\n        org.apache.jackrabbit.oak.plugins.document.Revision rev = parent.getLastRevision();\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n        int rawLimit = ((int) (java.lang.Math.min(java.lang.Integer.MAX_VALUE, ((long) (limit)) + 1)));\n        for (; ;) {\n            docs = readChildDocs(path, name, rawLimit);\n            int numReturned = 0;\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                numReturned++;\n                java.lang.String p = doc.getPath();\n                name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child = getNode(p, rev);\n                if (child == null) {\n                    continue;\n                }\n                if (c.children.size() < limit) {\n                    c.children.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n                } else {\n                    c.hasMore = true;\n                    return c;\n                }\n            }\n            if (numReturned < rawLimit) {\n                c.hasMore = false;\n                return c;\n            }\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> readChildDocs(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nullable\n    java.lang.String name, int limit) {\n        java.lang.String to = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(com.google.common.base.Preconditions.checkNotNull(path));\n        java.lang.String from;\n        if (name != null) {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(org.apache.jackrabbit.oak.commons.PathUtils.concat(path, name));\n        } else {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        }\n        if ((name != null) || (limit > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NUM_CHILDREN_CACHE_LIMIT)) {\n            return store.query(Collection.NODES, from, to, limit);\n        }\n        org.apache.jackrabbit.oak.plugins.document.util.StringValue key = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children c = docChildrenCache.getIfPresent(key);\n        if (c == null) {\n            c = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, limit);\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                c.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            c.isComplete = docs.size() < limit;\n            docChildrenCache.put(key, c);\n            return docs;\n        } else if ((c.childNames.size() < limit) && (!c.isComplete)) {\n            java.lang.String lastName = c.childNames.get(c.childNames.size() - 1);\n            java.lang.String lastPath = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, lastName);\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(lastPath);\n            int remainingLimit = limit - c.childNames.size();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, remainingLimit);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = c.clone();\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                clone.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            clone.isComplete = docs.size() < remainingLimit;\n            docChildrenCache.put(key, clone);\n            c = clone;\n        }\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> it = com.google.common.collect.Iterables.transform(c.childNames, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.lang.String name) {\n                java.lang.String p = org.apache.jackrabbit.oak.commons.PathUtils.concat(path, name);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(p));\n                if (doc == null) {\n                    docChildrenCache.invalidateAll();\n                    throw new java.lang.NullPointerException((\"Document \" + p) + \" not found\");\n                }\n                return doc;\n            }\n        });\n        if (c.childNames.size() > (limit * 2)) {\n            it = com.google.common.collect.Iterables.limit(it, limit * 2);\n        }\n        return it;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> getChildNodes(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return java.util.Collections.emptyList();\n        }\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        return com.google.common.collect.Iterables.transform(getChildren(parent, name, limit).children, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState apply(java.lang.String input) {\n                java.lang.String p = org.apache.jackrabbit.oak.commons.PathUtils.concat(parent.getPath(), input);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = getNode(p, readRevision);\n                if (result == null) {\n                    throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((((\"DocumentNodeState is null for revision \" + readRevision) + \" of \") + p) + \" (aborting getChildNodes())\");\n                }\n                return result;\n            }\n        });\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState readNode(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(path);\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = getPendingModifications().get(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n        if (doc == null) {\n            return null;\n        }\n        return doc.getNodeAtRevision(this, readRevision, lastRevision);\n    }\n\n    public void applyChanges(org.apache.jackrabbit.oak.plugins.document.Revision rev, java.lang.String path, boolean isNew, java.util.List<java.lang.String> added, java.util.List<java.lang.String> removed, java.util.List<java.lang.String> changed, org.apache.jackrabbit.oak.plugins.document.DiffCache.Entry cacheEntry) {\n        if (isNew) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n            java.util.Set<java.lang.String> set = com.google.common.collect.Sets.newTreeSet();\n            for (java.lang.String p : added) {\n                set.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n            }\n            c.children.addAll(set);\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, rev, null);\n            nodeChildrenCache.put(key, c);\n        }\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        for (java.lang.String p : added) {\n            w.tag('+').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        for (java.lang.String p : removed) {\n            w.tag('-').value(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).newline();\n        }\n        for (java.lang.String p : changed) {\n            w.tag('^').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        cacheEntry.append(path, w.toString());\n        if (!added.isEmpty()) {\n            org.apache.jackrabbit.oak.plugins.document.util.StringValue docChildrenKey = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children docChildren = docChildrenCache.getIfPresent(docChildrenKey);\n            if (docChildren != null) {\n                int currentSize = docChildren.childNames.size();\n                java.util.NavigableSet<java.lang.String> names = com.google.common.collect.Sets.newTreeSet(docChildren.childNames);\n                if (!docChildren.isComplete) {\n                    for (java.lang.String childPath : added) {\n                        java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath);\n                        if (names.higher(name) != null) {\n                            names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(name));\n                        }\n                    }\n                } else {\n                    for (java.lang.String childPath : added) {\n                        names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath)));\n                    }\n                }\n                if (names.size() != currentSize) {\n                    boolean complete = docChildren.isComplete;\n                    docChildren = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n                    docChildren.isComplete = complete;\n                    docChildren.childNames.addAll(names);\n                    docChildrenCache.put(docChildrenKey, docChildren);\n                }\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument updateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        boolean batch = true;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> op : commit.getChanges().entrySet()) {\n            java.lang.String name = op.getKey().getName();\n            if ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name)) || NodeDocument.COLLISIONS.equals(name)) {\n                continue;\n            }\n            batch = false;\n            break;\n        }\n        if (batch) {\n            return batchUpdateCommitRoot(commit);\n        } else {\n            return store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, commit);\n        }\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument batchUpdateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        try {\n            return batchCommitQueue.updateDocument(commit).call();\n        } catch (java.lang.InterruptedException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Interrupted while updating commit root document\");\n        } catch (java.lang.Exception e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Update of commit root document failed\");\n        }\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState root = getNode(\"/\", revision);\n        if (root == null) {\n            throw new java.lang.IllegalStateException(\"root node does not exist at revision \" + revision);\n        }\n        return root;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch createBranch(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch b = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch.getCurrentBranch();\n        if (b != null) {\n            return b;\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch(this, base, mergeLock);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision base) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(base);\n        if (disableBranches) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            return base.asBranchRevision();\n        }\n        if (b.getBase(branchHead).equals(base)) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision().asBranchRevision();\n        b.rebase(head, base);\n        return head;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision ancestor) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(ancestor);\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(\"Empty branch cannot be reset\");\n        }\n        if (!b.getCommits().last().equals(branchHead)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((branchHead + \" is not the head \") + \"of a branch\");\n        }\n        if (!b.containsCommit(ancestor)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(((ancestor + \" is not \") + \"an ancestor revision of \") + branchHead);\n        }\n        if (branchHead.equals(ancestor)) {\n            return branchHead;\n        }\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit commit = newCommit(branchHead);\n        try {\n            java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> it = b.getCommits().tailSet(ancestor).iterator();\n            org.apache.jackrabbit.oak.plugins.document.Revision base = it.next();\n            java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.document.UpdateOp> operations = com.google.common.collect.Maps.newHashMap();\n            while (it.hasNext()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision reset = it.next();\n                getRoot(reset).compareAgainstBaseState(getRoot(base), new org.apache.jackrabbit.oak.plugins.document.ResetDiff(reset.asTrunkRevision(), operations));\n                org.apache.jackrabbit.oak.plugins.document.UpdateOp rootOp = operations.get(\"/\");\n                if (rootOp == null) {\n                    rootOp = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(rootOp, commit.getRevision());\n                    operations.put(\"/\", rootOp);\n                }\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n            } \n            if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n                java.util.List<org.apache.jackrabbit.oak.plugins.document.Revision> revs = com.google.common.collect.Lists.newArrayList(b.getCommits().tailSet(ancestor));\n                for (org.apache.jackrabbit.oak.plugins.document.Revision r : revs.subList(1, revs.size())) {\n                    b.removeCommit(r);\n                }\n                success = true;\n            }\n            operations.remove(\"/\");\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : operations.values()) {\n                store.findAndUpdate(Collection.NODES, op);\n            }\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, true, null);\n            }\n        }\n        return ancestor;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        org.apache.jackrabbit.oak.plugins.document.Revision base = branchHead;\n        if (b != null) {\n            base = b.getBase(branchHead);\n        }\n        int numBranchCommits = (b != null) ? b.getCommits().size() : 1;\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit commit = newMergeCommit(base, numBranchCommits);\n        try {\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(op, commit.getRevision());\n            if (b != null) {\n                java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> mergeCommits = commit.getMergeRevisions().iterator();\n                for (org.apache.jackrabbit.oak.plugins.document.Revision rev : b.getCommits()) {\n                    rev = rev.asTrunkRevision();\n                    java.lang.String commitTag = \"c-\" + mergeCommits.next();\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setRevision(op, rev, commitTag);\n                    op.containsMapEntry(NodeDocument.COLLISIONS, rev, false);\n                }\n                if (store.findAndUpdate(Collection.NODES, op) != null) {\n                    b.applyTo(getPendingModifications(), commit.getRevision());\n                    getBranches().remove(b);\n                } else {\n                    throw new org.apache.jackrabbit.oak.api.CommitFailedException(MERGE, 2, \"Conflicting concurrent change. Update operation failed: \" + op);\n                }\n            } else {\n            }\n            success = true;\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, false, info);\n            }\n        }\n        return commit.getRevision();\n    }\n\n    java.lang.String diffChildren(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base) {\n        if (node.hasNoChildren() && base.hasNoChildren()) {\n            return \"\";\n        }\n        java.lang.String diff = diffCache.getChanges(base.getLastRevision(), node.getLastRevision(), node.getPath());\n        if (diff == null) {\n            diff = diffImpl(base, node);\n        }\n        return diff;\n    }\n\n    java.lang.String diff(@javax.annotation.Nonnull\n    final java.lang.String fromRevisionId, @javax.annotation.Nonnull\n    final java.lang.String toRevisionId, @javax.annotation.Nonnull\n    final java.lang.String path) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (fromRevisionId.equals(toRevisionId)) {\n            return \"\";\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision fromRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(fromRevisionId);\n        org.apache.jackrabbit.oak.plugins.document.Revision toRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(toRevisionId);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from = getNode(path, fromRev);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to = getNode(path, toRev);\n        if ((from == null) || (to == null)) {\n            java.lang.String msg = java.lang.String.format(\"Diff is only supported if the node exists in both cases. \" + \"Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s\", path, fromRev, from != null, toRev, to != null);\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(msg);\n        }\n        java.lang.String compactDiff = diffCache.getChanges(fromRev, toRev, path);\n        if (compactDiff == null) {\n            compactDiff = diffImpl(from, to);\n        }\n        org.apache.jackrabbit.oak.commons.json.JsopWriter writer = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.diffProperties(from, to, writer);\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer t = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(compactDiff);\n        int r;\n        do {\n            r = t.read();\n            switch (r) {\n                case '+' :\n                case '^' :\n                    {\n                        java.lang.String name = t.readString();\n                        t.read(':');\n                        t.read('{');\n                        t.read('}');\n                        writer.tag(((char) (r))).key(org.apache.jackrabbit.oak.commons.PathUtils.concat(path, name));\n                        writer.object().endObject().newline();\n                        break;\n                    }\n                case '-' :\n                    {\n                        java.lang.String name = t.readString();\n                        writer.tag('-').value(org.apache.jackrabbit.oak.commons.PathUtils.concat(path, name));\n                        writer.newline();\n                    }\n            }\n        } while (r != org.apache.jackrabbit.oak.commons.json.JsopReader.END );\n        return writer.toString();\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.LastRevTracker createTracker(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision r, final boolean isBranchCommit) {\n        if (isBranchCommit && (!disableBranches)) {\n            org.apache.jackrabbit.oak.plugins.document.Revision branchRev = r.asBranchRevision();\n            return branches.getBranchCommit(branchRev);\n        } else {\n            return new org.apache.jackrabbit.oak.plugins.document.LastRevTracker() {\n                @java.lang.Override\n                public void track(java.lang.String path) {\n                    unsavedLastRevisions.put(path, r);\n                }\n            };\n        }\n    }\n\n    @java.lang.Override\n    public java.io.Closeable addObserver(org.apache.jackrabbit.oak.spi.commit.Observer observer) {\n        return dispatcher.addObserver(observer);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot() {\n        return getRoot(headRevision);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitHook commitHook, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).merge(commitHook, info);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).rebase();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).reset();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob createBlob(java.io.InputStream inputStream) throws java.io.IOException {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobStore.writeBlob(inputStream));\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.api.Blob getBlob(java.lang.String reference) {\n        java.lang.String blobId = blobStore.getBlobId(reference);\n        if (blobId != null) {\n            return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"No blobId found matching reference [{}]\", reference);\n        return null;\n    }\n\n    public org.apache.jackrabbit.oak.api.Blob getBlobFromBlobId(java.lang.String blobId) {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime, @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> properties) {\n        return checkpoints.create(lifetime, properties).toString();\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime) {\n        java.util.Map<java.lang.String, java.lang.String> empty = java.util.Collections.emptyMap();\n        return checkpoint(lifetime, empty);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.util.Map<java.lang.String, java.lang.String> checkpointInfo(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info info = checkpoints.getCheckpoints().get(r);\n        if (info == null) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return info.get();\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState retrieve(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        if (checkpoints.getCheckpoints().containsKey(r)) {\n            return getRoot(r);\n        } else {\n            return null;\n        }\n    }\n\n    @java.lang.Override\n    public boolean release(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        checkpoints.release(checkpoint);\n        return true;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnmergedBranches getBranches() {\n        return branches;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnsavedModifications getPendingModifications() {\n        return unsavedLastRevisions;\n    }\n\n    @java.lang.Override\n    public Revision.RevisionComparator getRevisionComparator() {\n        return revisionComparator;\n    }\n\n    @java.lang.Override\n    public int getClusterId() {\n        return clusterId;\n    }\n\n    public synchronized void runBackgroundOperations() {\n        if (isDisposed.get()) {\n            return;\n        }\n        if (simpleRevisionCounter != null) {\n            return;\n        }\n        try {\n            long start = clock.getTime();\n            long time = start;\n            backgroundSplit();\n            long splitTime = clock.getTime() - time;\n            time = clock.getTime();\n            backgroundWrite();\n            long writeTime = clock.getTime() - time;\n            time = clock.getTime();\n            backgroundRead(true);\n            long readTime = clock.getTime() - time;\n            java.lang.String msg = \"Background operations stats (split:{}, write:{}, read:{})\";\n            if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, splitTime, writeTime, readTime);\n            } else {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, splitTime, writeTime, readTime);\n            }\n        } catch (java.lang.RuntimeException e) {\n            if (isDisposed.get()) {\n                return;\n            }\n            throw e;\n        }\n    }\n\n    boolean renewClusterIdLease() {\n        return (clusterNodeInfo != null) && clusterNodeInfo.renewLease();\n    }\n\n    void updateClusterState() {\n        long now = clock.getTime();\n        java.util.Set<java.lang.Integer> inactive = com.google.common.collect.Sets.newHashSet();\n        for (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument doc : org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument.all(store)) {\n            int cId = doc.getClusterId();\n            if ((cId != this.clusterId) && (!doc.isActive())) {\n                inactive.add(cId);\n            }\n        }\n        inactiveClusterNodes.keySet().retainAll(inactive);\n        for (java.lang.Integer clusterId : inactive) {\n            inactiveClusterNodes.putIfAbsent(clusterId, now);\n        }\n    }\n\n    java.util.Map<java.lang.Integer, java.lang.Long> getInactiveClusterNodes() {\n        return new java.util.HashMap<java.lang.Integer, java.lang.Long>(inactiveClusterNodes);\n    }\n\n    void backgroundRead(boolean dispatchChange) {\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\");\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\n        if (doc == null) {\n            return;\n        }\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevMap = doc.getLastRev();\n        org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator revisionComparator = getRevisionComparator();\n        org.apache.jackrabbit.oak.plugins.document.Revision headSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        org.apache.jackrabbit.oak.plugins.document.Revision otherSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> externalChanges = com.google.common.collect.Maps.newHashMap();\n        for (java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> e : lastRevMap.entrySet()) {\n            int machineId = e.getKey();\n            if (machineId == clusterId) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.Revision r = e.getValue();\n            org.apache.jackrabbit.oak.plugins.document.Revision last = lastKnownRevision.get(machineId);\n            if ((last == null) || (r.compareRevisionTime(last) > 0)) {\n                lastKnownRevision.put(machineId, r);\n                if ((last != null) || (r.getTimestamp() > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())) {\n                    externalChanges.put(r, otherSeen);\n                }\n            }\n        }\n        if (!externalChanges.isEmpty()) {\n            store.invalidateCache();\n            docChildrenCache.invalidateAll();\n            backgroundOperationLock.writeLock().lock();\n            try {\n                revisionComparator.add(newRevision(), headSeen);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> e : externalChanges.entrySet()) {\n                    revisionComparator.add(e.getKey(), e.getValue());\n                }\n                setHeadRevision(newRevision());\n                if (dispatchChange) {\n                    dispatcher.contentChanged(getRoot(), null);\n                }\n            } finally {\n                backgroundOperationLock.writeLock().unlock();\n            }\n        }\n        revisionComparator.purge(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis());\n    }\n\n    private static long revisionPurgeMillis() {\n        return org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS;\n    }\n\n    private void backgroundSplit() {\n        for (java.util.Iterator<java.lang.String> it = splitCandidates.keySet().iterator(); it.hasNext();) {\n            java.lang.String id = it.next();\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n            if (doc == null) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : doc.split(this)) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument before = store.createOrUpdate(Collection.NODES, op);\n                if (before != null) {\n                    if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument after = store.find(Collection.NODES, op.getId());\n                        if (after != null) {\n                            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation on {}. Size before: {}, after: {}\", id, before.getMemory(), after.getMemory());\n                        }\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation created {}\", op.getId());\n                }\n            }\n            it.remove();\n        }\n    }\n\n    void backgroundWrite() {\n        unsavedLastRevisions.persist(this, backgroundOperationLock.writeLock());\n    }\n\n    private static void diffProperties(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to, org.apache.jackrabbit.oak.commons.json.JsopWriter w) {\n        for (org.apache.jackrabbit.oak.api.PropertyState fromValue : from.getProperties()) {\n            java.lang.String name = fromValue.getName();\n            org.apache.jackrabbit.oak.api.PropertyState toValue = to.getProperty(name);\n            if (!fromValue.equals(toValue)) {\n                w.tag('^').key(org.apache.jackrabbit.oak.commons.PathUtils.concat(from.getPath(), name));\n                if (toValue == null) {\n                    w.value(null);\n                } else {\n                    w.encodedValue(to.getPropertyAsString(name)).newline();\n                }\n            }\n        }\n        for (java.lang.String name : to.getPropertyNames()) {\n            if (!from.hasProperty(name)) {\n                w.tag('^').key(org.apache.jackrabbit.oak.commons.PathUtils.concat(from.getPath(), name)).encodedValue(to.getPropertyAsString(name)).newline();\n            }\n        }\n    }\n\n    private java.lang.String diffImpl(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        int max = org.apache.jackrabbit.oak.plugins.document.DocumentMK.MANY_CHILDREN_THRESHOLD;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren;\n        fromChildren = getChildren(from, null, max);\n        toChildren = getChildren(to, null, max);\n        if ((!fromChildren.hasMore) && (!toChildren.hasMore)) {\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        } else if (org.apache.jackrabbit.oak.plugins.document.DocumentMK.FAST_DIFF) {\n            diffManyChildren(w, from.getPath(), from.getLastRevision(), to.getLastRevision());\n        } else {\n            max = java.lang.Integer.MAX_VALUE;\n            fromChildren = getChildren(from, null, max);\n            toChildren = getChildren(to, null, max);\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        }\n        return w.toString();\n    }\n\n    private void diffManyChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        long minTimestamp = java.lang.Math.min(revisionComparator.getMinimumTimestamp(fromRev, inactiveClusterNodes), revisionComparator.getMinimumTimestamp(toRev, inactiveClusterNodes));\n        long minValue = org.apache.jackrabbit.oak.plugins.document.NodeDocument.getModifiedInSecs(minTimestamp);\n        java.lang.String fromKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        java.lang.String toKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(path);\n        java.util.Set<java.lang.String> paths = com.google.common.collect.Sets.newHashSet();\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED_IN_SECS, minValue, java.lang.Integer.MAX_VALUE)) {\n            paths.add(doc.getPath());\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision minRev = new org.apache.jackrabbit.oak.plugins.document.Revision(minTimestamp, 0, getClusterId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, getPendingModifications().getPaths(minRev));\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : new org.apache.jackrabbit.oak.plugins.document.Revision[]{ fromRev, toRev }) {\n            if (r.isBranch()) {\n                org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit c = getBranches().getBranchCommit(r);\n                if (c != null) {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, c.getModifiedPaths());\n                }\n            }\n        }\n        for (java.lang.String p : paths) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState fromNode = getNode(p, fromRev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState toNode = getNode(p, toRev);\n            java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n            if (fromNode != null) {\n                if (toNode != null) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision a = fromNode.getLastRevision();\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = toNode.getLastRevision();\n                    if ((a == null) && (b == null)) {\n                    } else if (((a == null) || (b == null)) || (!a.equals(b))) {\n                        w.tag('^').key(name).object().endObject().newline();\n                    }\n                } else {\n                    w.tag('-').value(name).newline();\n                }\n            } else if (toNode != null) {\n                w.tag('+').key(name).object().endObject().newline();\n            } else {\n            }\n        }\n    }\n\n    private static void addPathsForDiff(java.lang.String path, java.util.Set<java.lang.String> paths, java.lang.Iterable<java.lang.String> modified) {\n        for (java.lang.String p : modified) {\n            if (org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(p)) {\n                continue;\n            }\n            java.lang.String parent = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(p);\n            if (path.equals(parent)) {\n                paths.add(p);\n            }\n        }\n    }\n\n    private void diffFewChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String parentPath, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        java.util.Set<java.lang.String> childrenSet = com.google.common.collect.Sets.newHashSet(toChildren.children);\n        for (java.lang.String n : fromChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('-').value(n).newline();\n            } else {\n                java.lang.String path = org.apache.jackrabbit.oak.commons.PathUtils.concat(parentPath, n);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n1 = getNode(path, fromRev);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n2 = getNode(path, toRev);\n                com.google.common.base.Preconditions.checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", path, fromRev);\n                com.google.common.base.Preconditions.checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", path, toRev);\n                if (!n1.getLastRevision().equals(n2.getLastRevision())) {\n                    w.tag('^').key(n).object().endObject().newline();\n                }\n            }\n        }\n        childrenSet = com.google.common.collect.Sets.newHashSet(fromChildren.children);\n        for (java.lang.String n : toChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('+').key(n).object().endObject().newline();\n            }\n        }\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.PathRev childNodeCacheKey(@javax.annotation.Nonnull\n    java.lang.String path, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    java.lang.String name) {\n        java.lang.String p = (name == null ? \"\" : name) + path;\n        return new org.apache.jackrabbit.oak.plugins.document.PathRev(p, readRevision);\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder asDocumentRootBuilder(org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) throws java.lang.IllegalArgumentException {\n        if (!(builder instanceof org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder)) {\n            throw new java.lang.IllegalArgumentException(\"builder must be a \" + org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder.class.getName());\n        }\n        return ((org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder) (builder));\n    }\n\n    private void moveOrCopyNode(boolean move, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState newNode = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, targetPath, commit.getRevision());\n        source.copyTo(newNode);\n        commit.addNode(newNode);\n        if (move) {\n            markAsDeleted(source, commit, false);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(source, null, java.lang.Integer.MAX_VALUE)) {\n            java.lang.String childName = org.apache.jackrabbit.oak.commons.PathUtils.getName(child.getPath());\n            java.lang.String destChildPath = org.apache.jackrabbit.oak.commons.PathUtils.concat(targetPath, childName);\n            moveOrCopyNode(move, child, destChildPath, commit);\n        }\n    }\n\n    private void checkRevisionAge(org.apache.jackrabbit.oak.plugins.document.Revision r, java.lang.String path) {\n        if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n            if (\"/\".equals(path) && ((headRevision.getTimestamp() - r.getTimestamp()) > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.WARN_REVISION_AGE)) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug((((\"Requesting an old revision for path \" + path) + \", \") + ((headRevision.getTimestamp() - r.getTimestamp()) / 1000)) + \" seconds old\");\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector createBlobGarbageCollector(long blobGcMaxAgeInSecs) {\n        org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector blobGC = null;\n        if (blobStore instanceof org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) {\n            try {\n                blobGC = new org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector(new org.apache.jackrabbit.oak.plugins.document.DocumentBlobReferenceRetriever(this), ((org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) (blobStore)), executor, java.util.concurrent.TimeUnit.SECONDS.toMillis(blobGcMaxAgeInSecs));\n            } catch (java.io.IOException e) {\n                throw new java.lang.RuntimeException(\"Error occurred while initializing \" + \"the MarkSweepGarbageCollector\", e);\n            }\n        }\n        return blobGC;\n    }\n\n    static abstract class NodeStoreTask implements java.lang.Runnable {\n        final java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore> ref;\n\n        private final java.util.concurrent.atomic.AtomicBoolean isDisposed;\n\n        private int delay;\n\n        NodeStoreTask(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            ref = new java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore>(nodeStore);\n            delay = nodeStore.getAsyncDelay();\n            this.isDisposed = isDisposed;\n        }\n\n        protected abstract void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore);\n\n        @java.lang.Override\n        public void run() {\n            while ((delay != 0) && (!isDisposed.get())) {\n                synchronized(isDisposed) {\n                    try {\n                        isDisposed.wait(delay);\n                    } catch (java.lang.InterruptedException e) {\n                    }\n                }\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore = ref.get();\n                if (nodeStore != null) {\n                    try {\n                        execute(nodeStore);\n                    } catch (java.lang.Throwable t) {\n                        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + t.toString(), t);\n                    }\n                    delay = nodeStore.getAsyncDelay();\n                } else {\n                    break;\n                }\n            } \n        }\n    }\n\n    static class BackgroundOperation extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundOperation(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            nodeStore.runBackgroundOperations();\n        }\n    }\n\n    static class BackgroundLeaseUpdate extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundLeaseUpdate(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            if (nodeStore.renewClusterIdLease()) {\n                nodeStore.updateClusterState();\n            }\n        }\n    }\n\n    public org.apache.jackrabbit.oak.spi.blob.BlobStore getBlobStore() {\n        return blobStore;\n    }\n\n    org.apache.jackrabbit.oak.kernel.BlobSerializer getBlobSerializer() {\n        return blobSerializer;\n    }\n\n    public java.util.Iterator<org.apache.jackrabbit.oak.api.Blob> getReferencedBlobsIterator() {\n        if (store instanceof org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) {\n            return new org.apache.jackrabbit.oak.plugins.document.mongo.MongoBlobReferenceIterator(this, ((org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) (store)));\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.BlobReferenceIterator(this);\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.DiffCache getDiffCache() {\n        return diffCache;\n    }\n\n    public org.apache.jackrabbit.oak.stats.Clock getClock() {\n        return clock;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.Checkpoints getCheckpoints() {\n        return checkpoints;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector getVersionGarbageCollector() {\n        return versionGarbageCollector;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent getLastRevRecoveryAgent() {\n        return lastRevRecoveryAgent;\n    }\n\n    public void setPersistentCache(org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache) {\n        this.persistentCache = persistentCache;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis()",
            "src_parent": "revisionComparator.purge(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "{\n    lastKnownRevision.put(machineId, r);\n    if ((last != null) || (r.getTimestamp() > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())) {\n        externalChanges.put(r, otherSeen);\n    }\n}",
            "src_parent": "if ((last == null) || (r.compareRevisionTime(last) > 0)) {\n    lastKnownRevision.put(machineId, r);\n    if ((last != null) || (r.getTimestamp() > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())) {\n        externalChanges.put(r, otherSeen);\n    }\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS",
            "dst_parent": "return org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS",
            "dst_parent_type": "Return",
            "dst_type": "BinaryOperator",
            "operator": "MOV",
            "src": "org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS",
            "src_parent": "revisionComparator.purge(org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS)",
            "src_parent_type": "Invocation",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "lastKnownRevision.put(machineId, r)",
            "dst_parent": "{\n    lastKnownRevision.put(machineId, r);\n    if ((last != null) || (r.getTimestamp() > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())) {\n        externalChanges.put(r, otherSeen);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "lastKnownRevision.put(machineId, r)",
            "src_parent": "{\n    lastKnownRevision.put(machineId, r);\n    externalChanges.put(r, otherSeen);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    externalChanges.put(r, otherSeen);\n}",
            "dst_parent": "if ((last != null) || (r.getTimestamp() > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())) {\n    externalChanges.put(r, otherSeen);\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    lastKnownRevision.put(machineId, r);\n    externalChanges.put(r, otherSeen);\n}",
            "src_parent": "if ((last == null) || (r.compareRevisionTime(last) > 0)) {\n    lastKnownRevision.put(machineId, r);\n    externalChanges.put(r, otherSeen);\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        }
      ],
      "file_name": "DocumentNodeStore"
    }
  ],
  "id": "jackrabbit-oak_a0dc4c89"
}