{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static boolean referencesOldDocAfterSplit(org.apache.jackrabbit.oak.plugins.document.NodeDocument mainDoc, org.apache.jackrabbit.oak.plugins.document.NodeDocument oldDoc) {\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> revs = oldDoc.getLocalRevisions().keySet();\n    for (java.lang.String property : mainDoc.data.keySet()) {\n        if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(property)) {\n            continue;\n        }\n        java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> changes = com.google.common.collect.Sets.newHashSet(mainDoc.getLocalMap(property).keySet());\n        changes.removeAll(oldDoc.getLocalMap(property).keySet());\n        if (!java.util.Collections.disjoint(changes, revs)) {\n            return true;\n        }\n    }\n    return false;\n}",
            "src_parent": "public final class NodeDocument extends org.apache.jackrabbit.oak.plugins.document.Document implements org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument {\n    public static final org.apache.jackrabbit.oak.plugins.document.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(new org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore());\n\n    static {\n        NULL.seal();\n    }\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.NodeDocument.class);\n\n    public static final java.lang.String MIN_ID_VALUE = \"0000000\";\n\n    public static final java.lang.String MAX_ID_VALUE = \";\";\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 8 * 1024;\n\n    static final int DOC_SIZE_THRESHOLD = 256 * 1024;\n\n    static final int NUM_REVS_THRESHOLD = 100;\n\n    static final float SPLIT_RATIO = 0.3F;\n\n    static final int PREV_SPLIT_FACTOR = 10;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    public static final java.lang.String MODIFIED_IN_SECS = \"_modified\";\n\n    private static final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> EMPTY_RANGE_MAP = com.google.common.collect.Maps.unmodifiableNavigableMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    public static final java.lang.String DELETED_ONCE = \"_deletedOnce\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    private static final java.lang.String CHILDREN_FLAG = \"_children\";\n\n    public static final java.lang.String PATH = \"_path\";\n\n    public static final java.lang.String HAS_BINARY_FLAG = \"_bin\";\n\n    public static final java.lang.String SD_TYPE = \"_sdType\";\n\n    public static final java.lang.String SD_MAX_REV_TIME_IN_SECS = \"_sdMaxRevTime\";\n\n    public static enum SplitDocType {\n\n        NONE(-1),\n        DEFAULT(10),\n        DEFAULT_NO_CHILD(20),\n        PROP_COMMIT_ONLY(30),\n        INTERMEDIATE(40);\n        final int type;\n\n        private SplitDocType(int type) {\n            this.type = type;\n        }\n\n        public int typeCode() {\n            return type;\n        }\n\n        static org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType valueOf(java.lang.Integer type) {\n            if (type == null) {\n                return org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.NONE;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType docType : org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.values()) {\n                if (docType.type == type) {\n                    return docType;\n                }\n            }\n            throw new java.lang.IllegalArgumentException(\"Not a valid SplitDocType :\" + type);\n        }\n    }\n\n    private static final java.util.Set<java.lang.String> IGNORE_ON_SPLIT = com.google.common.collect.ImmutableSet.of(org.apache.jackrabbit.oak.plugins.document.ID, org.apache.jackrabbit.oak.plugins.document.MOD_COUNT, org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PATH, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE);\n\n    public static final long HAS_BINARY_VAL = 1;\n\n    final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous;\n\n    private final java.util.concurrent.atomic.AtomicLong lastCheckTime = new java.util.concurrent.atomic.AtomicLong(java.lang.System.currentTimeMillis());\n\n    private final long creationTime;\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store) {\n        this(store, java.lang.System.currentTimeMillis());\n    }\n\n    public NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store, long creationTime) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n        this.creationTime = creationTime;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getValueMap(@javax.annotation.Nonnull\n    java.lang.String key) {\n        if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(key)) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, key);\n        }\n    }\n\n    @java.lang.Override\n    public long getCreated() {\n        return creationTime;\n    }\n\n    public boolean hasChildren() {\n        java.lang.Boolean childrenFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG)));\n        return (childrenFlag != null) && childrenFlag;\n    }\n\n    public boolean wasDeletedOnce() {\n        java.lang.Boolean deletedOnceFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE)));\n        return (deletedOnceFlag != null) && deletedOnceFlag;\n    }\n\n    public boolean hasBeenModifiedSince(long lastModifiedTime) {\n        java.lang.Long modified = ((java.lang.Long) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS)));\n        return (modified != null) && (modified > java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(lastModifiedTime));\n    }\n\n    public boolean hasAllRevisionLessThan(long maxRevisionTime) {\n        java.lang.Long maxRevTimeStamp = ((java.lang.Long) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_MAX_REV_TIME_IN_SECS)));\n        return (maxRevTimeStamp != null) && (maxRevTimeStamp < java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(maxRevisionTime));\n    }\n\n    public boolean isSplitDocument() {\n        return getSplitDocType() != org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.NONE;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType getSplitDocType() {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.valueOf(((java.lang.Integer) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_TYPE))));\n    }\n\n    @java.lang.Override\n    public void markUpToDate(long checkTime) {\n        lastCheckTime.set(checkTime);\n    }\n\n    @java.lang.Override\n    public boolean isUpToDate(long lastCheckTime) {\n        return lastCheckTime <= this.lastCheckTime.get();\n    }\n\n    @java.lang.Override\n    public long getLastCheckTime() {\n        return lastCheckTime.get();\n    }\n\n    public boolean hasBinary() {\n        java.lang.Number flag = ((java.lang.Number) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG)));\n        if (flag == null) {\n            return false;\n        }\n        return flag.intValue() == org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_VAL;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.String getMainPath() {\n        java.lang.String p = getPath();\n        if (p.startsWith(\"p\")) {\n            p = org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, 2);\n            if (p.length() == 1) {\n                return \"/\";\n            } else {\n                return p.substring(1);\n            }\n        } else {\n            return p;\n        }\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> map = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> e : valueMap.entrySet()) {\n            int clusterId = e.getKey().getClusterId();\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(e.getValue());\n            map.put(clusterId, rev);\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(revision);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : commitRootDoc.getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getLocalRevisions().containsKey(revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String depth = getCommitRootDepth(revision);\n        if (depth != null) {\n            if (depth.equals(\"0\")) {\n                return \"/\";\n            }\n            java.lang.String p = getPath();\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getNewestRevision(final org.apache.jackrabbit.oak.plugins.document.RevisionContext context, final org.apache.jackrabbit.oak.plugins.document.Revision changeRev, final org.apache.jackrabbit.oak.plugins.document.CollisionHandler handler) {\n        final java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions = com.google.common.collect.Maps.newHashMap();\n        com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.Revision> predicate = new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.Revision>() {\n            @java.lang.Override\n            public boolean apply(org.apache.jackrabbit.oak.plugins.document.Revision input) {\n                if (input.equals(changeRev)) {\n                    return false;\n                }\n                if (isValidRevision(context, input, null, changeRev, validRevisions)) {\n                    return true;\n                }\n                handler.concurrentModification(input);\n                return false;\n            }\n        };\n        org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> revisions = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commitRoots = getLocalCommitRoot();\n        java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> it = com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.mergeSorted(java.util.Arrays.asList(revisions.keySet(), commitRoots.keySet()), revisions.comparator()), predicate).iterator();\n        if (it.hasNext()) {\n            newestRev = it.next();\n        } else {\n            it = com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.mergeSorted(java.util.Arrays.asList(getValueMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS).keySet(), getValueMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT).keySet()), revisions.comparator()), predicate).iterator();\n            if (it.hasNext()) {\n                newestRev = it.next();\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getLocalDeleted();\n        java.lang.String value = deleted.get(newestRev);\n        if ((value == null) && deleted.headMap(newestRev).isEmpty()) {\n            return newestRev;\n        }\n        if (value == null) {\n            value = getDeleted().get(newestRev);\n        }\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        if (validRevisions.containsKey(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, commitValue, readRevision)) {\n            validRevisions.put(rev, commitValue);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNodeAtRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision lastModified) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions = com.google.common.collect.Maps.newHashMap();\n        org.apache.jackrabbit.oak.plugins.document.Revision min = getLiveRevision(nodeStore, readRevision, validRevisions);\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = getPath();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = min;\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions);\n            if ((value == null) && (!getPreviousRanges().isEmpty())) {\n                value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions);\n            }\n            java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.document.util.Utils.unescapePropertyName(key);\n            java.lang.String v = (value != null) ? value.value : null;\n            n.setProperty(propertyName, v);\n            if ((value != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n                lastRevision = value.revision;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch branch = nodeStore.getBranches().getBranch(readRevision);\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        if (lastModified != null) {\n            lastRevs.put(nodeStore.getClusterId(), lastModified);\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision branchBase = null;\n        if (branch != null) {\n            branchBase = branch.getBase(readRevision);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, readRevision)) {\n                lastRevision = readRevision;\n                continue;\n            } else if ((branchBase != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, branchBase)) {\n                r = branchBase;\n            }\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r.asBranchRevision();\n            }\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision maxRev, java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions);\n        if ((value == null) && (!getPreviousRanges().isEmpty())) {\n            value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions);\n        }\n        return (value != null) && value.value.equals(\"false\") ? value.revision : null;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getLocalDeleted();\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, entry.getKey(), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> entry : op.getChanges().entrySet()) {\n            if (entry.getValue().type != Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            java.lang.String name = entry.getKey().getName();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.Revision rev : getValueMap(name).keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous = getPreviousRanges();\n        if ((((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) && (getMemory() < org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD)) && (previous.size() < org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREV_SPLIT_FACTOR)) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String path = getPath();\n        java.lang.String id = getId();\n        if (id == null) {\n            throw new java.lang.IllegalStateException(\"document does not have an id: \" + this);\n        }\n        java.util.Map<java.lang.Integer, java.util.List<org.apache.jackrabbit.oak.plugins.document.Range>> prevHisto = com.google.common.collect.Maps.newHashMap();\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> entry : previous.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = entry.getKey();\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.Range r = entry.getValue();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.Range> list = prevHisto.get(r.getHeight());\n            if (list == null) {\n                list = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.Range>();\n                prevHisto.put(r.getHeight(), list);\n            }\n            list.add(r);\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>>();\n        for (java.lang.String property : data.keySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(property)) {\n                continue;\n            }\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision rev = entry.getKey();\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if (isCommitted(rev)) {\n                    splitMap.put(rev, entry.getValue());\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.document.UpdateOp> splitOps = com.google.common.collect.Lists.newArrayList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.document.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp main = null;\n        if (((high != null) && (low != null)) && ((numValues >= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) || (getMemory() > org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD))) {\n            main = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setPrevious(main, new org.apache.jackrabbit.oak.plugins.document.Range(high, low, 0));\n            java.lang.String oldPath = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousPathFor(path, high, 0);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp old = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(oldPath), true);\n            old.set(org.apache.jackrabbit.oak.plugins.document.ID, old.getId());\n            if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isLongPath(oldPath)) {\n                old.set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PATH, oldPath);\n            }\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument oldDoc = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(store);\n            org.apache.jackrabbit.oak.plugins.document.UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setSplitDocProps(this, oldDoc, old, high);\n            if (oldDoc.getMemory() > (getMemory() * org.apache.jackrabbit.oak.plugins.document.NodeDocument.SPLIT_RATIO)) {\n                splitOps.add(old);\n            } else {\n                main = null;\n            }\n        }\n        for (java.util.Map.Entry<java.lang.Integer, java.util.List<org.apache.jackrabbit.oak.plugins.document.Range>> entry : prevHisto.entrySet()) {\n            if (entry.getValue().size() >= org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREV_SPLIT_FACTOR) {\n                if (main == null) {\n                    main = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n                }\n                org.apache.jackrabbit.oak.plugins.document.Revision h = null;\n                org.apache.jackrabbit.oak.plugins.document.Revision l = null;\n                for (org.apache.jackrabbit.oak.plugins.document.Range r : entry.getValue()) {\n                    if ((h == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, r.high, h)) {\n                        h = r.high;\n                    }\n                    if ((l == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, l, r.low)) {\n                        l = r.low;\n                    }\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.removePrevious(main, r);\n                }\n                if ((h == null) || (l == null)) {\n                    throw new java.lang.IllegalStateException();\n                }\n                java.lang.String prevPath = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousPathFor(path, h, entry.getKey() + 1);\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(prevPath);\n                org.apache.jackrabbit.oak.plugins.document.UpdateOp intermediate = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(prevId, true);\n                intermediate.set(org.apache.jackrabbit.oak.plugins.document.ID, prevId);\n                if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isLongPath(prevPath)) {\n                    intermediate.set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PATH, prevPath);\n                }\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.setPrevious(main, new org.apache.jackrabbit.oak.plugins.document.Range(h, l, entry.getKey() + 1));\n                for (org.apache.jackrabbit.oak.plugins.document.Range r : entry.getValue()) {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setPrevious(intermediate, r);\n                }\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.setIntermediateDocProps(intermediate, h);\n                splitOps.add(intermediate);\n            }\n        }\n        if ((main != null) && (!splitOps.isEmpty())) {\n            splitOps.add(main);\n        }\n        return splitOps;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.document.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>(StableRevisionComparator.REVERSE);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Range r = org.apache.jackrabbit.oak.plugins.document.Range.fromEntry(entry.getKey(), entry.getValue());\n                    transformed.put(r.high, r);\n                }\n                previous = com.google.common.collect.Maps.unmodifiableNavigableMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocs(@javax.annotation.Nonnull\n    final java.lang.String property, @javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getPreviousRanges().isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        if (revision == null) {\n            return new org.apache.jackrabbit.oak.plugins.document.PropertyHistory(store, this, property);\n        } else {\n            final java.lang.String mainPath = getMainPath();\n            java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> entry = getPreviousRanges().floorEntry(revision);\n            if (entry != null) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                int h = entry.getValue().height;\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(mainPath, r, h);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev != null) {\n                    if (prev.getValueMap(property).containsKey(revision)) {\n                        return java.util.Collections.singleton(prev);\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n            }\n            return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(getPreviousRanges().headMap(revision).entrySet(), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> input) {\n                    if (input.getValue().includes(revision)) {\n                        return getPreviousDoc(input.getKey(), input.getValue());\n                    }\n                    return null;\n                }\n            }), new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public boolean apply(@javax.annotation.Nullable\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument input) {\n                    return (input != null) && input.getValueMap(property).containsKey(revision);\n                }\n            });\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getAllPreviousDocs() {\n        if (getPreviousRanges().isEmpty()) {\n            return com.google.common.collect.Iterators.emptyIterator();\n        }\n        return new com.google.common.collect.AbstractIterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            private java.util.Queue<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>> previousRanges = com.google.common.collect.Queues.newArrayDeque(getPreviousRanges().entrySet());\n\n            @java.lang.Override\n            protected org.apache.jackrabbit.oak.plugins.document.NodeDocument computeNext() {\n                if (!previousRanges.isEmpty()) {\n                    java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> e = previousRanges.remove();\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDoc(e.getKey(), e.getValue());\n                    if (prev != null) {\n                        previousRanges.addAll(prev.getPreviousRanges().entrySet());\n                        return prev;\n                    }\n                }\n                return endOfData();\n            }\n        };\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getPreviousDoc(org.apache.jackrabbit.oak.plugins.document.Revision rev, org.apache.jackrabbit.oak.plugins.document.Range range) {\n        int h = range.height;\n        java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getMainPath(), rev, h);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n        if (prev != null) {\n            return prev;\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n        }\n        return null;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>) (data.get(key)));\n        if (map == null) {\n            map = ValueMap.EMPTY;\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    public static void setChildrenFlag(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, boolean hasChildNode) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, hasChildNode);\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS, org.apache.jackrabbit.oak.plugins.document.Commit.getModifiedInSecs(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static boolean isRevisionsEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS.equals(name);\n    }\n\n    public static void removeRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void removeCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, revision.getClusterId()), revision.toString());\n    }\n\n    public static boolean hasLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        return com.google.common.base.Preconditions.checkNotNull(op).getChanges().containsKey(new org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId)));\n    }\n\n    public static void unsetLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId));\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void removeCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision);\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, boolean deleted) {\n        if (deleted) {\n            com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE, java.lang.Boolean.TRUE);\n        }\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(deleted));\n    }\n\n    public static void removeDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, revision);\n    }\n\n    public static void setPrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Range range) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(range).high, range.getLowValue());\n    }\n\n    public static void removePrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Range range) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(range).high);\n    }\n\n    public static void setHasBinary(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_VAL);\n    }\n\n    private static void setSplitDocType(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType type) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_TYPE, type.type);\n    }\n\n    private static void setSplitDocMaxRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision maxRev) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_MAX_REV_TIME_IN_SECS, org.apache.jackrabbit.oak.plugins.document.Commit.getModifiedInSecs(maxRev.getTimestamp()));\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev);\n        if (commitRootPath == null) {\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitRootDepth(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n        java.lang.String depth = local.get(revision);\n        if (depth == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n                depth = prev.getCommitRootDepth(revision);\n                if (depth != null) {\n                    break;\n                }\n            }\n        }\n        return depth;\n    }\n\n    private static void setSplitDocProps(org.apache.jackrabbit.oak.plugins.document.NodeDocument mainDoc, org.apache.jackrabbit.oak.plugins.document.NodeDocument oldDoc, org.apache.jackrabbit.oak.plugins.document.UpdateOp old, org.apache.jackrabbit.oak.plugins.document.Revision maxRev) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.setSplitDocMaxRev(old, maxRev);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType type = org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.DEFAULT;\n        if ((!mainDoc.hasChildren()) && (!org.apache.jackrabbit.oak.plugins.document.NodeDocument.referencesOldDocAfterSplit(mainDoc, oldDoc))) {\n            type = org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.DEFAULT_NO_CHILD;\n        } else if (oldDoc.getLocalRevisions().isEmpty()) {\n            type = org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.PROP_COMMIT_ONLY;\n        }\n        if (mainDoc.hasBinary()) {\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setHasBinary(old);\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.setSplitDocType(old, type);\n    }\n\n    private static boolean referencesOldDocAfterSplit(org.apache.jackrabbit.oak.plugins.document.NodeDocument mainDoc, org.apache.jackrabbit.oak.plugins.document.NodeDocument oldDoc) {\n        java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> revs = oldDoc.getLocalRevisions().keySet();\n        for (java.lang.String property : mainDoc.data.keySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(property)) {\n                continue;\n            }\n            java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> changes = com.google.common.collect.Sets.newHashSet(mainDoc.getLocalMap(property).keySet());\n            changes.removeAll(oldDoc.getLocalMap(property).keySet());\n            if (!java.util.Collections.disjoint(changes, revs)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static void setIntermediateDocProps(org.apache.jackrabbit.oak.plugins.document.UpdateOp intermediate, org.apache.jackrabbit.oak.plugins.document.Revision maxRev) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.setSplitDocMaxRev(intermediate, maxRev);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.setSplitDocType(intermediate, org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.INTERMEDIATE);\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        if (commitValue == null) {\n            commitValue = getCommitValue(revision);\n        }\n        if (commitValue == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue);\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String value = getLocalRevisions().get(revision);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n                value = prev.getCommitValue(revision);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision x, org.apache.jackrabbit.oak.plugins.document.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision latestRev = null;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision propRev = entry.getKey();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, propRev, readRevision)) {\n                continue;\n            }\n            java.lang.String commitValue = validRevisions.get(propRev);\n            if (commitValue == null) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(propRev);\n                if (commitRoot == null) {\n                    continue;\n                }\n                commitValue = commitRoot.getCommitValue(propRev);\n                if (commitValue == null) {\n                    continue;\n                }\n            }\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, min, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue))) {\n                continue;\n            }\n            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                latestRev = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue);\n                value = entry.getValue();\n                break;\n            }\n        }\n        return value != null ? new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(value, latestRev) : null;\n    }\n\n    @java.lang.Override\n    public java.lang.String getPath() {\n        java.lang.String p = ((java.lang.String) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PATH)));\n        if (p != null) {\n            return p;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    static final class Children implements java.lang.Cloneable , org.apache.jackrabbit.oak.cache.CacheValue {\n        java.util.ArrayList<java.lang.String> childNames = new java.util.ArrayList<java.lang.String>();\n\n        boolean isComplete;\n\n        @java.lang.Override\n        public int getMemory() {\n            int size = 114;\n            for (java.lang.String name : childNames) {\n                size += (name.length() * 2) + 56;\n            }\n            return size;\n        }\n\n        @java.lang.SuppressWarnings(\"unchecked\")\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone() {\n            try {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children) (super.clone()));\n                clone.childNames = ((java.util.ArrayList<java.lang.String>) (childNames.clone()));\n                return clone;\n            } catch (java.lang.CloneNotSupportedException e) {\n                throw new java.lang.RuntimeException();\n            }\n        }\n    }\n\n    private static final class Value {\n        final java.lang.String value;\n\n        final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n        Value(@javax.annotation.Nonnull\n        java.lang.String value, @javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n            this.value = com.google.common.base.Preconditions.checkNotNull(value);\n            this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "(!mainDoc.hasChildren()) && (!org.apache.jackrabbit.oak.plugins.document.NodeDocument.referencesOldDocAfterSplit(mainDoc, oldDoc))",
            "src_parent": "if ((!mainDoc.hasChildren()) && (!org.apache.jackrabbit.oak.plugins.document.NodeDocument.referencesOldDocAfterSplit(mainDoc, oldDoc))) {\n    type = org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.DEFAULT_NO_CHILD;\n} else if (oldDoc.getLocalRevisions().isEmpty()) {\n    type = org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.PROP_COMMIT_ONLY;\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "(!mainDoc.hasChildren())",
            "dst_parent": "(!mainDoc.hasChildren()) && (!org.apache.jackrabbit.oak.plugins.document.NodeDocument.referencesOldDocAfterSplit(mainDoc, oldDoc))",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "UnaryOperator",
            "operator": "MOV",
            "src": "!mainDoc.hasChildren()",
            "src_parent": "if (!mainDoc.hasChildren()) {\n    type = org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.DEFAULT_NO_CHILD;\n} else if (oldDoc.getLocalRevisions().isEmpty()) {\n    type = org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.PROP_COMMIT_ONLY;\n}",
            "src_parent_type": "If",
            "src_type": "UnaryOperator"
          }
        }
      ],
      "file_name": "NodeDocument"
    }
  ],
  "id": "jackrabbit-oak_7ba9dd66"
}