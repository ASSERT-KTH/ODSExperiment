{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@javax.annotation.Nonnull\njava.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> getPreviousRanges() {\n    if (previous == null) {\n        java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS);\n        if (map.isEmpty()) {\n            previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n        } else {\n            java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n                @java.lang.Override\n                public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                    int c = o2.compareRevisionTime(o1);\n                    if (c == 0) {\n                        c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                    }\n                    return c;\n                }\n            });\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n                transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n            }\n            previous = java.util.Collections.unmodifiableSortedMap(transformed);\n        }\n    }\n    return previous;\n}",
            "dst_parent": "public class NodeDocument extends org.apache.jackrabbit.oak.plugins.mongomk.Document {\n    public static final org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument(new org.apache.jackrabbit.oak.plugins.mongomk.MemoryDocumentStore());\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.class);\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 32 * 1024;\n\n    static final int REVISIONS_SPLIT_OFF_SIZE = 1000;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    static final java.lang.String MODIFIED = \"_modified\";\n\n    private static final java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> EMPTY_RANGE_MAP = java.util.Collections.unmodifiableSortedMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    final org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore store;\n\n    private java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous;\n\n    private final long time = java.lang.System.currentTimeMillis();\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore store) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n    }\n\n    public final long getCreated() {\n        return time;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> map = com.google.common.collect.Maps.newHashMap();\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.Map<java.lang.String, java.lang.String> valueMap = ((java.util.Map<java.lang.String, java.lang.String>) (get(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LAST_REV)));\n        if (valueMap != null) {\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> e : valueMap.entrySet()) {\n                int clusterId = java.lang.Integer.parseInt(e.getKey());\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision rev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(e.getValue());\n                map.put(clusterId, rev);\n            }\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(rev);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : commitRootDoc.getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n        if (getLocalRevisions().containsKey(rev)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    java.lang.String revision) {\n        return containsRevision(org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(com.google.common.base.Preconditions.checkNotNull(revision)));\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(commit.getKey());\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision b = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(java.lang.String revision) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getCommitRoot();\n        java.lang.String depth = valueMap.get(revision);\n        if (depth != null) {\n            java.lang.String p = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPathFromId(getId());\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        } else {\n            return null;\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Revision getNewestRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision changeRev, org.apache.jackrabbit.oak.plugins.mongomk.CollisionHandler handler) {\n        java.util.SortedSet<java.lang.String> revisions = new java.util.TreeSet<java.lang.String>(java.util.Collections.reverseOrder());\n        revisions.addAll(getRevisions().keySet());\n        revisions.addAll(getCommitRoot().keySet());\n        java.util.Map<java.lang.String, java.lang.String> deletedMap = getDeleted();\n        revisions.addAll(deletedMap.keySet());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision newestRev = null;\n        for (java.lang.String r : revisions) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, changeRev)) {\n                context.publishRevision(propRev, changeRev);\n            }\n            if ((newestRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, newestRev)) {\n                if (!propRev.equals(changeRev)) {\n                    if (!isValidRevision(context, propRev, changeRev, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.mongomk.Revision>())) {\n                        handler.concurrentModification(propRev);\n                    } else {\n                        newestRev = propRev;\n                    }\n                }\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.lang.String value = deletedMap.get(newestRev.toString());\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision rev, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, readRevision)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Node getNodeAtRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision min = getLiveRevision(context, readRevision, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.mongomk.Revision>());\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPathFromId(getId());\n        org.apache.jackrabbit.oak.plugins.mongomk.Node n = new org.apache.jackrabbit.oak.plugins.mongomk.Node(path, readRevision);\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            java.lang.Object v = get(key);\n            @java.lang.SuppressWarnings(\"unchecked\")\n            java.util.Map<java.lang.String, java.lang.String> valueMap = ((java.util.Map<java.lang.String, java.lang.String>) (v));\n            if (valueMap != null) {\n                if (valueMap instanceof java.util.NavigableMap) {\n                    valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n                }\n                java.lang.String value = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.getLatestValue(context, valueMap, min, readRevision);\n                java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.unescapePropertyName(key);\n                n.setProperty(propertyName, value);\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Branch branch = context.getBranches().getBranch(readRevision);\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision lastRevision = null;\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision lastModified = context.getPendingModifications().get(path);\n        if (lastModified != null) {\n            lastRevs.put(context.getClusterId(), lastModified);\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision base = branch.getBase(readRevision);\n            for (java.util.Iterator<org.apache.jackrabbit.oak.plugins.mongomk.Revision> it = lastRevs.values().iterator(); it.hasNext();) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = it.next();\n                if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, base)) {\n                    it.remove();\n                }\n            }\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, readRevision)) {\n                continue;\n            }\n            if ((lastRevision == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r;\n            }\n        }\n        if (lastRevision == null) {\n            lastRevision = readRevision;\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    public boolean isDeleted(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision, java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getDeleted();\n        if (valueMap.isEmpty()) {\n            return false;\n        }\n        if (valueMap instanceof java.util.NavigableMap) {\n            valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision mostRecent = null;\n        boolean deleted = false;\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision r = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, readRevision)) {\n                continue;\n            }\n            if ((mostRecent != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, mostRecent, r)) {\n                continue;\n            }\n            if (isValidRevision(context, r, readRevision, validRevisions)) {\n                mostRecent = r;\n                deleted = \"true\".equals(entry.getValue());\n            }\n        }\n        return (mostRecent == null) || deleted;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision maxRev, java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getDeleted();\n        if (valueMap.isEmpty()) {\n            return null;\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision deletedRev = null;\n        if (valueMap instanceof java.util.NavigableMap) {\n            valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n        }\n        for (java.lang.String r : valueMap.keySet()) {\n            java.lang.String value = valueMap.get(r);\n            if (!\"true\".equals(value)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, maxRev) || (!isValidRevision(context, propRev, maxRev, validRevisions))) {\n                continue;\n            }\n            if ((deletedRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, deletedRev)) {\n                deletedRev = propRev;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision liveRev = null;\n        for (java.lang.String r : valueMap.keySet()) {\n            java.lang.String value = valueMap.get(r);\n            if (\"true\".equals(value)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if ((deletedRev != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, deletedRev, propRev)) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, maxRev) || (!isValidRevision(context, propRev, maxRev, validRevisions))) {\n                continue;\n            }\n            if ((liveRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, liveRev, propRev)) {\n                liveRev = propRev;\n            }\n        }\n        return liveRev;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        java.util.Map<java.lang.String, java.lang.String> deleted = getDeleted();\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey()), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<java.lang.String, org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp.Operation> entry : op.changes.entrySet()) {\n            if (entry.getValue().type != UpdateOp.Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            int idx = entry.getKey().indexOf('.');\n            java.lang.String name = entry.getKey().substring(0, idx);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            @java.lang.SuppressWarnings(\"unchecked\")\n            java.util.Map<java.lang.String, java.lang.Object> changes = ((java.util.Map<java.lang.String, java.lang.Object>) (get(name)));\n            if (changes == null) {\n                continue;\n            }\n            for (java.lang.String rev : changes.keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(rev), baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        if ((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS_SPLIT_OFF_SIZE) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String id = getId();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous = getPreviousRanges();\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision recentPrevious = null;\n        for (org.apache.jackrabbit.oak.plugins.mongomk.Revision rev : previous.keySet()) {\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                recentPrevious = rev;\n            }\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>>();\n        for (java.lang.String property : new java.lang.String[]{ org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED }) {\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<java.lang.String, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision rev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                    if (isCommitted(rev)) {\n                        splitMap.put(rev, entry.getValue());\n                    }\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp> splitOps = java.util.Collections.emptyList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        if (((high != null) && (low != null)) && (numValues >= org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS_SPLIT_OFF_SIZE)) {\n            splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp>(2);\n            org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp main = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(id, false);\n            main.setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS, high.toString(), low.toString());\n            org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp old = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(id, high), true);\n            old.set(org.apache.jackrabbit.oak.plugins.mongomk.ID, old.getKey());\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    java.lang.String r = entry.getKey().toString();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n            }\n            splitOps.add(old);\n            splitOps.add(main);\n        }\n        return splitOps;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n                    @java.lang.Override\n                    public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                        int c = o2.compareRevisionTime(o1);\n                        if (c == 0) {\n                            c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                        }\n                        return c;\n                    }\n                });\n                for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n                    transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n                }\n                previous = java.util.Collections.unmodifiableSortedMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument> getPreviousDocs(@javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    final java.lang.String property) {\n        com.google.common.base.Preconditions.checkNotNull(property);\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument> docs = com.google.common.collect.Iterables.transform(com.google.common.collect.Iterables.filter(getPreviousRanges().entrySet(), new com.google.common.base.Predicate<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>>() {\n            @java.lang.Override\n            public boolean apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> input) {\n                return (revision == null) || input.getValue().includes(revision);\n            }\n        }), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> input) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = input.getKey();\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(getId(), r);\n                org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev == null) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n                return prev;\n            }\n        });\n        return com.google.common.collect.Iterables.filter(docs, new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument>() {\n            @java.lang.Override\n            public boolean apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument input) {\n                if (input == null) {\n                    return false;\n                }\n                return (revision == null) || input.getLocalMap(property).containsKey(revision.toString());\n            }\n        });\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.Map<java.lang.String, java.lang.String> map = ((java.util.Map<java.lang.String, java.lang.String>) (get(key)));\n        if (map == null) {\n            map = java.util.Collections.emptyMap();\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED);\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.mongomk.Commit.getModified(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision).toString(), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision).toString());\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LAST_REV, java.lang.String.valueOf(com.google.common.base.Preconditions.checkNotNull(revision).getClusterId()), revision.toString());\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision).toString(), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, boolean deleted) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision).toString(), java.lang.String.valueOf(deleted));\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev.toString());\n        if (commitRootPath == null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LOG.warn(\"Node {} does not have commit root reference for revision {}\", getId(), rev);\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        java.lang.String value = getCommitValue(revision);\n        if (value == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.resolveCommitRevision(revision, value);\n                return !org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (value.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(value).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.resolveCommitRevision(revision, value), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String r = revision.toString();\n        java.lang.String value = getLocalRevisions().get(r);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n                value = prev.getLocalRevisions().get(r);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision x, org.apache.jackrabbit.oak.plugins.mongomk.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private static java.lang.String getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision max) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision latestRev = null;\n        for (java.lang.String r : valueMap.keySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, min, propRev)) {\n                continue;\n            }\n            if ((latestRev != null) && (!org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, latestRev))) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.includeRevision(context, propRev, max)) {\n                latestRev = propRev;\n                value = valueMap.get(r);\n            }\n        }\n        return value;\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getRevisions() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getCommitRoot() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT);\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "@java.lang.Override\n@javax.annotation.Nonnull\nprotected java.util.Map<?, ?> transformAndSeal(@javax.annotation.Nonnull\njava.util.Map<java.lang.Object, java.lang.Object> map, @javax.annotation.Nullable\njava.lang.String key, int level) {\n    if (level == 1) {\n        if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS.equals(key)) {\n            java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n                @java.lang.Override\n                public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                    int c = o2.compareRevisionTime(o1);\n                    if (c == 0) {\n                        c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                    }\n                    return c;\n                }\n            });\n            for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n                transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n            }\n            return java.util.Collections.unmodifiableSortedMap(transformed);\n        }\n    }\n    return super.transformAndSeal(map, key, level);\n}",
            "src_parent": "public class NodeDocument extends org.apache.jackrabbit.oak.plugins.mongomk.Document {\n    public static final org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument(new org.apache.jackrabbit.oak.plugins.mongomk.MemoryDocumentStore());\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.class);\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 32 * 1024;\n\n    static final int REVISIONS_SPLIT_OFF_SIZE = 1000;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    static final java.lang.String MODIFIED = \"_modified\";\n\n    private static final java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> EMPTY_RANGE_MAP = java.util.Collections.unmodifiableSortedMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    final org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore store;\n\n    private final long time = java.lang.System.currentTimeMillis();\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore store) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n    }\n\n    public final long getCreated() {\n        return time;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> map = com.google.common.collect.Maps.newHashMap();\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.Map<java.lang.String, java.lang.String> valueMap = ((java.util.Map<java.lang.String, java.lang.String>) (get(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LAST_REV)));\n        if (valueMap != null) {\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> e : valueMap.entrySet()) {\n                int clusterId = java.lang.Integer.parseInt(e.getKey());\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision rev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(e.getValue());\n                map.put(clusterId, rev);\n            }\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n        java.lang.String value = getLocalRevisions().get(rev);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n        if (getLocalRevisions().containsKey(rev)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    java.lang.String revision) {\n        return containsRevision(org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(com.google.common.base.Preconditions.checkNotNull(revision)));\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(commit.getKey());\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision b = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(java.lang.String revision) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getCommitRoot();\n        java.lang.String depth = valueMap.get(revision);\n        if (depth != null) {\n            java.lang.String p = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPathFromId(getId());\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        } else {\n            return null;\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Revision getNewestRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision changeRev, org.apache.jackrabbit.oak.plugins.mongomk.CollisionHandler handler) {\n        java.util.SortedSet<java.lang.String> revisions = new java.util.TreeSet<java.lang.String>(java.util.Collections.reverseOrder());\n        revisions.addAll(getRevisions().keySet());\n        revisions.addAll(getCommitRoot().keySet());\n        java.util.Map<java.lang.String, java.lang.String> deletedMap = getDeleted();\n        revisions.addAll(deletedMap.keySet());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision newestRev = null;\n        for (java.lang.String r : revisions) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, changeRev)) {\n                context.publishRevision(propRev, changeRev);\n            }\n            if ((newestRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, newestRev)) {\n                if (!propRev.equals(changeRev)) {\n                    if (!isValidRevision(context, propRev, changeRev, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.mongomk.Revision>())) {\n                        handler.concurrentModification(propRev);\n                    } else {\n                        newestRev = propRev;\n                    }\n                }\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.lang.String value = deletedMap.get(newestRev.toString());\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision rev, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, readRevision)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Node getNodeAtRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision min = getLiveRevision(context, readRevision, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.mongomk.Revision>());\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPathFromId(getId());\n        org.apache.jackrabbit.oak.plugins.mongomk.Node n = new org.apache.jackrabbit.oak.plugins.mongomk.Node(path, readRevision);\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            java.lang.Object v = get(key);\n            @java.lang.SuppressWarnings(\"unchecked\")\n            java.util.Map<java.lang.String, java.lang.String> valueMap = ((java.util.Map<java.lang.String, java.lang.String>) (v));\n            if (valueMap != null) {\n                if (valueMap instanceof java.util.NavigableMap) {\n                    valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n                }\n                java.lang.String value = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.getLatestValue(context, valueMap, min, readRevision);\n                java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.unescapePropertyName(key);\n                n.setProperty(propertyName, value);\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Branch branch = context.getBranches().getBranch(readRevision);\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision lastRevision = null;\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision lastModified = context.getPendingModifications().get(path);\n        if (lastModified != null) {\n            lastRevs.put(context.getClusterId(), lastModified);\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision base = branch.getBase(readRevision);\n            for (java.util.Iterator<org.apache.jackrabbit.oak.plugins.mongomk.Revision> it = lastRevs.values().iterator(); it.hasNext();) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = it.next();\n                if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, base)) {\n                    it.remove();\n                }\n            }\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, readRevision)) {\n                continue;\n            }\n            if ((lastRevision == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r;\n            }\n        }\n        if (lastRevision == null) {\n            lastRevision = readRevision;\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    public boolean isDeleted(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision, java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getDeleted();\n        if (valueMap.isEmpty()) {\n            return false;\n        }\n        if (valueMap instanceof java.util.NavigableMap) {\n            valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision mostRecent = null;\n        boolean deleted = false;\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision r = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, readRevision)) {\n                continue;\n            }\n            if ((mostRecent != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, mostRecent, r)) {\n                continue;\n            }\n            if (isValidRevision(context, r, readRevision, validRevisions)) {\n                mostRecent = r;\n                deleted = \"true\".equals(entry.getValue());\n            }\n        }\n        return (mostRecent == null) || deleted;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision maxRev, java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getDeleted();\n        if (valueMap.isEmpty()) {\n            return null;\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision deletedRev = null;\n        if (valueMap instanceof java.util.NavigableMap) {\n            valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n        }\n        for (java.lang.String r : valueMap.keySet()) {\n            java.lang.String value = valueMap.get(r);\n            if (!\"true\".equals(value)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, maxRev) || (!isValidRevision(context, propRev, maxRev, validRevisions))) {\n                continue;\n            }\n            if ((deletedRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, deletedRev)) {\n                deletedRev = propRev;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision liveRev = null;\n        for (java.lang.String r : valueMap.keySet()) {\n            java.lang.String value = valueMap.get(r);\n            if (\"true\".equals(value)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if ((deletedRev != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, deletedRev, propRev)) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, maxRev) || (!isValidRevision(context, propRev, maxRev, validRevisions))) {\n                continue;\n            }\n            if ((liveRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, liveRev, propRev)) {\n                liveRev = propRev;\n            }\n        }\n        return liveRev;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        java.util.Map<java.lang.String, java.lang.String> deleted = getDeleted();\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey()), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<java.lang.String, org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp.Operation> entry : op.changes.entrySet()) {\n            if (entry.getValue().type != UpdateOp.Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            int idx = entry.getKey().indexOf('.');\n            java.lang.String name = entry.getKey().substring(0, idx);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            @java.lang.SuppressWarnings(\"unchecked\")\n            java.util.Map<java.lang.String, java.lang.Object> changes = ((java.util.Map<java.lang.String, java.lang.Object>) (get(name)));\n            if (changes == null) {\n                continue;\n            }\n            for (java.lang.String rev : changes.keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(rev), baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        if ((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS_SPLIT_OFF_SIZE) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String id = getId();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous = getPreviousRanges();\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision recentPrevious = null;\n        for (org.apache.jackrabbit.oak.plugins.mongomk.Revision rev : previous.keySet()) {\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                recentPrevious = rev;\n            }\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>>();\n        for (java.lang.String property : new java.lang.String[]{ org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED }) {\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<java.lang.String, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision rev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                    if (isCommitted(rev)) {\n                        splitMap.put(rev, entry.getValue());\n                    }\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp> splitOps = java.util.Collections.emptyList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        if (((high != null) && (low != null)) && (numValues >= org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS_SPLIT_OFF_SIZE)) {\n            splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp>(2);\n            org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp main = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(id, false);\n            main.setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS, high.toString(), low.toString());\n            org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp old = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(id, high), true);\n            old.set(org.apache.jackrabbit.oak.plugins.mongomk.ID, old.getKey());\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    java.lang.String r = entry.getKey().toString();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n                splitOps.add(old);\n                splitOps.add(main);\n            }\n        }\n        return splitOps;\n    }\n\n    @java.lang.Override\n    @javax.annotation.Nonnull\n    protected java.util.Map<?, ?> transformAndSeal(@javax.annotation.Nonnull\n    java.util.Map<java.lang.Object, java.lang.Object> map, @javax.annotation.Nullable\n    java.lang.String key, int level) {\n        if (level == 1) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS.equals(key)) {\n                java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n                    @java.lang.Override\n                    public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                        int c = o2.compareRevisionTime(o1);\n                        if (c == 0) {\n                            c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                        }\n                        return c;\n                    }\n                });\n                for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n                    transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n                }\n                return java.util.Collections.unmodifiableSortedMap(transformed);\n            }\n        }\n        return super.transformAndSeal(map, key, level);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> getPreviousRanges() {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>) (get(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS)));\n        if (previous == null) {\n            previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n        }\n        return previous;\n    }\n\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument> getPreviousDocs(@javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    final java.lang.String property) {\n        com.google.common.base.Preconditions.checkNotNull(property);\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument> docs = com.google.common.collect.Iterables.transform(com.google.common.collect.Iterables.filter(getPreviousRanges().entrySet(), new com.google.common.base.Predicate<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>>() {\n            @java.lang.Override\n            public boolean apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> input) {\n                return (revision == null) || input.getValue().includes(revision);\n            }\n        }), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> input) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = input.getKey();\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(getId(), r);\n                org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev == null) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n                return prev;\n            }\n        });\n        return com.google.common.collect.Iterables.filter(docs, new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument>() {\n            @java.lang.Override\n            public boolean apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument input) {\n                if (input == null) {\n                    return false;\n                }\n                return (revision == null) || input.getLocalMap(property).containsKey(revision.toString());\n            }\n        });\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.Map<java.lang.String, java.lang.String> map = ((java.util.Map<java.lang.String, java.lang.String>) (get(key)));\n        if (map == null) {\n            map = java.util.Collections.emptyMap();\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED);\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.mongomk.Commit.getModified(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision).toString(), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision).toString());\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LAST_REV, java.lang.String.valueOf(com.google.common.base.Preconditions.checkNotNull(revision).getClusterId()), revision.toString());\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision).toString(), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, boolean deleted) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision).toString(), java.lang.String.valueOf(deleted));\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev.toString());\n        if (commitRootPath == null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LOG.warn(\"Node {} does not have commit root reference for revision {}\", getId(), rev);\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        java.lang.String value = getCommitValue(revision);\n        if (value == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.resolveCommitRevision(revision, value);\n                return !org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (value.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(value).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.resolveCommitRevision(revision, value), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String r = revision.toString();\n        java.lang.String value = getLocalRevisions().get(r);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n                value = prev.getLocalRevisions().get(r);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision x, org.apache.jackrabbit.oak.plugins.mongomk.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private static java.lang.String getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision max) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision latestRev = null;\n        for (java.lang.String r : valueMap.keySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, min, propRev)) {\n                continue;\n            }\n            if ((latestRev != null) && (!org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, latestRev))) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.includeRevision(context, propRev, max)) {\n                latestRev = propRev;\n                value = valueMap.get(r);\n            }\n        }\n        return value;\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getRevisions() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getCommitRoot() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT);\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "TypeReference",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>",
            "dst_parent": "@javax.annotation.Nonnull\njava.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> getPreviousRanges() {\n    if (previous == null) {\n        java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS);\n        if (map.isEmpty()) {\n            previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n        } else {\n            java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n                @java.lang.Override\n                public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                    int c = o2.compareRevisionTime(o1);\n                    if (c == 0) {\n                        c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                    }\n                    return c;\n                }\n            });\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n                transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n            }\n            previous = java.util.Collections.unmodifiableSortedMap(transformed);\n        }\n    }\n    return previous;\n}",
            "dst_parent_type": "Method",
            "dst_type": "TypeReference",
            "operator": "UPD",
            "src": "java.util.Map<?, ?>",
            "src_parent": "@java.lang.Override\n@javax.annotation.Nonnull\nprotected java.util.Map<?, ?> transformAndSeal(@javax.annotation.Nonnull\njava.util.Map<java.lang.Object, java.lang.Object> map, @javax.annotation.Nullable\njava.lang.String key, int level) {\n    if (level == 1) {\n        if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS.equals(key)) {\n            java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n                @java.lang.Override\n                public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                    int c = o2.compareRevisionTime(o1);\n                    if (c == 0) {\n                        c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                    }\n                    return c;\n                }\n            });\n            for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n                transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n            }\n            return java.util.Collections.unmodifiableSortedMap(transformed);\n        }\n    }\n    return super.transformAndSeal(map, key, level);\n}",
            "src_parent_type": "Method",
            "src_type": "TypeReference"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey())",
            "dst_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey())",
            "dst_parent_type": "LocalVariable",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "entry.getKey().toString()",
            "src_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString())",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue())",
            "dst_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue())",
            "dst_parent_type": "LocalVariable",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "entry.getValue().toString()",
            "src_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString())",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument",
            "src_parent": "",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument",
            "src_parent": "",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS.equals(key)",
            "src_parent": "if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS.equals(key)) {\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n        @java.lang.Override\n        public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n            int c = o2.compareRevisionTime(o1);\n            if (c == 0) {\n                c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n            }\n            return c;\n        }\n    });\n    for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n        transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n    }\n    return java.util.Collections.unmodifiableSortedMap(transformed);\n}",
            "src_parent_type": "If",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString())",
            "src_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString())",
            "src_parent_type": "LocalVariable",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString())",
            "src_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString())",
            "src_parent_type": "LocalVariable",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "return java.util.Collections.unmodifiableSortedMap(transformed)",
            "src_parent": "{\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n        @java.lang.Override\n        public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n            int c = o2.compareRevisionTime(o1);\n            if (c == 0) {\n                c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n            }\n            return c;\n        }\n    });\n    for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n        transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n    }\n    return java.util.Collections.unmodifiableSortedMap(transformed);\n}",
            "src_parent_type": "Block",
            "src_type": "Return"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "super.transformAndSeal(map, key, level)",
            "src_parent": "return super.transformAndSeal(map, key, level)",
            "src_parent_type": "Return",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "@javax.annotation.Nonnull\njava.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> getPreviousRanges() {\n    @java.lang.SuppressWarnings(\"unchecked\")\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>) (get(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS)));\n    if (previous == null) {\n        previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n    }\n    return previous;\n}",
            "src_parent": "public class NodeDocument extends org.apache.jackrabbit.oak.plugins.mongomk.Document {\n    public static final org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument(new org.apache.jackrabbit.oak.plugins.mongomk.MemoryDocumentStore());\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.class);\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 32 * 1024;\n\n    static final int REVISIONS_SPLIT_OFF_SIZE = 1000;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    static final java.lang.String MODIFIED = \"_modified\";\n\n    private static final java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> EMPTY_RANGE_MAP = java.util.Collections.unmodifiableSortedMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    final org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore store;\n\n    private final long time = java.lang.System.currentTimeMillis();\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore store) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n    }\n\n    public final long getCreated() {\n        return time;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> map = com.google.common.collect.Maps.newHashMap();\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.Map<java.lang.String, java.lang.String> valueMap = ((java.util.Map<java.lang.String, java.lang.String>) (get(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LAST_REV)));\n        if (valueMap != null) {\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> e : valueMap.entrySet()) {\n                int clusterId = java.lang.Integer.parseInt(e.getKey());\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision rev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(e.getValue());\n                map.put(clusterId, rev);\n            }\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n        java.lang.String value = getLocalRevisions().get(rev);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n        if (getLocalRevisions().containsKey(rev)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    java.lang.String revision) {\n        return containsRevision(org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(com.google.common.base.Preconditions.checkNotNull(revision)));\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(commit.getKey());\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision b = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(java.lang.String revision) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getCommitRoot();\n        java.lang.String depth = valueMap.get(revision);\n        if (depth != null) {\n            java.lang.String p = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPathFromId(getId());\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        } else {\n            return null;\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Revision getNewestRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision changeRev, org.apache.jackrabbit.oak.plugins.mongomk.CollisionHandler handler) {\n        java.util.SortedSet<java.lang.String> revisions = new java.util.TreeSet<java.lang.String>(java.util.Collections.reverseOrder());\n        revisions.addAll(getRevisions().keySet());\n        revisions.addAll(getCommitRoot().keySet());\n        java.util.Map<java.lang.String, java.lang.String> deletedMap = getDeleted();\n        revisions.addAll(deletedMap.keySet());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision newestRev = null;\n        for (java.lang.String r : revisions) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, changeRev)) {\n                context.publishRevision(propRev, changeRev);\n            }\n            if ((newestRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, newestRev)) {\n                if (!propRev.equals(changeRev)) {\n                    if (!isValidRevision(context, propRev, changeRev, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.mongomk.Revision>())) {\n                        handler.concurrentModification(propRev);\n                    } else {\n                        newestRev = propRev;\n                    }\n                }\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.lang.String value = deletedMap.get(newestRev.toString());\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision rev, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, readRevision)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Node getNodeAtRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision min = getLiveRevision(context, readRevision, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.mongomk.Revision>());\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPathFromId(getId());\n        org.apache.jackrabbit.oak.plugins.mongomk.Node n = new org.apache.jackrabbit.oak.plugins.mongomk.Node(path, readRevision);\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            java.lang.Object v = get(key);\n            @java.lang.SuppressWarnings(\"unchecked\")\n            java.util.Map<java.lang.String, java.lang.String> valueMap = ((java.util.Map<java.lang.String, java.lang.String>) (v));\n            if (valueMap != null) {\n                if (valueMap instanceof java.util.NavigableMap) {\n                    valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n                }\n                java.lang.String value = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.getLatestValue(context, valueMap, min, readRevision);\n                java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.unescapePropertyName(key);\n                n.setProperty(propertyName, value);\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Branch branch = context.getBranches().getBranch(readRevision);\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision lastRevision = null;\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision lastModified = context.getPendingModifications().get(path);\n        if (lastModified != null) {\n            lastRevs.put(context.getClusterId(), lastModified);\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision base = branch.getBase(readRevision);\n            for (java.util.Iterator<org.apache.jackrabbit.oak.plugins.mongomk.Revision> it = lastRevs.values().iterator(); it.hasNext();) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = it.next();\n                if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, base)) {\n                    it.remove();\n                }\n            }\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, readRevision)) {\n                continue;\n            }\n            if ((lastRevision == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r;\n            }\n        }\n        if (lastRevision == null) {\n            lastRevision = readRevision;\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    public boolean isDeleted(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision, java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getDeleted();\n        if (valueMap.isEmpty()) {\n            return false;\n        }\n        if (valueMap instanceof java.util.NavigableMap) {\n            valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision mostRecent = null;\n        boolean deleted = false;\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision r = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, readRevision)) {\n                continue;\n            }\n            if ((mostRecent != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, mostRecent, r)) {\n                continue;\n            }\n            if (isValidRevision(context, r, readRevision, validRevisions)) {\n                mostRecent = r;\n                deleted = \"true\".equals(entry.getValue());\n            }\n        }\n        return (mostRecent == null) || deleted;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision maxRev, java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getDeleted();\n        if (valueMap.isEmpty()) {\n            return null;\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision deletedRev = null;\n        if (valueMap instanceof java.util.NavigableMap) {\n            valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n        }\n        for (java.lang.String r : valueMap.keySet()) {\n            java.lang.String value = valueMap.get(r);\n            if (!\"true\".equals(value)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, maxRev) || (!isValidRevision(context, propRev, maxRev, validRevisions))) {\n                continue;\n            }\n            if ((deletedRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, deletedRev)) {\n                deletedRev = propRev;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision liveRev = null;\n        for (java.lang.String r : valueMap.keySet()) {\n            java.lang.String value = valueMap.get(r);\n            if (\"true\".equals(value)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if ((deletedRev != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, deletedRev, propRev)) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, maxRev) || (!isValidRevision(context, propRev, maxRev, validRevisions))) {\n                continue;\n            }\n            if ((liveRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, liveRev, propRev)) {\n                liveRev = propRev;\n            }\n        }\n        return liveRev;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        java.util.Map<java.lang.String, java.lang.String> deleted = getDeleted();\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey()), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<java.lang.String, org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp.Operation> entry : op.changes.entrySet()) {\n            if (entry.getValue().type != UpdateOp.Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            int idx = entry.getKey().indexOf('.');\n            java.lang.String name = entry.getKey().substring(0, idx);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            @java.lang.SuppressWarnings(\"unchecked\")\n            java.util.Map<java.lang.String, java.lang.Object> changes = ((java.util.Map<java.lang.String, java.lang.Object>) (get(name)));\n            if (changes == null) {\n                continue;\n            }\n            for (java.lang.String rev : changes.keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(rev), baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        if ((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS_SPLIT_OFF_SIZE) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String id = getId();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous = getPreviousRanges();\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision recentPrevious = null;\n        for (org.apache.jackrabbit.oak.plugins.mongomk.Revision rev : previous.keySet()) {\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                recentPrevious = rev;\n            }\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>>();\n        for (java.lang.String property : new java.lang.String[]{ org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED }) {\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<java.lang.String, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision rev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                    if (isCommitted(rev)) {\n                        splitMap.put(rev, entry.getValue());\n                    }\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp> splitOps = java.util.Collections.emptyList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        if (((high != null) && (low != null)) && (numValues >= org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS_SPLIT_OFF_SIZE)) {\n            splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp>(2);\n            org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp main = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(id, false);\n            main.setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS, high.toString(), low.toString());\n            org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp old = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(id, high), true);\n            old.set(org.apache.jackrabbit.oak.plugins.mongomk.ID, old.getKey());\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    java.lang.String r = entry.getKey().toString();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n                splitOps.add(old);\n                splitOps.add(main);\n            }\n        }\n        return splitOps;\n    }\n\n    @java.lang.Override\n    @javax.annotation.Nonnull\n    protected java.util.Map<?, ?> transformAndSeal(@javax.annotation.Nonnull\n    java.util.Map<java.lang.Object, java.lang.Object> map, @javax.annotation.Nullable\n    java.lang.String key, int level) {\n        if (level == 1) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS.equals(key)) {\n                java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n                    @java.lang.Override\n                    public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                        int c = o2.compareRevisionTime(o1);\n                        if (c == 0) {\n                            c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                        }\n                        return c;\n                    }\n                });\n                for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n                    transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n                }\n                return java.util.Collections.unmodifiableSortedMap(transformed);\n            }\n        }\n        return super.transformAndSeal(map, key, level);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> getPreviousRanges() {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>) (get(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS)));\n        if (previous == null) {\n            previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n        }\n        return previous;\n    }\n\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument> getPreviousDocs(@javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    final java.lang.String property) {\n        com.google.common.base.Preconditions.checkNotNull(property);\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument> docs = com.google.common.collect.Iterables.transform(com.google.common.collect.Iterables.filter(getPreviousRanges().entrySet(), new com.google.common.base.Predicate<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>>() {\n            @java.lang.Override\n            public boolean apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> input) {\n                return (revision == null) || input.getValue().includes(revision);\n            }\n        }), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> input) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = input.getKey();\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(getId(), r);\n                org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev == null) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n                return prev;\n            }\n        });\n        return com.google.common.collect.Iterables.filter(docs, new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument>() {\n            @java.lang.Override\n            public boolean apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument input) {\n                if (input == null) {\n                    return false;\n                }\n                return (revision == null) || input.getLocalMap(property).containsKey(revision.toString());\n            }\n        });\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.Map<java.lang.String, java.lang.String> map = ((java.util.Map<java.lang.String, java.lang.String>) (get(key)));\n        if (map == null) {\n            map = java.util.Collections.emptyMap();\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED);\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.mongomk.Commit.getModified(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision).toString(), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision).toString());\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LAST_REV, java.lang.String.valueOf(com.google.common.base.Preconditions.checkNotNull(revision).getClusterId()), revision.toString());\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision).toString(), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, boolean deleted) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision).toString(), java.lang.String.valueOf(deleted));\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev.toString());\n        if (commitRootPath == null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LOG.warn(\"Node {} does not have commit root reference for revision {}\", getId(), rev);\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        java.lang.String value = getCommitValue(revision);\n        if (value == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.resolveCommitRevision(revision, value);\n                return !org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (value.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(value).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.resolveCommitRevision(revision, value), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String r = revision.toString();\n        java.lang.String value = getLocalRevisions().get(r);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n                value = prev.getLocalRevisions().get(r);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision x, org.apache.jackrabbit.oak.plugins.mongomk.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private static java.lang.String getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision max) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision latestRev = null;\n        for (java.lang.String r : valueMap.keySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, min, propRev)) {\n                continue;\n            }\n            if ((latestRev != null) && (!org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, latestRev))) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.includeRevision(context, propRev, max)) {\n                latestRev = propRev;\n                value = valueMap.get(r);\n            }\n        }\n        return value;\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getRevisions() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getCommitRoot() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT);\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous;",
            "src_parent": "public class NodeDocument extends org.apache.jackrabbit.oak.plugins.mongomk.Document {\n    public static final org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument(new org.apache.jackrabbit.oak.plugins.mongomk.MemoryDocumentStore());\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.class);\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 32 * 1024;\n\n    static final int REVISIONS_SPLIT_OFF_SIZE = 1000;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    static final java.lang.String MODIFIED = \"_modified\";\n\n    private static final java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> EMPTY_RANGE_MAP = java.util.Collections.unmodifiableSortedMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    final org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore store;\n\n    private java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous;\n\n    private final long time = java.lang.System.currentTimeMillis();\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.DocumentStore store) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n    }\n\n    public final long getCreated() {\n        return time;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> map = com.google.common.collect.Maps.newHashMap();\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.Map<java.lang.String, java.lang.String> valueMap = ((java.util.Map<java.lang.String, java.lang.String>) (get(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LAST_REV)));\n        if (valueMap != null) {\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> e : valueMap.entrySet()) {\n                int clusterId = java.lang.Integer.parseInt(e.getKey());\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision rev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(e.getValue());\n                map.put(clusterId, rev);\n            }\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(rev);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : commitRootDoc.getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n        if (getLocalRevisions().containsKey(rev)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    java.lang.String revision) {\n        return containsRevision(org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(com.google.common.base.Preconditions.checkNotNull(revision)));\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(commit.getKey());\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision b = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(java.lang.String revision) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getCommitRoot();\n        java.lang.String depth = valueMap.get(revision);\n        if (depth != null) {\n            java.lang.String p = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPathFromId(getId());\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        } else {\n            return null;\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Revision getNewestRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision changeRev, org.apache.jackrabbit.oak.plugins.mongomk.CollisionHandler handler) {\n        java.util.SortedSet<java.lang.String> revisions = new java.util.TreeSet<java.lang.String>(java.util.Collections.reverseOrder());\n        revisions.addAll(getRevisions().keySet());\n        revisions.addAll(getCommitRoot().keySet());\n        java.util.Map<java.lang.String, java.lang.String> deletedMap = getDeleted();\n        revisions.addAll(deletedMap.keySet());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision newestRev = null;\n        for (java.lang.String r : revisions) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, changeRev)) {\n                context.publishRevision(propRev, changeRev);\n            }\n            if ((newestRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, newestRev)) {\n                if (!propRev.equals(changeRev)) {\n                    if (!isValidRevision(context, propRev, changeRev, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.mongomk.Revision>())) {\n                        handler.concurrentModification(propRev);\n                    } else {\n                        newestRev = propRev;\n                    }\n                }\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.lang.String value = deletedMap.get(newestRev.toString());\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision rev, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, readRevision)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Node getNodeAtRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision min = getLiveRevision(context, readRevision, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.mongomk.Revision>());\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPathFromId(getId());\n        org.apache.jackrabbit.oak.plugins.mongomk.Node n = new org.apache.jackrabbit.oak.plugins.mongomk.Node(path, readRevision);\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            java.lang.Object v = get(key);\n            @java.lang.SuppressWarnings(\"unchecked\")\n            java.util.Map<java.lang.String, java.lang.String> valueMap = ((java.util.Map<java.lang.String, java.lang.String>) (v));\n            if (valueMap != null) {\n                if (valueMap instanceof java.util.NavigableMap) {\n                    valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n                }\n                java.lang.String value = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.getLatestValue(context, valueMap, min, readRevision);\n                java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.unescapePropertyName(key);\n                n.setProperty(propertyName, value);\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Branch branch = context.getBranches().getBranch(readRevision);\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision lastRevision = null;\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.mongomk.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision lastModified = context.getPendingModifications().get(path);\n        if (lastModified != null) {\n            lastRevs.put(context.getClusterId(), lastModified);\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision base = branch.getBase(readRevision);\n            for (java.util.Iterator<org.apache.jackrabbit.oak.plugins.mongomk.Revision> it = lastRevs.values().iterator(); it.hasNext();) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = it.next();\n                if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, base)) {\n                    it.remove();\n                }\n            }\n        }\n        for (org.apache.jackrabbit.oak.plugins.mongomk.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, readRevision)) {\n                continue;\n            }\n            if ((lastRevision == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r;\n            }\n        }\n        if (lastRevision == null) {\n            lastRevision = readRevision;\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    public boolean isDeleted(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision, java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getDeleted();\n        if (valueMap.isEmpty()) {\n            return false;\n        }\n        if (valueMap instanceof java.util.NavigableMap) {\n            valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision mostRecent = null;\n        boolean deleted = false;\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision r = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, r, readRevision)) {\n                continue;\n            }\n            if ((mostRecent != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, mostRecent, r)) {\n                continue;\n            }\n            if (isValidRevision(context, r, readRevision, validRevisions)) {\n                mostRecent = r;\n                deleted = \"true\".equals(entry.getValue());\n            }\n        }\n        return (mostRecent == null) || deleted;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.mongomk.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision maxRev, java.util.Set<org.apache.jackrabbit.oak.plugins.mongomk.Revision> validRevisions) {\n        java.util.Map<java.lang.String, java.lang.String> valueMap = getDeleted();\n        if (valueMap.isEmpty()) {\n            return null;\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision deletedRev = null;\n        if (valueMap instanceof java.util.NavigableMap) {\n            valueMap = ((java.util.NavigableMap<java.lang.String, java.lang.String>) (valueMap)).descendingMap();\n        }\n        for (java.lang.String r : valueMap.keySet()) {\n            java.lang.String value = valueMap.get(r);\n            if (!\"true\".equals(value)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, maxRev) || (!isValidRevision(context, propRev, maxRev, validRevisions))) {\n                continue;\n            }\n            if ((deletedRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, deletedRev)) {\n                deletedRev = propRev;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision liveRev = null;\n        for (java.lang.String r : valueMap.keySet()) {\n            java.lang.String value = valueMap.get(r);\n            if (\"true\".equals(value)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if ((deletedRev != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, deletedRev, propRev)) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, maxRev) || (!isValidRevision(context, propRev, maxRev, validRevisions))) {\n                continue;\n            }\n            if ((liveRev == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, liveRev, propRev)) {\n                liveRev = propRev;\n            }\n        }\n        return liveRev;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        java.util.Map<java.lang.String, java.lang.String> deleted = getDeleted();\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey()), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<java.lang.String, org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp.Operation> entry : op.changes.entrySet()) {\n            if (entry.getValue().type != UpdateOp.Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            int idx = entry.getKey().indexOf('.');\n            java.lang.String name = entry.getKey().substring(0, idx);\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            @java.lang.SuppressWarnings(\"unchecked\")\n            java.util.Map<java.lang.String, java.lang.Object> changes = ((java.util.Map<java.lang.String, java.lang.Object>) (get(name)));\n            if (changes == null) {\n                continue;\n            }\n            for (java.lang.String rev : changes.keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(rev), baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context) {\n        if ((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS_SPLIT_OFF_SIZE) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String id = getId();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> previous = getPreviousRanges();\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision recentPrevious = null;\n        for (org.apache.jackrabbit.oak.plugins.mongomk.Revision rev : previous.keySet()) {\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                recentPrevious = rev;\n            }\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>>();\n        for (java.lang.String property : new java.lang.String[]{ org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED }) {\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<java.lang.String, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision rev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                    if (isCommitted(rev)) {\n                        splitMap.put(rev, entry.getValue());\n                    }\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp> splitOps = java.util.Collections.emptyList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        if (((high != null) && (low != null)) && (numValues >= org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS_SPLIT_OFF_SIZE)) {\n            splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp>(2);\n            org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp main = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(id, false);\n            main.setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS, high.toString(), low.toString());\n            org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp old = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(id, high), true);\n            old.set(org.apache.jackrabbit.oak.plugins.mongomk.ID, old.getKey());\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    java.lang.String r = entry.getKey().toString();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n            }\n            splitOps.add(old);\n            splitOps.add(main);\n        }\n        return splitOps;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n                    @java.lang.Override\n                    public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                        int c = o2.compareRevisionTime(o1);\n                        if (c == 0) {\n                            c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                        }\n                        return c;\n                    }\n                });\n                for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n                    org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n                    transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n                }\n                previous = java.util.Collections.unmodifiableSortedMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument> getPreviousDocs(@javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    final java.lang.String property) {\n        com.google.common.base.Preconditions.checkNotNull(property);\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument> docs = com.google.common.collect.Iterables.transform(com.google.common.collect.Iterables.filter(getPreviousRanges().entrySet(), new com.google.common.base.Predicate<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>>() {\n            @java.lang.Override\n            public boolean apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> input) {\n                return (revision == null) || input.getValue().includes(revision);\n            }\n        }), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument>() {\n            @javax.annotation.Nullable\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> input) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision r = input.getKey();\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(getId(), r);\n                org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev == null) {\n                    org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n                return prev;\n            }\n        });\n        return com.google.common.collect.Iterables.filter(docs, new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument>() {\n            @java.lang.Override\n            public boolean apply(@javax.annotation.Nullable\n            org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument input) {\n                if (input == null) {\n                    return false;\n                }\n                return (revision == null) || input.getLocalMap(property).containsKey(revision.toString());\n            }\n        });\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.Map<java.lang.String, java.lang.String> map = ((java.util.Map<java.lang.String, java.lang.String>) (get(key)));\n        if (map == null) {\n            map = java.util.Collections.emptyMap();\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED);\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.mongomk.Commit.getModified(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision).toString(), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision).toString());\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LAST_REV, java.lang.String.valueOf(com.google.common.base.Preconditions.checkNotNull(revision).getClusterId()), revision.toString());\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision).toString(), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, boolean deleted) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision).toString(), java.lang.String.valueOf(deleted));\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev.toString());\n        if (commitRootPath == null) {\n            org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.LOG.warn(\"Node {} does not have commit root reference for revision {}\", getId(), rev);\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision revision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        java.lang.String value = getCommitValue(revision);\n        if (value == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.resolveCommitRevision(revision, value);\n                return !org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (value.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(value).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.resolveCommitRevision(revision, value), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.mongomk.Revision revision) {\n        java.lang.String r = revision.toString();\n        java.lang.String value = getLocalRevisions().get(r);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n                value = prev.getLocalRevisions().get(r);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, org.apache.jackrabbit.oak.plugins.mongomk.Revision x, org.apache.jackrabbit.oak.plugins.mongomk.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private static java.lang.String getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision max) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision latestRev = null;\n        for (java.lang.String r : valueMap.keySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision propRev = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(r);\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, min, propRev)) {\n                continue;\n            }\n            if ((latestRev != null) && (!org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.isRevisionNewer(context, propRev, latestRev))) {\n                continue;\n            }\n            if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.includeRevision(context, propRev, max)) {\n                latestRev = propRev;\n                value = valueMap.get(r);\n            }\n        }\n        return value;\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getRevisions() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<java.lang.String, java.lang.String> getCommitRoot() {\n        return org.apache.jackrabbit.oak.plugins.mongomk.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.COMMIT_ROOT);\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision))",
            "src_parent": "{\n    org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n    if (commitRootDoc == null) {\n        return false;\n    }\n    java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n    java.lang.String value = commitRootDoc.getLocalRevisions().get(rev);\n    if (value != null) {\n        return org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value);\n    }\n    for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : commitRootDoc.getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n        if (prev.containsRevision(revision)) {\n            return prev.isCommitted(revision);\n        }\n    }\n    return false;\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (commitRootDoc == null) {\n    return false;\n}",
            "src_parent": "{\n    org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n    if (commitRootDoc == null) {\n        return false;\n    }\n    java.lang.String rev = com.google.common.base.Preconditions.checkNotNull(revision).toString();\n    java.lang.String value = commitRootDoc.getLocalRevisions().get(rev);\n    if (value != null) {\n        return org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.isCommitted(value);\n    }\n    for (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument prev : commitRootDoc.getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)) {\n        if (prev.containsRevision(revision)) {\n            return prev.isCommitted(revision);\n        }\n    }\n    return false;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "previous == null",
            "src_parent": "if (previous == null) {\n    java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS);\n    if (map.isEmpty()) {\n        previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n    } else {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n            @java.lang.Override\n            public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                int c = o2.compareRevisionTime(o1);\n                if (c == 0) {\n                    c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                }\n                return c;\n            }\n        });\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n            transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n        }\n        previous = java.util.Collections.unmodifiableSortedMap(transformed);\n    }\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "previous",
            "src_parent": "return previous",
            "src_parent_type": "Return",
            "src_type": "FieldRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "commitRootDoc",
            "src_parent": "commitRootDoc.getPreviousDocs(revision, org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.REVISIONS)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS)",
            "src_parent": "{\n    java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS);\n    if (map.isEmpty()) {\n        previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n    } else {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n            @java.lang.Override\n            public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                int c = o2.compareRevisionTime(o1);\n                if (c == 0) {\n                    c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                }\n                return c;\n            }\n        });\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n            transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n        }\n        previous = java.util.Collections.unmodifiableSortedMap(transformed);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (map.isEmpty()) {\n    previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n} else {\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n        @java.lang.Override\n        public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n            int c = o2.compareRevisionTime(o1);\n            if (c == 0) {\n                c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n            }\n            return c;\n        }\n    });\n    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n        transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n    }\n    previous = java.util.Collections.unmodifiableSortedMap(transformed);\n}",
            "src_parent": "{\n    java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS);\n    if (map.isEmpty()) {\n        previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n    } else {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n            @java.lang.Override\n            public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                int c = o2.compareRevisionTime(o1);\n                if (c == 0) {\n                    c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                }\n                return c;\n            }\n        });\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n            transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n        }\n        previous = java.util.Collections.unmodifiableSortedMap(transformed);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "commitRootDoc",
            "src_parent": "commitRootDoc.getLocalRevisions()",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if (previous == null) {\n    java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS);\n    if (map.isEmpty()) {\n        previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n    } else {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n            @java.lang.Override\n            public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                int c = o2.compareRevisionTime(o1);\n                if (c == 0) {\n                    c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                }\n                return c;\n            }\n        });\n        for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n            transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n        }\n        previous = java.util.Collections.unmodifiableSortedMap(transformed);\n    }\n}",
            "dst_parent": "{\n    if (previous == null) {\n        java.util.Map<java.lang.String, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS);\n        if (map.isEmpty()) {\n            previous = org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.EMPTY_RANGE_MAP;\n        } else {\n            java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n                @java.lang.Override\n                public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                    int c = o2.compareRevisionTime(o1);\n                    if (c == 0) {\n                        c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                    }\n                    return c;\n                }\n            });\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n                org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n                transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n            }\n            previous = java.util.Collections.unmodifiableSortedMap(transformed);\n        }\n    }\n    return previous;\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS.equals(key)) {\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n        @java.lang.Override\n        public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n            int c = o2.compareRevisionTime(o1);\n            if (c == 0) {\n                c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n            }\n            return c;\n        }\n    });\n    for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n        transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n    }\n    return java.util.Collections.unmodifiableSortedMap(transformed);\n}",
            "src_parent": "{\n    if (org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS.equals(key)) {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n            @java.lang.Override\n            public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n                int c = o2.compareRevisionTime(o1);\n                if (c == 0) {\n                    c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n                }\n                return c;\n            }\n        });\n        for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n            org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n            transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n        }\n        return java.util.Collections.unmodifiableSortedMap(transformed);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "splitOps.add(old)",
            "dst_parent": "{\n    splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp>(2);\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp main = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(id, false);\n    main.setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS, high.toString(), low.toString());\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp old = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(id, high), true);\n    old.set(org.apache.jackrabbit.oak.plugins.mongomk.ID, old.getKey());\n    for (java.lang.String property : splitValues.keySet()) {\n        java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = splitValues.get(property);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> entry : splitMap.entrySet()) {\n            java.lang.String r = entry.getKey().toString();\n            main.removeMapEntry(property, r);\n            old.setMapEntry(property, r, entry.getValue());\n        }\n    }\n    splitOps.add(old);\n    splitOps.add(main);\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "splitOps.add(old)",
            "src_parent": "{\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = splitValues.get(property);\n    for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> entry : splitMap.entrySet()) {\n        java.lang.String r = entry.getKey().toString();\n        main.removeMapEntry(property, r);\n        old.setMapEntry(property, r, entry.getValue());\n    }\n    splitOps.add(old);\n    splitOps.add(main);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "Invocation",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "splitOps.add(main)",
            "dst_parent": "{\n    splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp>(2);\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp main = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(id, false);\n    main.setMapEntry(org.apache.jackrabbit.oak.plugins.mongomk.NodeDocument.PREVIOUS, high.toString(), low.toString());\n    org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp old = new org.apache.jackrabbit.oak.plugins.mongomk.UpdateOp(org.apache.jackrabbit.oak.plugins.mongomk.util.Utils.getPreviousIdFor(id, high), true);\n    old.set(org.apache.jackrabbit.oak.plugins.mongomk.ID, old.getKey());\n    for (java.lang.String property : splitValues.keySet()) {\n        java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = splitValues.get(property);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> entry : splitMap.entrySet()) {\n            java.lang.String r = entry.getKey().toString();\n            main.removeMapEntry(property, r);\n            old.setMapEntry(property, r, entry.getValue());\n        }\n    }\n    splitOps.add(old);\n    splitOps.add(main);\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "splitOps.add(main)",
            "src_parent": "{\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> splitMap = splitValues.get(property);\n    for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.mongomk.Revision, java.lang.String> entry : splitMap.entrySet()) {\n        java.lang.String r = entry.getKey().toString();\n        main.removeMapEntry(property, r);\n        old.setMapEntry(property, r, entry.getValue());\n    }\n    splitOps.add(old);\n    splitOps.add(main);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n    @java.lang.Override\n    public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n        int c = o2.compareRevisionTime(o1);\n        if (c == 0) {\n            c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n        }\n        return c;\n    }\n})",
            "dst_parent": "{\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n        @java.lang.Override\n        public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n            int c = o2.compareRevisionTime(o1);\n            if (c == 0) {\n                c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n            }\n            return c;\n        }\n    });\n    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n        transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n    }\n    previous = java.util.Collections.unmodifiableSortedMap(transformed);\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n    @java.lang.Override\n    public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n        int c = o2.compareRevisionTime(o1);\n        if (c == 0) {\n            c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n        }\n        return c;\n    }\n})",
            "src_parent": "{\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n        @java.lang.Override\n        public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n            int c = o2.compareRevisionTime(o1);\n            if (c == 0) {\n                c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n            }\n            return c;\n        }\n    });\n    for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n        transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n    }\n    return java.util.Collections.unmodifiableSortedMap(transformed);\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n    transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n}",
            "dst_parent": "{\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n        @java.lang.Override\n        public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n            int c = o2.compareRevisionTime(o1);\n            if (c == 0) {\n                c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n            }\n            return c;\n        }\n    });\n    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry : map.entrySet()) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue());\n        transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n    }\n    previous = java.util.Collections.unmodifiableSortedMap(transformed);\n}",
            "dst_parent_type": "Block",
            "dst_type": "ForEach",
            "operator": "MOV",
            "src": "for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n    org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n    transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n}",
            "src_parent": "{\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.mongomk.Revision, org.apache.jackrabbit.oak.plugins.mongomk.Range>(new java.util.Comparator<org.apache.jackrabbit.oak.plugins.mongomk.Revision>() {\n        @java.lang.Override\n        public int compare(org.apache.jackrabbit.oak.plugins.mongomk.Revision o1, org.apache.jackrabbit.oak.plugins.mongomk.Revision o2) {\n            int c = o2.compareRevisionTime(o1);\n            if (c == 0) {\n                c = (o1.getClusterId() < o2.getClusterId()) ? -1 : o1.getClusterId() == o2.getClusterId() ? 0 : 1;\n            }\n            return c;\n        }\n    });\n    for (java.util.Map.Entry<java.lang.Object, java.lang.Object> entry : map.entrySet()) {\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString());\n        org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString());\n        transformed.put(high, new org.apache.jackrabbit.oak.plugins.mongomk.Range(high, low));\n    }\n    return java.util.Collections.unmodifiableSortedMap(transformed);\n}",
            "src_parent_type": "Block",
            "src_type": "ForEach"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "java.util.Collections.unmodifiableSortedMap(transformed)",
            "dst_parent": "previous = java.util.Collections.unmodifiableSortedMap(transformed)",
            "dst_parent_type": "Assignment",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "java.util.Collections.unmodifiableSortedMap(transformed)",
            "src_parent": "return java.util.Collections.unmodifiableSortedMap(transformed)",
            "src_parent_type": "Return",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey())",
            "dst_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision high = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey())",
            "dst_parent_type": "LocalVariable",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "entry.getKey().toString()",
            "src_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getKey().toString())",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue())",
            "dst_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision low = org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue())",
            "dst_parent_type": "LocalVariable",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "entry.getValue().toString()",
            "src_parent": "org.apache.jackrabbit.oak.plugins.mongomk.Revision.fromString(entry.getValue().toString())",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        }
      ],
      "file_name": "NodeDocument"
    }
  ],
  "id": "jackrabbit-oak_e1ae968c"
}