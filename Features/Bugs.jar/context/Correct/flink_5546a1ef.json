{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "subTypeHierarchy",
            "dst_parent": "createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), subTypeHierarchy, in1Type, in2Type)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "UPD",
            "src": "typeHierarchy",
            "src_parent": "createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "private java.util.Set<java.lang.Class<?>> alreadySeen;",
            "src_parent": "public class TypeExtractor {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.flink.api.java.typeutils.TypeExtractor.class);\n\n    private java.util.Set<java.lang.Class<?>> alreadySeen;\n\n    protected TypeExtractor() {\n        alreadySeen = new java.util.HashSet<java.lang.Class<?>>();\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getMapReturnTypes(mapInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapInterface)), org.apache.flink.api.common.functions.MapFunction.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFlatMapReturnTypes(flatMapInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (flatMapInterface)), org.apache.flink.api.common.functions.FlatMapFunction.class, false, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFoldReturnTypes(org.apache.flink.api.common.functions.FoldFunction<IN, OUT> foldInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFoldReturnTypes(foldInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFoldReturnTypes(org.apache.flink.api.common.functions.FoldFunction<IN, OUT> foldInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (foldInterface)), org.apache.flink.api.common.functions.FoldFunction.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getMapPartitionReturnTypes(mapPartitionInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapPartitionInterface)), org.apache.flink.api.common.functions.MapPartitionFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getGroupReduceReturnTypes(groupReduceInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (groupReduceInterface)), org.apache.flink.api.common.functions.GroupReduceFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupCombineReturnTypes(org.apache.flink.api.common.functions.GroupCombineFunction<IN, OUT> combineInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getGroupCombineReturnTypes(combineInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupCombineReturnTypes(org.apache.flink.api.common.functions.GroupCombineFunction<IN, OUT> combineInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (combineInterface)), org.apache.flink.api.common.functions.GroupCombineFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFlatJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.FlatJoinFunction.class, false, true, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.JoinFunction.class, false, false, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getCoGroupReturnTypes(coGroupInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (coGroupInterface)), org.apache.flink.api.common.functions.CoGroupFunction.class, true, true, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getCrossReturnTypes(crossInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (crossInterface)), org.apache.flink.api.common.functions.CrossFunction.class, false, false, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getKeySelectorTypes(selectorInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (selectorInterface)), org.apache.flink.api.java.functions.KeySelector.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <T> org.apache.flink.api.common.typeinfo.TypeInformation<T> getPartitionerTypes(org.apache.flink.api.common.functions.Partitioner<T> partitioner) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getPartitionerTypes(partitioner, null, false);\n    }\n\n    public static <T> org.apache.flink.api.common.typeinfo.TypeInformation<T> getPartitionerTypes(org.apache.flink.api.common.functions.Partitioner<T> partitioner, java.lang.String functionName, boolean allowMissing) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.functions.Partitioner.class, partitioner.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN> org.apache.flink.api.common.typeinfo.TypeInformation<IN> getInputFormatTypes(org.apache.flink.api.common.io.InputFormat<IN, ?> inputFormatInterface) {\n        if (inputFormatInterface instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n            return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<IN>) (inputFormatInterface)).getProducedType();\n        }\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.io.InputFormat.class, inputFormatInterface.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getUnaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterable, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        try {\n            final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n            if (m != null) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n                final int paramLen = m.getGenericParameterTypes().length - 1;\n                final java.lang.reflect.Type input = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterable ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input) : input, inType);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), inType, null);\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, inType);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null);\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (allowMissing) {\n                return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.MissingTypeInfo(functionName != null ? functionName : function.toString(), e)));\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getBinaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterables, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        try {\n            final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n            if (m != null) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n                final int paramLen = m.getGenericParameterTypes().length - 1;\n                final java.lang.reflect.Type input1 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1];\n                final java.lang.reflect.Type input2 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input1) : input1, in1Type);\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input2) : input2, in2Type);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), in1Type, in2Type);\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, in1Type);\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 1, in2Type);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type);\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (allowMissing) {\n                return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.MissingTypeInfo(functionName != null ? functionName : function.toString(), e)));\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    public static org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfo(java.lang.reflect.Type t) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> ti = new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(t);\n        if (ti == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not extract type information.\");\n        }\n        return ti;\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> ti = new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, clazz, returnParamPos, in1Type, in2Type);\n        if (ti == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not extract type information.\");\n        }\n        return ti;\n    }\n\n    private org.apache.flink.api.common.typeinfo.TypeInformation<?> privateCreateTypeInfo(java.lang.reflect.Type t) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        typeHierarchy.add(t);\n        return createTypeInfoWithTypeHierarchy(typeHierarchy, t, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type returnType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo;\n        if (returnType instanceof java.lang.reflect.TypeVariable<?>) {\n            typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)));\n            if (typeInfo != null) {\n                return typeInfo;\n            }\n        }\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.reflect.Type returnType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfoWithTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t))) {\n            java.lang.reflect.Type curT = t;\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n            }\n            while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                typeHierarchy.add(curT);\n                curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n            } \n            if (curT instanceof java.lang.Class<?>) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n            }\n            typeHierarchy.add(curT);\n            java.lang.reflect.ParameterizedType tupleChild = ((java.lang.reflect.ParameterizedType) (curT));\n            java.lang.reflect.Type[] subtypes = new java.lang.reflect.Type[tupleChild.getActualTypeArguments().length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (tupleChild.getActualTypeArguments()[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    subtypes[i] = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleChild.getActualTypeArguments()[i])));\n                } else {\n                    subtypes[i] = tupleChild.getActualTypeArguments()[i];\n                }\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] tupleSubTypes = new org.apache.flink.api.common.typeinfo.TypeInformation<?>[subtypes.length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (subtypes[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    tupleSubTypes[i] = createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type);\n                    if (tupleSubTypes[i] == null) {\n                        throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                    }\n                } else {\n                    tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n                }\n            }\n            java.lang.Class<?> tAsClass = null;\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t)) {\n                tAsClass = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t);\n            }\n            com.google.common.base.Preconditions.checkNotNull(tAsClass, \"t has a unexpected type\");\n            int fieldCount = countFieldsInClass(tAsClass);\n            if (fieldCount != tupleSubTypes.length) {\n                if (t instanceof java.lang.reflect.ParameterizedType) {\n                    return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (analyzePojo(tAsClass, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), ((java.lang.reflect.ParameterizedType) (t)), in1Type, in2Type)));\n                } else {\n                    return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (analyzePojo(tAsClass, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), null, in1Type, in2Type)));\n                }\n            }\n            return new org.apache.flink.api.java.typeutils.TupleTypeInfo(tAsClass, tupleSubTypes);\n        } else if (t instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.Type typeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (t)));\n            if (!(typeVar instanceof java.lang.reflect.TypeVariable)) {\n                return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n            } else {\n                org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)));\n                if (typeInfo != null) {\n                    return typeInfo;\n                } else {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (t)).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (t)).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            }\n        } else if (t instanceof java.lang.reflect.GenericArrayType) {\n            java.lang.reflect.GenericArrayType genericArray = ((java.lang.reflect.GenericArrayType) (t));\n            java.lang.reflect.Type componentType = genericArray.getGenericComponentType();\n            if (componentType instanceof java.lang.Class) {\n                java.lang.Class<?> componentClass = ((java.lang.Class<?>) (componentType));\n                java.lang.String className;\n                if (componentClass.isPrimitive()) {\n                    className = org.apache.flink.api.java.typeutils.TypeExtractor.encodePrimitiveClass(componentClass);\n                } else {\n                    className = (\"L\" + componentClass.getName()) + \";\";\n                }\n                java.lang.Class<OUT> classArray;\n                try {\n                    classArray = ((java.lang.Class<OUT>) (java.lang.Class.forName(\"[\" + className)));\n                } catch (java.lang.ClassNotFoundException e) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n                }\n                return org.apache.flink.api.java.typeutils.TypeExtractor.getForClass(classArray);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n            return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (privateGetForClass(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t), typeHierarchy, ((java.lang.reflect.ParameterizedType) (t)), in1Type, in2Type)));\n        } else if (t instanceof java.lang.Class) {\n            return privateGetForClass(((java.lang.Class<OUT>) (t)), typeHierarchy);\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type Information could not be created.\");\n    }\n\n    private <IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInputs(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1TypeInfo, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2TypeInfo) {\n        java.lang.reflect.Type matReturnTypeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n        if (!(matReturnTypeVar instanceof java.lang.reflect.TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n        } else {\n            returnTypeVar = ((java.lang.reflect.TypeVariable<?>) (matReturnTypeVar));\n        }\n        if ((in1TypeInfo == null) && (in2TypeInfo == null)) {\n            return null;\n        }\n        java.util.ArrayList<java.lang.reflect.Type> inputTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        for (java.lang.reflect.Type t : returnTypeHierarchy) {\n            if ((org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t) && org.apache.flink.api.common.functions.Function.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t))) && (org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t) != org.apache.flink.api.common.functions.Function.class)) {\n                inputTypeHierarchy.add(t);\n            } else {\n                break;\n            }\n        }\n        java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (inputTypeHierarchy.get(inputTypeHierarchy.size() - 1)));\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (in1TypeInfo != null) {\n            java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n            info = createTypeInfoFromInput(returnTypeVar, new java.util.ArrayList<java.lang.reflect.Type>(inputTypeHierarchy), in1Type, in1TypeInfo);\n        }\n        if ((info == null) && (in2TypeInfo != null)) {\n            java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n            info = createTypeInfoFromInput(returnTypeVar, new java.util.ArrayList<java.lang.reflect.Type>(inputTypeHierarchy), in2Type, in2TypeInfo);\n        }\n        if (info != null) {\n            return info;\n        }\n        return null;\n    }\n\n    private <IN1> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInput(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> inputTypeHierarchy, java.lang.reflect.Type inType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> inTypeInfo) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (inType instanceof java.lang.reflect.TypeVariable) {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(inputTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (inType)));\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo, inputTypeHierarchy);\n        } else if (inType instanceof java.lang.reflect.GenericArrayType) {\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = null;\n            if (inTypeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (inTypeInfo)).getComponentInfo();\n            } else if (inTypeInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                componentInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType());\n            } else if (inTypeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (inTypeInfo)).getComponentInfo();\n            }\n            info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((java.lang.reflect.GenericArrayType) (inType)).getGenericComponentType(), componentInfo);\n        } else if (((inTypeInfo instanceof org.apache.flink.api.java.typeutils.TupleTypeInfo) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(inType)) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType))) {\n            java.lang.reflect.ParameterizedType tupleBaseClass;\n            while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(inType) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                inputTypeHierarchy.add(inType);\n                inType = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType).getGenericSuperclass();\n            } \n            inputTypeHierarchy.add(inType);\n            tupleBaseClass = ((java.lang.reflect.ParameterizedType) (inType));\n            java.lang.reflect.Type[] tupleElements = tupleBaseClass.getActualTypeArguments();\n            for (int i = 0; i < tupleElements.length; i++) {\n                info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (inTypeInfo)).getTypeAt(i));\n                if (info != null) {\n                    break;\n                }\n            }\n        } else if (inTypeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(inputTypeHierarchy, inType, java.lang.Object.class);\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo, inputTypeHierarchy);\n        }\n        return info;\n    }\n\n    public static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int pos) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, null, clazz, pos);\n    }\n\n    private static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.Class<?> clazz, int pos) {\n        if (typeHierarchy != null) {\n            typeHierarchy.add(clazz);\n        }\n        java.lang.reflect.Type[] interfaceTypes = clazz.getGenericInterfaces();\n        for (java.lang.reflect.Type t : interfaceTypes) {\n            java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n            if (parameter != null) {\n                return parameter;\n            }\n        }\n        java.lang.reflect.Type t = clazz.getGenericSuperclass();\n        java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n        if (parameter != null) {\n            return parameter;\n        }\n        throw new java.lang.IllegalArgumentException(((\"The types of the interface \" + baseClass.getName()) + \" could not be inferred. \") + \"Support for synthetic interfaces, lambdas, and generic types is limited at this point.\");\n    }\n\n    private static java.lang.reflect.Type getParameterTypeFromGenericType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, int pos) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.equals(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            java.lang.reflect.ParameterizedType baseClassChild = ((java.lang.reflect.ParameterizedType) (t));\n            return baseClassChild.getActualTypeArguments()[pos];\n        } else if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), pos);\n        } else if ((t instanceof java.lang.Class<?>) && baseClass.isAssignableFrom(((java.lang.Class<?>) (t)))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (t)), pos);\n        }\n        return null;\n    }\n\n    private static void validateInputType(java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, t, inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    private static void validateInputType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int inputParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<?> inTypeInfo) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type inType;\n        try {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, inputParamPos);\n        } catch (java.lang.IllegalArgumentException e) {\n            return;\n        }\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, inType, inTypeInfo);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static void validateInfo(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> typeInfo) {\n        if (type == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. Type is null.\");\n        }\n        if (typeInfo == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\n        }\n        if (!(type instanceof java.lang.reflect.TypeVariable<?>)) {\n            if (typeInfo.isBasicType()) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual;\n                if ((!(type instanceof java.lang.Class<?>)) || ((actual = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(((java.lang.Class<?>) (type)))) == null)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Basic type expected.\");\n                }\n                if (!typeInfo.equals(actual)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Basic type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo.isTupleType()) {\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple type expected.\");\n                }\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Concrete subclass of Tuple expected.\");\n                }\n                while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                    typeHierarchy.add(type);\n                    type = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getGenericSuperclass();\n                } \n                if (type instanceof java.lang.Class<?>) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Parameterized Tuple type expected.\");\n                }\n                org.apache.flink.api.java.typeutils.TupleTypeInfo<?> tti = ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo));\n                java.lang.reflect.Type[] subTypes = ((java.lang.reflect.ParameterizedType) (type)).getActualTypeArguments();\n                if (subTypes.length != tti.getArity()) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Tuple arity '\" + tti.getArity()) + \"' expected but was '\") + subTypes.length) + \"'.\");\n                }\n                for (int i = 0; i < subTypes.length; i++) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subTypes[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo)).getTypeAt(i));\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.hadoop.io.Writable.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Writable type expected.\");\n                }\n                java.lang.Class<?> clazz;\n                if (((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass() != (clazz = ((java.lang.Class<?>) (type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Writable type '\" + ((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                java.lang.reflect.Type component;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                if (!((component instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (component)).isPrimitive())) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Primitive component expected.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) {\n                java.lang.reflect.Type component;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) {\n                if ((!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray())) && (!(type instanceof java.lang.reflect.GenericArrayType))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object array type expected.\");\n                }\n                java.lang.reflect.Type component;\n                if (type instanceof java.lang.Class<?>) {\n                    component = ((java.lang.Class<?>) (type)).getComponentType();\n                } else {\n                    component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType();\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.flink.types.Value.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Value type expected.\");\n                }\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual;\n                if (!((org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) (typeInfo)).equals(actual = org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(((java.lang.Class<? extends org.apache.flink.types.Value>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Value type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n                java.lang.Class<?> clazz = null;\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"POJO type '\" + ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.EnumTypeInfo) {\n                if (!((type instanceof java.lang.Class<?>) && java.lang.Enum.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Enum type expected.\");\n                }\n                if (!(typeInfo.getTypeClass() == type)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Enum type '\" + typeInfo.getTypeClass().getCanonicalName()) + \"' expected but was '\") + org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) {\n                java.lang.Class<?> clazz = null;\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Generic object type '\" + ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            }\n        } else {\n            type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type)));\n            if (!(type instanceof java.lang.reflect.TypeVariable)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, type, typeInfo);\n            }\n        }\n    }\n\n    private static java.lang.reflect.Type getTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type curT, java.lang.Class<?> stopAtClass) {\n        if (((typeHierarchy.size() > 0) && (typeHierarchy.get(0) == curT)) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT)) {\n            curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n        }\n        while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).equals(stopAtClass))) {\n            typeHierarchy.add(curT);\n            curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n            if (curT == null) {\n                break;\n            }\n        } \n        return curT;\n    }\n\n    private int countFieldsInClass(java.lang.Class<?> clazz) {\n        int fieldCount = 0;\n        for (java.lang.reflect.Field field : clazz.getFields()) {\n            if ((!java.lang.reflect.Modifier.isStatic(field.getModifiers())) && (!java.lang.reflect.Modifier.isTransient(field.getModifiers()))) {\n                fieldCount++;\n            }\n        }\n        return fieldCount;\n    }\n\n    private static java.lang.reflect.Type removeGenericWrapper(java.lang.reflect.Type t) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && (org.apache.flink.util.Collector.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t)) || java.lang.Iterable.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t)))) {\n            return ((java.lang.reflect.ParameterizedType) (t)).getActualTypeArguments()[0];\n        }\n        return t;\n    }\n\n    private static void validateLambdaGenericParameters(java.lang.reflect.Method m) {\n        for (java.lang.reflect.Type t : m.getGenericParameterTypes()) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(t);\n        }\n        org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(m.getGenericReturnType());\n    }\n\n    private static void validateLambdaGenericParameter(java.lang.reflect.Type t) {\n        if (!(t instanceof java.lang.Class)) {\n            return;\n        }\n        final java.lang.Class<?> clazz = ((java.lang.Class<?>) (t));\n        if (clazz.getTypeParameters().length > 0) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(((((\"The generic type parameters of '\" + clazz.getSimpleName()) + \"\\' are missing. \\n\") + \"It seems that your compiler has not stored them into the .class file. \\n\") + \"Currently, only the Eclipse JDT compiler preserves the type information necessary to use the lambdas feature type-safely. \\n\") + \"See the documentation for more information about how to compile jobs containing lambda expressions.\");\n        }\n    }\n\n    private static java.lang.String encodePrimitiveClass(java.lang.Class<?> primitiveClass) {\n        if (primitiveClass == boolean.class) {\n            return \"Z\";\n        } else if (primitiveClass == byte.class) {\n            return \"B\";\n        } else if (primitiveClass == char.class) {\n            return \"C\";\n        } else if (primitiveClass == double.class) {\n            return \"D\";\n        } else if (primitiveClass == float.class) {\n            return \"F\";\n        } else if (primitiveClass == int.class) {\n            return \"I\";\n        } else if (primitiveClass == long.class) {\n            return \"J\";\n        } else if (primitiveClass == short.class) {\n            return \"S\";\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException();\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> findCorrespondingInfo(java.lang.reflect.TypeVariable<?> typeVar, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> corrInfo, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(type, typeVar)) {\n            return corrInfo;\n        } else if ((type instanceof java.lang.reflect.TypeVariable) && org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type))), typeVar)) {\n            return corrInfo;\n        } else if (type instanceof java.lang.reflect.GenericArrayType) {\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = null;\n            if (corrInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (corrInfo)).getComponentInfo();\n            } else if (corrInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                componentInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(corrInfo.getTypeClass().getComponentType());\n            } else if (corrInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (corrInfo)).getComponentInfo();\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType(), componentInfo, typeHierarchy);\n            if (info != null) {\n                return info;\n            }\n        } else if (((corrInfo instanceof org.apache.flink.api.java.typeutils.TupleTypeInfo) && (type instanceof java.lang.reflect.ParameterizedType)) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))) {\n            java.lang.reflect.ParameterizedType tuple = ((java.lang.reflect.ParameterizedType) (type));\n            java.lang.reflect.Type[] args = tuple.getActualTypeArguments();\n            for (int i = 0; i < args.length; i++) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, args[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (corrInfo)).getTypeAt(i), typeHierarchy);\n                if (info != null) {\n                    return info;\n                }\n            }\n        } else if ((corrInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type)) {\n            java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type));\n            for (java.lang.reflect.Field field : fields) {\n                java.lang.reflect.Type fieldType = field.getGenericType();\n                if ((fieldType instanceof java.lang.reflect.TypeVariable) && org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(typeVar, org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (fieldType))))) {\n                    return org.apache.flink.api.java.typeutils.TypeExtractor.getTypeOfPojoField(corrInfo, field);\n                } else if ((fieldType instanceof java.lang.reflect.ParameterizedType) || (fieldType instanceof java.lang.reflect.GenericArrayType)) {\n                    java.util.ArrayList<java.lang.reflect.Type> typeHierarchyWithFieldType = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                    typeHierarchyWithFieldType.add(fieldType);\n                    org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, fieldType, org.apache.flink.api.java.typeutils.TypeExtractor.getTypeOfPojoField(corrInfo, field), typeHierarchyWithFieldType);\n                    if (info != null) {\n                        return info;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private static java.lang.reflect.Type materializeTypeVariable(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.TypeVariable<?> typeVar) {\n        java.lang.reflect.TypeVariable<?> inTypeTypeVar = typeVar;\n        for (int i = typeHierarchy.size() - 1; i >= 0; i--) {\n            java.lang.reflect.Type curT = typeHierarchy.get(i);\n            if (curT instanceof java.lang.reflect.ParameterizedType) {\n                java.lang.Class<?> rawType = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType()));\n                for (int paramIndex = 0; paramIndex < rawType.getTypeParameters().length; paramIndex++) {\n                    java.lang.reflect.TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex];\n                    if (org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(curVarOfCurT, inTypeTypeVar)) {\n                        java.lang.reflect.Type curVarType = ((java.lang.reflect.ParameterizedType) (curT)).getActualTypeArguments()[paramIndex];\n                        if (curVarType instanceof java.lang.reflect.TypeVariable<?>) {\n                            inTypeTypeVar = ((java.lang.reflect.TypeVariable<?>) (curVarType));\n                        } else {\n                            return curVarType;\n                        }\n                    }\n                }\n            }\n        }\n        return inTypeTypeVar;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForClass(java.lang.Class<X> clazz) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForClass(clazz, new java.util.ArrayList<java.lang.reflect.Type>());\n    }\n\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForClass(java.lang.Class<X> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        return privateGetForClass(clazz, typeHierarchy, null, null, null);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <OUT, IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateGetForClass(java.lang.Class<OUT> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.ParameterizedType parameterizedType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        com.google.common.base.Preconditions.checkNotNull(clazz);\n        if (clazz.equals(java.lang.Object.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (clazz.isArray()) {\n            org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo.getInfoFor(clazz);\n            if (primitiveArrayInfo != null) {\n                return primitiveArrayInfo;\n            }\n            org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<OUT, ?> basicArrayInfo = org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo.getInfoFor(clazz);\n            if (basicArrayInfo != null) {\n                return basicArrayInfo;\n            } else {\n                return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(clazz);\n            }\n        }\n        if (org.apache.hadoop.io.Writable.class.isAssignableFrom(clazz) && (!org.apache.hadoop.io.Writable.class.equals(clazz))) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.WritableTypeInfo.getWritableTypeInfo(((java.lang.Class<? extends org.apache.hadoop.io.Writable>) (clazz)))));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> basicTypeInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(clazz);\n        if (basicTypeInfo != null) {\n            return basicTypeInfo;\n        }\n        if (org.apache.flink.types.Value.class.isAssignableFrom(clazz)) {\n            java.lang.Class<? extends org.apache.flink.types.Value> valueClass = clazz.asSubclass(org.apache.flink.types.Value.class);\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(valueClass)));\n        }\n        if (org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(clazz)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n        }\n        if (java.lang.Enum.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.EnumTypeInfo(clazz)));\n        }\n        if (org.apache.avro.specific.SpecificRecordBase.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.AvroTypeInfo(clazz)));\n        }\n        if (alreadySeen.contains(clazz)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        alreadySeen.add(clazz);\n        if (java.lang.reflect.Modifier.isInterface(clazz.getModifiers())) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (clazz.equals(java.lang.Class.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        try {\n            org.apache.flink.api.common.typeinfo.TypeInformation<OUT> pojoType = analyzePojo(clazz, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\n            if (pojoType != null) {\n                return pojoType;\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.LOG.isDebugEnabled()) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Unable to handle type \" + clazz) + \" as POJO. Message: \") + e.getMessage(), e);\n            }\n        }\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n    }\n\n    private boolean isValidPojoField(java.lang.reflect.Field f, java.lang.Class<?> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        if (java.lang.reflect.Modifier.isPublic(f.getModifiers())) {\n            return true;\n        } else {\n            boolean hasGetter = false;\n            boolean hasSetter = false;\n            final java.lang.String fieldNameLow = f.getName().toLowerCase();\n            java.lang.reflect.Type fieldType = f.getGenericType();\n            java.lang.reflect.TypeVariable<?> fieldTypeGeneric = null;\n            if (fieldType instanceof java.lang.reflect.TypeVariable) {\n                fieldTypeGeneric = ((java.lang.reflect.TypeVariable<?>) (fieldType));\n                fieldType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (fieldType)));\n            }\n            for (java.lang.reflect.Method m : clazz.getMethods()) {\n                if ((((m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow)) || m.getName().toLowerCase().equals(fieldNameLow)) && (m.getParameterTypes().length == 0)) && (m.getGenericReturnType().equals(fieldType) || ((fieldTypeGeneric != null) && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                    if (hasGetter) {\n                        throw new java.lang.IllegalStateException(\"Detected more than one getter\");\n                    }\n                    hasGetter = true;\n                }\n                if ((((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && (m.getParameterTypes().length == 1)) && (m.getGenericParameterTypes()[0].equals(fieldType) || ((fieldTypeGeneric != null) && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric)))) && m.getReturnType().equals(java.lang.Void.TYPE)) {\n                    if (hasSetter) {\n                        throw new java.lang.IllegalStateException(\"Detected more than one setter\");\n                    }\n                    hasSetter = true;\n                }\n            }\n            if (hasGetter && hasSetter) {\n                return true;\n            } else {\n                if (!hasGetter) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Class \" + clazz) + \" does not contain a getter for field \") + f.getName());\n                }\n                if (!hasSetter) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Class \" + clazz) + \" does not contain a setter for field \") + f.getName());\n                }\n                return false;\n            }\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    protected <OUT, IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> analyzePojo(java.lang.Class<OUT> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.ParameterizedType parameterizedType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (parameterizedType != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(typeHierarchy, parameterizedType, java.lang.Object.class);\n        } else if (typeHierarchy.size() <= 1) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(typeHierarchy, clazz, java.lang.Object.class);\n        }\n        java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz);\n        if (fields.size() == 0) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"No fields detected for class \" + clazz) + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        java.util.List<org.apache.flink.api.java.typeutils.PojoField> pojoFields = new java.util.ArrayList<org.apache.flink.api.java.typeutils.PojoField>();\n        for (java.lang.reflect.Field field : fields) {\n            java.lang.reflect.Type fieldType = field.getGenericType();\n            if (!isValidPojoField(field, clazz, typeHierarchy)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" is not a valid POJO type\");\n                return null;\n            }\n            try {\n                java.util.ArrayList<java.lang.reflect.Type> fieldTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                fieldTypeHierarchy.add(fieldType);\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> ti = createTypeInfoWithTypeHierarchy(fieldTypeHierarchy, fieldType, in1Type, in2Type);\n                pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, ti));\n            } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n                java.lang.Class<?> genericClass = java.lang.Object.class;\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(fieldType)) {\n                    genericClass = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(fieldType);\n                }\n                pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(((java.lang.Class<OUT>) (genericClass)))));\n            }\n        }\n        org.apache.flink.api.common.typeutils.CompositeType<OUT> pojoType = new org.apache.flink.api.java.typeutils.PojoTypeInfo<OUT>(clazz, pojoFields);\n        java.util.List<java.lang.reflect.Method> methods = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredMethods(clazz);\n        for (java.lang.reflect.Method method : methods) {\n            if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" contains custom serialization methods we do not call.\");\n                return null;\n            }\n        }\n        try {\n            clazz.getDeclaredConstructor();\n        } catch (java.lang.NoSuchMethodException e) {\n            if (clazz.isInterface() || java.lang.reflect.Modifier.isAbstract(clazz.getModifiers())) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info(((\"Class \" + clazz) + \" is abstract or an interface, having a concrete \") + \"type can increase performance.\");\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" must have a default constructor to be used as a POJO.\");\n                return null;\n            }\n        }\n        return pojoType;\n    }\n\n    public static java.util.List<java.lang.reflect.Field> getAllDeclaredFields(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Field> result = new java.util.ArrayList<java.lang.reflect.Field>();\n        while (clazz != null) {\n            java.lang.reflect.Field[] fields = clazz.getDeclaredFields();\n            for (java.lang.reflect.Field field : fields) {\n                if (java.lang.reflect.Modifier.isTransient(field.getModifiers()) || java.lang.reflect.Modifier.isStatic(field.getModifiers())) {\n                    continue;\n                }\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.hasFieldWithSameName(field.getName(), result)) {\n                    throw new java.lang.RuntimeException(((((\"The field \" + field) + \" is already contained in the hierarchy of the class \") + clazz) + \".\") + \"Please use unique field names through your classes hierarchy\");\n                }\n                result.add(field);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static java.lang.reflect.Field getDeclaredField(java.lang.Class<?> clazz, java.lang.String name) {\n        for (java.lang.reflect.Field field : org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz)) {\n            if (field.getName().equals(name)) {\n                return field;\n            }\n        }\n        return null;\n    }\n\n    private static boolean hasFieldWithSameName(java.lang.String name, java.util.List<java.lang.reflect.Field> fields) {\n        for (java.lang.reflect.Field field : fields) {\n            if (name.equals(field.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static java.util.List<java.lang.reflect.Method> getAllDeclaredMethods(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Method> result = new java.util.ArrayList<java.lang.reflect.Method>();\n        while (clazz != null) {\n            java.lang.reflect.Method[] methods = clazz.getDeclaredMethods();\n            for (java.lang.reflect.Method method : methods) {\n                result.add(method);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static java.lang.Class<?> typeToClass(java.lang.reflect.Type t) {\n        if (t instanceof java.lang.Class) {\n            return ((java.lang.Class<?>) (t));\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()));\n        }\n        throw new java.lang.IllegalArgumentException(\"Cannot convert type to class\");\n    }\n\n    public static boolean isClassType(java.lang.reflect.Type t) {\n        return (t instanceof java.lang.Class<?>) || (t instanceof java.lang.reflect.ParameterizedType);\n    }\n\n    private static boolean sameTypeVars(java.lang.reflect.Type t1, java.lang.reflect.Type t2) {\n        if ((!(t1 instanceof java.lang.reflect.TypeVariable)) || (!(t2 instanceof java.lang.reflect.TypeVariable))) {\n            return false;\n        }\n        return ((java.lang.reflect.TypeVariable<?>) (t1)).getName().equals(((java.lang.reflect.TypeVariable<?>) (t2)).getName()) && ((java.lang.reflect.TypeVariable<?>) (t1)).getGenericDeclaration().equals(((java.lang.reflect.TypeVariable<?>) (t2)).getGenericDeclaration());\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> getTypeOfPojoField(org.apache.flink.api.common.typeinfo.TypeInformation<?> pojoInfo, java.lang.reflect.Field field) {\n        for (int j = 0; j < pojoInfo.getArity(); j++) {\n            org.apache.flink.api.java.typeutils.PojoField pf = ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (pojoInfo)).getPojoFieldAt(j);\n            if (pf.field.getName().equals(field.getName())) {\n                return pf.type;\n            }\n        }\n        return null;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForObject(X value) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForObject(value);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForObject(X value) {\n        com.google.common.base.Preconditions.checkNotNull(value);\n        if (value instanceof org.apache.flink.api.java.tuple.Tuple) {\n            org.apache.flink.api.java.tuple.Tuple t = ((org.apache.flink.api.java.tuple.Tuple) (value));\n            int numFields = t.getArity();\n            if (numFields != countFieldsInClass(value.getClass())) {\n                return analyzePojo(((java.lang.Class<X>) (value.getClass())), new java.util.ArrayList<java.lang.reflect.Type>(), null, null, null);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] infos = new org.apache.flink.api.common.typeinfo.TypeInformation[numFields];\n            for (int i = 0; i < numFields; i++) {\n                java.lang.Object field = t.getField(i);\n                if (field == null) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Automatic type extraction is not possible on candidates with null values. \" + \"Please specify the types directly.\");\n                }\n                infos[i] = privateGetForObject(field);\n            }\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (new org.apache.flink.api.java.typeutils.TupleTypeInfo(value.getClass(), infos)));\n        } else {\n            return privateGetForClass(((java.lang.Class<X>) (value.getClass())), new java.util.ArrayList<java.lang.reflect.Type>());\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Constructor",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "protected TypeExtractor() {\n    alreadySeen = new java.util.HashSet<java.lang.Class<?>>();\n}",
            "src_parent": "public class TypeExtractor {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.flink.api.java.typeutils.TypeExtractor.class);\n\n    private java.util.Set<java.lang.Class<?>> alreadySeen;\n\n    protected TypeExtractor() {\n        alreadySeen = new java.util.HashSet<java.lang.Class<?>>();\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getMapReturnTypes(mapInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapInterface)), org.apache.flink.api.common.functions.MapFunction.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFlatMapReturnTypes(flatMapInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (flatMapInterface)), org.apache.flink.api.common.functions.FlatMapFunction.class, false, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFoldReturnTypes(org.apache.flink.api.common.functions.FoldFunction<IN, OUT> foldInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFoldReturnTypes(foldInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFoldReturnTypes(org.apache.flink.api.common.functions.FoldFunction<IN, OUT> foldInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (foldInterface)), org.apache.flink.api.common.functions.FoldFunction.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getMapPartitionReturnTypes(mapPartitionInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapPartitionInterface)), org.apache.flink.api.common.functions.MapPartitionFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getGroupReduceReturnTypes(groupReduceInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (groupReduceInterface)), org.apache.flink.api.common.functions.GroupReduceFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupCombineReturnTypes(org.apache.flink.api.common.functions.GroupCombineFunction<IN, OUT> combineInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getGroupCombineReturnTypes(combineInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupCombineReturnTypes(org.apache.flink.api.common.functions.GroupCombineFunction<IN, OUT> combineInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (combineInterface)), org.apache.flink.api.common.functions.GroupCombineFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFlatJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.FlatJoinFunction.class, false, true, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.JoinFunction.class, false, false, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getCoGroupReturnTypes(coGroupInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (coGroupInterface)), org.apache.flink.api.common.functions.CoGroupFunction.class, true, true, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getCrossReturnTypes(crossInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (crossInterface)), org.apache.flink.api.common.functions.CrossFunction.class, false, false, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getKeySelectorTypes(selectorInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (selectorInterface)), org.apache.flink.api.java.functions.KeySelector.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <T> org.apache.flink.api.common.typeinfo.TypeInformation<T> getPartitionerTypes(org.apache.flink.api.common.functions.Partitioner<T> partitioner) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getPartitionerTypes(partitioner, null, false);\n    }\n\n    public static <T> org.apache.flink.api.common.typeinfo.TypeInformation<T> getPartitionerTypes(org.apache.flink.api.common.functions.Partitioner<T> partitioner, java.lang.String functionName, boolean allowMissing) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.functions.Partitioner.class, partitioner.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN> org.apache.flink.api.common.typeinfo.TypeInformation<IN> getInputFormatTypes(org.apache.flink.api.common.io.InputFormat<IN, ?> inputFormatInterface) {\n        if (inputFormatInterface instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n            return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<IN>) (inputFormatInterface)).getProducedType();\n        }\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.io.InputFormat.class, inputFormatInterface.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getUnaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterable, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        try {\n            final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n            if (m != null) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n                final int paramLen = m.getGenericParameterTypes().length - 1;\n                final java.lang.reflect.Type input = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterable ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input) : input, inType);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), inType, null);\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, inType);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null);\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (allowMissing) {\n                return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.MissingTypeInfo(functionName != null ? functionName : function.toString(), e)));\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getBinaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterables, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        try {\n            final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n            if (m != null) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n                final int paramLen = m.getGenericParameterTypes().length - 1;\n                final java.lang.reflect.Type input1 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1];\n                final java.lang.reflect.Type input2 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input1) : input1, in1Type);\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input2) : input2, in2Type);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), in1Type, in2Type);\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, in1Type);\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 1, in2Type);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type);\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (allowMissing) {\n                return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.MissingTypeInfo(functionName != null ? functionName : function.toString(), e)));\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    public static org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfo(java.lang.reflect.Type t) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> ti = new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(t);\n        if (ti == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not extract type information.\");\n        }\n        return ti;\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> ti = new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, clazz, returnParamPos, in1Type, in2Type);\n        if (ti == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not extract type information.\");\n        }\n        return ti;\n    }\n\n    private org.apache.flink.api.common.typeinfo.TypeInformation<?> privateCreateTypeInfo(java.lang.reflect.Type t) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        typeHierarchy.add(t);\n        return createTypeInfoWithTypeHierarchy(typeHierarchy, t, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type returnType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo;\n        if (returnType instanceof java.lang.reflect.TypeVariable<?>) {\n            typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)));\n            if (typeInfo != null) {\n                return typeInfo;\n            }\n        }\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.reflect.Type returnType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfoWithTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t))) {\n            java.lang.reflect.Type curT = t;\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n            }\n            while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                typeHierarchy.add(curT);\n                curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n            } \n            if (curT instanceof java.lang.Class<?>) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n            }\n            typeHierarchy.add(curT);\n            java.lang.reflect.ParameterizedType tupleChild = ((java.lang.reflect.ParameterizedType) (curT));\n            java.lang.reflect.Type[] subtypes = new java.lang.reflect.Type[tupleChild.getActualTypeArguments().length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (tupleChild.getActualTypeArguments()[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    subtypes[i] = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleChild.getActualTypeArguments()[i])));\n                } else {\n                    subtypes[i] = tupleChild.getActualTypeArguments()[i];\n                }\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] tupleSubTypes = new org.apache.flink.api.common.typeinfo.TypeInformation<?>[subtypes.length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (subtypes[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    tupleSubTypes[i] = createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), typeHierarchy, in1Type, in2Type);\n                    if (tupleSubTypes[i] == null) {\n                        throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                    }\n                } else {\n                    tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n                }\n            }\n            java.lang.Class<?> tAsClass = null;\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t)) {\n                tAsClass = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t);\n            }\n            com.google.common.base.Preconditions.checkNotNull(tAsClass, \"t has a unexpected type\");\n            int fieldCount = countFieldsInClass(tAsClass);\n            if (fieldCount != tupleSubTypes.length) {\n                if (t instanceof java.lang.reflect.ParameterizedType) {\n                    return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (analyzePojo(tAsClass, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), ((java.lang.reflect.ParameterizedType) (t)), in1Type, in2Type)));\n                } else {\n                    return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (analyzePojo(tAsClass, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), null, in1Type, in2Type)));\n                }\n            }\n            return new org.apache.flink.api.java.typeutils.TupleTypeInfo(tAsClass, tupleSubTypes);\n        } else if (t instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.Type typeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (t)));\n            if (!(typeVar instanceof java.lang.reflect.TypeVariable)) {\n                return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n            } else {\n                org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)));\n                if (typeInfo != null) {\n                    return typeInfo;\n                } else {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (t)).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (t)).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            }\n        } else if (t instanceof java.lang.reflect.GenericArrayType) {\n            java.lang.reflect.GenericArrayType genericArray = ((java.lang.reflect.GenericArrayType) (t));\n            java.lang.reflect.Type componentType = genericArray.getGenericComponentType();\n            if (componentType instanceof java.lang.Class) {\n                java.lang.Class<?> componentClass = ((java.lang.Class<?>) (componentType));\n                java.lang.String className;\n                if (componentClass.isPrimitive()) {\n                    className = org.apache.flink.api.java.typeutils.TypeExtractor.encodePrimitiveClass(componentClass);\n                } else {\n                    className = (\"L\" + componentClass.getName()) + \";\";\n                }\n                java.lang.Class<OUT> classArray;\n                try {\n                    classArray = ((java.lang.Class<OUT>) (java.lang.Class.forName(\"[\" + className)));\n                } catch (java.lang.ClassNotFoundException e) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n                }\n                return org.apache.flink.api.java.typeutils.TypeExtractor.getForClass(classArray);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n            return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (privateGetForClass(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t), typeHierarchy, ((java.lang.reflect.ParameterizedType) (t)), in1Type, in2Type)));\n        } else if (t instanceof java.lang.Class) {\n            return privateGetForClass(((java.lang.Class<OUT>) (t)), typeHierarchy);\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type Information could not be created.\");\n    }\n\n    private <IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInputs(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1TypeInfo, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2TypeInfo) {\n        java.lang.reflect.Type matReturnTypeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n        if (!(matReturnTypeVar instanceof java.lang.reflect.TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n        } else {\n            returnTypeVar = ((java.lang.reflect.TypeVariable<?>) (matReturnTypeVar));\n        }\n        if ((in1TypeInfo == null) && (in2TypeInfo == null)) {\n            return null;\n        }\n        java.util.ArrayList<java.lang.reflect.Type> inputTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        for (java.lang.reflect.Type t : returnTypeHierarchy) {\n            if ((org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t) && org.apache.flink.api.common.functions.Function.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t))) && (org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t) != org.apache.flink.api.common.functions.Function.class)) {\n                inputTypeHierarchy.add(t);\n            } else {\n                break;\n            }\n        }\n        java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (inputTypeHierarchy.get(inputTypeHierarchy.size() - 1)));\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (in1TypeInfo != null) {\n            java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n            info = createTypeInfoFromInput(returnTypeVar, new java.util.ArrayList<java.lang.reflect.Type>(inputTypeHierarchy), in1Type, in1TypeInfo);\n        }\n        if ((info == null) && (in2TypeInfo != null)) {\n            java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n            info = createTypeInfoFromInput(returnTypeVar, new java.util.ArrayList<java.lang.reflect.Type>(inputTypeHierarchy), in2Type, in2TypeInfo);\n        }\n        if (info != null) {\n            return info;\n        }\n        return null;\n    }\n\n    private <IN1> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInput(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> inputTypeHierarchy, java.lang.reflect.Type inType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> inTypeInfo) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (inType instanceof java.lang.reflect.TypeVariable) {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(inputTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (inType)));\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo, inputTypeHierarchy);\n        } else if (inType instanceof java.lang.reflect.GenericArrayType) {\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = null;\n            if (inTypeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (inTypeInfo)).getComponentInfo();\n            } else if (inTypeInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                componentInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType());\n            } else if (inTypeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (inTypeInfo)).getComponentInfo();\n            }\n            info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((java.lang.reflect.GenericArrayType) (inType)).getGenericComponentType(), componentInfo);\n        } else if (((inTypeInfo instanceof org.apache.flink.api.java.typeutils.TupleTypeInfo) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(inType)) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType))) {\n            java.lang.reflect.ParameterizedType tupleBaseClass;\n            while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(inType) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                inputTypeHierarchy.add(inType);\n                inType = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType).getGenericSuperclass();\n            } \n            inputTypeHierarchy.add(inType);\n            tupleBaseClass = ((java.lang.reflect.ParameterizedType) (inType));\n            java.lang.reflect.Type[] tupleElements = tupleBaseClass.getActualTypeArguments();\n            for (int i = 0; i < tupleElements.length; i++) {\n                info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (inTypeInfo)).getTypeAt(i));\n                if (info != null) {\n                    break;\n                }\n            }\n        } else if (inTypeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(inputTypeHierarchy, inType, java.lang.Object.class);\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo, inputTypeHierarchy);\n        }\n        return info;\n    }\n\n    public static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int pos) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, null, clazz, pos);\n    }\n\n    private static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.Class<?> clazz, int pos) {\n        if (typeHierarchy != null) {\n            typeHierarchy.add(clazz);\n        }\n        java.lang.reflect.Type[] interfaceTypes = clazz.getGenericInterfaces();\n        for (java.lang.reflect.Type t : interfaceTypes) {\n            java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n            if (parameter != null) {\n                return parameter;\n            }\n        }\n        java.lang.reflect.Type t = clazz.getGenericSuperclass();\n        java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n        if (parameter != null) {\n            return parameter;\n        }\n        throw new java.lang.IllegalArgumentException(((\"The types of the interface \" + baseClass.getName()) + \" could not be inferred. \") + \"Support for synthetic interfaces, lambdas, and generic types is limited at this point.\");\n    }\n\n    private static java.lang.reflect.Type getParameterTypeFromGenericType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, int pos) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.equals(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            java.lang.reflect.ParameterizedType baseClassChild = ((java.lang.reflect.ParameterizedType) (t));\n            return baseClassChild.getActualTypeArguments()[pos];\n        } else if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), pos);\n        } else if ((t instanceof java.lang.Class<?>) && baseClass.isAssignableFrom(((java.lang.Class<?>) (t)))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (t)), pos);\n        }\n        return null;\n    }\n\n    private static void validateInputType(java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, t, inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    private static void validateInputType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int inputParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<?> inTypeInfo) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type inType;\n        try {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, inputParamPos);\n        } catch (java.lang.IllegalArgumentException e) {\n            return;\n        }\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, inType, inTypeInfo);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static void validateInfo(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> typeInfo) {\n        if (type == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. Type is null.\");\n        }\n        if (typeInfo == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\n        }\n        if (!(type instanceof java.lang.reflect.TypeVariable<?>)) {\n            if (typeInfo.isBasicType()) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual;\n                if ((!(type instanceof java.lang.Class<?>)) || ((actual = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(((java.lang.Class<?>) (type)))) == null)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Basic type expected.\");\n                }\n                if (!typeInfo.equals(actual)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Basic type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo.isTupleType()) {\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple type expected.\");\n                }\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Concrete subclass of Tuple expected.\");\n                }\n                while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                    typeHierarchy.add(type);\n                    type = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getGenericSuperclass();\n                } \n                if (type instanceof java.lang.Class<?>) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Parameterized Tuple type expected.\");\n                }\n                org.apache.flink.api.java.typeutils.TupleTypeInfo<?> tti = ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo));\n                java.lang.reflect.Type[] subTypes = ((java.lang.reflect.ParameterizedType) (type)).getActualTypeArguments();\n                if (subTypes.length != tti.getArity()) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Tuple arity '\" + tti.getArity()) + \"' expected but was '\") + subTypes.length) + \"'.\");\n                }\n                for (int i = 0; i < subTypes.length; i++) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subTypes[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo)).getTypeAt(i));\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.hadoop.io.Writable.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Writable type expected.\");\n                }\n                java.lang.Class<?> clazz;\n                if (((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass() != (clazz = ((java.lang.Class<?>) (type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Writable type '\" + ((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                java.lang.reflect.Type component;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                if (!((component instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (component)).isPrimitive())) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Primitive component expected.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) {\n                java.lang.reflect.Type component;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) {\n                if ((!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray())) && (!(type instanceof java.lang.reflect.GenericArrayType))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object array type expected.\");\n                }\n                java.lang.reflect.Type component;\n                if (type instanceof java.lang.Class<?>) {\n                    component = ((java.lang.Class<?>) (type)).getComponentType();\n                } else {\n                    component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType();\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.flink.types.Value.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Value type expected.\");\n                }\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual;\n                if (!((org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) (typeInfo)).equals(actual = org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(((java.lang.Class<? extends org.apache.flink.types.Value>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Value type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n                java.lang.Class<?> clazz = null;\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"POJO type '\" + ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.EnumTypeInfo) {\n                if (!((type instanceof java.lang.Class<?>) && java.lang.Enum.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Enum type expected.\");\n                }\n                if (!(typeInfo.getTypeClass() == type)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Enum type '\" + typeInfo.getTypeClass().getCanonicalName()) + \"' expected but was '\") + org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) {\n                java.lang.Class<?> clazz = null;\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Generic object type '\" + ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            }\n        } else {\n            type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type)));\n            if (!(type instanceof java.lang.reflect.TypeVariable)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, type, typeInfo);\n            }\n        }\n    }\n\n    private static java.lang.reflect.Type getTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type curT, java.lang.Class<?> stopAtClass) {\n        if (((typeHierarchy.size() > 0) && (typeHierarchy.get(0) == curT)) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT)) {\n            curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n        }\n        while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).equals(stopAtClass))) {\n            typeHierarchy.add(curT);\n            curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n            if (curT == null) {\n                break;\n            }\n        } \n        return curT;\n    }\n\n    private int countFieldsInClass(java.lang.Class<?> clazz) {\n        int fieldCount = 0;\n        for (java.lang.reflect.Field field : clazz.getFields()) {\n            if ((!java.lang.reflect.Modifier.isStatic(field.getModifiers())) && (!java.lang.reflect.Modifier.isTransient(field.getModifiers()))) {\n                fieldCount++;\n            }\n        }\n        return fieldCount;\n    }\n\n    private static java.lang.reflect.Type removeGenericWrapper(java.lang.reflect.Type t) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && (org.apache.flink.util.Collector.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t)) || java.lang.Iterable.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t)))) {\n            return ((java.lang.reflect.ParameterizedType) (t)).getActualTypeArguments()[0];\n        }\n        return t;\n    }\n\n    private static void validateLambdaGenericParameters(java.lang.reflect.Method m) {\n        for (java.lang.reflect.Type t : m.getGenericParameterTypes()) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(t);\n        }\n        org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(m.getGenericReturnType());\n    }\n\n    private static void validateLambdaGenericParameter(java.lang.reflect.Type t) {\n        if (!(t instanceof java.lang.Class)) {\n            return;\n        }\n        final java.lang.Class<?> clazz = ((java.lang.Class<?>) (t));\n        if (clazz.getTypeParameters().length > 0) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(((((\"The generic type parameters of '\" + clazz.getSimpleName()) + \"\\' are missing. \\n\") + \"It seems that your compiler has not stored them into the .class file. \\n\") + \"Currently, only the Eclipse JDT compiler preserves the type information necessary to use the lambdas feature type-safely. \\n\") + \"See the documentation for more information about how to compile jobs containing lambda expressions.\");\n        }\n    }\n\n    private static java.lang.String encodePrimitiveClass(java.lang.Class<?> primitiveClass) {\n        if (primitiveClass == boolean.class) {\n            return \"Z\";\n        } else if (primitiveClass == byte.class) {\n            return \"B\";\n        } else if (primitiveClass == char.class) {\n            return \"C\";\n        } else if (primitiveClass == double.class) {\n            return \"D\";\n        } else if (primitiveClass == float.class) {\n            return \"F\";\n        } else if (primitiveClass == int.class) {\n            return \"I\";\n        } else if (primitiveClass == long.class) {\n            return \"J\";\n        } else if (primitiveClass == short.class) {\n            return \"S\";\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException();\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> findCorrespondingInfo(java.lang.reflect.TypeVariable<?> typeVar, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> corrInfo, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(type, typeVar)) {\n            return corrInfo;\n        } else if ((type instanceof java.lang.reflect.TypeVariable) && org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type))), typeVar)) {\n            return corrInfo;\n        } else if (type instanceof java.lang.reflect.GenericArrayType) {\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = null;\n            if (corrInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (corrInfo)).getComponentInfo();\n            } else if (corrInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                componentInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(corrInfo.getTypeClass().getComponentType());\n            } else if (corrInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (corrInfo)).getComponentInfo();\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType(), componentInfo, typeHierarchy);\n            if (info != null) {\n                return info;\n            }\n        } else if (((corrInfo instanceof org.apache.flink.api.java.typeutils.TupleTypeInfo) && (type instanceof java.lang.reflect.ParameterizedType)) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))) {\n            java.lang.reflect.ParameterizedType tuple = ((java.lang.reflect.ParameterizedType) (type));\n            java.lang.reflect.Type[] args = tuple.getActualTypeArguments();\n            for (int i = 0; i < args.length; i++) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, args[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (corrInfo)).getTypeAt(i), typeHierarchy);\n                if (info != null) {\n                    return info;\n                }\n            }\n        } else if ((corrInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type)) {\n            java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type));\n            for (java.lang.reflect.Field field : fields) {\n                java.lang.reflect.Type fieldType = field.getGenericType();\n                if ((fieldType instanceof java.lang.reflect.TypeVariable) && org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(typeVar, org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (fieldType))))) {\n                    return org.apache.flink.api.java.typeutils.TypeExtractor.getTypeOfPojoField(corrInfo, field);\n                } else if ((fieldType instanceof java.lang.reflect.ParameterizedType) || (fieldType instanceof java.lang.reflect.GenericArrayType)) {\n                    java.util.ArrayList<java.lang.reflect.Type> typeHierarchyWithFieldType = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                    typeHierarchyWithFieldType.add(fieldType);\n                    org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, fieldType, org.apache.flink.api.java.typeutils.TypeExtractor.getTypeOfPojoField(corrInfo, field), typeHierarchyWithFieldType);\n                    if (info != null) {\n                        return info;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private static java.lang.reflect.Type materializeTypeVariable(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.TypeVariable<?> typeVar) {\n        java.lang.reflect.TypeVariable<?> inTypeTypeVar = typeVar;\n        for (int i = typeHierarchy.size() - 1; i >= 0; i--) {\n            java.lang.reflect.Type curT = typeHierarchy.get(i);\n            if (curT instanceof java.lang.reflect.ParameterizedType) {\n                java.lang.Class<?> rawType = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType()));\n                for (int paramIndex = 0; paramIndex < rawType.getTypeParameters().length; paramIndex++) {\n                    java.lang.reflect.TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex];\n                    if (org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(curVarOfCurT, inTypeTypeVar)) {\n                        java.lang.reflect.Type curVarType = ((java.lang.reflect.ParameterizedType) (curT)).getActualTypeArguments()[paramIndex];\n                        if (curVarType instanceof java.lang.reflect.TypeVariable<?>) {\n                            inTypeTypeVar = ((java.lang.reflect.TypeVariable<?>) (curVarType));\n                        } else {\n                            return curVarType;\n                        }\n                    }\n                }\n            }\n        }\n        return inTypeTypeVar;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForClass(java.lang.Class<X> clazz) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForClass(clazz, new java.util.ArrayList<java.lang.reflect.Type>());\n    }\n\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForClass(java.lang.Class<X> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        return privateGetForClass(clazz, typeHierarchy, null, null, null);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <OUT, IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateGetForClass(java.lang.Class<OUT> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.ParameterizedType parameterizedType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        com.google.common.base.Preconditions.checkNotNull(clazz);\n        if (clazz.equals(java.lang.Object.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (clazz.isArray()) {\n            org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo.getInfoFor(clazz);\n            if (primitiveArrayInfo != null) {\n                return primitiveArrayInfo;\n            }\n            org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<OUT, ?> basicArrayInfo = org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo.getInfoFor(clazz);\n            if (basicArrayInfo != null) {\n                return basicArrayInfo;\n            } else {\n                return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(clazz);\n            }\n        }\n        if (org.apache.hadoop.io.Writable.class.isAssignableFrom(clazz) && (!org.apache.hadoop.io.Writable.class.equals(clazz))) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.WritableTypeInfo.getWritableTypeInfo(((java.lang.Class<? extends org.apache.hadoop.io.Writable>) (clazz)))));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> basicTypeInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(clazz);\n        if (basicTypeInfo != null) {\n            return basicTypeInfo;\n        }\n        if (org.apache.flink.types.Value.class.isAssignableFrom(clazz)) {\n            java.lang.Class<? extends org.apache.flink.types.Value> valueClass = clazz.asSubclass(org.apache.flink.types.Value.class);\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(valueClass)));\n        }\n        if (org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(clazz)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n        }\n        if (java.lang.Enum.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.EnumTypeInfo(clazz)));\n        }\n        if (org.apache.avro.specific.SpecificRecordBase.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.AvroTypeInfo(clazz)));\n        }\n        if (alreadySeen.contains(clazz)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        alreadySeen.add(clazz);\n        if (java.lang.reflect.Modifier.isInterface(clazz.getModifiers())) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (clazz.equals(java.lang.Class.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        try {\n            org.apache.flink.api.common.typeinfo.TypeInformation<OUT> pojoType = analyzePojo(clazz, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\n            if (pojoType != null) {\n                return pojoType;\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.LOG.isDebugEnabled()) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Unable to handle type \" + clazz) + \" as POJO. Message: \") + e.getMessage(), e);\n            }\n        }\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n    }\n\n    private boolean isValidPojoField(java.lang.reflect.Field f, java.lang.Class<?> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        if (java.lang.reflect.Modifier.isPublic(f.getModifiers())) {\n            return true;\n        } else {\n            boolean hasGetter = false;\n            boolean hasSetter = false;\n            final java.lang.String fieldNameLow = f.getName().toLowerCase();\n            java.lang.reflect.Type fieldType = f.getGenericType();\n            java.lang.reflect.TypeVariable<?> fieldTypeGeneric = null;\n            if (fieldType instanceof java.lang.reflect.TypeVariable) {\n                fieldTypeGeneric = ((java.lang.reflect.TypeVariable<?>) (fieldType));\n                fieldType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (fieldType)));\n            }\n            for (java.lang.reflect.Method m : clazz.getMethods()) {\n                if ((((m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow)) || m.getName().toLowerCase().equals(fieldNameLow)) && (m.getParameterTypes().length == 0)) && (m.getGenericReturnType().equals(fieldType) || ((fieldTypeGeneric != null) && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                    if (hasGetter) {\n                        throw new java.lang.IllegalStateException(\"Detected more than one getter\");\n                    }\n                    hasGetter = true;\n                }\n                if ((((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && (m.getParameterTypes().length == 1)) && (m.getGenericParameterTypes()[0].equals(fieldType) || ((fieldTypeGeneric != null) && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric)))) && m.getReturnType().equals(java.lang.Void.TYPE)) {\n                    if (hasSetter) {\n                        throw new java.lang.IllegalStateException(\"Detected more than one setter\");\n                    }\n                    hasSetter = true;\n                }\n            }\n            if (hasGetter && hasSetter) {\n                return true;\n            } else {\n                if (!hasGetter) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Class \" + clazz) + \" does not contain a getter for field \") + f.getName());\n                }\n                if (!hasSetter) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Class \" + clazz) + \" does not contain a setter for field \") + f.getName());\n                }\n                return false;\n            }\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    protected <OUT, IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> analyzePojo(java.lang.Class<OUT> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.ParameterizedType parameterizedType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (parameterizedType != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(typeHierarchy, parameterizedType, java.lang.Object.class);\n        } else if (typeHierarchy.size() <= 1) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(typeHierarchy, clazz, java.lang.Object.class);\n        }\n        java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz);\n        if (fields.size() == 0) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"No fields detected for class \" + clazz) + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        java.util.List<org.apache.flink.api.java.typeutils.PojoField> pojoFields = new java.util.ArrayList<org.apache.flink.api.java.typeutils.PojoField>();\n        for (java.lang.reflect.Field field : fields) {\n            java.lang.reflect.Type fieldType = field.getGenericType();\n            if (!isValidPojoField(field, clazz, typeHierarchy)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" is not a valid POJO type\");\n                return null;\n            }\n            try {\n                java.util.ArrayList<java.lang.reflect.Type> fieldTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                fieldTypeHierarchy.add(fieldType);\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> ti = createTypeInfoWithTypeHierarchy(fieldTypeHierarchy, fieldType, in1Type, in2Type);\n                pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, ti));\n            } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n                java.lang.Class<?> genericClass = java.lang.Object.class;\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(fieldType)) {\n                    genericClass = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(fieldType);\n                }\n                pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(((java.lang.Class<OUT>) (genericClass)))));\n            }\n        }\n        org.apache.flink.api.common.typeutils.CompositeType<OUT> pojoType = new org.apache.flink.api.java.typeutils.PojoTypeInfo<OUT>(clazz, pojoFields);\n        java.util.List<java.lang.reflect.Method> methods = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredMethods(clazz);\n        for (java.lang.reflect.Method method : methods) {\n            if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" contains custom serialization methods we do not call.\");\n                return null;\n            }\n        }\n        try {\n            clazz.getDeclaredConstructor();\n        } catch (java.lang.NoSuchMethodException e) {\n            if (clazz.isInterface() || java.lang.reflect.Modifier.isAbstract(clazz.getModifiers())) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info(((\"Class \" + clazz) + \" is abstract or an interface, having a concrete \") + \"type can increase performance.\");\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" must have a default constructor to be used as a POJO.\");\n                return null;\n            }\n        }\n        return pojoType;\n    }\n\n    public static java.util.List<java.lang.reflect.Field> getAllDeclaredFields(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Field> result = new java.util.ArrayList<java.lang.reflect.Field>();\n        while (clazz != null) {\n            java.lang.reflect.Field[] fields = clazz.getDeclaredFields();\n            for (java.lang.reflect.Field field : fields) {\n                if (java.lang.reflect.Modifier.isTransient(field.getModifiers()) || java.lang.reflect.Modifier.isStatic(field.getModifiers())) {\n                    continue;\n                }\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.hasFieldWithSameName(field.getName(), result)) {\n                    throw new java.lang.RuntimeException(((((\"The field \" + field) + \" is already contained in the hierarchy of the class \") + clazz) + \".\") + \"Please use unique field names through your classes hierarchy\");\n                }\n                result.add(field);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static java.lang.reflect.Field getDeclaredField(java.lang.Class<?> clazz, java.lang.String name) {\n        for (java.lang.reflect.Field field : org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz)) {\n            if (field.getName().equals(name)) {\n                return field;\n            }\n        }\n        return null;\n    }\n\n    private static boolean hasFieldWithSameName(java.lang.String name, java.util.List<java.lang.reflect.Field> fields) {\n        for (java.lang.reflect.Field field : fields) {\n            if (name.equals(field.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static java.util.List<java.lang.reflect.Method> getAllDeclaredMethods(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Method> result = new java.util.ArrayList<java.lang.reflect.Method>();\n        while (clazz != null) {\n            java.lang.reflect.Method[] methods = clazz.getDeclaredMethods();\n            for (java.lang.reflect.Method method : methods) {\n                result.add(method);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static java.lang.Class<?> typeToClass(java.lang.reflect.Type t) {\n        if (t instanceof java.lang.Class) {\n            return ((java.lang.Class<?>) (t));\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()));\n        }\n        throw new java.lang.IllegalArgumentException(\"Cannot convert type to class\");\n    }\n\n    public static boolean isClassType(java.lang.reflect.Type t) {\n        return (t instanceof java.lang.Class<?>) || (t instanceof java.lang.reflect.ParameterizedType);\n    }\n\n    private static boolean sameTypeVars(java.lang.reflect.Type t1, java.lang.reflect.Type t2) {\n        if ((!(t1 instanceof java.lang.reflect.TypeVariable)) || (!(t2 instanceof java.lang.reflect.TypeVariable))) {\n            return false;\n        }\n        return ((java.lang.reflect.TypeVariable<?>) (t1)).getName().equals(((java.lang.reflect.TypeVariable<?>) (t2)).getName()) && ((java.lang.reflect.TypeVariable<?>) (t1)).getGenericDeclaration().equals(((java.lang.reflect.TypeVariable<?>) (t2)).getGenericDeclaration());\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> getTypeOfPojoField(org.apache.flink.api.common.typeinfo.TypeInformation<?> pojoInfo, java.lang.reflect.Field field) {\n        for (int j = 0; j < pojoInfo.getArity(); j++) {\n            org.apache.flink.api.java.typeutils.PojoField pf = ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (pojoInfo)).getPojoFieldAt(j);\n            if (pf.field.getName().equals(field.getName())) {\n                return pf.type;\n            }\n        }\n        return null;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForObject(X value) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForObject(value);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForObject(X value) {\n        com.google.common.base.Preconditions.checkNotNull(value);\n        if (value instanceof org.apache.flink.api.java.tuple.Tuple) {\n            org.apache.flink.api.java.tuple.Tuple t = ((org.apache.flink.api.java.tuple.Tuple) (value));\n            int numFields = t.getArity();\n            if (numFields != countFieldsInClass(value.getClass())) {\n                return analyzePojo(((java.lang.Class<X>) (value.getClass())), new java.util.ArrayList<java.lang.reflect.Type>(), null, null, null);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] infos = new org.apache.flink.api.common.typeinfo.TypeInformation[numFields];\n            for (int i = 0; i < numFields; i++) {\n                java.lang.Object field = t.getField(i);\n                if (field == null) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Automatic type extraction is not possible on candidates with null values. \" + \"Please specify the types directly.\");\n                }\n                infos[i] = privateGetForObject(field);\n            }\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (new org.apache.flink.api.java.typeutils.TupleTypeInfo(value.getClass(), infos)));\n        } else {\n            return privateGetForClass(((java.lang.Class<X>) (value.getClass())), new java.util.ArrayList<java.lang.reflect.Type>());\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Constructor"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "alreadySeen.contains(clazz)",
            "src_parent": "if (alreadySeen.contains(clazz)) {\n    return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n}",
            "src_parent_type": "If",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Try",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "alreadySeen.add(clazz)",
            "src_parent": "{\n    com.google.common.base.Preconditions.checkNotNull(clazz);\n    if (clazz.equals(java.lang.Object.class)) {\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n    }\n    if (clazz.isArray()) {\n        org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo.getInfoFor(clazz);\n        if (primitiveArrayInfo != null) {\n            return primitiveArrayInfo;\n        }\n        org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<OUT, ?> basicArrayInfo = org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo.getInfoFor(clazz);\n        if (basicArrayInfo != null) {\n            return basicArrayInfo;\n        } else {\n            return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(clazz);\n        }\n    }\n    if (org.apache.hadoop.io.Writable.class.isAssignableFrom(clazz) && (!org.apache.hadoop.io.Writable.class.equals(clazz))) {\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.WritableTypeInfo.getWritableTypeInfo(((java.lang.Class<? extends org.apache.hadoop.io.Writable>) (clazz)))));\n    }\n    org.apache.flink.api.common.typeinfo.TypeInformation<OUT> basicTypeInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(clazz);\n    if (basicTypeInfo != null) {\n        return basicTypeInfo;\n    }\n    if (org.apache.flink.types.Value.class.isAssignableFrom(clazz)) {\n        java.lang.Class<? extends org.apache.flink.types.Value> valueClass = clazz.asSubclass(org.apache.flink.types.Value.class);\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(valueClass)));\n    }\n    if (org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(clazz)) {\n        throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n    }\n    if (java.lang.Enum.class.isAssignableFrom(clazz)) {\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.EnumTypeInfo(clazz)));\n    }\n    if (org.apache.avro.specific.SpecificRecordBase.class.isAssignableFrom(clazz)) {\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.AvroTypeInfo(clazz)));\n    }\n    if (alreadySeen.contains(clazz)) {\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n    }\n    alreadySeen.add(clazz);\n    if (java.lang.reflect.Modifier.isInterface(clazz.getModifiers())) {\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n    }\n    if (clazz.equals(java.lang.Class.class)) {\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n    }\n    try {\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> pojoType = analyzePojo(clazz, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\n        if (pojoType != null) {\n            return pojoType;\n        }\n    } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.LOG.isDebugEnabled()) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Unable to handle type \" + clazz) + \" as POJO. Message: \") + e.getMessage(), e);\n        }\n    }\n    return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "protected TypeExtractor() {\n}",
            "src_parent": "public class TypeExtractor {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.flink.api.java.typeutils.TypeExtractor.class);\n\n    protected TypeExtractor() {\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getMapReturnTypes(mapInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapInterface)), org.apache.flink.api.common.functions.MapFunction.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFlatMapReturnTypes(flatMapInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (flatMapInterface)), org.apache.flink.api.common.functions.FlatMapFunction.class, false, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFoldReturnTypes(org.apache.flink.api.common.functions.FoldFunction<IN, OUT> foldInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFoldReturnTypes(foldInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFoldReturnTypes(org.apache.flink.api.common.functions.FoldFunction<IN, OUT> foldInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (foldInterface)), org.apache.flink.api.common.functions.FoldFunction.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getMapPartitionReturnTypes(mapPartitionInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapPartitionInterface)), org.apache.flink.api.common.functions.MapPartitionFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getGroupReduceReturnTypes(groupReduceInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (groupReduceInterface)), org.apache.flink.api.common.functions.GroupReduceFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupCombineReturnTypes(org.apache.flink.api.common.functions.GroupCombineFunction<IN, OUT> combineInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getGroupCombineReturnTypes(combineInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupCombineReturnTypes(org.apache.flink.api.common.functions.GroupCombineFunction<IN, OUT> combineInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (combineInterface)), org.apache.flink.api.common.functions.GroupCombineFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFlatJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.FlatJoinFunction.class, false, true, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.JoinFunction.class, false, false, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getCoGroupReturnTypes(coGroupInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (coGroupInterface)), org.apache.flink.api.common.functions.CoGroupFunction.class, true, true, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getCrossReturnTypes(crossInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (crossInterface)), org.apache.flink.api.common.functions.CrossFunction.class, false, false, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getKeySelectorTypes(selectorInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (selectorInterface)), org.apache.flink.api.java.functions.KeySelector.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <T> org.apache.flink.api.common.typeinfo.TypeInformation<T> getPartitionerTypes(org.apache.flink.api.common.functions.Partitioner<T> partitioner) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getPartitionerTypes(partitioner, null, false);\n    }\n\n    public static <T> org.apache.flink.api.common.typeinfo.TypeInformation<T> getPartitionerTypes(org.apache.flink.api.common.functions.Partitioner<T> partitioner, java.lang.String functionName, boolean allowMissing) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.functions.Partitioner.class, partitioner.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN> org.apache.flink.api.common.typeinfo.TypeInformation<IN> getInputFormatTypes(org.apache.flink.api.common.io.InputFormat<IN, ?> inputFormatInterface) {\n        if (inputFormatInterface instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n            return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<IN>) (inputFormatInterface)).getProducedType();\n        }\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.io.InputFormat.class, inputFormatInterface.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getUnaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterable, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        try {\n            final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n            if (m != null) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n                final int paramLen = m.getGenericParameterTypes().length - 1;\n                final java.lang.reflect.Type input = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterable ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input) : input, inType);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), inType, null);\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, inType);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null);\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (allowMissing) {\n                return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.MissingTypeInfo(functionName != null ? functionName : function.toString(), e)));\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getBinaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterables, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        try {\n            final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n            if (m != null) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n                final int paramLen = m.getGenericParameterTypes().length - 1;\n                final java.lang.reflect.Type input1 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1];\n                final java.lang.reflect.Type input2 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input1) : input1, in1Type);\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input2) : input2, in2Type);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), in1Type, in2Type);\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, in1Type);\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 1, in2Type);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type);\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (allowMissing) {\n                return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.MissingTypeInfo(functionName != null ? functionName : function.toString(), e)));\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    public static org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfo(java.lang.reflect.Type t) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> ti = new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(t);\n        if (ti == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not extract type information.\");\n        }\n        return ti;\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> ti = new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, clazz, returnParamPos, in1Type, in2Type);\n        if (ti == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not extract type information.\");\n        }\n        return ti;\n    }\n\n    private org.apache.flink.api.common.typeinfo.TypeInformation<?> privateCreateTypeInfo(java.lang.reflect.Type t) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        typeHierarchy.add(t);\n        return createTypeInfoWithTypeHierarchy(typeHierarchy, t, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type returnType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo;\n        if (returnType instanceof java.lang.reflect.TypeVariable<?>) {\n            typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)));\n            if (typeInfo != null) {\n                return typeInfo;\n            }\n        }\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.reflect.Type returnType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfoWithTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t))) {\n            java.lang.reflect.Type curT = t;\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n            }\n            while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                typeHierarchy.add(curT);\n                curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n            } \n            if (curT instanceof java.lang.Class<?>) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n            }\n            typeHierarchy.add(curT);\n            java.lang.reflect.ParameterizedType tupleChild = ((java.lang.reflect.ParameterizedType) (curT));\n            java.lang.reflect.Type[] subtypes = new java.lang.reflect.Type[tupleChild.getActualTypeArguments().length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (tupleChild.getActualTypeArguments()[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    subtypes[i] = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleChild.getActualTypeArguments()[i])));\n                } else {\n                    subtypes[i] = tupleChild.getActualTypeArguments()[i];\n                }\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] tupleSubTypes = new org.apache.flink.api.common.typeinfo.TypeInformation<?>[subtypes.length];\n            for (int i = 0; i < subtypes.length; i++) {\n                java.util.ArrayList<java.lang.reflect.Type> subTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                subTypeHierarchy.add(subtypes[i]);\n                if (subtypes[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    tupleSubTypes[i] = createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), subTypeHierarchy, in1Type, in2Type);\n                    if (tupleSubTypes[i] == null) {\n                        throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                    }\n                } else {\n                    tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type);\n                }\n            }\n            java.lang.Class<?> tAsClass = null;\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t)) {\n                tAsClass = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t);\n            }\n            com.google.common.base.Preconditions.checkNotNull(tAsClass, \"t has a unexpected type\");\n            int fieldCount = countFieldsInClass(tAsClass);\n            if (fieldCount != tupleSubTypes.length) {\n                if (t instanceof java.lang.reflect.ParameterizedType) {\n                    return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (analyzePojo(tAsClass, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), ((java.lang.reflect.ParameterizedType) (t)), in1Type, in2Type)));\n                } else {\n                    return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (analyzePojo(tAsClass, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), null, in1Type, in2Type)));\n                }\n            }\n            return new org.apache.flink.api.java.typeutils.TupleTypeInfo(tAsClass, tupleSubTypes);\n        } else if (t instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.Type typeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (t)));\n            if (!(typeVar instanceof java.lang.reflect.TypeVariable)) {\n                return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n            } else {\n                org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)));\n                if (typeInfo != null) {\n                    return typeInfo;\n                } else {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (t)).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (t)).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            }\n        } else if (t instanceof java.lang.reflect.GenericArrayType) {\n            java.lang.reflect.GenericArrayType genericArray = ((java.lang.reflect.GenericArrayType) (t));\n            java.lang.reflect.Type componentType = genericArray.getGenericComponentType();\n            if (componentType instanceof java.lang.Class) {\n                java.lang.Class<?> componentClass = ((java.lang.Class<?>) (componentType));\n                java.lang.String className;\n                if (componentClass.isPrimitive()) {\n                    className = org.apache.flink.api.java.typeutils.TypeExtractor.encodePrimitiveClass(componentClass);\n                } else {\n                    className = (\"L\" + componentClass.getName()) + \";\";\n                }\n                java.lang.Class<OUT> classArray;\n                try {\n                    classArray = ((java.lang.Class<OUT>) (java.lang.Class.forName(\"[\" + className)));\n                } catch (java.lang.ClassNotFoundException e) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n                }\n                return org.apache.flink.api.java.typeutils.TypeExtractor.getForClass(classArray);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n            return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (privateGetForClass(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t), typeHierarchy, ((java.lang.reflect.ParameterizedType) (t)), in1Type, in2Type)));\n        } else if (t instanceof java.lang.Class) {\n            return privateGetForClass(((java.lang.Class<OUT>) (t)), typeHierarchy);\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type Information could not be created.\");\n    }\n\n    private <IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInputs(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1TypeInfo, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2TypeInfo) {\n        java.lang.reflect.Type matReturnTypeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n        if (!(matReturnTypeVar instanceof java.lang.reflect.TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n        } else {\n            returnTypeVar = ((java.lang.reflect.TypeVariable<?>) (matReturnTypeVar));\n        }\n        if ((in1TypeInfo == null) && (in2TypeInfo == null)) {\n            return null;\n        }\n        java.util.ArrayList<java.lang.reflect.Type> inputTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        for (java.lang.reflect.Type t : returnTypeHierarchy) {\n            if ((org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t) && org.apache.flink.api.common.functions.Function.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t))) && (org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t) != org.apache.flink.api.common.functions.Function.class)) {\n                inputTypeHierarchy.add(t);\n            } else {\n                break;\n            }\n        }\n        java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (inputTypeHierarchy.get(inputTypeHierarchy.size() - 1)));\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (in1TypeInfo != null) {\n            java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n            info = createTypeInfoFromInput(returnTypeVar, new java.util.ArrayList<java.lang.reflect.Type>(inputTypeHierarchy), in1Type, in1TypeInfo);\n        }\n        if ((info == null) && (in2TypeInfo != null)) {\n            java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n            info = createTypeInfoFromInput(returnTypeVar, new java.util.ArrayList<java.lang.reflect.Type>(inputTypeHierarchy), in2Type, in2TypeInfo);\n        }\n        if (info != null) {\n            return info;\n        }\n        return null;\n    }\n\n    private <IN1> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInput(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> inputTypeHierarchy, java.lang.reflect.Type inType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> inTypeInfo) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (inType instanceof java.lang.reflect.TypeVariable) {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(inputTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (inType)));\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo, inputTypeHierarchy);\n        } else if (inType instanceof java.lang.reflect.GenericArrayType) {\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = null;\n            if (inTypeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (inTypeInfo)).getComponentInfo();\n            } else if (inTypeInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                componentInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType());\n            } else if (inTypeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (inTypeInfo)).getComponentInfo();\n            }\n            info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((java.lang.reflect.GenericArrayType) (inType)).getGenericComponentType(), componentInfo);\n        } else if (((inTypeInfo instanceof org.apache.flink.api.java.typeutils.TupleTypeInfo) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(inType)) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType))) {\n            java.lang.reflect.ParameterizedType tupleBaseClass;\n            while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(inType) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                inputTypeHierarchy.add(inType);\n                inType = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType).getGenericSuperclass();\n            } \n            inputTypeHierarchy.add(inType);\n            tupleBaseClass = ((java.lang.reflect.ParameterizedType) (inType));\n            java.lang.reflect.Type[] tupleElements = tupleBaseClass.getActualTypeArguments();\n            for (int i = 0; i < tupleElements.length; i++) {\n                info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (inTypeInfo)).getTypeAt(i));\n                if (info != null) {\n                    break;\n                }\n            }\n        } else if (inTypeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(inputTypeHierarchy, inType, java.lang.Object.class);\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo, inputTypeHierarchy);\n        }\n        return info;\n    }\n\n    public static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int pos) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, null, clazz, pos);\n    }\n\n    private static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.Class<?> clazz, int pos) {\n        if (typeHierarchy != null) {\n            typeHierarchy.add(clazz);\n        }\n        java.lang.reflect.Type[] interfaceTypes = clazz.getGenericInterfaces();\n        for (java.lang.reflect.Type t : interfaceTypes) {\n            java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n            if (parameter != null) {\n                return parameter;\n            }\n        }\n        java.lang.reflect.Type t = clazz.getGenericSuperclass();\n        java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n        if (parameter != null) {\n            return parameter;\n        }\n        throw new java.lang.IllegalArgumentException(((\"The types of the interface \" + baseClass.getName()) + \" could not be inferred. \") + \"Support for synthetic interfaces, lambdas, and generic types is limited at this point.\");\n    }\n\n    private static java.lang.reflect.Type getParameterTypeFromGenericType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, int pos) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.equals(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            java.lang.reflect.ParameterizedType baseClassChild = ((java.lang.reflect.ParameterizedType) (t));\n            return baseClassChild.getActualTypeArguments()[pos];\n        } else if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), pos);\n        } else if ((t instanceof java.lang.Class<?>) && baseClass.isAssignableFrom(((java.lang.Class<?>) (t)))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (t)), pos);\n        }\n        return null;\n    }\n\n    private static void validateInputType(java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, t, inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    private static void validateInputType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int inputParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<?> inTypeInfo) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type inType;\n        try {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, inputParamPos);\n        } catch (java.lang.IllegalArgumentException e) {\n            return;\n        }\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, inType, inTypeInfo);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static void validateInfo(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> typeInfo) {\n        if (type == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. Type is null.\");\n        }\n        if (typeInfo == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\n        }\n        if (!(type instanceof java.lang.reflect.TypeVariable<?>)) {\n            if (typeInfo.isBasicType()) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual;\n                if ((!(type instanceof java.lang.Class<?>)) || ((actual = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(((java.lang.Class<?>) (type)))) == null)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Basic type expected.\");\n                }\n                if (!typeInfo.equals(actual)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Basic type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo.isTupleType()) {\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple type expected.\");\n                }\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Concrete subclass of Tuple expected.\");\n                }\n                while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                    typeHierarchy.add(type);\n                    type = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getGenericSuperclass();\n                } \n                if (type instanceof java.lang.Class<?>) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Parameterized Tuple type expected.\");\n                }\n                org.apache.flink.api.java.typeutils.TupleTypeInfo<?> tti = ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo));\n                java.lang.reflect.Type[] subTypes = ((java.lang.reflect.ParameterizedType) (type)).getActualTypeArguments();\n                if (subTypes.length != tti.getArity()) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Tuple arity '\" + tti.getArity()) + \"' expected but was '\") + subTypes.length) + \"'.\");\n                }\n                for (int i = 0; i < subTypes.length; i++) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subTypes[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo)).getTypeAt(i));\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.hadoop.io.Writable.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Writable type expected.\");\n                }\n                java.lang.Class<?> clazz;\n                if (((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass() != (clazz = ((java.lang.Class<?>) (type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Writable type '\" + ((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                java.lang.reflect.Type component;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                if (!((component instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (component)).isPrimitive())) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Primitive component expected.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) {\n                java.lang.reflect.Type component;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) {\n                if ((!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray())) && (!(type instanceof java.lang.reflect.GenericArrayType))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object array type expected.\");\n                }\n                java.lang.reflect.Type component;\n                if (type instanceof java.lang.Class<?>) {\n                    component = ((java.lang.Class<?>) (type)).getComponentType();\n                } else {\n                    component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType();\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.flink.types.Value.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Value type expected.\");\n                }\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual;\n                if (!((org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) (typeInfo)).equals(actual = org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(((java.lang.Class<? extends org.apache.flink.types.Value>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Value type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n                java.lang.Class<?> clazz = null;\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"POJO type '\" + ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.EnumTypeInfo) {\n                if (!((type instanceof java.lang.Class<?>) && java.lang.Enum.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Enum type expected.\");\n                }\n                if (!(typeInfo.getTypeClass() == type)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Enum type '\" + typeInfo.getTypeClass().getCanonicalName()) + \"' expected but was '\") + org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) {\n                java.lang.Class<?> clazz = null;\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Generic object type '\" + ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            }\n        } else {\n            type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type)));\n            if (!(type instanceof java.lang.reflect.TypeVariable)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, type, typeInfo);\n            }\n        }\n    }\n\n    private static int countTypeInHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type) {\n        int count = 0;\n        for (java.lang.reflect.Type t : typeHierarchy) {\n            if ((t == type) || (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (t == org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type)))) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private static java.lang.reflect.Type getTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type curT, java.lang.Class<?> stopAtClass) {\n        if (((typeHierarchy.size() > 0) && (typeHierarchy.get(0) == curT)) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT)) {\n            curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n        }\n        while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).equals(stopAtClass))) {\n            typeHierarchy.add(curT);\n            curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n            if (curT == null) {\n                break;\n            }\n        } \n        return curT;\n    }\n\n    private int countFieldsInClass(java.lang.Class<?> clazz) {\n        int fieldCount = 0;\n        for (java.lang.reflect.Field field : clazz.getFields()) {\n            if ((!java.lang.reflect.Modifier.isStatic(field.getModifiers())) && (!java.lang.reflect.Modifier.isTransient(field.getModifiers()))) {\n                fieldCount++;\n            }\n        }\n        return fieldCount;\n    }\n\n    private static java.lang.reflect.Type removeGenericWrapper(java.lang.reflect.Type t) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && (org.apache.flink.util.Collector.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t)) || java.lang.Iterable.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t)))) {\n            return ((java.lang.reflect.ParameterizedType) (t)).getActualTypeArguments()[0];\n        }\n        return t;\n    }\n\n    private static void validateLambdaGenericParameters(java.lang.reflect.Method m) {\n        for (java.lang.reflect.Type t : m.getGenericParameterTypes()) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(t);\n        }\n        org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(m.getGenericReturnType());\n    }\n\n    private static void validateLambdaGenericParameter(java.lang.reflect.Type t) {\n        if (!(t instanceof java.lang.Class)) {\n            return;\n        }\n        final java.lang.Class<?> clazz = ((java.lang.Class<?>) (t));\n        if (clazz.getTypeParameters().length > 0) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(((((\"The generic type parameters of '\" + clazz.getSimpleName()) + \"\\' are missing. \\n\") + \"It seems that your compiler has not stored them into the .class file. \\n\") + \"Currently, only the Eclipse JDT compiler preserves the type information necessary to use the lambdas feature type-safely. \\n\") + \"See the documentation for more information about how to compile jobs containing lambda expressions.\");\n        }\n    }\n\n    private static java.lang.String encodePrimitiveClass(java.lang.Class<?> primitiveClass) {\n        if (primitiveClass == boolean.class) {\n            return \"Z\";\n        } else if (primitiveClass == byte.class) {\n            return \"B\";\n        } else if (primitiveClass == char.class) {\n            return \"C\";\n        } else if (primitiveClass == double.class) {\n            return \"D\";\n        } else if (primitiveClass == float.class) {\n            return \"F\";\n        } else if (primitiveClass == int.class) {\n            return \"I\";\n        } else if (primitiveClass == long.class) {\n            return \"J\";\n        } else if (primitiveClass == short.class) {\n            return \"S\";\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException();\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> findCorrespondingInfo(java.lang.reflect.TypeVariable<?> typeVar, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> corrInfo, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(type, typeVar)) {\n            return corrInfo;\n        } else if ((type instanceof java.lang.reflect.TypeVariable) && org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type))), typeVar)) {\n            return corrInfo;\n        } else if (type instanceof java.lang.reflect.GenericArrayType) {\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = null;\n            if (corrInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (corrInfo)).getComponentInfo();\n            } else if (corrInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                componentInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(corrInfo.getTypeClass().getComponentType());\n            } else if (corrInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (corrInfo)).getComponentInfo();\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType(), componentInfo, typeHierarchy);\n            if (info != null) {\n                return info;\n            }\n        } else if (((corrInfo instanceof org.apache.flink.api.java.typeutils.TupleTypeInfo) && (type instanceof java.lang.reflect.ParameterizedType)) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))) {\n            java.lang.reflect.ParameterizedType tuple = ((java.lang.reflect.ParameterizedType) (type));\n            java.lang.reflect.Type[] args = tuple.getActualTypeArguments();\n            for (int i = 0; i < args.length; i++) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, args[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (corrInfo)).getTypeAt(i), typeHierarchy);\n                if (info != null) {\n                    return info;\n                }\n            }\n        } else if ((corrInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type)) {\n            java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type));\n            for (java.lang.reflect.Field field : fields) {\n                java.lang.reflect.Type fieldType = field.getGenericType();\n                if ((fieldType instanceof java.lang.reflect.TypeVariable) && org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(typeVar, org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (fieldType))))) {\n                    return org.apache.flink.api.java.typeutils.TypeExtractor.getTypeOfPojoField(corrInfo, field);\n                } else if ((fieldType instanceof java.lang.reflect.ParameterizedType) || (fieldType instanceof java.lang.reflect.GenericArrayType)) {\n                    java.util.ArrayList<java.lang.reflect.Type> typeHierarchyWithFieldType = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                    typeHierarchyWithFieldType.add(fieldType);\n                    org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, fieldType, org.apache.flink.api.java.typeutils.TypeExtractor.getTypeOfPojoField(corrInfo, field), typeHierarchyWithFieldType);\n                    if (info != null) {\n                        return info;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private static java.lang.reflect.Type materializeTypeVariable(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.TypeVariable<?> typeVar) {\n        java.lang.reflect.TypeVariable<?> inTypeTypeVar = typeVar;\n        for (int i = typeHierarchy.size() - 1; i >= 0; i--) {\n            java.lang.reflect.Type curT = typeHierarchy.get(i);\n            if (curT instanceof java.lang.reflect.ParameterizedType) {\n                java.lang.Class<?> rawType = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType()));\n                for (int paramIndex = 0; paramIndex < rawType.getTypeParameters().length; paramIndex++) {\n                    java.lang.reflect.TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex];\n                    if (org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(curVarOfCurT, inTypeTypeVar)) {\n                        java.lang.reflect.Type curVarType = ((java.lang.reflect.ParameterizedType) (curT)).getActualTypeArguments()[paramIndex];\n                        if (curVarType instanceof java.lang.reflect.TypeVariable<?>) {\n                            inTypeTypeVar = ((java.lang.reflect.TypeVariable<?>) (curVarType));\n                        } else {\n                            return curVarType;\n                        }\n                    }\n                }\n            }\n        }\n        return inTypeTypeVar;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForClass(java.lang.Class<X> clazz) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForClass(clazz, new java.util.ArrayList<java.lang.reflect.Type>());\n    }\n\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForClass(java.lang.Class<X> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        return privateGetForClass(clazz, typeHierarchy, null, null, null);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <OUT, IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateGetForClass(java.lang.Class<OUT> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.ParameterizedType parameterizedType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        com.google.common.base.Preconditions.checkNotNull(clazz);\n        if (clazz.equals(java.lang.Object.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (clazz.isArray()) {\n            org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo.getInfoFor(clazz);\n            if (primitiveArrayInfo != null) {\n                return primitiveArrayInfo;\n            }\n            org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<OUT, ?> basicArrayInfo = org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo.getInfoFor(clazz);\n            if (basicArrayInfo != null) {\n                return basicArrayInfo;\n            } else {\n                return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(clazz);\n            }\n        }\n        if (org.apache.hadoop.io.Writable.class.isAssignableFrom(clazz) && (!org.apache.hadoop.io.Writable.class.equals(clazz))) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.WritableTypeInfo.getWritableTypeInfo(((java.lang.Class<? extends org.apache.hadoop.io.Writable>) (clazz)))));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> basicTypeInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(clazz);\n        if (basicTypeInfo != null) {\n            return basicTypeInfo;\n        }\n        if (org.apache.flink.types.Value.class.isAssignableFrom(clazz)) {\n            java.lang.Class<? extends org.apache.flink.types.Value> valueClass = clazz.asSubclass(org.apache.flink.types.Value.class);\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(valueClass)));\n        }\n        if (org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(clazz)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n        }\n        if (java.lang.Enum.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.EnumTypeInfo(clazz)));\n        }\n        if (org.apache.avro.specific.SpecificRecordBase.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.AvroTypeInfo(clazz)));\n        }\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.countTypeInHierarchy(typeHierarchy, clazz) > 1) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (java.lang.reflect.Modifier.isInterface(clazz.getModifiers())) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (clazz.equals(java.lang.Class.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        try {\n            org.apache.flink.api.common.typeinfo.TypeInformation<OUT> pojoType = analyzePojo(clazz, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\n            if (pojoType != null) {\n                return pojoType;\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.LOG.isDebugEnabled()) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Unable to handle type \" + clazz) + \" as POJO. Message: \") + e.getMessage(), e);\n            }\n        }\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n    }\n\n    private boolean isValidPojoField(java.lang.reflect.Field f, java.lang.Class<?> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        if (java.lang.reflect.Modifier.isPublic(f.getModifiers())) {\n            return true;\n        } else {\n            boolean hasGetter = false;\n            boolean hasSetter = false;\n            final java.lang.String fieldNameLow = f.getName().toLowerCase();\n            java.lang.reflect.Type fieldType = f.getGenericType();\n            java.lang.reflect.TypeVariable<?> fieldTypeGeneric = null;\n            if (fieldType instanceof java.lang.reflect.TypeVariable) {\n                fieldTypeGeneric = ((java.lang.reflect.TypeVariable<?>) (fieldType));\n                fieldType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (fieldType)));\n            }\n            for (java.lang.reflect.Method m : clazz.getMethods()) {\n                if ((((m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow)) || m.getName().toLowerCase().equals(fieldNameLow)) && (m.getParameterTypes().length == 0)) && (m.getGenericReturnType().equals(fieldType) || ((fieldTypeGeneric != null) && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                    if (hasGetter) {\n                        throw new java.lang.IllegalStateException(\"Detected more than one getter\");\n                    }\n                    hasGetter = true;\n                }\n                if ((((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && (m.getParameterTypes().length == 1)) && (m.getGenericParameterTypes()[0].equals(fieldType) || ((fieldTypeGeneric != null) && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric)))) && m.getReturnType().equals(java.lang.Void.TYPE)) {\n                    if (hasSetter) {\n                        throw new java.lang.IllegalStateException(\"Detected more than one setter\");\n                    }\n                    hasSetter = true;\n                }\n            }\n            if (hasGetter && hasSetter) {\n                return true;\n            } else {\n                if (!hasGetter) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Class \" + clazz) + \" does not contain a getter for field \") + f.getName());\n                }\n                if (!hasSetter) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Class \" + clazz) + \" does not contain a setter for field \") + f.getName());\n                }\n                return false;\n            }\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    protected <OUT, IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> analyzePojo(java.lang.Class<OUT> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.ParameterizedType parameterizedType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (parameterizedType != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(typeHierarchy, parameterizedType, java.lang.Object.class);\n        } else if (typeHierarchy.size() <= 1) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(typeHierarchy, clazz, java.lang.Object.class);\n        }\n        java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz);\n        if (fields.size() == 0) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"No fields detected for class \" + clazz) + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        java.util.List<org.apache.flink.api.java.typeutils.PojoField> pojoFields = new java.util.ArrayList<org.apache.flink.api.java.typeutils.PojoField>();\n        for (java.lang.reflect.Field field : fields) {\n            java.lang.reflect.Type fieldType = field.getGenericType();\n            if (!isValidPojoField(field, clazz, typeHierarchy)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" is not a valid POJO type\");\n                return null;\n            }\n            try {\n                java.util.ArrayList<java.lang.reflect.Type> fieldTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                fieldTypeHierarchy.add(fieldType);\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> ti = createTypeInfoWithTypeHierarchy(fieldTypeHierarchy, fieldType, in1Type, in2Type);\n                pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, ti));\n            } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n                java.lang.Class<?> genericClass = java.lang.Object.class;\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(fieldType)) {\n                    genericClass = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(fieldType);\n                }\n                pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(((java.lang.Class<OUT>) (genericClass)))));\n            }\n        }\n        org.apache.flink.api.common.typeutils.CompositeType<OUT> pojoType = new org.apache.flink.api.java.typeutils.PojoTypeInfo<OUT>(clazz, pojoFields);\n        java.util.List<java.lang.reflect.Method> methods = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredMethods(clazz);\n        for (java.lang.reflect.Method method : methods) {\n            if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" contains custom serialization methods we do not call.\");\n                return null;\n            }\n        }\n        try {\n            clazz.getDeclaredConstructor();\n        } catch (java.lang.NoSuchMethodException e) {\n            if (clazz.isInterface() || java.lang.reflect.Modifier.isAbstract(clazz.getModifiers())) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info(((\"Class \" + clazz) + \" is abstract or an interface, having a concrete \") + \"type can increase performance.\");\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" must have a default constructor to be used as a POJO.\");\n                return null;\n            }\n        }\n        return pojoType;\n    }\n\n    public static java.util.List<java.lang.reflect.Field> getAllDeclaredFields(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Field> result = new java.util.ArrayList<java.lang.reflect.Field>();\n        while (clazz != null) {\n            java.lang.reflect.Field[] fields = clazz.getDeclaredFields();\n            for (java.lang.reflect.Field field : fields) {\n                if (java.lang.reflect.Modifier.isTransient(field.getModifiers()) || java.lang.reflect.Modifier.isStatic(field.getModifiers())) {\n                    continue;\n                }\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.hasFieldWithSameName(field.getName(), result)) {\n                    throw new java.lang.RuntimeException(((((\"The field \" + field) + \" is already contained in the hierarchy of the class \") + clazz) + \".\") + \"Please use unique field names through your classes hierarchy\");\n                }\n                result.add(field);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static java.lang.reflect.Field getDeclaredField(java.lang.Class<?> clazz, java.lang.String name) {\n        for (java.lang.reflect.Field field : org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz)) {\n            if (field.getName().equals(name)) {\n                return field;\n            }\n        }\n        return null;\n    }\n\n    private static boolean hasFieldWithSameName(java.lang.String name, java.util.List<java.lang.reflect.Field> fields) {\n        for (java.lang.reflect.Field field : fields) {\n            if (name.equals(field.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static java.util.List<java.lang.reflect.Method> getAllDeclaredMethods(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Method> result = new java.util.ArrayList<java.lang.reflect.Method>();\n        while (clazz != null) {\n            java.lang.reflect.Method[] methods = clazz.getDeclaredMethods();\n            for (java.lang.reflect.Method method : methods) {\n                result.add(method);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static java.lang.Class<?> typeToClass(java.lang.reflect.Type t) {\n        if (t instanceof java.lang.Class) {\n            return ((java.lang.Class<?>) (t));\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()));\n        }\n        throw new java.lang.IllegalArgumentException(\"Cannot convert type to class\");\n    }\n\n    public static boolean isClassType(java.lang.reflect.Type t) {\n        return (t instanceof java.lang.Class<?>) || (t instanceof java.lang.reflect.ParameterizedType);\n    }\n\n    private static boolean sameTypeVars(java.lang.reflect.Type t1, java.lang.reflect.Type t2) {\n        if ((!(t1 instanceof java.lang.reflect.TypeVariable)) || (!(t2 instanceof java.lang.reflect.TypeVariable))) {\n            return false;\n        }\n        return ((java.lang.reflect.TypeVariable<?>) (t1)).getName().equals(((java.lang.reflect.TypeVariable<?>) (t2)).getName()) && ((java.lang.reflect.TypeVariable<?>) (t1)).getGenericDeclaration().equals(((java.lang.reflect.TypeVariable<?>) (t2)).getGenericDeclaration());\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> getTypeOfPojoField(org.apache.flink.api.common.typeinfo.TypeInformation<?> pojoInfo, java.lang.reflect.Field field) {\n        for (int j = 0; j < pojoInfo.getArity(); j++) {\n            org.apache.flink.api.java.typeutils.PojoField pf = ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (pojoInfo)).getPojoFieldAt(j);\n            if (pf.field.getName().equals(field.getName())) {\n                return pf.type;\n            }\n        }\n        return null;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForObject(X value) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForObject(value);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForObject(X value) {\n        com.google.common.base.Preconditions.checkNotNull(value);\n        if (value instanceof org.apache.flink.api.java.tuple.Tuple) {\n            org.apache.flink.api.java.tuple.Tuple t = ((org.apache.flink.api.java.tuple.Tuple) (value));\n            int numFields = t.getArity();\n            if (numFields != countFieldsInClass(value.getClass())) {\n                return analyzePojo(((java.lang.Class<X>) (value.getClass())), new java.util.ArrayList<java.lang.reflect.Type>(), null, null, null);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] infos = new org.apache.flink.api.common.typeinfo.TypeInformation[numFields];\n            for (int i = 0; i < numFields; i++) {\n                java.lang.Object field = t.getField(i);\n                if (field == null) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Automatic type extraction is not possible on candidates with null values. \" + \"Please specify the types directly.\");\n                }\n                infos[i] = privateGetForObject(field);\n            }\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (new org.apache.flink.api.java.typeutils.TupleTypeInfo(value.getClass(), infos)));\n        } else {\n            return privateGetForClass(((java.lang.Class<X>) (value.getClass())), new java.util.ArrayList<java.lang.reflect.Type>());\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Constructor"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static int countTypeInHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type) {\n    int count = 0;\n    for (java.lang.reflect.Type t : typeHierarchy) {\n        if ((t == type) || (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (t == org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type)))) {\n            count++;\n        }\n    }\n    return count;\n}",
            "src_parent": "public class TypeExtractor {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.flink.api.java.typeutils.TypeExtractor.class);\n\n    protected TypeExtractor() {\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getMapReturnTypes(mapInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapReturnTypes(org.apache.flink.api.common.functions.MapFunction<IN, OUT> mapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapInterface)), org.apache.flink.api.common.functions.MapFunction.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFlatMapReturnTypes(flatMapInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatMapReturnTypes(org.apache.flink.api.common.functions.FlatMapFunction<IN, OUT> flatMapInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (flatMapInterface)), org.apache.flink.api.common.functions.FlatMapFunction.class, false, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFoldReturnTypes(org.apache.flink.api.common.functions.FoldFunction<IN, OUT> foldInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFoldReturnTypes(foldInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFoldReturnTypes(org.apache.flink.api.common.functions.FoldFunction<IN, OUT> foldInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (foldInterface)), org.apache.flink.api.common.functions.FoldFunction.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getMapPartitionReturnTypes(mapPartitionInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getMapPartitionReturnTypes(org.apache.flink.api.common.functions.MapPartitionFunction<IN, OUT> mapPartitionInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (mapPartitionInterface)), org.apache.flink.api.common.functions.MapPartitionFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getGroupReduceReturnTypes(groupReduceInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupReduceReturnTypes(org.apache.flink.api.common.functions.GroupReduceFunction<IN, OUT> groupReduceInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (groupReduceInterface)), org.apache.flink.api.common.functions.GroupReduceFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupCombineReturnTypes(org.apache.flink.api.common.functions.GroupCombineFunction<IN, OUT> combineInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getGroupCombineReturnTypes(combineInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getGroupCombineReturnTypes(org.apache.flink.api.common.functions.GroupCombineFunction<IN, OUT> combineInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (combineInterface)), org.apache.flink.api.common.functions.GroupCombineFunction.class, true, true, inType, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getFlatJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getFlatJoinReturnTypes(org.apache.flink.api.common.functions.FlatJoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.FlatJoinFunction.class, false, true, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getJoinReturnTypes(joinInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getJoinReturnTypes(org.apache.flink.api.common.functions.JoinFunction<IN1, IN2, OUT> joinInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (joinInterface)), org.apache.flink.api.common.functions.JoinFunction.class, false, false, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getCoGroupReturnTypes(coGroupInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCoGroupReturnTypes(org.apache.flink.api.common.functions.CoGroupFunction<IN1, IN2, OUT> coGroupInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (coGroupInterface)), org.apache.flink.api.common.functions.CoGroupFunction.class, true, true, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getCrossReturnTypes(crossInterface, in1Type, in2Type, null, false);\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getCrossReturnTypes(org.apache.flink.api.common.functions.CrossFunction<IN1, IN2, OUT> crossInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getBinaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (crossInterface)), org.apache.flink.api.common.functions.CrossFunction.class, false, false, in1Type, in2Type, functionName, allowMissing);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getKeySelectorTypes(selectorInterface, inType, null, false);\n    }\n\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getKeySelectorTypes(org.apache.flink.api.java.functions.KeySelector<IN, OUT> selectorInterface, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getUnaryOperatorReturnType(((org.apache.flink.api.common.functions.Function) (selectorInterface)), org.apache.flink.api.java.functions.KeySelector.class, false, false, inType, functionName, allowMissing);\n    }\n\n    public static <T> org.apache.flink.api.common.typeinfo.TypeInformation<T> getPartitionerTypes(org.apache.flink.api.common.functions.Partitioner<T> partitioner) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getPartitionerTypes(partitioner, null, false);\n    }\n\n    public static <T> org.apache.flink.api.common.typeinfo.TypeInformation<T> getPartitionerTypes(org.apache.flink.api.common.functions.Partitioner<T> partitioner, java.lang.String functionName, boolean allowMissing) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.functions.Partitioner.class, partitioner.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN> org.apache.flink.api.common.typeinfo.TypeInformation<IN> getInputFormatTypes(org.apache.flink.api.common.io.InputFormat<IN, ?> inputFormatInterface) {\n        if (inputFormatInterface instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n            return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<IN>) (inputFormatInterface)).getProducedType();\n        }\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(org.apache.flink.api.common.io.InputFormat.class, inputFormatInterface.getClass(), 0, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getUnaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterable, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN> inType, java.lang.String functionName, boolean allowMissing) {\n        try {\n            final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n            if (m != null) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n                final int paramLen = m.getGenericParameterTypes().length - 1;\n                final java.lang.reflect.Type input = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterable ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input) : input, inType);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), inType, null);\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, inType);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 1, inType, null);\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (allowMissing) {\n                return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.MissingTypeInfo(functionName != null ? functionName : function.toString(), e)));\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> getBinaryOperatorReturnType(org.apache.flink.api.common.functions.Function function, java.lang.Class<?> baseClass, boolean hasIterables, boolean hasCollector, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type, java.lang.String functionName, boolean allowMissing) {\n        try {\n            final java.lang.reflect.Method m = org.apache.flink.api.common.functions.util.FunctionUtils.checkAndExtractLambdaMethod(function);\n            if (m != null) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameters(m);\n                final int paramLen = m.getGenericParameterTypes().length - 1;\n                final java.lang.reflect.Type input1 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 2] : m.getGenericParameterTypes()[paramLen - 1];\n                final java.lang.reflect.Type input2 = (hasCollector) ? m.getGenericParameterTypes()[paramLen - 1] : m.getGenericParameterTypes()[paramLen];\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input1) : input1, in1Type);\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(hasIterables ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(input2) : input2, in2Type);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(hasCollector ? org.apache.flink.api.java.typeutils.TypeExtractor.removeGenericWrapper(m.getGenericParameterTypes()[paramLen]) : m.getGenericReturnType(), in1Type, in2Type);\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 0, in1Type);\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInputType(baseClass, function.getClass(), 1, in2Type);\n                if (function instanceof org.apache.flink.api.java.typeutils.ResultTypeQueryable) {\n                    return ((org.apache.flink.api.java.typeutils.ResultTypeQueryable<OUT>) (function)).getProducedType();\n                }\n                return new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, function.getClass(), 2, in1Type, in2Type);\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (allowMissing) {\n                return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.MissingTypeInfo(functionName != null ? functionName : function.toString(), e)));\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    public static org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfo(java.lang.reflect.Type t) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> ti = new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(t);\n        if (ti == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not extract type information.\");\n        }\n        return ti;\n    }\n\n    public static <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> ti = new org.apache.flink.api.java.typeutils.TypeExtractor().privateCreateTypeInfo(baseClass, clazz, returnParamPos, in1Type, in2Type);\n        if (ti == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not extract type information.\");\n        }\n        return ti;\n    }\n\n    private org.apache.flink.api.common.typeinfo.TypeInformation<?> privateCreateTypeInfo(java.lang.reflect.Type t) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        typeHierarchy.add(t);\n        return createTypeInfoWithTypeHierarchy(typeHierarchy, t, null, null);\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int returnParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type returnType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, returnParamPos);\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo;\n        if (returnType instanceof java.lang.reflect.TypeVariable<?>) {\n            typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (returnType)), typeHierarchy, in1Type, in2Type)));\n            if (typeInfo != null) {\n                return typeInfo;\n            }\n        }\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateCreateTypeInfo(java.lang.reflect.Type returnType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoWithTypeHierarchy(typeHierarchy, returnType, in1Type, in2Type)));\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <IN1, IN2, OUT> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> createTypeInfoWithTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t))) {\n            java.lang.reflect.Type curT = t;\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Usage of class Tuple as a type is not allowed. Use a concrete subclass (e.g. Tuple1, Tuple2, etc.) instead.\");\n            }\n            while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                typeHierarchy.add(curT);\n                curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n            } \n            if (curT instanceof java.lang.Class<?>) {\n                throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple needs to be parameterized by using generics.\");\n            }\n            typeHierarchy.add(curT);\n            java.lang.reflect.ParameterizedType tupleChild = ((java.lang.reflect.ParameterizedType) (curT));\n            java.lang.reflect.Type[] subtypes = new java.lang.reflect.Type[tupleChild.getActualTypeArguments().length];\n            for (int i = 0; i < subtypes.length; i++) {\n                if (tupleChild.getActualTypeArguments()[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    subtypes[i] = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (tupleChild.getActualTypeArguments()[i])));\n                } else {\n                    subtypes[i] = tupleChild.getActualTypeArguments()[i];\n                }\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] tupleSubTypes = new org.apache.flink.api.common.typeinfo.TypeInformation<?>[subtypes.length];\n            for (int i = 0; i < subtypes.length; i++) {\n                java.util.ArrayList<java.lang.reflect.Type> subTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                subTypeHierarchy.add(subtypes[i]);\n                if (subtypes[i] instanceof java.lang.reflect.TypeVariable<?>) {\n                    tupleSubTypes[i] = createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), subTypeHierarchy, in1Type, in2Type);\n                    if (tupleSubTypes[i] == null) {\n                        throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                    }\n                } else {\n                    tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type);\n                }\n            }\n            java.lang.Class<?> tAsClass = null;\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t)) {\n                tAsClass = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t);\n            }\n            com.google.common.base.Preconditions.checkNotNull(tAsClass, \"t has a unexpected type\");\n            int fieldCount = countFieldsInClass(tAsClass);\n            if (fieldCount != tupleSubTypes.length) {\n                if (t instanceof java.lang.reflect.ParameterizedType) {\n                    return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (analyzePojo(tAsClass, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), ((java.lang.reflect.ParameterizedType) (t)), in1Type, in2Type)));\n                } else {\n                    return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (analyzePojo(tAsClass, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), null, in1Type, in2Type)));\n                }\n            }\n            return new org.apache.flink.api.java.typeutils.TupleTypeInfo(tAsClass, tupleSubTypes);\n        } else if (t instanceof java.lang.reflect.TypeVariable) {\n            java.lang.reflect.Type typeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (t)));\n            if (!(typeVar instanceof java.lang.reflect.TypeVariable)) {\n                return createTypeInfoWithTypeHierarchy(typeHierarchy, typeVar, in1Type, in2Type);\n            } else {\n                org.apache.flink.api.common.typeinfo.TypeInformation<OUT> typeInfo = ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (t)), typeHierarchy, in1Type, in2Type)));\n                if (typeInfo != null) {\n                    return typeInfo;\n                } else {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (t)).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (t)).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n                }\n            }\n        } else if (t instanceof java.lang.reflect.GenericArrayType) {\n            java.lang.reflect.GenericArrayType genericArray = ((java.lang.reflect.GenericArrayType) (t));\n            java.lang.reflect.Type componentType = genericArray.getGenericComponentType();\n            if (componentType instanceof java.lang.Class) {\n                java.lang.Class<?> componentClass = ((java.lang.Class<?>) (componentType));\n                java.lang.String className;\n                if (componentClass.isPrimitive()) {\n                    className = org.apache.flink.api.java.typeutils.TypeExtractor.encodePrimitiveClass(componentClass);\n                } else {\n                    className = (\"L\" + componentClass.getName()) + \";\";\n                }\n                java.lang.Class<OUT> classArray;\n                try {\n                    classArray = ((java.lang.Class<OUT>) (java.lang.Class.forName(\"[\" + className)));\n                } catch (java.lang.ClassNotFoundException e) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Could not convert GenericArrayType to Class.\");\n                }\n                return org.apache.flink.api.java.typeutils.TypeExtractor.getForClass(classArray);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = createTypeInfoWithTypeHierarchy(typeHierarchy, genericArray.getGenericComponentType(), in1Type, in2Type);\n            return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(t, componentInfo);\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (privateGetForClass(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t), typeHierarchy, ((java.lang.reflect.ParameterizedType) (t)), in1Type, in2Type)));\n        } else if (t instanceof java.lang.Class) {\n            return privateGetForClass(((java.lang.Class<OUT>) (t)), typeHierarchy);\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type Information could not be created.\");\n    }\n\n    private <IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInputs(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> returnTypeHierarchy, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1TypeInfo, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2TypeInfo) {\n        java.lang.reflect.Type matReturnTypeVar = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(returnTypeHierarchy, returnTypeVar);\n        if (!(matReturnTypeVar instanceof java.lang.reflect.TypeVariable)) {\n            return createTypeInfoWithTypeHierarchy(returnTypeHierarchy, matReturnTypeVar, in1TypeInfo, in2TypeInfo);\n        } else {\n            returnTypeVar = ((java.lang.reflect.TypeVariable<?>) (matReturnTypeVar));\n        }\n        if ((in1TypeInfo == null) && (in2TypeInfo == null)) {\n            return null;\n        }\n        java.util.ArrayList<java.lang.reflect.Type> inputTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        for (java.lang.reflect.Type t : returnTypeHierarchy) {\n            if ((org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(t) && org.apache.flink.api.common.functions.Function.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t))) && (org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t) != org.apache.flink.api.common.functions.Function.class)) {\n                inputTypeHierarchy.add(t);\n            } else {\n                break;\n            }\n        }\n        java.lang.reflect.ParameterizedType baseClass = ((java.lang.reflect.ParameterizedType) (inputTypeHierarchy.get(inputTypeHierarchy.size() - 1)));\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (in1TypeInfo != null) {\n            java.lang.reflect.Type in1Type = baseClass.getActualTypeArguments()[0];\n            info = createTypeInfoFromInput(returnTypeVar, new java.util.ArrayList<java.lang.reflect.Type>(inputTypeHierarchy), in1Type, in1TypeInfo);\n        }\n        if ((info == null) && (in2TypeInfo != null)) {\n            java.lang.reflect.Type in2Type = baseClass.getActualTypeArguments()[1];\n            info = createTypeInfoFromInput(returnTypeVar, new java.util.ArrayList<java.lang.reflect.Type>(inputTypeHierarchy), in2Type, in2TypeInfo);\n        }\n        if (info != null) {\n            return info;\n        }\n        return null;\n    }\n\n    private <IN1> org.apache.flink.api.common.typeinfo.TypeInformation<?> createTypeInfoFromInput(java.lang.reflect.TypeVariable<?> returnTypeVar, java.util.ArrayList<java.lang.reflect.Type> inputTypeHierarchy, java.lang.reflect.Type inType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> inTypeInfo) {\n        org.apache.flink.api.common.typeinfo.TypeInformation<?> info = null;\n        if (inType instanceof java.lang.reflect.TypeVariable) {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(inputTypeHierarchy, ((java.lang.reflect.TypeVariable<?>) (inType)));\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo, inputTypeHierarchy);\n        } else if (inType instanceof java.lang.reflect.GenericArrayType) {\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = null;\n            if (inTypeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (inTypeInfo)).getComponentInfo();\n            } else if (inTypeInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                componentInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(inTypeInfo.getTypeClass().getComponentType());\n            } else if (inTypeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (inTypeInfo)).getComponentInfo();\n            }\n            info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, ((java.lang.reflect.GenericArrayType) (inType)).getGenericComponentType(), componentInfo);\n        } else if (((inTypeInfo instanceof org.apache.flink.api.java.typeutils.TupleTypeInfo) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(inType)) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType))) {\n            java.lang.reflect.ParameterizedType tupleBaseClass;\n            while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(inType) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                inputTypeHierarchy.add(inType);\n                inType = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(inType).getGenericSuperclass();\n            } \n            inputTypeHierarchy.add(inType);\n            tupleBaseClass = ((java.lang.reflect.ParameterizedType) (inType));\n            java.lang.reflect.Type[] tupleElements = tupleBaseClass.getActualTypeArguments();\n            for (int i = 0; i < tupleElements.length; i++) {\n                info = createTypeInfoFromInput(returnTypeVar, inputTypeHierarchy, tupleElements[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (inTypeInfo)).getTypeAt(i));\n                if (info != null) {\n                    break;\n                }\n            }\n        } else if (inTypeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(inputTypeHierarchy, inType, java.lang.Object.class);\n            info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(returnTypeVar, inType, inTypeInfo, inputTypeHierarchy);\n        }\n        return info;\n    }\n\n    public static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int pos) {\n        return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, null, clazz, pos);\n    }\n\n    private static java.lang.reflect.Type getParameterType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.Class<?> clazz, int pos) {\n        if (typeHierarchy != null) {\n            typeHierarchy.add(clazz);\n        }\n        java.lang.reflect.Type[] interfaceTypes = clazz.getGenericInterfaces();\n        for (java.lang.reflect.Type t : interfaceTypes) {\n            java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n            if (parameter != null) {\n                return parameter;\n            }\n        }\n        java.lang.reflect.Type t = clazz.getGenericSuperclass();\n        java.lang.reflect.Type parameter = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterTypeFromGenericType(baseClass, typeHierarchy, t, pos);\n        if (parameter != null) {\n            return parameter;\n        }\n        throw new java.lang.IllegalArgumentException(((\"The types of the interface \" + baseClass.getName()) + \" could not be inferred. \") + \"Support for synthetic interfaces, lambdas, and generic types is limited at this point.\");\n    }\n\n    private static java.lang.reflect.Type getParameterTypeFromGenericType(java.lang.Class<?> baseClass, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type t, int pos) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.equals(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            java.lang.reflect.ParameterizedType baseClassChild = ((java.lang.reflect.ParameterizedType) (t));\n            return baseClassChild.getActualTypeArguments()[pos];\n        } else if ((t instanceof java.lang.reflect.ParameterizedType) && baseClass.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType())), pos);\n        } else if ((t instanceof java.lang.Class<?>) && baseClass.isAssignableFrom(((java.lang.Class<?>) (t)))) {\n            if (typeHierarchy != null) {\n                typeHierarchy.add(t);\n            }\n            return org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, ((java.lang.Class<?>) (t)), pos);\n        }\n        return null;\n    }\n\n    private static void validateInputType(java.lang.reflect.Type t, org.apache.flink.api.common.typeinfo.TypeInformation<?> inType) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, t, inType);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    private static void validateInputType(java.lang.Class<?> baseClass, java.lang.Class<?> clazz, int inputParamPos, org.apache.flink.api.common.typeinfo.TypeInformation<?> inTypeInfo) {\n        java.util.ArrayList<java.lang.reflect.Type> typeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>();\n        java.lang.reflect.Type inType;\n        try {\n            inType = org.apache.flink.api.java.typeutils.TypeExtractor.getParameterType(baseClass, typeHierarchy, clazz, inputParamPos);\n        } catch (java.lang.IllegalArgumentException e) {\n            return;\n        }\n        try {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, inType, inTypeInfo);\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Input mismatch: \" + e.getMessage());\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static void validateInfo(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> typeInfo) {\n        if (type == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. Type is null.\");\n        }\n        if (typeInfo == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Unknown Error. TypeInformation is null.\");\n        }\n        if (!(type instanceof java.lang.reflect.TypeVariable<?>)) {\n            if (typeInfo.isBasicType()) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual;\n                if ((!(type instanceof java.lang.Class<?>)) || ((actual = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(((java.lang.Class<?>) (type)))) == null)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Basic type expected.\");\n                }\n                if (!typeInfo.equals(actual)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Basic type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo.isTupleType()) {\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Tuple type expected.\");\n                }\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).equals(org.apache.flink.api.java.tuple.Tuple.class)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Concrete subclass of Tuple expected.\");\n                }\n                while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getSuperclass().equals(org.apache.flink.api.java.tuple.Tuple.class))) {\n                    typeHierarchy.add(type);\n                    type = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getGenericSuperclass();\n                } \n                if (type instanceof java.lang.Class<?>) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Parameterized Tuple type expected.\");\n                }\n                org.apache.flink.api.java.typeutils.TupleTypeInfo<?> tti = ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo));\n                java.lang.reflect.Type[] subTypes = ((java.lang.reflect.ParameterizedType) (type)).getActualTypeArguments();\n                if (subTypes.length != tti.getArity()) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Tuple arity '\" + tti.getArity()) + \"' expected but was '\") + subTypes.length) + \"'.\");\n                }\n                for (int i = 0; i < subTypes.length; i++) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subTypes[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (typeInfo)).getTypeAt(i));\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.hadoop.io.Writable.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Writable type expected.\");\n                }\n                java.lang.Class<?> clazz;\n                if (((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass() != (clazz = ((java.lang.Class<?>) (type)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Writable type '\" + ((org.apache.flink.api.java.typeutils.WritableTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                java.lang.reflect.Type component;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                if (!((component instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (component)).isPrimitive())) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Primitive component expected.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) {\n                java.lang.reflect.Type component;\n                if ((!(((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray()) && ((component = ((java.lang.Class<?>) (type)).getComponentType()) != null))) && (!((type instanceof java.lang.reflect.GenericArrayType) && ((component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType()) != null)))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Array type expected.\");\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) {\n                if ((!((type instanceof java.lang.Class<?>) && ((java.lang.Class<?>) (type)).isArray())) && (!(type instanceof java.lang.reflect.GenericArrayType))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Object array type expected.\");\n                }\n                java.lang.reflect.Type component;\n                if (type instanceof java.lang.Class<?>) {\n                    component = ((java.lang.Class<?>) (type)).getComponentType();\n                } else {\n                    component = ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType();\n                }\n                if (component instanceof java.lang.reflect.TypeVariable<?>) {\n                    component = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (component)));\n                    if (component instanceof java.lang.reflect.TypeVariable) {\n                        return;\n                    }\n                }\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, component, ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (typeInfo)).getComponentInfo());\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) {\n                if (!((type instanceof java.lang.Class<?>) && org.apache.flink.types.Value.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Value type expected.\");\n                }\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> actual;\n                if (!((org.apache.flink.api.java.typeutils.ValueTypeInfo<?>) (typeInfo)).equals(actual = org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(((java.lang.Class<? extends org.apache.flink.types.Value>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Value type '\" + typeInfo) + \"' expected but was '\") + actual) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) {\n                java.lang.Class<?> clazz = null;\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"POJO type '\" + ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.EnumTypeInfo) {\n                if (!((type instanceof java.lang.Class<?>) && java.lang.Enum.class.isAssignableFrom(((java.lang.Class<?>) (type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Enum type expected.\");\n                }\n                if (!(typeInfo.getTypeClass() == type)) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Enum type '\" + typeInfo.getTypeClass().getCanonicalName()) + \"' expected but was '\") + org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type).getCanonicalName()) + \"'.\");\n                }\n            } else if (typeInfo instanceof org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) {\n                java.lang.Class<?> clazz = null;\n                if (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass() == (clazz = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type))))) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException((((\"Generic object type '\" + ((org.apache.flink.api.java.typeutils.GenericTypeInfo<?>) (typeInfo)).getTypeClass().getCanonicalName()) + \"' expected but was '\") + clazz.getCanonicalName()) + \"'.\");\n                }\n            }\n        } else {\n            type = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type)));\n            if (!(type instanceof java.lang.reflect.TypeVariable)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.validateInfo(typeHierarchy, type, typeInfo);\n            }\n        }\n    }\n\n    private static int countTypeInHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type type) {\n        int count = 0;\n        for (java.lang.reflect.Type t : typeHierarchy) {\n            if ((t == type) || (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type) && (t == org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type)))) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private static java.lang.reflect.Type getTypeHierarchy(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.Type curT, java.lang.Class<?> stopAtClass) {\n        if (((typeHierarchy.size() > 0) && (typeHierarchy.get(0) == curT)) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT)) {\n            curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n        }\n        while (!(org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(curT) && org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).equals(stopAtClass))) {\n            typeHierarchy.add(curT);\n            curT = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(curT).getGenericSuperclass();\n            if (curT == null) {\n                break;\n            }\n        } \n        return curT;\n    }\n\n    private int countFieldsInClass(java.lang.Class<?> clazz) {\n        int fieldCount = 0;\n        for (java.lang.reflect.Field field : clazz.getFields()) {\n            if ((!java.lang.reflect.Modifier.isStatic(field.getModifiers())) && (!java.lang.reflect.Modifier.isTransient(field.getModifiers()))) {\n                fieldCount++;\n            }\n        }\n        return fieldCount;\n    }\n\n    private static java.lang.reflect.Type removeGenericWrapper(java.lang.reflect.Type t) {\n        if ((t instanceof java.lang.reflect.ParameterizedType) && (org.apache.flink.util.Collector.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t)) || java.lang.Iterable.class.isAssignableFrom(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(t)))) {\n            return ((java.lang.reflect.ParameterizedType) (t)).getActualTypeArguments()[0];\n        }\n        return t;\n    }\n\n    private static void validateLambdaGenericParameters(java.lang.reflect.Method m) {\n        for (java.lang.reflect.Type t : m.getGenericParameterTypes()) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(t);\n        }\n        org.apache.flink.api.java.typeutils.TypeExtractor.validateLambdaGenericParameter(m.getGenericReturnType());\n    }\n\n    private static void validateLambdaGenericParameter(java.lang.reflect.Type t) {\n        if (!(t instanceof java.lang.Class)) {\n            return;\n        }\n        final java.lang.Class<?> clazz = ((java.lang.Class<?>) (t));\n        if (clazz.getTypeParameters().length > 0) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(((((\"The generic type parameters of '\" + clazz.getSimpleName()) + \"\\' are missing. \\n\") + \"It seems that your compiler has not stored them into the .class file. \\n\") + \"Currently, only the Eclipse JDT compiler preserves the type information necessary to use the lambdas feature type-safely. \\n\") + \"See the documentation for more information about how to compile jobs containing lambda expressions.\");\n        }\n    }\n\n    private static java.lang.String encodePrimitiveClass(java.lang.Class<?> primitiveClass) {\n        if (primitiveClass == boolean.class) {\n            return \"Z\";\n        } else if (primitiveClass == byte.class) {\n            return \"B\";\n        } else if (primitiveClass == char.class) {\n            return \"C\";\n        } else if (primitiveClass == double.class) {\n            return \"D\";\n        } else if (primitiveClass == float.class) {\n            return \"F\";\n        } else if (primitiveClass == int.class) {\n            return \"I\";\n        } else if (primitiveClass == long.class) {\n            return \"J\";\n        } else if (primitiveClass == short.class) {\n            return \"S\";\n        }\n        throw new org.apache.flink.api.common.functions.InvalidTypesException();\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> findCorrespondingInfo(java.lang.reflect.TypeVariable<?> typeVar, java.lang.reflect.Type type, org.apache.flink.api.common.typeinfo.TypeInformation<?> corrInfo, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(type, typeVar)) {\n            return corrInfo;\n        } else if ((type instanceof java.lang.reflect.TypeVariable) && org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (type))), typeVar)) {\n            return corrInfo;\n        } else if (type instanceof java.lang.reflect.GenericArrayType) {\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> componentInfo = null;\n            if (corrInfo instanceof org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<?, ?>) (corrInfo)).getComponentInfo();\n            } else if (corrInfo instanceof org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo) {\n                componentInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(corrInfo.getTypeClass().getComponentType());\n            } else if (corrInfo instanceof org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo) {\n                componentInfo = ((org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo<?, ?>) (corrInfo)).getComponentInfo();\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, ((java.lang.reflect.GenericArrayType) (type)).getGenericComponentType(), componentInfo, typeHierarchy);\n            if (info != null) {\n                return info;\n            }\n        } else if (((corrInfo instanceof org.apache.flink.api.java.typeutils.TupleTypeInfo) && (type instanceof java.lang.reflect.ParameterizedType)) && org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (type)).getRawType())))) {\n            java.lang.reflect.ParameterizedType tuple = ((java.lang.reflect.ParameterizedType) (type));\n            java.lang.reflect.Type[] args = tuple.getActualTypeArguments();\n            for (int i = 0; i < args.length; i++) {\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, args[i], ((org.apache.flink.api.java.typeutils.TupleTypeInfo<?>) (corrInfo)).getTypeAt(i), typeHierarchy);\n                if (info != null) {\n                    return info;\n                }\n            }\n        } else if ((corrInfo instanceof org.apache.flink.api.java.typeutils.PojoTypeInfo) && org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(type)) {\n            java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(type));\n            for (java.lang.reflect.Field field : fields) {\n                java.lang.reflect.Type fieldType = field.getGenericType();\n                if ((fieldType instanceof java.lang.reflect.TypeVariable) && org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(typeVar, org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (fieldType))))) {\n                    return org.apache.flink.api.java.typeutils.TypeExtractor.getTypeOfPojoField(corrInfo, field);\n                } else if ((fieldType instanceof java.lang.reflect.ParameterizedType) || (fieldType instanceof java.lang.reflect.GenericArrayType)) {\n                    java.util.ArrayList<java.lang.reflect.Type> typeHierarchyWithFieldType = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                    typeHierarchyWithFieldType.add(fieldType);\n                    org.apache.flink.api.common.typeinfo.TypeInformation<?> info = org.apache.flink.api.java.typeutils.TypeExtractor.findCorrespondingInfo(typeVar, fieldType, org.apache.flink.api.java.typeutils.TypeExtractor.getTypeOfPojoField(corrInfo, field), typeHierarchyWithFieldType);\n                    if (info != null) {\n                        return info;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private static java.lang.reflect.Type materializeTypeVariable(java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.TypeVariable<?> typeVar) {\n        java.lang.reflect.TypeVariable<?> inTypeTypeVar = typeVar;\n        for (int i = typeHierarchy.size() - 1; i >= 0; i--) {\n            java.lang.reflect.Type curT = typeHierarchy.get(i);\n            if (curT instanceof java.lang.reflect.ParameterizedType) {\n                java.lang.Class<?> rawType = ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (curT)).getRawType()));\n                for (int paramIndex = 0; paramIndex < rawType.getTypeParameters().length; paramIndex++) {\n                    java.lang.reflect.TypeVariable<?> curVarOfCurT = rawType.getTypeParameters()[paramIndex];\n                    if (org.apache.flink.api.java.typeutils.TypeExtractor.sameTypeVars(curVarOfCurT, inTypeTypeVar)) {\n                        java.lang.reflect.Type curVarType = ((java.lang.reflect.ParameterizedType) (curT)).getActualTypeArguments()[paramIndex];\n                        if (curVarType instanceof java.lang.reflect.TypeVariable<?>) {\n                            inTypeTypeVar = ((java.lang.reflect.TypeVariable<?>) (curVarType));\n                        } else {\n                            return curVarType;\n                        }\n                    }\n                }\n            }\n        }\n        return inTypeTypeVar;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForClass(java.lang.Class<X> clazz) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForClass(clazz, new java.util.ArrayList<java.lang.reflect.Type>());\n    }\n\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForClass(java.lang.Class<X> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        return privateGetForClass(clazz, typeHierarchy, null, null, null);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <OUT, IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> privateGetForClass(java.lang.Class<OUT> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.ParameterizedType parameterizedType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        com.google.common.base.Preconditions.checkNotNull(clazz);\n        if (clazz.equals(java.lang.Object.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (clazz.isArray()) {\n            org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo<OUT> primitiveArrayInfo = org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo.getInfoFor(clazz);\n            if (primitiveArrayInfo != null) {\n                return primitiveArrayInfo;\n            }\n            org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo<OUT, ?> basicArrayInfo = org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo.getInfoFor(clazz);\n            if (basicArrayInfo != null) {\n                return basicArrayInfo;\n            } else {\n                return org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo.getInfoFor(clazz);\n            }\n        }\n        if (org.apache.hadoop.io.Writable.class.isAssignableFrom(clazz) && (!org.apache.hadoop.io.Writable.class.equals(clazz))) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.WritableTypeInfo.getWritableTypeInfo(((java.lang.Class<? extends org.apache.hadoop.io.Writable>) (clazz)))));\n        }\n        org.apache.flink.api.common.typeinfo.TypeInformation<OUT> basicTypeInfo = org.apache.flink.api.common.typeinfo.BasicTypeInfo.getInfoFor(clazz);\n        if (basicTypeInfo != null) {\n            return basicTypeInfo;\n        }\n        if (org.apache.flink.types.Value.class.isAssignableFrom(clazz)) {\n            java.lang.Class<? extends org.apache.flink.types.Value> valueClass = clazz.asSubclass(org.apache.flink.types.Value.class);\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (org.apache.flink.api.java.typeutils.ValueTypeInfo.getValueTypeInfo(valueClass)));\n        }\n        if (org.apache.flink.api.java.tuple.Tuple.class.isAssignableFrom(clazz)) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Type information extraction for tuples cannot be done based on the class.\");\n        }\n        if (java.lang.Enum.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.EnumTypeInfo(clazz)));\n        }\n        if (org.apache.avro.specific.SpecificRecordBase.class.isAssignableFrom(clazz)) {\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<OUT>) (new org.apache.flink.api.java.typeutils.AvroTypeInfo(clazz)));\n        }\n        if (org.apache.flink.api.java.typeutils.TypeExtractor.countTypeInHierarchy(typeHierarchy, clazz) > 1) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (java.lang.reflect.Modifier.isInterface(clazz.getModifiers())) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        if (clazz.equals(java.lang.Class.class)) {\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        try {\n            org.apache.flink.api.common.typeinfo.TypeInformation<OUT> pojoType = analyzePojo(clazz, new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), parameterizedType, in1Type, in2Type);\n            if (pojoType != null) {\n                return pojoType;\n            }\n        } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n            if (org.apache.flink.api.java.typeutils.TypeExtractor.LOG.isDebugEnabled()) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Unable to handle type \" + clazz) + \" as POJO. Message: \") + e.getMessage(), e);\n            }\n        }\n        return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n    }\n\n    private boolean isValidPojoField(java.lang.reflect.Field f, java.lang.Class<?> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy) {\n        if (java.lang.reflect.Modifier.isPublic(f.getModifiers())) {\n            return true;\n        } else {\n            boolean hasGetter = false;\n            boolean hasSetter = false;\n            final java.lang.String fieldNameLow = f.getName().toLowerCase();\n            java.lang.reflect.Type fieldType = f.getGenericType();\n            java.lang.reflect.TypeVariable<?> fieldTypeGeneric = null;\n            if (fieldType instanceof java.lang.reflect.TypeVariable) {\n                fieldTypeGeneric = ((java.lang.reflect.TypeVariable<?>) (fieldType));\n                fieldType = org.apache.flink.api.java.typeutils.TypeExtractor.materializeTypeVariable(typeHierarchy, ((java.lang.reflect.TypeVariable<?>) (fieldType)));\n            }\n            for (java.lang.reflect.Method m : clazz.getMethods()) {\n                if ((((m.getName().toLowerCase().equals(\"get\" + fieldNameLow) || m.getName().toLowerCase().equals(\"is\" + fieldNameLow)) || m.getName().toLowerCase().equals(fieldNameLow)) && (m.getParameterTypes().length == 0)) && (m.getGenericReturnType().equals(fieldType) || ((fieldTypeGeneric != null) && m.getGenericReturnType().equals(fieldTypeGeneric)))) {\n                    if (hasGetter) {\n                        throw new java.lang.IllegalStateException(\"Detected more than one getter\");\n                    }\n                    hasGetter = true;\n                }\n                if ((((m.getName().toLowerCase().equals(\"set\" + fieldNameLow) || m.getName().toLowerCase().equals(fieldNameLow + \"_$eq\")) && (m.getParameterTypes().length == 1)) && (m.getGenericParameterTypes()[0].equals(fieldType) || ((fieldTypeGeneric != null) && m.getGenericParameterTypes()[0].equals(fieldTypeGeneric)))) && m.getReturnType().equals(java.lang.Void.TYPE)) {\n                    if (hasSetter) {\n                        throw new java.lang.IllegalStateException(\"Detected more than one setter\");\n                    }\n                    hasSetter = true;\n                }\n            }\n            if (hasGetter && hasSetter) {\n                return true;\n            } else {\n                if (!hasGetter) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Class \" + clazz) + \" does not contain a getter for field \") + f.getName());\n                }\n                if (!hasSetter) {\n                    org.apache.flink.api.java.typeutils.TypeExtractor.LOG.debug(((\"Class \" + clazz) + \" does not contain a setter for field \") + f.getName());\n                }\n                return false;\n            }\n        }\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    protected <OUT, IN1, IN2> org.apache.flink.api.common.typeinfo.TypeInformation<OUT> analyzePojo(java.lang.Class<OUT> clazz, java.util.ArrayList<java.lang.reflect.Type> typeHierarchy, java.lang.reflect.ParameterizedType parameterizedType, org.apache.flink.api.common.typeinfo.TypeInformation<IN1> in1Type, org.apache.flink.api.common.typeinfo.TypeInformation<IN2> in2Type) {\n        if (parameterizedType != null) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(typeHierarchy, parameterizedType, java.lang.Object.class);\n        } else if (typeHierarchy.size() <= 1) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.getTypeHierarchy(typeHierarchy, clazz, java.lang.Object.class);\n        }\n        java.util.List<java.lang.reflect.Field> fields = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz);\n        if (fields.size() == 0) {\n            org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"No fields detected for class \" + clazz) + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n            return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n        }\n        java.util.List<org.apache.flink.api.java.typeutils.PojoField> pojoFields = new java.util.ArrayList<org.apache.flink.api.java.typeutils.PojoField>();\n        for (java.lang.reflect.Field field : fields) {\n            java.lang.reflect.Type fieldType = field.getGenericType();\n            if (!isValidPojoField(field, clazz, typeHierarchy)) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" is not a valid POJO type\");\n                return null;\n            }\n            try {\n                java.util.ArrayList<java.lang.reflect.Type> fieldTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n                fieldTypeHierarchy.add(fieldType);\n                org.apache.flink.api.common.typeinfo.TypeInformation<?> ti = createTypeInfoWithTypeHierarchy(fieldTypeHierarchy, fieldType, in1Type, in2Type);\n                pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, ti));\n            } catch (org.apache.flink.api.common.functions.InvalidTypesException e) {\n                java.lang.Class<?> genericClass = java.lang.Object.class;\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.isClassType(fieldType)) {\n                    genericClass = org.apache.flink.api.java.typeutils.TypeExtractor.typeToClass(fieldType);\n                }\n                pojoFields.add(new org.apache.flink.api.java.typeutils.PojoField(field, new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(((java.lang.Class<OUT>) (genericClass)))));\n            }\n        }\n        org.apache.flink.api.common.typeutils.CompositeType<OUT> pojoType = new org.apache.flink.api.java.typeutils.PojoTypeInfo<OUT>(clazz, pojoFields);\n        java.util.List<java.lang.reflect.Method> methods = org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredMethods(clazz);\n        for (java.lang.reflect.Method method : methods) {\n            if (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" contains custom serialization methods we do not call.\");\n                return null;\n            }\n        }\n        try {\n            clazz.getDeclaredConstructor();\n        } catch (java.lang.NoSuchMethodException e) {\n            if (clazz.isInterface() || java.lang.reflect.Modifier.isAbstract(clazz.getModifiers())) {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info(((\"Class \" + clazz) + \" is abstract or an interface, having a concrete \") + \"type can increase performance.\");\n            } else {\n                org.apache.flink.api.java.typeutils.TypeExtractor.LOG.info((\"Class \" + clazz) + \" must have a default constructor to be used as a POJO.\");\n                return null;\n            }\n        }\n        return pojoType;\n    }\n\n    public static java.util.List<java.lang.reflect.Field> getAllDeclaredFields(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Field> result = new java.util.ArrayList<java.lang.reflect.Field>();\n        while (clazz != null) {\n            java.lang.reflect.Field[] fields = clazz.getDeclaredFields();\n            for (java.lang.reflect.Field field : fields) {\n                if (java.lang.reflect.Modifier.isTransient(field.getModifiers()) || java.lang.reflect.Modifier.isStatic(field.getModifiers())) {\n                    continue;\n                }\n                if (org.apache.flink.api.java.typeutils.TypeExtractor.hasFieldWithSameName(field.getName(), result)) {\n                    throw new java.lang.RuntimeException(((((\"The field \" + field) + \" is already contained in the hierarchy of the class \") + clazz) + \".\") + \"Please use unique field names through your classes hierarchy\");\n                }\n                result.add(field);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static java.lang.reflect.Field getDeclaredField(java.lang.Class<?> clazz, java.lang.String name) {\n        for (java.lang.reflect.Field field : org.apache.flink.api.java.typeutils.TypeExtractor.getAllDeclaredFields(clazz)) {\n            if (field.getName().equals(name)) {\n                return field;\n            }\n        }\n        return null;\n    }\n\n    private static boolean hasFieldWithSameName(java.lang.String name, java.util.List<java.lang.reflect.Field> fields) {\n        for (java.lang.reflect.Field field : fields) {\n            if (name.equals(field.getName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static java.util.List<java.lang.reflect.Method> getAllDeclaredMethods(java.lang.Class<?> clazz) {\n        java.util.List<java.lang.reflect.Method> result = new java.util.ArrayList<java.lang.reflect.Method>();\n        while (clazz != null) {\n            java.lang.reflect.Method[] methods = clazz.getDeclaredMethods();\n            for (java.lang.reflect.Method method : methods) {\n                result.add(method);\n            }\n            clazz = clazz.getSuperclass();\n        } \n        return result;\n    }\n\n    public static java.lang.Class<?> typeToClass(java.lang.reflect.Type t) {\n        if (t instanceof java.lang.Class) {\n            return ((java.lang.Class<?>) (t));\n        } else if (t instanceof java.lang.reflect.ParameterizedType) {\n            return ((java.lang.Class<?>) (((java.lang.reflect.ParameterizedType) (t)).getRawType()));\n        }\n        throw new java.lang.IllegalArgumentException(\"Cannot convert type to class\");\n    }\n\n    public static boolean isClassType(java.lang.reflect.Type t) {\n        return (t instanceof java.lang.Class<?>) || (t instanceof java.lang.reflect.ParameterizedType);\n    }\n\n    private static boolean sameTypeVars(java.lang.reflect.Type t1, java.lang.reflect.Type t2) {\n        if ((!(t1 instanceof java.lang.reflect.TypeVariable)) || (!(t2 instanceof java.lang.reflect.TypeVariable))) {\n            return false;\n        }\n        return ((java.lang.reflect.TypeVariable<?>) (t1)).getName().equals(((java.lang.reflect.TypeVariable<?>) (t2)).getName()) && ((java.lang.reflect.TypeVariable<?>) (t1)).getGenericDeclaration().equals(((java.lang.reflect.TypeVariable<?>) (t2)).getGenericDeclaration());\n    }\n\n    private static org.apache.flink.api.common.typeinfo.TypeInformation<?> getTypeOfPojoField(org.apache.flink.api.common.typeinfo.TypeInformation<?> pojoInfo, java.lang.reflect.Field field) {\n        for (int j = 0; j < pojoInfo.getArity(); j++) {\n            org.apache.flink.api.java.typeutils.PojoField pf = ((org.apache.flink.api.java.typeutils.PojoTypeInfo<?>) (pojoInfo)).getPojoFieldAt(j);\n            if (pf.field.getName().equals(field.getName())) {\n                return pf.type;\n            }\n        }\n        return null;\n    }\n\n    public static <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> getForObject(X value) {\n        return new org.apache.flink.api.java.typeutils.TypeExtractor().privateGetForObject(value);\n    }\n\n    @java.lang.SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private <X> org.apache.flink.api.common.typeinfo.TypeInformation<X> privateGetForObject(X value) {\n        com.google.common.base.Preconditions.checkNotNull(value);\n        if (value instanceof org.apache.flink.api.java.tuple.Tuple) {\n            org.apache.flink.api.java.tuple.Tuple t = ((org.apache.flink.api.java.tuple.Tuple) (value));\n            int numFields = t.getArity();\n            if (numFields != countFieldsInClass(value.getClass())) {\n                return analyzePojo(((java.lang.Class<X>) (value.getClass())), new java.util.ArrayList<java.lang.reflect.Type>(), null, null, null);\n            }\n            org.apache.flink.api.common.typeinfo.TypeInformation<?>[] infos = new org.apache.flink.api.common.typeinfo.TypeInformation[numFields];\n            for (int i = 0; i < numFields; i++) {\n                java.lang.Object field = t.getField(i);\n                if (field == null) {\n                    throw new org.apache.flink.api.common.functions.InvalidTypesException(\"Automatic type extraction is not possible on candidates with null values. \" + \"Please specify the types directly.\");\n                }\n                infos[i] = privateGetForObject(field);\n            }\n            return ((org.apache.flink.api.common.typeinfo.TypeInformation<X>) (new org.apache.flink.api.java.typeutils.TupleTypeInfo(value.getClass(), infos)));\n        } else {\n            return privateGetForClass(((java.lang.Class<X>) (value.getClass())), new java.util.ArrayList<java.lang.reflect.Type>());\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "org.apache.flink.api.java.typeutils.TypeExtractor.countTypeInHierarchy(typeHierarchy, clazz) > 1",
            "src_parent": "if (org.apache.flink.api.java.typeutils.TypeExtractor.countTypeInHierarchy(typeHierarchy, clazz) > 1) {\n    return new org.apache.flink.api.java.typeutils.GenericTypeInfo<OUT>(clazz);\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Throw",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "java.util.ArrayList<java.lang.reflect.Type> subTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy)",
            "src_parent": "{\n    java.util.ArrayList<java.lang.reflect.Type> subTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n    subTypeHierarchy.add(subtypes[i]);\n    if (subtypes[i] instanceof java.lang.reflect.TypeVariable<?>) {\n        tupleSubTypes[i] = createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), subTypeHierarchy, in1Type, in2Type);\n        if (tupleSubTypes[i] == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n        }\n    } else {\n        tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Throw",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "subTypeHierarchy.add(subtypes[i])",
            "src_parent": "{\n    java.util.ArrayList<java.lang.reflect.Type> subTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy);\n    subTypeHierarchy.add(subtypes[i]);\n    if (subtypes[i] instanceof java.lang.reflect.TypeVariable<?>) {\n        tupleSubTypes[i] = createTypeInfoFromInputs(((java.lang.reflect.TypeVariable<?>) (subtypes[i])), subTypeHierarchy, in1Type, in2Type);\n        if (tupleSubTypes[i] == null) {\n            throw new org.apache.flink.api.common.functions.InvalidTypesException((((((\"Type of TypeVariable '\" + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getName()) + \"' in '\") + ((java.lang.reflect.TypeVariable<?>) (subtypes[i])).getGenericDeclaration()) + \"' could not be determined. This is most likely a type erasure problem. \") + \"The type extraction currently supports types with generic variables only in cases where \") + \"all variables in the return type can be deduced from the input type(s).\");\n        }\n    } else {\n        tupleSubTypes[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "subTypeHierarchy",
            "src_parent": "createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Constructor",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "VirtualElement",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "VE: Modifiers_Constructor",
            "dst_parent": "protected TypeExtractor() {\n}",
            "dst_parent_type": "Constructor",
            "dst_type": "VirtualEle",
            "operator": "MOV",
            "src": "VE: Modifiers_Constructor",
            "src_parent": "protected TypeExtractor() {\n    alreadySeen = new java.util.HashSet<java.lang.Class<?>>();\n}",
            "src_parent_type": "Constructor",
            "src_type": "VirtualEle"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "clazz",
            "dst_parent": "org.apache.flink.api.java.typeutils.TypeExtractor.countTypeInHierarchy(typeHierarchy, clazz)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "clazz",
            "src_parent": "alreadySeen.contains(clazz)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Assignment",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy)",
            "dst_parent": "java.util.ArrayList<java.lang.reflect.Type> subTypeHierarchy = new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy)",
            "dst_parent_type": "LocalVariable",
            "dst_type": "ConstructorCall",
            "operator": "MOV",
            "src": "new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy)",
            "src_parent": "createTypeInfoWithTypeHierarchy(new java.util.ArrayList<java.lang.reflect.Type>(typeHierarchy), subtypes[i], in1Type, in2Type)",
            "src_parent_type": "Invocation",
            "src_type": "ConstructorCall"
          }
        }
      ],
      "file_name": "TypeExtractor"
    }
  ],
  "id": "flink_5546a1ef"
}