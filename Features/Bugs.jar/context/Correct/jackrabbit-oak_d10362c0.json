{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition))",
            "dst_parent": "return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition))",
            "dst_parent_type": "Return",
            "dst_type": "ConstructorCall",
            "operator": "UPD",
            "src": "new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath)",
            "src_parent": "return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath)",
            "src_parent_type": "Return",
            "src_type": "ConstructorCall"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory(remote, local, reindexMode, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getIndexPathForLogging(definition), getSharedWorkingSet(definition))",
            "dst_parent": "return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory(remote, local, reindexMode, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getIndexPathForLogging(definition), getSharedWorkingSet(definition))",
            "dst_parent_type": "Return",
            "dst_type": "ConstructorCall",
            "operator": "UPD",
            "src": "new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory(remote, local, reindexMode, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getIndexPathForLogging(definition))",
            "src_parent": "return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory(remote, local, reindexMode, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getIndexPathForLogging(definition))",
            "src_parent_type": "Return",
            "src_type": "ConstructorCall"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Catch",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "\"Attempt would be made to delete it on next run \"",
            "dst_parent": "\"Error occurred while removing deleted file {} from Local {}. \" + \"Attempt would be made to delete it on next run \"",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "Literal",
            "operator": "UPD",
            "src": "\"Attempt would be maid to delete it on next run \"",
            "src_parent": "\"Error occurred while removing deleted file {} from Local {}. \" + \"Attempt would be maid to delete it on next run \"",
            "src_parent_type": "BinaryOperator",
            "src_type": "Literal"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private final java.util.Map<java.lang.String, java.util.Set<java.lang.String>> sharedWorkingSetMap = com.google.common.collect.Maps.newHashMap();",
            "src_parent": "public class IndexCopier implements java.io.Closeable , org.apache.jackrabbit.oak.plugins.index.lucene.CopyOnReadStatsMBean {\n    private static final java.util.Set<java.lang.String> REMOTE_ONLY = com.google.common.collect.ImmutableSet.of(\"segments.gen\");\n\n    private static final int MAX_FAILURE_ENTRIES = 10000;\n\n    private static final java.util.concurrent.atomic.AtomicInteger UNIQUE_COUNTER = new java.util.concurrent.atomic.AtomicInteger();\n\n    private static final java.lang.String WORK_DIR_NAME = \"indexWriterDir\";\n\n    private final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(getClass());\n\n    private final org.apache.jackrabbit.oak.util.PerfLogger PERF_LOGGER = new org.apache.jackrabbit.oak.util.PerfLogger(org.slf4j.LoggerFactory.getLogger(log.getName() + \".perf\"));\n\n    private final java.util.concurrent.Executor executor;\n\n    private final java.io.File indexRootDir;\n\n    private final java.io.File indexWorkDir;\n\n    private final java.util.concurrent.atomic.AtomicInteger readerLocalReadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger writerLocalReadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger readerRemoteReadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger writerRemoteReadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger invalidFileCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger deletedFileCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger scheduledForCopyCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger copyInProgressCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger maxCopyInProgressCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger maxScheduledForCopyCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger uploadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger downloadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicLong copyInProgressSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong downloadSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong uploadSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong garbageCollectedSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong skippedFromUploadSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong downloadTime = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong uploadTime = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.Map<java.lang.String, java.lang.String> indexPathMapping = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Map<java.lang.String, java.util.Set<java.lang.String>> sharedWorkingSetMap = com.google.common.collect.Maps.newHashMap();\n\n    private final java.util.Map<java.lang.String, java.lang.String> indexPathVersionMapping = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.concurrent.ConcurrentMap<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile> failedToDeleteFiles = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Set<org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile> copyInProgressFiles = java.util.Collections.newSetFromMap(new java.util.concurrent.ConcurrentHashMap<org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile, java.lang.Boolean>());\n\n    private final boolean prefetchEnabled;\n\n    private volatile boolean closed;\n\n    public IndexCopier(java.util.concurrent.Executor executor, java.io.File indexRootDir) throws java.io.IOException {\n        this(executor, indexRootDir, false);\n    }\n\n    public IndexCopier(java.util.concurrent.Executor executor, java.io.File indexRootDir, boolean prefetchEnabled) throws java.io.IOException {\n        this.executor = executor;\n        this.indexRootDir = indexRootDir;\n        this.prefetchEnabled = prefetchEnabled;\n        this.indexWorkDir = org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.initializerWorkDir(indexRootDir);\n    }\n\n    public org.apache.lucene.store.Directory wrapForRead(java.lang.String indexPath, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition definition, org.apache.lucene.store.Directory remote) throws java.io.IOException {\n        org.apache.lucene.store.Directory local = createLocalDirForIndexReader(indexPath, definition);\n        return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));\n    }\n\n    public org.apache.lucene.store.Directory wrapForWrite(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition definition, org.apache.lucene.store.Directory remote, boolean reindexMode) throws java.io.IOException {\n        org.apache.lucene.store.Directory local = createLocalDirForIndexWriter(definition);\n        return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory(remote, local, reindexMode, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getIndexPathForLogging(definition), getSharedWorkingSet(definition));\n    }\n\n    @java.lang.Override\n    public void close() throws java.io.IOException {\n        this.closed = true;\n    }\n\n    java.io.File getIndexWorkDir() {\n        return indexWorkDir;\n    }\n\n    java.io.File getIndexRootDir() {\n        return indexRootDir;\n    }\n\n    protected org.apache.lucene.store.Directory createLocalDirForIndexWriter(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition definition) throws java.io.IOException {\n        java.lang.String indexPath = definition.getIndexPathFromConfig();\n        java.io.File indexWriterDir;\n        if (indexPath == null) {\n            indexWriterDir = new java.io.File(indexWorkDir, java.lang.String.valueOf(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.UNIQUE_COUNTER.incrementAndGet()));\n        } else {\n            java.io.File indexDir = getIndexDir(indexPath);\n            java.lang.String newVersion = java.lang.String.valueOf(definition.getReindexCount());\n            indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);\n        }\n        org.apache.lucene.store.Directory dir = org.apache.lucene.store.FSDirectory.open(indexWriterDir, org.apache.lucene.store.NoLockFactory.getNoLockFactory());\n        log.debug(\"IndexWriter would use {}\", indexWriterDir);\n        if (indexPath == null) {\n            dir = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.DeleteOldDirOnClose(dir, indexWriterDir);\n            log.debug(\"IndexPath [{}] not configured in index definition {}. Writer would create index \" + (\"files in temporary dir {} which would be deleted upon close. For better performance do \" + \"configure the 'indexPath' as part of your index definition\"), LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);\n        }\n        return dir;\n    }\n\n    protected org.apache.lucene.store.Directory createLocalDirForIndexReader(java.lang.String indexPath, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition definition) throws java.io.IOException {\n        java.io.File indexDir = getIndexDir(indexPath);\n        java.lang.String newVersion = java.lang.String.valueOf(definition.getReindexCount());\n        java.io.File versionedIndexDir = getVersionedDir(indexPath, indexDir, newVersion);\n        org.apache.lucene.store.Directory result = org.apache.lucene.store.FSDirectory.open(versionedIndexDir);\n        java.lang.String oldVersion = indexPathVersionMapping.put(indexPath, newVersion);\n        if ((!newVersion.equals(oldVersion)) && (oldVersion != null)) {\n            result = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.DeleteOldDirOnClose(result, new java.io.File(indexDir, oldVersion));\n        }\n        return result;\n    }\n\n    private java.io.File getVersionedDir(java.lang.String indexPath, java.io.File indexDir, java.lang.String newVersion) {\n        java.io.File versionedIndexDir = new java.io.File(indexDir, newVersion);\n        if (!versionedIndexDir.exists()) {\n            com.google.common.base.Preconditions.checkState(versionedIndexDir.mkdirs(), \"Cannot create directory %s\", versionedIndexDir);\n        }\n        indexPathMapping.put(indexPath, indexDir.getAbsolutePath());\n        return versionedIndexDir;\n    }\n\n    public java.io.File getIndexDir(java.lang.String indexPath) {\n        java.lang.String subDir = com.google.common.hash.Hashing.sha256().hashString(indexPath, com.google.common.base.Charsets.UTF_8).toString();\n        return new java.io.File(indexRootDir, subDir);\n    }\n\n    java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile> getFailedToDeleteFiles() {\n        return java.util.Collections.unmodifiableMap(failedToDeleteFiles);\n    }\n\n    private void failedToDelete(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file) {\n        if (failedToDeleteFiles.size() < org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.MAX_FAILURE_ENTRIES) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile failedToDeleteFile = failedToDeleteFiles.putIfAbsent(file.getKey(), file);\n            if (failedToDeleteFile == null) {\n                failedToDeleteFile = file;\n            }\n            failedToDeleteFile.incrementAttemptToDelete();\n        } else {\n            log.warn(\"Not able to delete {}. Currently more than {} file with total size {} are pending delete.\", file.deleteLog(), failedToDeleteFiles.size(), getGarbageSize());\n        }\n    }\n\n    private void successfullyDeleted(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file, boolean fileExisted) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile failedToDeleteFile = failedToDeleteFiles.remove(file.getKey());\n        if (failedToDeleteFile != null) {\n            log.debug(\"Deleted : {}\", failedToDeleteFile.deleteLog());\n        }\n        if (fileExisted) {\n            garbageCollectedSize.addAndGet(file.size);\n            deletedFileCount.incrementAndGet();\n        }\n    }\n\n    private java.util.Set<java.lang.String> getSharedWorkingSet(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition defn) {\n        java.lang.String indexPath = defn.getIndexPathFromConfig();\n        if (indexPath == null) {\n            return new java.util.HashSet<java.lang.String>();\n        }\n        java.util.Set<java.lang.String> sharedSet;\n        synchronized(sharedWorkingSetMap) {\n            sharedSet = sharedWorkingSetMap.get(indexPath);\n            if (sharedSet == null) {\n                sharedSet = com.google.common.collect.Sets.newConcurrentHashSet();\n                sharedWorkingSetMap.put(indexPath, sharedSet);\n            }\n        }\n        return sharedSet;\n    }\n\n    private static java.io.File initializerWorkDir(java.io.File indexRootDir) throws java.io.IOException {\n        java.io.File workDir = new java.io.File(indexRootDir, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.WORK_DIR_NAME);\n        org.apache.commons.io.FileUtils.deleteDirectory(workDir);\n        com.google.common.base.Preconditions.checkState(workDir.mkdirs(), \"Cannot create directory %s\", workDir);\n        return workDir;\n    }\n\n    private static java.lang.String getIndexPathForLogging(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition defn) {\n        java.lang.String indexPath = defn.getIndexPathFromConfig();\n        if (indexPath == null) {\n            return \"UNKNOWN\";\n        }\n        return indexPath;\n    }\n\n    private class CopyOnReadDirectory extends org.apache.lucene.store.FilterDirectory {\n        private final org.apache.lucene.store.Directory remote;\n\n        private final org.apache.lucene.store.Directory local;\n\n        private final java.lang.String indexPath;\n\n        private final java.util.concurrent.ConcurrentMap<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference> files = com.google.common.collect.Maps.newConcurrentMap();\n\n        private final java.util.Set<java.lang.String> localFileNames = com.google.common.collect.Sets.newConcurrentHashSet();\n\n        public CopyOnReadDirectory(org.apache.lucene.store.Directory remote, org.apache.lucene.store.Directory local, boolean prefetch, java.lang.String indexPath, java.util.Set<java.lang.String> sharedWorkingSet) throws java.io.IOException {\n            super(remote);\n            this.remote = remote;\n            this.local = local;\n            this.indexPath = indexPath;\n            this.localFileNames.addAll(java.util.Arrays.asList(local.listAll()));\n            this.localFileNames.removeAll(sharedWorkingSet);\n            if (prefetch) {\n                prefetchIndexFiles();\n            }\n        }\n\n        @java.lang.Override\n        public void deleteFile(java.lang.String name) throws java.io.IOException {\n            throw new java.lang.UnsupportedOperationException(\"Cannot delete in a ReadOnly directory\");\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexOutput createOutput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            throw new java.lang.UnsupportedOperationException(\"Cannot write in a ReadOnly directory\");\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexInput openInput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            if (org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.REMOTE_ONLY.contains(name)) {\n                log.trace(\"[{}] opening remote only file {}\", indexPath, name);\n                return remote.openInput(name, context);\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference ref = files.get(name);\n            if (ref != null) {\n                if (ref.isLocalValid()) {\n                    log.trace(\"[{}] opening existing local file {}\", indexPath, name);\n                    return files.get(name).openLocalInput(context);\n                } else {\n                    readerRemoteReadCount.incrementAndGet();\n                    log.trace(\"[{}] opening existing remote file as local version is not valid {}\", indexPath, name);\n                    return remote.openInput(name, context);\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference toPut = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference(name);\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference old = files.putIfAbsent(name, toPut);\n            if (old == null) {\n                log.trace(\"[{}] scheduled local copy for {}\", indexPath, name);\n                copy(toPut);\n            }\n            if (toPut.isLocalValid()) {\n                log.trace(\"[{}] opening new local file {}\", indexPath, name);\n                return toPut.openLocalInput(context);\n            }\n            log.trace(\"[{}] opening new remote file {}\", indexPath, name);\n            readerRemoteReadCount.incrementAndGet();\n            return remote.openInput(name, context);\n        }\n\n        private void copy(final org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference reference) {\n            updateMaxScheduled(scheduledForCopyCount.incrementAndGet());\n            executor.execute(new java.lang.Runnable() {\n                @java.lang.Override\n                public void run() {\n                    scheduledForCopyCount.decrementAndGet();\n                    copyFilesToLocal(reference, true);\n                }\n            });\n        }\n\n        private void prefetchIndexFiles() throws java.io.IOException {\n            long start = PERF_LOGGER.start();\n            long totalSize = 0;\n            int copyCount = 0;\n            for (java.lang.String name : remote.listAll()) {\n                if (org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.REMOTE_ONLY.contains(name)) {\n                    continue;\n                }\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference fileRef = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference(name);\n                files.putIfAbsent(name, fileRef);\n                long fileSize = copyFilesToLocal(fileRef, false);\n                if (fileSize > 0) {\n                    copyCount++;\n                    totalSize += fileSize;\n                }\n            }\n            PERF_LOGGER.end(start, -1, \"[{}] Copied {} files totaling {}\", indexPath, copyCount, humanReadableByteCount(totalSize));\n        }\n\n        private long copyFilesToLocal(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference reference, boolean logDuration) {\n            java.lang.String name = reference.name;\n            boolean success = false;\n            boolean copyAttempted = false;\n            long fileSize = 0;\n            try {\n                if (!local.fileExists(name)) {\n                    long perfStart = -1;\n                    if (logDuration) {\n                        perfStart = PERF_LOGGER.start();\n                    }\n                    fileSize = remote.fileLength(name);\n                    org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile(local, name, fileSize, true);\n                    long start = startCopy(file);\n                    copyAttempted = true;\n                    remote.copy(local, name, name, IOContext.READ);\n                    reference.markValid();\n                    doneCopy(file, start);\n                    if (logDuration) {\n                        PERF_LOGGER.end(perfStart, 0, \"[{}] Copied file {} of size {}\", indexPath, name, humanReadableByteCount(fileSize));\n                    }\n                } else {\n                    long localLength = local.fileLength(name);\n                    long remoteLength = remote.fileLength(name);\n                    if (localLength != remoteLength) {\n                        log.warn(\"[{}] Found local copy for {} in {} but size of local {} differs from remote {}. \" + \"Content would be read from remote file only\", indexPath, name, local, localLength, remoteLength);\n                        invalidFileCount.incrementAndGet();\n                    } else {\n                        reference.markValid();\n                        log.trace(\"[{}] found local copy of file {}\", indexPath, name);\n                    }\n                }\n                success = true;\n            } catch (java.io.IOException e) {\n                log.warn(\"[{}] Error occurred while copying file [{}] from {} to {}\", indexPath, name, remote, local, e);\n            } finally {\n                if (copyAttempted && (!success)) {\n                    try {\n                        if (local.fileExists(name)) {\n                            local.deleteFile(name);\n                        }\n                    } catch (java.io.IOException e) {\n                        log.warn(\"[{}] Error occurred while deleting corrupted file [{}] from [{}]\", indexPath, name, local, e);\n                    }\n                }\n            }\n            return fileSize;\n        }\n\n        @java.lang.Override\n        public void close() throws java.io.IOException {\n            executor.execute(new java.lang.Runnable() {\n                @java.lang.Override\n                public void run() {\n                    try {\n                        removeDeletedFiles();\n                    } catch (java.io.IOException e) {\n                        log.warn(\"[{}] Error occurred while removing deleted files from Local {}, Remote {}\", indexPath, local, remote, e);\n                    }\n                    try {\n                        local.close();\n                        remote.close();\n                    } catch (java.io.IOException e) {\n                        log.warn(\"[{}] Error occurred while closing directory \", indexPath, e);\n                    }\n                }\n            });\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            return java.lang.String.format(\"[COR] Local %s, Remote %s\", local, remote);\n        }\n\n        private void removeDeletedFiles() throws java.io.IOException {\n            java.util.Set<java.lang.String> filesToBeDeleted = com.google.common.collect.Sets.difference(com.google.common.collect.ImmutableSet.copyOf(localFileNames), com.google.common.collect.ImmutableSet.copyOf(remote.listAll()));\n            java.util.Set<java.lang.String> failedToDelete = com.google.common.collect.Sets.newHashSet();\n            for (java.lang.String fileName : filesToBeDeleted) {\n                boolean deleted = IndexCopier.this.deleteFile(local, fileName, true);\n                if (!deleted) {\n                    failedToDelete.add(fileName);\n                }\n            }\n            filesToBeDeleted = new java.util.HashSet<java.lang.String>(filesToBeDeleted);\n            filesToBeDeleted.removeAll(failedToDelete);\n            if (!filesToBeDeleted.isEmpty()) {\n                log.debug(\"[{}] Following files have been removed from Lucene index directory {}\", indexPath, filesToBeDeleted);\n            }\n        }\n\n        private class CORFileReference {\n            final java.lang.String name;\n\n            private volatile boolean valid;\n\n            private CORFileReference(java.lang.String name) {\n                this.name = name;\n            }\n\n            boolean isLocalValid() {\n                return valid;\n            }\n\n            org.apache.lucene.store.IndexInput openLocalInput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                readerLocalReadCount.incrementAndGet();\n                return local.openInput(name, context);\n            }\n\n            void markValid() {\n                this.valid = true;\n                localFileNames.add(name);\n            }\n        }\n    }\n\n    private class CopyOnWriteDirectory extends org.apache.lucene.store.FilterDirectory {\n        private final java.util.concurrent.Callable<java.lang.Void> STOP = new java.util.concurrent.Callable<java.lang.Void>() {\n            @java.lang.Override\n            public java.lang.Void call() throws java.lang.Exception {\n                return null;\n            }\n        };\n\n        private final org.apache.lucene.store.Directory remote;\n\n        private final org.apache.lucene.store.Directory local;\n\n        private final java.util.concurrent.ConcurrentMap<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference> fileMap = com.google.common.collect.Maps.newConcurrentMap();\n\n        private final java.util.Set<java.lang.String> deletedFilesLocal = com.google.common.collect.Sets.newConcurrentHashSet();\n\n        private final java.util.Set<java.lang.String> skippedFiles = com.google.common.collect.Sets.newConcurrentHashSet();\n\n        private final java.util.concurrent.BlockingQueue<java.util.concurrent.Callable<java.lang.Void>> queue = new java.util.concurrent.LinkedBlockingQueue<java.util.concurrent.Callable<java.lang.Void>>();\n\n        private final java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> errorInCopy = new java.util.concurrent.atomic.AtomicReference<java.lang.Throwable>();\n\n        private final java.util.concurrent.CountDownLatch copyDone = new java.util.concurrent.CountDownLatch(1);\n\n        private final boolean reindexMode;\n\n        private final java.lang.String indexPathForLogging;\n\n        private final java.util.Set<java.lang.String> sharedWorkingSet;\n\n        private volatile org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask currentTask = org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask.completed();\n\n        private final java.lang.Runnable completionHandler = new java.lang.Runnable() {\n            java.util.concurrent.Callable<java.lang.Void> task = new java.util.concurrent.Callable<java.lang.Void>() {\n                @java.lang.Override\n                public java.lang.Void call() throws java.lang.Exception {\n                    try {\n                        java.util.concurrent.Callable<java.lang.Void> task = queue.poll();\n                        if ((task != null) && (task != STOP)) {\n                            if (errorInCopy.get() != null) {\n                                log.trace(\"[COW][{}] Skipping task {} as some exception occurred in previous run\", indexPathForLogging, task);\n                            } else {\n                                task.call();\n                            }\n                            currentTask.onComplete(completionHandler);\n                        }\n                        if (task == STOP) {\n                            copyDone.countDown();\n                        }\n                    } catch (java.lang.Throwable t) {\n                        errorInCopy.set(t);\n                        log.debug(\"[COW][{}] Error occurred while copying files. Further processing would \" + \"be skipped\", indexPathForLogging, t);\n                        currentTask.onComplete(completionHandler);\n                    }\n                    return null;\n                }\n            };\n\n            @java.lang.Override\n            public void run() {\n                currentTask = new org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask(task);\n                try {\n                    executor.execute(currentTask);\n                } catch (java.util.concurrent.RejectedExecutionException e) {\n                    checkIfClosed(false);\n                    throw e;\n                }\n            }\n        };\n\n        public CopyOnWriteDirectory(org.apache.lucene.store.Directory remote, org.apache.lucene.store.Directory local, boolean reindexMode, java.lang.String indexPathForLogging, java.util.Set<java.lang.String> sharedWorkingSet) throws java.io.IOException {\n            super(local);\n            this.remote = remote;\n            this.local = local;\n            this.indexPathForLogging = indexPathForLogging;\n            this.reindexMode = reindexMode;\n            this.sharedWorkingSet = sharedWorkingSet;\n            initialize();\n        }\n\n        @java.lang.Override\n        public java.lang.String[] listAll() throws java.io.IOException {\n            return com.google.common.collect.Iterables.toArray(fileMap.keySet(), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public boolean fileExists(java.lang.String name) throws java.io.IOException {\n            return fileMap.containsKey(name);\n        }\n\n        @java.lang.Override\n        public void deleteFile(java.lang.String name) throws java.io.IOException {\n            log.trace(\"[COW][{}] Deleted file {}\", indexPathForLogging, name);\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.remove(name);\n            if (ref != null) {\n                ref.delete();\n            }\n        }\n\n        @java.lang.Override\n        public long fileLength(java.lang.String name) throws java.io.IOException {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.get(name);\n            if (ref == null) {\n                throw new java.io.FileNotFoundException(name);\n            }\n            return ref.fileLength();\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexOutput createOutput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.remove(name);\n            if (ref != null) {\n                ref.delete();\n            }\n            ref = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWLocalFileReference(name);\n            fileMap.put(name, ref);\n            sharedWorkingSet.add(name);\n            return ref.createOutput(context);\n        }\n\n        @java.lang.Override\n        public void sync(java.util.Collection<java.lang.String> names) throws java.io.IOException {\n            for (java.lang.String name : names) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference file = fileMap.get(name);\n                if (file != null) {\n                    file.sync();\n                }\n            }\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexInput openInput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.get(name);\n            if (ref == null) {\n                throw new java.io.FileNotFoundException(name);\n            }\n            return ref.openInput(context);\n        }\n\n        @java.lang.Override\n        public void close() throws java.io.IOException {\n            int pendingCopies = queue.size();\n            addTask(STOP);\n            try {\n                long start = PERF_LOGGER.start();\n                while (!copyDone.await(10, java.util.concurrent.TimeUnit.SECONDS)) {\n                    if (closed) {\n                        throw new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException((\"IndexCopier found to be closed \" + \"while processing copy task for\") + remote.toString());\n                    }\n                } \n                PERF_LOGGER.end(start, -1, \"[COW][{}] Completed pending copying task {}\", indexPathForLogging, pendingCopies);\n            } catch (java.lang.InterruptedException e) {\n                java.lang.Thread.currentThread().interrupt();\n                throw new java.io.IOException(e);\n            }\n            java.lang.Throwable t = errorInCopy.get();\n            if (t != null) {\n                throw new java.io.IOException(\"Error occurred while copying files for \" + indexPathForLogging, t);\n            }\n            com.google.common.base.Preconditions.checkArgument(queue.isEmpty(), \"Copy queue still \" + \"has pending task left [%d]. %s\", queue.size(), queue);\n            long skippedFilesSize = getSkippedFilesSize();\n            for (java.lang.String fileName : deletedFilesLocal) {\n                deleteLocalFile(fileName);\n            }\n            skippedFromUploadSize.addAndGet(skippedFilesSize);\n            java.lang.String msg = \"[COW][{}] CopyOnWrite stats : Skipped copying {} files with total size {}\";\n            if (reindexMode || (skippedFilesSize > (10 * org.apache.commons.io.FileUtils.ONE_MB))) {\n                log.info(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\n            } else {\n                log.debug(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\n            }\n            if (log.isTraceEnabled()) {\n                log.trace(\"[COW][{}] File listing - Upon completion {}\", indexPathForLogging, java.util.Arrays.toString(remote.listAll()));\n            }\n            local.close();\n            remote.close();\n            sharedWorkingSet.clear();\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            return java.lang.String.format(\"[COW][%s] Local %s, Remote %s\", indexPathForLogging, local, remote);\n        }\n\n        private long getSkippedFilesSize() {\n            long size = 0;\n            for (java.lang.String name : skippedFiles) {\n                try {\n                    if (local.fileExists(name)) {\n                        size += local.fileLength(name);\n                    }\n                } catch (java.lang.Exception ignore) {\n                }\n            }\n            return size;\n        }\n\n        private void deleteLocalFile(java.lang.String fileName) {\n            IndexCopier.this.deleteFile(local, fileName, false);\n        }\n\n        private void initialize() throws java.io.IOException {\n            for (java.lang.String name : remote.listAll()) {\n                fileMap.put(name, new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWRemoteFileReference(name));\n            }\n            if (log.isTraceEnabled()) {\n                log.trace(\"[COW][{}] File listing - At start {}\", indexPathForLogging, java.util.Arrays.toString(remote.listAll()));\n            }\n        }\n\n        private void addCopyTask(final java.lang.String name) {\n            updateMaxScheduled(scheduledForCopyCount.incrementAndGet());\n            addTask(new java.util.concurrent.Callable<java.lang.Void>() {\n                @java.lang.Override\n                public java.lang.Void call() throws java.lang.Exception {\n                    scheduledForCopyCount.decrementAndGet();\n                    if (deletedFilesLocal.contains(name)) {\n                        skippedFiles.add(name);\n                        log.trace(\"[COW][{}] Skip copying of deleted file {}\", indexPathForLogging, name);\n                        return null;\n                    }\n                    long fileSize = local.fileLength(name);\n                    org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile(local, name, fileSize, false);\n                    long perfStart = PERF_LOGGER.start();\n                    long start = startCopy(file);\n                    local.copy(remote, name, name, IOContext.DEFAULT);\n                    doneCopy(file, start);\n                    PERF_LOGGER.end(perfStart, 0, \"[COW][{}] Copied to remote {} \", indexPathForLogging, name);\n                    return null;\n                }\n\n                @java.lang.Override\n                public java.lang.String toString() {\n                    return \"Copy: \" + name;\n                }\n            });\n        }\n\n        private void addDeleteTask(final java.lang.String name) {\n            addTask(new java.util.concurrent.Callable<java.lang.Void>() {\n                @java.lang.Override\n                public java.lang.Void call() throws java.lang.Exception {\n                    if (!skippedFiles.contains(name)) {\n                        log.trace(\"[COW][{}] Marking as deleted {}\", indexPathForLogging, name);\n                        remote.deleteFile(name);\n                    }\n                    return null;\n                }\n\n                @java.lang.Override\n                public java.lang.String toString() {\n                    return \"Delete : \" + name;\n                }\n            });\n        }\n\n        private void addTask(java.util.concurrent.Callable<java.lang.Void> task) {\n            checkIfClosed(true);\n            queue.add(task);\n            currentTask.onComplete(completionHandler);\n        }\n\n        private void checkIfClosed(boolean throwException) {\n            if (closed) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException e = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException((\"IndexCopier found to be closed \" + \"while processing\") + remote.toString());\n                errorInCopy.set(e);\n                copyDone.countDown();\n                if (throwException) {\n                    throw e;\n                }\n            }\n        }\n\n        private abstract class COWFileReference {\n            protected final java.lang.String name;\n\n            public COWFileReference(java.lang.String name) {\n                this.name = name;\n            }\n\n            public abstract long fileLength() throws java.io.IOException;\n\n            public abstract org.apache.lucene.store.IndexInput openInput(org.apache.lucene.store.IOContext context) throws java.io.IOException;\n\n            public abstract org.apache.lucene.store.IndexOutput createOutput(org.apache.lucene.store.IOContext context) throws java.io.IOException;\n\n            public abstract void delete() throws java.io.IOException;\n\n            public void sync() throws java.io.IOException {\n            }\n        }\n\n        private class COWRemoteFileReference extends org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference {\n            private boolean validLocalCopyPresent;\n\n            private final long length;\n\n            public COWRemoteFileReference(java.lang.String name) throws java.io.IOException {\n                super(name);\n                this.length = remote.fileLength(name);\n            }\n\n            @java.lang.Override\n            public long fileLength() throws java.io.IOException {\n                return length;\n            }\n\n            @java.lang.Override\n            public org.apache.lucene.store.IndexInput openInput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                checkIfLocalValid();\n                if (validLocalCopyPresent && (!org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.REMOTE_ONLY.contains(name))) {\n                    writerLocalReadCount.incrementAndGet();\n                    return local.openInput(name, context);\n                }\n                writerRemoteReadCount.incrementAndGet();\n                return remote.openInput(name, context);\n            }\n\n            @java.lang.Override\n            public org.apache.lucene.store.IndexOutput createOutput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                throw new java.lang.UnsupportedOperationException(\"Cannot create output for existing remote file \" + name);\n            }\n\n            @java.lang.Override\n            public void delete() throws java.io.IOException {\n                addDeleteTask(name);\n            }\n\n            private void checkIfLocalValid() throws java.io.IOException {\n                validLocalCopyPresent = local.fileExists(name) && (local.fileLength(name) == remote.fileLength(name));\n            }\n        }\n\n        private class COWLocalFileReference extends org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference {\n            public COWLocalFileReference(java.lang.String name) {\n                super(name);\n            }\n\n            @java.lang.Override\n            public long fileLength() throws java.io.IOException {\n                return local.fileLength(name);\n            }\n\n            @java.lang.Override\n            public org.apache.lucene.store.IndexInput openInput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                return local.openInput(name, context);\n            }\n\n            @java.lang.Override\n            public org.apache.lucene.store.IndexOutput createOutput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                log.debug(\"[COW][{}] Creating output {}\", indexPathForLogging, name);\n                return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWLocalFileReference.CopyOnCloseIndexOutput(local.createOutput(name, context));\n            }\n\n            @java.lang.Override\n            public void delete() throws java.io.IOException {\n                addDeleteTask(name);\n                deletedFilesLocal.add(name);\n            }\n\n            @java.lang.Override\n            public void sync() throws java.io.IOException {\n                local.sync(java.util.Collections.singleton(name));\n            }\n\n            private class CopyOnCloseIndexOutput extends org.apache.lucene.store.IndexOutput {\n                private final org.apache.lucene.store.IndexOutput delegate;\n\n                public CopyOnCloseIndexOutput(org.apache.lucene.store.IndexOutput delegate) {\n                    this.delegate = delegate;\n                }\n\n                @java.lang.Override\n                public void flush() throws java.io.IOException {\n                    delegate.flush();\n                }\n\n                @java.lang.Override\n                public void close() throws java.io.IOException {\n                    delegate.close();\n                    addCopyTask(name);\n                }\n\n                @java.lang.Override\n                public long getFilePointer() {\n                    return delegate.getFilePointer();\n                }\n\n                @java.lang.Override\n                public void seek(long pos) throws java.io.IOException {\n                    delegate.seek(pos);\n                }\n\n                @java.lang.Override\n                public long length() throws java.io.IOException {\n                    return delegate.length();\n                }\n\n                @java.lang.Override\n                public void writeByte(byte b) throws java.io.IOException {\n                    delegate.writeByte(b);\n                }\n\n                @java.lang.Override\n                public void writeBytes(byte[] b, int offset, int length) throws java.io.IOException {\n                    delegate.writeBytes(b, offset, length);\n                }\n\n                @java.lang.Override\n                public void setLength(long length) throws java.io.IOException {\n                    delegate.setLength(length);\n                }\n            }\n        }\n    }\n\n    private boolean deleteFile(org.apache.lucene.store.Directory dir, java.lang.String fileName, boolean copiedFromRemote) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile(dir, fileName, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getFileLength(dir, fileName), copiedFromRemote);\n        boolean successFullyDeleted = false;\n        try {\n            boolean fileExisted = false;\n            if (dir.fileExists(fileName)) {\n                fileExisted = true;\n                dir.deleteFile(fileName);\n            }\n            successfullyDeleted(file, fileExisted);\n            successFullyDeleted = true;\n        } catch (java.io.IOException e) {\n            failedToDelete(file);\n            log.debug(\"Error occurred while removing deleted file {} from Local {}. \" + \"Attempt would be made to delete it on next run \", fileName, dir, e);\n        }\n        return successFullyDeleted;\n    }\n\n    private long startCopy(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file) {\n        updateMaxInProgress(copyInProgressCount.incrementAndGet());\n        copyInProgressSize.addAndGet(file.size);\n        copyInProgressFiles.add(file);\n        return java.lang.System.currentTimeMillis();\n    }\n\n    private void doneCopy(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file, long start) {\n        copyInProgressFiles.remove(file);\n        copyInProgressCount.decrementAndGet();\n        copyInProgressSize.addAndGet(-file.size);\n        if (file.copyFromRemote) {\n            downloadTime.addAndGet(java.lang.System.currentTimeMillis() - start);\n            downloadSize.addAndGet(file.size);\n            downloadCount.incrementAndGet();\n        } else {\n            uploadSize.addAndGet(file.size);\n            uploadTime.addAndGet(java.lang.System.currentTimeMillis() - start);\n            uploadCount.incrementAndGet();\n        }\n    }\n\n    private void updateMaxScheduled(int val) {\n        synchronized(maxScheduledForCopyCount) {\n            int current = maxScheduledForCopyCount.get();\n            if (val > current) {\n                maxScheduledForCopyCount.set(val);\n            }\n        }\n    }\n\n    private void updateMaxInProgress(int val) {\n        synchronized(maxCopyInProgressCount) {\n            int current = maxCopyInProgressCount.get();\n            if (val > current) {\n                maxCopyInProgressCount.set(val);\n            }\n        }\n    }\n\n    private class DeleteOldDirOnClose extends org.apache.lucene.store.FilterDirectory {\n        private final java.io.File oldIndexDir;\n\n        protected DeleteOldDirOnClose(org.apache.lucene.store.Directory in, java.io.File oldIndexDir) {\n            super(in);\n            this.oldIndexDir = oldIndexDir;\n        }\n\n        @java.lang.Override\n        public void close() throws java.io.IOException {\n            try {\n                super.close();\n            } finally {\n                try {\n                    org.apache.commons.io.FileUtils.deleteDirectory(oldIndexDir);\n                    log.debug(\"Removed old index content from {} \", oldIndexDir);\n                } catch (java.io.IOException e) {\n                    log.warn(\"Not able to remove old version of copied index at {}\", oldIndexDir, e);\n                }\n            }\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            return \"DeleteOldDirOnClose wrapper for \" + getDelegate();\n        }\n    }\n\n    static final class LocalIndexFile {\n        final java.io.File dir;\n\n        final java.lang.String name;\n\n        final long size;\n\n        final boolean copyFromRemote;\n\n        private volatile int deleteAttemptCount;\n\n        final long creationTime = java.lang.System.currentTimeMillis();\n\n        public LocalIndexFile(org.apache.lucene.store.Directory dir, java.lang.String fileName, long size, boolean copyFromRemote) {\n            this.copyFromRemote = copyFromRemote;\n            this.dir = org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getFSDir(dir);\n            this.name = fileName;\n            this.size = size;\n        }\n\n        public LocalIndexFile(org.apache.lucene.store.Directory dir, java.lang.String fileName) {\n            this(dir, fileName, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getFileLength(dir, fileName), true);\n        }\n\n        public java.lang.String getKey() {\n            if (dir != null) {\n                return new java.io.File(dir, name).getAbsolutePath();\n            }\n            return name;\n        }\n\n        public void incrementAttemptToDelete() {\n            deleteAttemptCount++;\n        }\n\n        public int getDeleteAttemptCount() {\n            return deleteAttemptCount;\n        }\n\n        public java.lang.String deleteLog() {\n            return java.lang.String.format(\"%s (%s, %d attempts, %d s)\", name, humanReadableByteCount(size), deleteAttemptCount, timeTaken());\n        }\n\n        public java.lang.String copyLog() {\n            return java.lang.String.format(\"%s (%s, %1.1f%%, %s, %d s)\", name, humanReadableByteCount(actualSize()), copyProgress(), humanReadableByteCount(size), timeTaken());\n        }\n\n        @java.lang.Override\n        public boolean equals(java.lang.Object o) {\n            if (this == o) {\n                return true;\n            }\n            if ((o == null) || (getClass() != o.getClass())) {\n                return false;\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile localIndexFile = ((org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile) (o));\n            if (dir != null ? !dir.equals(localIndexFile.dir) : localIndexFile.dir != null) {\n                return false;\n            }\n            return name.equals(localIndexFile.name);\n        }\n\n        @java.lang.Override\n        public int hashCode() {\n            int result = (dir != null) ? dir.hashCode() : 0;\n            result = (31 * result) + name.hashCode();\n            return result;\n        }\n\n        private long timeTaken() {\n            return java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(java.lang.System.currentTimeMillis() - creationTime);\n        }\n\n        private float copyProgress() {\n            return ((actualSize() * 1.0F) / size) * 100;\n        }\n\n        private long actualSize() {\n            return dir != null ? new java.io.File(dir, name).length() : 0;\n        }\n    }\n\n    static java.io.File getFSDir(org.apache.lucene.store.Directory dir) {\n        if (dir instanceof org.apache.lucene.store.FilterDirectory) {\n            dir = ((org.apache.lucene.store.FilterDirectory) (dir)).getDelegate();\n        }\n        if (dir instanceof org.apache.lucene.store.FSDirectory) {\n            return ((org.apache.lucene.store.FSDirectory) (dir)).getDirectory();\n        }\n        return null;\n    }\n\n    private static long getFileLength(org.apache.lucene.store.Directory dir, java.lang.String fileName) {\n        try {\n            return dir.fileLength(fileName);\n        } catch (java.lang.Exception e) {\n            return -1;\n        }\n    }\n\n    @java.lang.Override\n    public javax.management.openmbean.TabularData getIndexPathMapping() {\n        javax.management.openmbean.TabularDataSupport tds;\n        try {\n            javax.management.openmbean.TabularType tt = new javax.management.openmbean.TabularType(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.class.getName(), \"Lucene Index Stats\", org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.TYPE, new java.lang.String[]{ \"jcrPath\" });\n            tds = new javax.management.openmbean.TabularDataSupport(tt);\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> e : indexPathMapping.entrySet()) {\n                java.lang.String size = humanReadableByteCount(org.apache.commons.io.FileUtils.sizeOfDirectory(new java.io.File(e.getValue())));\n                tds.put(new javax.management.openmbean.CompositeDataSupport(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.TYPE, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.FIELD_NAMES, new java.lang.String[]{ e.getKey(), e.getValue(), size }));\n            }\n        } catch (javax.management.openmbean.OpenDataException e) {\n            throw new java.lang.IllegalStateException(e);\n        }\n        return tds;\n    }\n\n    @java.lang.Override\n    public boolean isPrefetchEnabled() {\n        return prefetchEnabled;\n    }\n\n    @java.lang.Override\n    public int getReaderLocalReadCount() {\n        return readerLocalReadCount.get();\n    }\n\n    @java.lang.Override\n    public int getReaderRemoteReadCount() {\n        return readerRemoteReadCount.get();\n    }\n\n    @java.lang.Override\n    public int getWriterLocalReadCount() {\n        return writerLocalReadCount.get();\n    }\n\n    @java.lang.Override\n    public int getWriterRemoteReadCount() {\n        return writerRemoteReadCount.get();\n    }\n\n    public int getInvalidFileCount() {\n        return invalidFileCount.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getDownloadSize() {\n        return humanReadableByteCount(downloadSize.get());\n    }\n\n    @java.lang.Override\n    public long getDownloadTime() {\n        return downloadTime.get();\n    }\n\n    @java.lang.Override\n    public int getDownloadCount() {\n        return downloadCount.get();\n    }\n\n    @java.lang.Override\n    public int getUploadCount() {\n        return uploadCount.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getUploadSize() {\n        return humanReadableByteCount(uploadSize.get());\n    }\n\n    @java.lang.Override\n    public long getUploadTime() {\n        return uploadTime.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getLocalIndexSize() {\n        return humanReadableByteCount(org.apache.commons.io.FileUtils.sizeOfDirectory(indexRootDir));\n    }\n\n    @java.lang.Override\n    public java.lang.String[] getGarbageDetails() {\n        return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(failedToDeleteFiles.values(), new com.google.common.base.Function<org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile, java.lang.String>() {\n            @java.lang.Override\n            public java.lang.String apply(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile input) {\n                return input.deleteLog();\n            }\n        }), java.lang.String.class);\n    }\n\n    @java.lang.Override\n    public java.lang.String getGarbageSize() {\n        long garbageSize = 0;\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile failedToDeleteFile : failedToDeleteFiles.values()) {\n            garbageSize += failedToDeleteFile.size;\n        }\n        return humanReadableByteCount(garbageSize);\n    }\n\n    @java.lang.Override\n    public int getScheduledForCopyCount() {\n        return scheduledForCopyCount.get();\n    }\n\n    @java.lang.Override\n    public int getCopyInProgressCount() {\n        return copyInProgressCount.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getCopyInProgressSize() {\n        return humanReadableByteCount(copyInProgressSize.get());\n    }\n\n    @java.lang.Override\n    public int getMaxCopyInProgressCount() {\n        return maxCopyInProgressCount.get();\n    }\n\n    @java.lang.Override\n    public int getMaxScheduledForCopyCount() {\n        return maxScheduledForCopyCount.get();\n    }\n\n    public java.lang.String getSkippedFromUploadSize() {\n        return humanReadableByteCount(skippedFromUploadSize.get());\n    }\n\n    @java.lang.Override\n    public java.lang.String[] getCopyInProgressDetails() {\n        return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(copyInProgressFiles, new com.google.common.base.Function<org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile, java.lang.String>() {\n            @java.lang.Override\n            public java.lang.String apply(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile input) {\n                return input.copyLog();\n            }\n        }), java.lang.String.class);\n    }\n\n    @java.lang.Override\n    public int getDeletedFilesCount() {\n        return deletedFileCount.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getGarbageCollectedSize() {\n        return humanReadableByteCount(garbageCollectedSize.get());\n    }\n\n    private static class IndexMappingData {\n        static final java.lang.String[] FIELD_NAMES = new java.lang.String[]{ \"jcrPath\", \"fsPath\", \"size\" };\n\n        static final java.lang.String[] FIELD_DESCRIPTIONS = new java.lang.String[]{ \"JCR Path\", \"Filesystem Path\", \"Size\" };\n\n        static final javax.management.openmbean.OpenType[] FIELD_TYPES = new javax.management.openmbean.OpenType[]{ javax.management.openmbean.SimpleType.STRING, javax.management.openmbean.SimpleType.STRING, javax.management.openmbean.SimpleType.STRING };\n\n        static final javax.management.openmbean.CompositeType TYPE = org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.createCompositeType();\n\n        static javax.management.openmbean.CompositeType createCompositeType() {\n            try {\n                return new javax.management.openmbean.CompositeType(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.class.getName(), \"Composite data type for Index Mapping Data\", org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.FIELD_NAMES, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.FIELD_DESCRIPTIONS, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.FIELD_TYPES);\n            } catch (javax.management.openmbean.OpenDataException e) {\n                throw new java.lang.IllegalStateException(e);\n            }\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private java.util.Set<java.lang.String> getSharedWorkingSet(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition defn) {\n    java.lang.String indexPath = defn.getIndexPathFromConfig();\n    if (indexPath == null) {\n        return new java.util.HashSet<java.lang.String>();\n    }\n    java.util.Set<java.lang.String> sharedSet;\n    synchronized(sharedWorkingSetMap) {\n        sharedSet = sharedWorkingSetMap.get(indexPath);\n        if (sharedSet == null) {\n            sharedSet = com.google.common.collect.Sets.newConcurrentHashSet();\n            sharedWorkingSetMap.put(indexPath, sharedSet);\n        }\n    }\n    return sharedSet;\n}",
            "src_parent": "public class IndexCopier implements java.io.Closeable , org.apache.jackrabbit.oak.plugins.index.lucene.CopyOnReadStatsMBean {\n    private static final java.util.Set<java.lang.String> REMOTE_ONLY = com.google.common.collect.ImmutableSet.of(\"segments.gen\");\n\n    private static final int MAX_FAILURE_ENTRIES = 10000;\n\n    private static final java.util.concurrent.atomic.AtomicInteger UNIQUE_COUNTER = new java.util.concurrent.atomic.AtomicInteger();\n\n    private static final java.lang.String WORK_DIR_NAME = \"indexWriterDir\";\n\n    private final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(getClass());\n\n    private final org.apache.jackrabbit.oak.util.PerfLogger PERF_LOGGER = new org.apache.jackrabbit.oak.util.PerfLogger(org.slf4j.LoggerFactory.getLogger(log.getName() + \".perf\"));\n\n    private final java.util.concurrent.Executor executor;\n\n    private final java.io.File indexRootDir;\n\n    private final java.io.File indexWorkDir;\n\n    private final java.util.concurrent.atomic.AtomicInteger readerLocalReadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger writerLocalReadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger readerRemoteReadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger writerRemoteReadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger invalidFileCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger deletedFileCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger scheduledForCopyCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger copyInProgressCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger maxCopyInProgressCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger maxScheduledForCopyCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger uploadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicInteger downloadCount = new java.util.concurrent.atomic.AtomicInteger();\n\n    private final java.util.concurrent.atomic.AtomicLong copyInProgressSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong downloadSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong uploadSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong garbageCollectedSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong skippedFromUploadSize = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong downloadTime = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.concurrent.atomic.AtomicLong uploadTime = new java.util.concurrent.atomic.AtomicLong();\n\n    private final java.util.Map<java.lang.String, java.lang.String> indexPathMapping = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Map<java.lang.String, java.util.Set<java.lang.String>> sharedWorkingSetMap = com.google.common.collect.Maps.newHashMap();\n\n    private final java.util.Map<java.lang.String, java.lang.String> indexPathVersionMapping = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.concurrent.ConcurrentMap<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile> failedToDeleteFiles = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Set<org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile> copyInProgressFiles = java.util.Collections.newSetFromMap(new java.util.concurrent.ConcurrentHashMap<org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile, java.lang.Boolean>());\n\n    private final boolean prefetchEnabled;\n\n    private volatile boolean closed;\n\n    public IndexCopier(java.util.concurrent.Executor executor, java.io.File indexRootDir) throws java.io.IOException {\n        this(executor, indexRootDir, false);\n    }\n\n    public IndexCopier(java.util.concurrent.Executor executor, java.io.File indexRootDir, boolean prefetchEnabled) throws java.io.IOException {\n        this.executor = executor;\n        this.indexRootDir = indexRootDir;\n        this.prefetchEnabled = prefetchEnabled;\n        this.indexWorkDir = org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.initializerWorkDir(indexRootDir);\n    }\n\n    public org.apache.lucene.store.Directory wrapForRead(java.lang.String indexPath, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition definition, org.apache.lucene.store.Directory remote) throws java.io.IOException {\n        org.apache.lucene.store.Directory local = createLocalDirForIndexReader(indexPath, definition);\n        return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory(remote, local, prefetchEnabled, indexPath, getSharedWorkingSet(definition));\n    }\n\n    public org.apache.lucene.store.Directory wrapForWrite(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition definition, org.apache.lucene.store.Directory remote, boolean reindexMode) throws java.io.IOException {\n        org.apache.lucene.store.Directory local = createLocalDirForIndexWriter(definition);\n        return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory(remote, local, reindexMode, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getIndexPathForLogging(definition), getSharedWorkingSet(definition));\n    }\n\n    @java.lang.Override\n    public void close() throws java.io.IOException {\n        this.closed = true;\n    }\n\n    java.io.File getIndexWorkDir() {\n        return indexWorkDir;\n    }\n\n    java.io.File getIndexRootDir() {\n        return indexRootDir;\n    }\n\n    protected org.apache.lucene.store.Directory createLocalDirForIndexWriter(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition definition) throws java.io.IOException {\n        java.lang.String indexPath = definition.getIndexPathFromConfig();\n        java.io.File indexWriterDir;\n        if (indexPath == null) {\n            indexWriterDir = new java.io.File(indexWorkDir, java.lang.String.valueOf(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.UNIQUE_COUNTER.incrementAndGet()));\n        } else {\n            java.io.File indexDir = getIndexDir(indexPath);\n            java.lang.String newVersion = java.lang.String.valueOf(definition.getReindexCount());\n            indexWriterDir = getVersionedDir(indexPath, indexDir, newVersion);\n        }\n        org.apache.lucene.store.Directory dir = org.apache.lucene.store.FSDirectory.open(indexWriterDir, org.apache.lucene.store.NoLockFactory.getNoLockFactory());\n        log.debug(\"IndexWriter would use {}\", indexWriterDir);\n        if (indexPath == null) {\n            dir = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.DeleteOldDirOnClose(dir, indexWriterDir);\n            log.debug(\"IndexPath [{}] not configured in index definition {}. Writer would create index \" + (\"files in temporary dir {} which would be deleted upon close. For better performance do \" + \"configure the 'indexPath' as part of your index definition\"), LuceneIndexConstants.INDEX_PATH, definition, indexWriterDir);\n        }\n        return dir;\n    }\n\n    protected org.apache.lucene.store.Directory createLocalDirForIndexReader(java.lang.String indexPath, org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition definition) throws java.io.IOException {\n        java.io.File indexDir = getIndexDir(indexPath);\n        java.lang.String newVersion = java.lang.String.valueOf(definition.getReindexCount());\n        java.io.File versionedIndexDir = getVersionedDir(indexPath, indexDir, newVersion);\n        org.apache.lucene.store.Directory result = org.apache.lucene.store.FSDirectory.open(versionedIndexDir);\n        java.lang.String oldVersion = indexPathVersionMapping.put(indexPath, newVersion);\n        if ((!newVersion.equals(oldVersion)) && (oldVersion != null)) {\n            result = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.DeleteOldDirOnClose(result, new java.io.File(indexDir, oldVersion));\n        }\n        return result;\n    }\n\n    private java.io.File getVersionedDir(java.lang.String indexPath, java.io.File indexDir, java.lang.String newVersion) {\n        java.io.File versionedIndexDir = new java.io.File(indexDir, newVersion);\n        if (!versionedIndexDir.exists()) {\n            com.google.common.base.Preconditions.checkState(versionedIndexDir.mkdirs(), \"Cannot create directory %s\", versionedIndexDir);\n        }\n        indexPathMapping.put(indexPath, indexDir.getAbsolutePath());\n        return versionedIndexDir;\n    }\n\n    public java.io.File getIndexDir(java.lang.String indexPath) {\n        java.lang.String subDir = com.google.common.hash.Hashing.sha256().hashString(indexPath, com.google.common.base.Charsets.UTF_8).toString();\n        return new java.io.File(indexRootDir, subDir);\n    }\n\n    java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile> getFailedToDeleteFiles() {\n        return java.util.Collections.unmodifiableMap(failedToDeleteFiles);\n    }\n\n    private void failedToDelete(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file) {\n        if (failedToDeleteFiles.size() < org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.MAX_FAILURE_ENTRIES) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile failedToDeleteFile = failedToDeleteFiles.putIfAbsent(file.getKey(), file);\n            if (failedToDeleteFile == null) {\n                failedToDeleteFile = file;\n            }\n            failedToDeleteFile.incrementAttemptToDelete();\n        } else {\n            log.warn(\"Not able to delete {}. Currently more than {} file with total size {} are pending delete.\", file.deleteLog(), failedToDeleteFiles.size(), getGarbageSize());\n        }\n    }\n\n    private void successfullyDeleted(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file, boolean fileExisted) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile failedToDeleteFile = failedToDeleteFiles.remove(file.getKey());\n        if (failedToDeleteFile != null) {\n            log.debug(\"Deleted : {}\", failedToDeleteFile.deleteLog());\n        }\n        if (fileExisted) {\n            garbageCollectedSize.addAndGet(file.size);\n            deletedFileCount.incrementAndGet();\n        }\n    }\n\n    private java.util.Set<java.lang.String> getSharedWorkingSet(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition defn) {\n        java.lang.String indexPath = defn.getIndexPathFromConfig();\n        if (indexPath == null) {\n            return new java.util.HashSet<java.lang.String>();\n        }\n        java.util.Set<java.lang.String> sharedSet;\n        synchronized(sharedWorkingSetMap) {\n            sharedSet = sharedWorkingSetMap.get(indexPath);\n            if (sharedSet == null) {\n                sharedSet = com.google.common.collect.Sets.newConcurrentHashSet();\n                sharedWorkingSetMap.put(indexPath, sharedSet);\n            }\n        }\n        return sharedSet;\n    }\n\n    private static java.io.File initializerWorkDir(java.io.File indexRootDir) throws java.io.IOException {\n        java.io.File workDir = new java.io.File(indexRootDir, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.WORK_DIR_NAME);\n        org.apache.commons.io.FileUtils.deleteDirectory(workDir);\n        com.google.common.base.Preconditions.checkState(workDir.mkdirs(), \"Cannot create directory %s\", workDir);\n        return workDir;\n    }\n\n    private static java.lang.String getIndexPathForLogging(org.apache.jackrabbit.oak.plugins.index.lucene.IndexDefinition defn) {\n        java.lang.String indexPath = defn.getIndexPathFromConfig();\n        if (indexPath == null) {\n            return \"UNKNOWN\";\n        }\n        return indexPath;\n    }\n\n    private class CopyOnReadDirectory extends org.apache.lucene.store.FilterDirectory {\n        private final org.apache.lucene.store.Directory remote;\n\n        private final org.apache.lucene.store.Directory local;\n\n        private final java.lang.String indexPath;\n\n        private final java.util.concurrent.ConcurrentMap<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference> files = com.google.common.collect.Maps.newConcurrentMap();\n\n        private final java.util.Set<java.lang.String> localFileNames = com.google.common.collect.Sets.newConcurrentHashSet();\n\n        public CopyOnReadDirectory(org.apache.lucene.store.Directory remote, org.apache.lucene.store.Directory local, boolean prefetch, java.lang.String indexPath, java.util.Set<java.lang.String> sharedWorkingSet) throws java.io.IOException {\n            super(remote);\n            this.remote = remote;\n            this.local = local;\n            this.indexPath = indexPath;\n            this.localFileNames.addAll(java.util.Arrays.asList(local.listAll()));\n            this.localFileNames.removeAll(sharedWorkingSet);\n            if (prefetch) {\n                prefetchIndexFiles();\n            }\n        }\n\n        @java.lang.Override\n        public void deleteFile(java.lang.String name) throws java.io.IOException {\n            throw new java.lang.UnsupportedOperationException(\"Cannot delete in a ReadOnly directory\");\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexOutput createOutput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            throw new java.lang.UnsupportedOperationException(\"Cannot write in a ReadOnly directory\");\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexInput openInput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            if (org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.REMOTE_ONLY.contains(name)) {\n                log.trace(\"[{}] opening remote only file {}\", indexPath, name);\n                return remote.openInput(name, context);\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference ref = files.get(name);\n            if (ref != null) {\n                if (ref.isLocalValid()) {\n                    log.trace(\"[{}] opening existing local file {}\", indexPath, name);\n                    return files.get(name).openLocalInput(context);\n                } else {\n                    readerRemoteReadCount.incrementAndGet();\n                    log.trace(\"[{}] opening existing remote file as local version is not valid {}\", indexPath, name);\n                    return remote.openInput(name, context);\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference toPut = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference(name);\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference old = files.putIfAbsent(name, toPut);\n            if (old == null) {\n                log.trace(\"[{}] scheduled local copy for {}\", indexPath, name);\n                copy(toPut);\n            }\n            if (toPut.isLocalValid()) {\n                log.trace(\"[{}] opening new local file {}\", indexPath, name);\n                return toPut.openLocalInput(context);\n            }\n            log.trace(\"[{}] opening new remote file {}\", indexPath, name);\n            readerRemoteReadCount.incrementAndGet();\n            return remote.openInput(name, context);\n        }\n\n        private void copy(final org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference reference) {\n            updateMaxScheduled(scheduledForCopyCount.incrementAndGet());\n            executor.execute(new java.lang.Runnable() {\n                @java.lang.Override\n                public void run() {\n                    scheduledForCopyCount.decrementAndGet();\n                    copyFilesToLocal(reference, true);\n                }\n            });\n        }\n\n        private void prefetchIndexFiles() throws java.io.IOException {\n            long start = PERF_LOGGER.start();\n            long totalSize = 0;\n            int copyCount = 0;\n            for (java.lang.String name : remote.listAll()) {\n                if (org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.REMOTE_ONLY.contains(name)) {\n                    continue;\n                }\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference fileRef = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference(name);\n                files.putIfAbsent(name, fileRef);\n                long fileSize = copyFilesToLocal(fileRef, false);\n                if (fileSize > 0) {\n                    copyCount++;\n                    totalSize += fileSize;\n                }\n            }\n            PERF_LOGGER.end(start, -1, \"[{}] Copied {} files totaling {}\", indexPath, copyCount, humanReadableByteCount(totalSize));\n        }\n\n        private long copyFilesToLocal(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnReadDirectory.CORFileReference reference, boolean logDuration) {\n            java.lang.String name = reference.name;\n            boolean success = false;\n            boolean copyAttempted = false;\n            long fileSize = 0;\n            try {\n                if (!local.fileExists(name)) {\n                    long perfStart = -1;\n                    if (logDuration) {\n                        perfStart = PERF_LOGGER.start();\n                    }\n                    fileSize = remote.fileLength(name);\n                    org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile(local, name, fileSize, true);\n                    long start = startCopy(file);\n                    copyAttempted = true;\n                    remote.copy(local, name, name, IOContext.READ);\n                    reference.markValid();\n                    doneCopy(file, start);\n                    if (logDuration) {\n                        PERF_LOGGER.end(perfStart, 0, \"[{}] Copied file {} of size {}\", indexPath, name, humanReadableByteCount(fileSize));\n                    }\n                } else {\n                    long localLength = local.fileLength(name);\n                    long remoteLength = remote.fileLength(name);\n                    if (localLength != remoteLength) {\n                        log.warn(\"[{}] Found local copy for {} in {} but size of local {} differs from remote {}. \" + \"Content would be read from remote file only\", indexPath, name, local, localLength, remoteLength);\n                        invalidFileCount.incrementAndGet();\n                    } else {\n                        reference.markValid();\n                        log.trace(\"[{}] found local copy of file {}\", indexPath, name);\n                    }\n                }\n                success = true;\n            } catch (java.io.IOException e) {\n                log.warn(\"[{}] Error occurred while copying file [{}] from {} to {}\", indexPath, name, remote, local, e);\n            } finally {\n                if (copyAttempted && (!success)) {\n                    try {\n                        if (local.fileExists(name)) {\n                            local.deleteFile(name);\n                        }\n                    } catch (java.io.IOException e) {\n                        log.warn(\"[{}] Error occurred while deleting corrupted file [{}] from [{}]\", indexPath, name, local, e);\n                    }\n                }\n            }\n            return fileSize;\n        }\n\n        @java.lang.Override\n        public void close() throws java.io.IOException {\n            executor.execute(new java.lang.Runnable() {\n                @java.lang.Override\n                public void run() {\n                    try {\n                        removeDeletedFiles();\n                    } catch (java.io.IOException e) {\n                        log.warn(\"[{}] Error occurred while removing deleted files from Local {}, Remote {}\", indexPath, local, remote, e);\n                    }\n                    try {\n                        local.close();\n                        remote.close();\n                    } catch (java.io.IOException e) {\n                        log.warn(\"[{}] Error occurred while closing directory \", indexPath, e);\n                    }\n                }\n            });\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            return java.lang.String.format(\"[COR] Local %s, Remote %s\", local, remote);\n        }\n\n        private void removeDeletedFiles() throws java.io.IOException {\n            java.util.Set<java.lang.String> filesToBeDeleted = com.google.common.collect.Sets.difference(com.google.common.collect.ImmutableSet.copyOf(localFileNames), com.google.common.collect.ImmutableSet.copyOf(remote.listAll()));\n            java.util.Set<java.lang.String> failedToDelete = com.google.common.collect.Sets.newHashSet();\n            for (java.lang.String fileName : filesToBeDeleted) {\n                boolean deleted = IndexCopier.this.deleteFile(local, fileName, true);\n                if (!deleted) {\n                    failedToDelete.add(fileName);\n                }\n            }\n            filesToBeDeleted = new java.util.HashSet<java.lang.String>(filesToBeDeleted);\n            filesToBeDeleted.removeAll(failedToDelete);\n            if (!filesToBeDeleted.isEmpty()) {\n                log.debug(\"[{}] Following files have been removed from Lucene index directory {}\", indexPath, filesToBeDeleted);\n            }\n        }\n\n        private class CORFileReference {\n            final java.lang.String name;\n\n            private volatile boolean valid;\n\n            private CORFileReference(java.lang.String name) {\n                this.name = name;\n            }\n\n            boolean isLocalValid() {\n                return valid;\n            }\n\n            org.apache.lucene.store.IndexInput openLocalInput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                readerLocalReadCount.incrementAndGet();\n                return local.openInput(name, context);\n            }\n\n            void markValid() {\n                this.valid = true;\n                localFileNames.add(name);\n            }\n        }\n    }\n\n    private class CopyOnWriteDirectory extends org.apache.lucene.store.FilterDirectory {\n        private final java.util.concurrent.Callable<java.lang.Void> STOP = new java.util.concurrent.Callable<java.lang.Void>() {\n            @java.lang.Override\n            public java.lang.Void call() throws java.lang.Exception {\n                return null;\n            }\n        };\n\n        private final org.apache.lucene.store.Directory remote;\n\n        private final org.apache.lucene.store.Directory local;\n\n        private final java.util.concurrent.ConcurrentMap<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference> fileMap = com.google.common.collect.Maps.newConcurrentMap();\n\n        private final java.util.Set<java.lang.String> deletedFilesLocal = com.google.common.collect.Sets.newConcurrentHashSet();\n\n        private final java.util.Set<java.lang.String> skippedFiles = com.google.common.collect.Sets.newConcurrentHashSet();\n\n        private final java.util.concurrent.BlockingQueue<java.util.concurrent.Callable<java.lang.Void>> queue = new java.util.concurrent.LinkedBlockingQueue<java.util.concurrent.Callable<java.lang.Void>>();\n\n        private final java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> errorInCopy = new java.util.concurrent.atomic.AtomicReference<java.lang.Throwable>();\n\n        private final java.util.concurrent.CountDownLatch copyDone = new java.util.concurrent.CountDownLatch(1);\n\n        private final boolean reindexMode;\n\n        private final java.lang.String indexPathForLogging;\n\n        private final java.util.Set<java.lang.String> sharedWorkingSet;\n\n        private volatile org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask currentTask = org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask.completed();\n\n        private final java.lang.Runnable completionHandler = new java.lang.Runnable() {\n            java.util.concurrent.Callable<java.lang.Void> task = new java.util.concurrent.Callable<java.lang.Void>() {\n                @java.lang.Override\n                public java.lang.Void call() throws java.lang.Exception {\n                    try {\n                        java.util.concurrent.Callable<java.lang.Void> task = queue.poll();\n                        if ((task != null) && (task != STOP)) {\n                            if (errorInCopy.get() != null) {\n                                log.trace(\"[COW][{}] Skipping task {} as some exception occurred in previous run\", indexPathForLogging, task);\n                            } else {\n                                task.call();\n                            }\n                            currentTask.onComplete(completionHandler);\n                        }\n                        if (task == STOP) {\n                            copyDone.countDown();\n                        }\n                    } catch (java.lang.Throwable t) {\n                        errorInCopy.set(t);\n                        log.debug(\"[COW][{}] Error occurred while copying files. Further processing would \" + \"be skipped\", indexPathForLogging, t);\n                        currentTask.onComplete(completionHandler);\n                    }\n                    return null;\n                }\n            };\n\n            @java.lang.Override\n            public void run() {\n                currentTask = new org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask(task);\n                try {\n                    executor.execute(currentTask);\n                } catch (java.util.concurrent.RejectedExecutionException e) {\n                    checkIfClosed(false);\n                    throw e;\n                }\n            }\n        };\n\n        public CopyOnWriteDirectory(org.apache.lucene.store.Directory remote, org.apache.lucene.store.Directory local, boolean reindexMode, java.lang.String indexPathForLogging, java.util.Set<java.lang.String> sharedWorkingSet) throws java.io.IOException {\n            super(local);\n            this.remote = remote;\n            this.local = local;\n            this.indexPathForLogging = indexPathForLogging;\n            this.reindexMode = reindexMode;\n            this.sharedWorkingSet = sharedWorkingSet;\n            initialize();\n        }\n\n        @java.lang.Override\n        public java.lang.String[] listAll() throws java.io.IOException {\n            return com.google.common.collect.Iterables.toArray(fileMap.keySet(), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public boolean fileExists(java.lang.String name) throws java.io.IOException {\n            return fileMap.containsKey(name);\n        }\n\n        @java.lang.Override\n        public void deleteFile(java.lang.String name) throws java.io.IOException {\n            log.trace(\"[COW][{}] Deleted file {}\", indexPathForLogging, name);\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.remove(name);\n            if (ref != null) {\n                ref.delete();\n            }\n        }\n\n        @java.lang.Override\n        public long fileLength(java.lang.String name) throws java.io.IOException {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.get(name);\n            if (ref == null) {\n                throw new java.io.FileNotFoundException(name);\n            }\n            return ref.fileLength();\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexOutput createOutput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.remove(name);\n            if (ref != null) {\n                ref.delete();\n            }\n            ref = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWLocalFileReference(name);\n            fileMap.put(name, ref);\n            sharedWorkingSet.add(name);\n            return ref.createOutput(context);\n        }\n\n        @java.lang.Override\n        public void sync(java.util.Collection<java.lang.String> names) throws java.io.IOException {\n            for (java.lang.String name : names) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference file = fileMap.get(name);\n                if (file != null) {\n                    file.sync();\n                }\n            }\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexInput openInput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.get(name);\n            if (ref == null) {\n                throw new java.io.FileNotFoundException(name);\n            }\n            return ref.openInput(context);\n        }\n\n        @java.lang.Override\n        public void close() throws java.io.IOException {\n            int pendingCopies = queue.size();\n            addTask(STOP);\n            try {\n                long start = PERF_LOGGER.start();\n                while (!copyDone.await(10, java.util.concurrent.TimeUnit.SECONDS)) {\n                    if (closed) {\n                        throw new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException((\"IndexCopier found to be closed \" + \"while processing copy task for\") + remote.toString());\n                    }\n                } \n                PERF_LOGGER.end(start, -1, \"[COW][{}] Completed pending copying task {}\", indexPathForLogging, pendingCopies);\n            } catch (java.lang.InterruptedException e) {\n                java.lang.Thread.currentThread().interrupt();\n                throw new java.io.IOException(e);\n            }\n            java.lang.Throwable t = errorInCopy.get();\n            if (t != null) {\n                throw new java.io.IOException(\"Error occurred while copying files for \" + indexPathForLogging, t);\n            }\n            com.google.common.base.Preconditions.checkArgument(queue.isEmpty(), \"Copy queue still \" + \"has pending task left [%d]. %s\", queue.size(), queue);\n            long skippedFilesSize = getSkippedFilesSize();\n            for (java.lang.String fileName : deletedFilesLocal) {\n                deleteLocalFile(fileName);\n            }\n            skippedFromUploadSize.addAndGet(skippedFilesSize);\n            java.lang.String msg = \"[COW][{}] CopyOnWrite stats : Skipped copying {} files with total size {}\";\n            if (reindexMode || (skippedFilesSize > (10 * org.apache.commons.io.FileUtils.ONE_MB))) {\n                log.info(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\n            } else {\n                log.debug(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\n            }\n            if (log.isTraceEnabled()) {\n                log.trace(\"[COW][{}] File listing - Upon completion {}\", indexPathForLogging, java.util.Arrays.toString(remote.listAll()));\n            }\n            local.close();\n            remote.close();\n            sharedWorkingSet.clear();\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            return java.lang.String.format(\"[COW][%s] Local %s, Remote %s\", indexPathForLogging, local, remote);\n        }\n\n        private long getSkippedFilesSize() {\n            long size = 0;\n            for (java.lang.String name : skippedFiles) {\n                try {\n                    if (local.fileExists(name)) {\n                        size += local.fileLength(name);\n                    }\n                } catch (java.lang.Exception ignore) {\n                }\n            }\n            return size;\n        }\n\n        private void deleteLocalFile(java.lang.String fileName) {\n            IndexCopier.this.deleteFile(local, fileName, false);\n        }\n\n        private void initialize() throws java.io.IOException {\n            for (java.lang.String name : remote.listAll()) {\n                fileMap.put(name, new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWRemoteFileReference(name));\n            }\n            if (log.isTraceEnabled()) {\n                log.trace(\"[COW][{}] File listing - At start {}\", indexPathForLogging, java.util.Arrays.toString(remote.listAll()));\n            }\n        }\n\n        private void addCopyTask(final java.lang.String name) {\n            updateMaxScheduled(scheduledForCopyCount.incrementAndGet());\n            addTask(new java.util.concurrent.Callable<java.lang.Void>() {\n                @java.lang.Override\n                public java.lang.Void call() throws java.lang.Exception {\n                    scheduledForCopyCount.decrementAndGet();\n                    if (deletedFilesLocal.contains(name)) {\n                        skippedFiles.add(name);\n                        log.trace(\"[COW][{}] Skip copying of deleted file {}\", indexPathForLogging, name);\n                        return null;\n                    }\n                    long fileSize = local.fileLength(name);\n                    org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile(local, name, fileSize, false);\n                    long perfStart = PERF_LOGGER.start();\n                    long start = startCopy(file);\n                    local.copy(remote, name, name, IOContext.DEFAULT);\n                    doneCopy(file, start);\n                    PERF_LOGGER.end(perfStart, 0, \"[COW][{}] Copied to remote {} \", indexPathForLogging, name);\n                    return null;\n                }\n\n                @java.lang.Override\n                public java.lang.String toString() {\n                    return \"Copy: \" + name;\n                }\n            });\n        }\n\n        private void addDeleteTask(final java.lang.String name) {\n            addTask(new java.util.concurrent.Callable<java.lang.Void>() {\n                @java.lang.Override\n                public java.lang.Void call() throws java.lang.Exception {\n                    if (!skippedFiles.contains(name)) {\n                        log.trace(\"[COW][{}] Marking as deleted {}\", indexPathForLogging, name);\n                        remote.deleteFile(name);\n                    }\n                    return null;\n                }\n\n                @java.lang.Override\n                public java.lang.String toString() {\n                    return \"Delete : \" + name;\n                }\n            });\n        }\n\n        private void addTask(java.util.concurrent.Callable<java.lang.Void> task) {\n            checkIfClosed(true);\n            queue.add(task);\n            currentTask.onComplete(completionHandler);\n        }\n\n        private void checkIfClosed(boolean throwException) {\n            if (closed) {\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException e = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException((\"IndexCopier found to be closed \" + \"while processing\") + remote.toString());\n                errorInCopy.set(e);\n                copyDone.countDown();\n                if (throwException) {\n                    throw e;\n                }\n            }\n        }\n\n        private abstract class COWFileReference {\n            protected final java.lang.String name;\n\n            public COWFileReference(java.lang.String name) {\n                this.name = name;\n            }\n\n            public abstract long fileLength() throws java.io.IOException;\n\n            public abstract org.apache.lucene.store.IndexInput openInput(org.apache.lucene.store.IOContext context) throws java.io.IOException;\n\n            public abstract org.apache.lucene.store.IndexOutput createOutput(org.apache.lucene.store.IOContext context) throws java.io.IOException;\n\n            public abstract void delete() throws java.io.IOException;\n\n            public void sync() throws java.io.IOException {\n            }\n        }\n\n        private class COWRemoteFileReference extends org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference {\n            private boolean validLocalCopyPresent;\n\n            private final long length;\n\n            public COWRemoteFileReference(java.lang.String name) throws java.io.IOException {\n                super(name);\n                this.length = remote.fileLength(name);\n            }\n\n            @java.lang.Override\n            public long fileLength() throws java.io.IOException {\n                return length;\n            }\n\n            @java.lang.Override\n            public org.apache.lucene.store.IndexInput openInput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                checkIfLocalValid();\n                if (validLocalCopyPresent && (!org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.REMOTE_ONLY.contains(name))) {\n                    writerLocalReadCount.incrementAndGet();\n                    return local.openInput(name, context);\n                }\n                writerRemoteReadCount.incrementAndGet();\n                return remote.openInput(name, context);\n            }\n\n            @java.lang.Override\n            public org.apache.lucene.store.IndexOutput createOutput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                throw new java.lang.UnsupportedOperationException(\"Cannot create output for existing remote file \" + name);\n            }\n\n            @java.lang.Override\n            public void delete() throws java.io.IOException {\n                addDeleteTask(name);\n            }\n\n            private void checkIfLocalValid() throws java.io.IOException {\n                validLocalCopyPresent = local.fileExists(name) && (local.fileLength(name) == remote.fileLength(name));\n            }\n        }\n\n        private class COWLocalFileReference extends org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference {\n            public COWLocalFileReference(java.lang.String name) {\n                super(name);\n            }\n\n            @java.lang.Override\n            public long fileLength() throws java.io.IOException {\n                return local.fileLength(name);\n            }\n\n            @java.lang.Override\n            public org.apache.lucene.store.IndexInput openInput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                return local.openInput(name, context);\n            }\n\n            @java.lang.Override\n            public org.apache.lucene.store.IndexOutput createOutput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n                log.debug(\"[COW][{}] Creating output {}\", indexPathForLogging, name);\n                return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWLocalFileReference.CopyOnCloseIndexOutput(local.createOutput(name, context));\n            }\n\n            @java.lang.Override\n            public void delete() throws java.io.IOException {\n                addDeleteTask(name);\n                deletedFilesLocal.add(name);\n            }\n\n            @java.lang.Override\n            public void sync() throws java.io.IOException {\n                local.sync(java.util.Collections.singleton(name));\n            }\n\n            private class CopyOnCloseIndexOutput extends org.apache.lucene.store.IndexOutput {\n                private final org.apache.lucene.store.IndexOutput delegate;\n\n                public CopyOnCloseIndexOutput(org.apache.lucene.store.IndexOutput delegate) {\n                    this.delegate = delegate;\n                }\n\n                @java.lang.Override\n                public void flush() throws java.io.IOException {\n                    delegate.flush();\n                }\n\n                @java.lang.Override\n                public void close() throws java.io.IOException {\n                    delegate.close();\n                    addCopyTask(name);\n                }\n\n                @java.lang.Override\n                public long getFilePointer() {\n                    return delegate.getFilePointer();\n                }\n\n                @java.lang.Override\n                public void seek(long pos) throws java.io.IOException {\n                    delegate.seek(pos);\n                }\n\n                @java.lang.Override\n                public long length() throws java.io.IOException {\n                    return delegate.length();\n                }\n\n                @java.lang.Override\n                public void writeByte(byte b) throws java.io.IOException {\n                    delegate.writeByte(b);\n                }\n\n                @java.lang.Override\n                public void writeBytes(byte[] b, int offset, int length) throws java.io.IOException {\n                    delegate.writeBytes(b, offset, length);\n                }\n\n                @java.lang.Override\n                public void setLength(long length) throws java.io.IOException {\n                    delegate.setLength(length);\n                }\n            }\n        }\n    }\n\n    private boolean deleteFile(org.apache.lucene.store.Directory dir, java.lang.String fileName, boolean copiedFromRemote) {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile(dir, fileName, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getFileLength(dir, fileName), copiedFromRemote);\n        boolean successFullyDeleted = false;\n        try {\n            boolean fileExisted = false;\n            if (dir.fileExists(fileName)) {\n                fileExisted = true;\n                dir.deleteFile(fileName);\n            }\n            successfullyDeleted(file, fileExisted);\n            successFullyDeleted = true;\n        } catch (java.io.IOException e) {\n            failedToDelete(file);\n            log.debug(\"Error occurred while removing deleted file {} from Local {}. \" + \"Attempt would be made to delete it on next run \", fileName, dir, e);\n        }\n        return successFullyDeleted;\n    }\n\n    private long startCopy(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file) {\n        updateMaxInProgress(copyInProgressCount.incrementAndGet());\n        copyInProgressSize.addAndGet(file.size);\n        copyInProgressFiles.add(file);\n        return java.lang.System.currentTimeMillis();\n    }\n\n    private void doneCopy(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file, long start) {\n        copyInProgressFiles.remove(file);\n        copyInProgressCount.decrementAndGet();\n        copyInProgressSize.addAndGet(-file.size);\n        if (file.copyFromRemote) {\n            downloadTime.addAndGet(java.lang.System.currentTimeMillis() - start);\n            downloadSize.addAndGet(file.size);\n            downloadCount.incrementAndGet();\n        } else {\n            uploadSize.addAndGet(file.size);\n            uploadTime.addAndGet(java.lang.System.currentTimeMillis() - start);\n            uploadCount.incrementAndGet();\n        }\n    }\n\n    private void updateMaxScheduled(int val) {\n        synchronized(maxScheduledForCopyCount) {\n            int current = maxScheduledForCopyCount.get();\n            if (val > current) {\n                maxScheduledForCopyCount.set(val);\n            }\n        }\n    }\n\n    private void updateMaxInProgress(int val) {\n        synchronized(maxCopyInProgressCount) {\n            int current = maxCopyInProgressCount.get();\n            if (val > current) {\n                maxCopyInProgressCount.set(val);\n            }\n        }\n    }\n\n    private class DeleteOldDirOnClose extends org.apache.lucene.store.FilterDirectory {\n        private final java.io.File oldIndexDir;\n\n        protected DeleteOldDirOnClose(org.apache.lucene.store.Directory in, java.io.File oldIndexDir) {\n            super(in);\n            this.oldIndexDir = oldIndexDir;\n        }\n\n        @java.lang.Override\n        public void close() throws java.io.IOException {\n            try {\n                super.close();\n            } finally {\n                try {\n                    org.apache.commons.io.FileUtils.deleteDirectory(oldIndexDir);\n                    log.debug(\"Removed old index content from {} \", oldIndexDir);\n                } catch (java.io.IOException e) {\n                    log.warn(\"Not able to remove old version of copied index at {}\", oldIndexDir, e);\n                }\n            }\n        }\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            return \"DeleteOldDirOnClose wrapper for \" + getDelegate();\n        }\n    }\n\n    static final class LocalIndexFile {\n        final java.io.File dir;\n\n        final java.lang.String name;\n\n        final long size;\n\n        final boolean copyFromRemote;\n\n        private volatile int deleteAttemptCount;\n\n        final long creationTime = java.lang.System.currentTimeMillis();\n\n        public LocalIndexFile(org.apache.lucene.store.Directory dir, java.lang.String fileName, long size, boolean copyFromRemote) {\n            this.copyFromRemote = copyFromRemote;\n            this.dir = org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getFSDir(dir);\n            this.name = fileName;\n            this.size = size;\n        }\n\n        public LocalIndexFile(org.apache.lucene.store.Directory dir, java.lang.String fileName) {\n            this(dir, fileName, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.getFileLength(dir, fileName), true);\n        }\n\n        public java.lang.String getKey() {\n            if (dir != null) {\n                return new java.io.File(dir, name).getAbsolutePath();\n            }\n            return name;\n        }\n\n        public void incrementAttemptToDelete() {\n            deleteAttemptCount++;\n        }\n\n        public int getDeleteAttemptCount() {\n            return deleteAttemptCount;\n        }\n\n        public java.lang.String deleteLog() {\n            return java.lang.String.format(\"%s (%s, %d attempts, %d s)\", name, humanReadableByteCount(size), deleteAttemptCount, timeTaken());\n        }\n\n        public java.lang.String copyLog() {\n            return java.lang.String.format(\"%s (%s, %1.1f%%, %s, %d s)\", name, humanReadableByteCount(actualSize()), copyProgress(), humanReadableByteCount(size), timeTaken());\n        }\n\n        @java.lang.Override\n        public boolean equals(java.lang.Object o) {\n            if (this == o) {\n                return true;\n            }\n            if ((o == null) || (getClass() != o.getClass())) {\n                return false;\n            }\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile localIndexFile = ((org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile) (o));\n            if (dir != null ? !dir.equals(localIndexFile.dir) : localIndexFile.dir != null) {\n                return false;\n            }\n            return name.equals(localIndexFile.name);\n        }\n\n        @java.lang.Override\n        public int hashCode() {\n            int result = (dir != null) ? dir.hashCode() : 0;\n            result = (31 * result) + name.hashCode();\n            return result;\n        }\n\n        private long timeTaken() {\n            return java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(java.lang.System.currentTimeMillis() - creationTime);\n        }\n\n        private float copyProgress() {\n            return ((actualSize() * 1.0F) / size) * 100;\n        }\n\n        private long actualSize() {\n            return dir != null ? new java.io.File(dir, name).length() : 0;\n        }\n    }\n\n    static java.io.File getFSDir(org.apache.lucene.store.Directory dir) {\n        if (dir instanceof org.apache.lucene.store.FilterDirectory) {\n            dir = ((org.apache.lucene.store.FilterDirectory) (dir)).getDelegate();\n        }\n        if (dir instanceof org.apache.lucene.store.FSDirectory) {\n            return ((org.apache.lucene.store.FSDirectory) (dir)).getDirectory();\n        }\n        return null;\n    }\n\n    private static long getFileLength(org.apache.lucene.store.Directory dir, java.lang.String fileName) {\n        try {\n            return dir.fileLength(fileName);\n        } catch (java.lang.Exception e) {\n            return -1;\n        }\n    }\n\n    @java.lang.Override\n    public javax.management.openmbean.TabularData getIndexPathMapping() {\n        javax.management.openmbean.TabularDataSupport tds;\n        try {\n            javax.management.openmbean.TabularType tt = new javax.management.openmbean.TabularType(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.class.getName(), \"Lucene Index Stats\", org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.TYPE, new java.lang.String[]{ \"jcrPath\" });\n            tds = new javax.management.openmbean.TabularDataSupport(tt);\n            for (java.util.Map.Entry<java.lang.String, java.lang.String> e : indexPathMapping.entrySet()) {\n                java.lang.String size = humanReadableByteCount(org.apache.commons.io.FileUtils.sizeOfDirectory(new java.io.File(e.getValue())));\n                tds.put(new javax.management.openmbean.CompositeDataSupport(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.TYPE, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.FIELD_NAMES, new java.lang.String[]{ e.getKey(), e.getValue(), size }));\n            }\n        } catch (javax.management.openmbean.OpenDataException e) {\n            throw new java.lang.IllegalStateException(e);\n        }\n        return tds;\n    }\n\n    @java.lang.Override\n    public boolean isPrefetchEnabled() {\n        return prefetchEnabled;\n    }\n\n    @java.lang.Override\n    public int getReaderLocalReadCount() {\n        return readerLocalReadCount.get();\n    }\n\n    @java.lang.Override\n    public int getReaderRemoteReadCount() {\n        return readerRemoteReadCount.get();\n    }\n\n    @java.lang.Override\n    public int getWriterLocalReadCount() {\n        return writerLocalReadCount.get();\n    }\n\n    @java.lang.Override\n    public int getWriterRemoteReadCount() {\n        return writerRemoteReadCount.get();\n    }\n\n    public int getInvalidFileCount() {\n        return invalidFileCount.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getDownloadSize() {\n        return humanReadableByteCount(downloadSize.get());\n    }\n\n    @java.lang.Override\n    public long getDownloadTime() {\n        return downloadTime.get();\n    }\n\n    @java.lang.Override\n    public int getDownloadCount() {\n        return downloadCount.get();\n    }\n\n    @java.lang.Override\n    public int getUploadCount() {\n        return uploadCount.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getUploadSize() {\n        return humanReadableByteCount(uploadSize.get());\n    }\n\n    @java.lang.Override\n    public long getUploadTime() {\n        return uploadTime.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getLocalIndexSize() {\n        return humanReadableByteCount(org.apache.commons.io.FileUtils.sizeOfDirectory(indexRootDir));\n    }\n\n    @java.lang.Override\n    public java.lang.String[] getGarbageDetails() {\n        return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(failedToDeleteFiles.values(), new com.google.common.base.Function<org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile, java.lang.String>() {\n            @java.lang.Override\n            public java.lang.String apply(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile input) {\n                return input.deleteLog();\n            }\n        }), java.lang.String.class);\n    }\n\n    @java.lang.Override\n    public java.lang.String getGarbageSize() {\n        long garbageSize = 0;\n        for (org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile failedToDeleteFile : failedToDeleteFiles.values()) {\n            garbageSize += failedToDeleteFile.size;\n        }\n        return humanReadableByteCount(garbageSize);\n    }\n\n    @java.lang.Override\n    public int getScheduledForCopyCount() {\n        return scheduledForCopyCount.get();\n    }\n\n    @java.lang.Override\n    public int getCopyInProgressCount() {\n        return copyInProgressCount.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getCopyInProgressSize() {\n        return humanReadableByteCount(copyInProgressSize.get());\n    }\n\n    @java.lang.Override\n    public int getMaxCopyInProgressCount() {\n        return maxCopyInProgressCount.get();\n    }\n\n    @java.lang.Override\n    public int getMaxScheduledForCopyCount() {\n        return maxScheduledForCopyCount.get();\n    }\n\n    public java.lang.String getSkippedFromUploadSize() {\n        return humanReadableByteCount(skippedFromUploadSize.get());\n    }\n\n    @java.lang.Override\n    public java.lang.String[] getCopyInProgressDetails() {\n        return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(copyInProgressFiles, new com.google.common.base.Function<org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile, java.lang.String>() {\n            @java.lang.Override\n            public java.lang.String apply(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile input) {\n                return input.copyLog();\n            }\n        }), java.lang.String.class);\n    }\n\n    @java.lang.Override\n    public int getDeletedFilesCount() {\n        return deletedFileCount.get();\n    }\n\n    @java.lang.Override\n    public java.lang.String getGarbageCollectedSize() {\n        return humanReadableByteCount(garbageCollectedSize.get());\n    }\n\n    private static class IndexMappingData {\n        static final java.lang.String[] FIELD_NAMES = new java.lang.String[]{ \"jcrPath\", \"fsPath\", \"size\" };\n\n        static final java.lang.String[] FIELD_DESCRIPTIONS = new java.lang.String[]{ \"JCR Path\", \"Filesystem Path\", \"Size\" };\n\n        static final javax.management.openmbean.OpenType[] FIELD_TYPES = new javax.management.openmbean.OpenType[]{ javax.management.openmbean.SimpleType.STRING, javax.management.openmbean.SimpleType.STRING, javax.management.openmbean.SimpleType.STRING };\n\n        static final javax.management.openmbean.CompositeType TYPE = org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.createCompositeType();\n\n        static javax.management.openmbean.CompositeType createCompositeType() {\n            try {\n                return new javax.management.openmbean.CompositeType(org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.class.getName(), \"Composite data type for Index Mapping Data\", org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.FIELD_NAMES, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.FIELD_DESCRIPTIONS, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.IndexMappingData.FIELD_TYPES);\n            } catch (javax.management.openmbean.OpenDataException e) {\n                throw new java.lang.IllegalStateException(e);\n            }\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private final java.util.Set<java.lang.String> sharedWorkingSet;",
            "src_parent": "private class CopyOnWriteDirectory extends org.apache.lucene.store.FilterDirectory {\n    private final java.util.concurrent.Callable<java.lang.Void> STOP = new java.util.concurrent.Callable<java.lang.Void>() {\n        @java.lang.Override\n        public java.lang.Void call() throws java.lang.Exception {\n            return null;\n        }\n    };\n\n    private final org.apache.lucene.store.Directory remote;\n\n    private final org.apache.lucene.store.Directory local;\n\n    private final java.util.concurrent.ConcurrentMap<java.lang.String, org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference> fileMap = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Set<java.lang.String> deletedFilesLocal = com.google.common.collect.Sets.newConcurrentHashSet();\n\n    private final java.util.Set<java.lang.String> skippedFiles = com.google.common.collect.Sets.newConcurrentHashSet();\n\n    private final java.util.concurrent.BlockingQueue<java.util.concurrent.Callable<java.lang.Void>> queue = new java.util.concurrent.LinkedBlockingQueue<java.util.concurrent.Callable<java.lang.Void>>();\n\n    private final java.util.concurrent.atomic.AtomicReference<java.lang.Throwable> errorInCopy = new java.util.concurrent.atomic.AtomicReference<java.lang.Throwable>();\n\n    private final java.util.concurrent.CountDownLatch copyDone = new java.util.concurrent.CountDownLatch(1);\n\n    private final boolean reindexMode;\n\n    private final java.lang.String indexPathForLogging;\n\n    private final java.util.Set<java.lang.String> sharedWorkingSet;\n\n    private volatile org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask currentTask = org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask.completed();\n\n    private final java.lang.Runnable completionHandler = new java.lang.Runnable() {\n        java.util.concurrent.Callable<java.lang.Void> task = new java.util.concurrent.Callable<java.lang.Void>() {\n            @java.lang.Override\n            public java.lang.Void call() throws java.lang.Exception {\n                try {\n                    java.util.concurrent.Callable<java.lang.Void> task = queue.poll();\n                    if ((task != null) && (task != STOP)) {\n                        if (errorInCopy.get() != null) {\n                            log.trace(\"[COW][{}] Skipping task {} as some exception occurred in previous run\", indexPathForLogging, task);\n                        } else {\n                            task.call();\n                        }\n                        currentTask.onComplete(completionHandler);\n                    }\n                    if (task == STOP) {\n                        copyDone.countDown();\n                    }\n                } catch (java.lang.Throwable t) {\n                    errorInCopy.set(t);\n                    log.debug(\"[COW][{}] Error occurred while copying files. Further processing would \" + \"be skipped\", indexPathForLogging, t);\n                    currentTask.onComplete(completionHandler);\n                }\n                return null;\n            }\n        };\n\n        @java.lang.Override\n        public void run() {\n            currentTask = new org.apache.jackrabbit.oak.commons.concurrent.NotifyingFutureTask(task);\n            try {\n                executor.execute(currentTask);\n            } catch (java.util.concurrent.RejectedExecutionException e) {\n                checkIfClosed(false);\n                throw e;\n            }\n        }\n    };\n\n    public CopyOnWriteDirectory(org.apache.lucene.store.Directory remote, org.apache.lucene.store.Directory local, boolean reindexMode, java.lang.String indexPathForLogging, java.util.Set<java.lang.String> sharedWorkingSet) throws java.io.IOException {\n        super(local);\n        this.remote = remote;\n        this.local = local;\n        this.indexPathForLogging = indexPathForLogging;\n        this.reindexMode = reindexMode;\n        this.sharedWorkingSet = sharedWorkingSet;\n        initialize();\n    }\n\n    @java.lang.Override\n    public java.lang.String[] listAll() throws java.io.IOException {\n        return com.google.common.collect.Iterables.toArray(fileMap.keySet(), java.lang.String.class);\n    }\n\n    @java.lang.Override\n    public boolean fileExists(java.lang.String name) throws java.io.IOException {\n        return fileMap.containsKey(name);\n    }\n\n    @java.lang.Override\n    public void deleteFile(java.lang.String name) throws java.io.IOException {\n        log.trace(\"[COW][{}] Deleted file {}\", indexPathForLogging, name);\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.remove(name);\n        if (ref != null) {\n            ref.delete();\n        }\n    }\n\n    @java.lang.Override\n    public long fileLength(java.lang.String name) throws java.io.IOException {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.get(name);\n        if (ref == null) {\n            throw new java.io.FileNotFoundException(name);\n        }\n        return ref.fileLength();\n    }\n\n    @java.lang.Override\n    public org.apache.lucene.store.IndexOutput createOutput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.remove(name);\n        if (ref != null) {\n            ref.delete();\n        }\n        ref = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWLocalFileReference(name);\n        fileMap.put(name, ref);\n        sharedWorkingSet.add(name);\n        return ref.createOutput(context);\n    }\n\n    @java.lang.Override\n    public void sync(java.util.Collection<java.lang.String> names) throws java.io.IOException {\n        for (java.lang.String name : names) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference file = fileMap.get(name);\n            if (file != null) {\n                file.sync();\n            }\n        }\n    }\n\n    @java.lang.Override\n    public org.apache.lucene.store.IndexInput openInput(java.lang.String name, org.apache.lucene.store.IOContext context) throws java.io.IOException {\n        org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.get(name);\n        if (ref == null) {\n            throw new java.io.FileNotFoundException(name);\n        }\n        return ref.openInput(context);\n    }\n\n    @java.lang.Override\n    public void close() throws java.io.IOException {\n        int pendingCopies = queue.size();\n        addTask(STOP);\n        try {\n            long start = PERF_LOGGER.start();\n            while (!copyDone.await(10, java.util.concurrent.TimeUnit.SECONDS)) {\n                if (closed) {\n                    throw new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException((\"IndexCopier found to be closed \" + \"while processing copy task for\") + remote.toString());\n                }\n            } \n            PERF_LOGGER.end(start, -1, \"[COW][{}] Completed pending copying task {}\", indexPathForLogging, pendingCopies);\n        } catch (java.lang.InterruptedException e) {\n            java.lang.Thread.currentThread().interrupt();\n            throw new java.io.IOException(e);\n        }\n        java.lang.Throwable t = errorInCopy.get();\n        if (t != null) {\n            throw new java.io.IOException(\"Error occurred while copying files for \" + indexPathForLogging, t);\n        }\n        com.google.common.base.Preconditions.checkArgument(queue.isEmpty(), \"Copy queue still \" + \"has pending task left [%d]. %s\", queue.size(), queue);\n        long skippedFilesSize = getSkippedFilesSize();\n        for (java.lang.String fileName : deletedFilesLocal) {\n            deleteLocalFile(fileName);\n        }\n        skippedFromUploadSize.addAndGet(skippedFilesSize);\n        java.lang.String msg = \"[COW][{}] CopyOnWrite stats : Skipped copying {} files with total size {}\";\n        if (reindexMode || (skippedFilesSize > (10 * org.apache.commons.io.FileUtils.ONE_MB))) {\n            log.info(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\n        } else {\n            log.debug(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"[COW][{}] File listing - Upon completion {}\", indexPathForLogging, java.util.Arrays.toString(remote.listAll()));\n        }\n        local.close();\n        remote.close();\n        sharedWorkingSet.clear();\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return java.lang.String.format(\"[COW][%s] Local %s, Remote %s\", indexPathForLogging, local, remote);\n    }\n\n    private long getSkippedFilesSize() {\n        long size = 0;\n        for (java.lang.String name : skippedFiles) {\n            try {\n                if (local.fileExists(name)) {\n                    size += local.fileLength(name);\n                }\n            } catch (java.lang.Exception ignore) {\n            }\n        }\n        return size;\n    }\n\n    private void deleteLocalFile(java.lang.String fileName) {\n        IndexCopier.this.deleteFile(local, fileName, false);\n    }\n\n    private void initialize() throws java.io.IOException {\n        for (java.lang.String name : remote.listAll()) {\n            fileMap.put(name, new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWRemoteFileReference(name));\n        }\n        if (log.isTraceEnabled()) {\n            log.trace(\"[COW][{}] File listing - At start {}\", indexPathForLogging, java.util.Arrays.toString(remote.listAll()));\n        }\n    }\n\n    private void addCopyTask(final java.lang.String name) {\n        updateMaxScheduled(scheduledForCopyCount.incrementAndGet());\n        addTask(new java.util.concurrent.Callable<java.lang.Void>() {\n            @java.lang.Override\n            public java.lang.Void call() throws java.lang.Exception {\n                scheduledForCopyCount.decrementAndGet();\n                if (deletedFilesLocal.contains(name)) {\n                    skippedFiles.add(name);\n                    log.trace(\"[COW][{}] Skip copying of deleted file {}\", indexPathForLogging, name);\n                    return null;\n                }\n                long fileSize = local.fileLength(name);\n                org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile file = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.LocalIndexFile(local, name, fileSize, false);\n                long perfStart = PERF_LOGGER.start();\n                long start = startCopy(file);\n                local.copy(remote, name, name, IOContext.DEFAULT);\n                doneCopy(file, start);\n                PERF_LOGGER.end(perfStart, 0, \"[COW][{}] Copied to remote {} \", indexPathForLogging, name);\n                return null;\n            }\n\n            @java.lang.Override\n            public java.lang.String toString() {\n                return \"Copy: \" + name;\n            }\n        });\n    }\n\n    private void addDeleteTask(final java.lang.String name) {\n        addTask(new java.util.concurrent.Callable<java.lang.Void>() {\n            @java.lang.Override\n            public java.lang.Void call() throws java.lang.Exception {\n                if (!skippedFiles.contains(name)) {\n                    log.trace(\"[COW][{}] Marking as deleted {}\", indexPathForLogging, name);\n                    remote.deleteFile(name);\n                }\n                return null;\n            }\n\n            @java.lang.Override\n            public java.lang.String toString() {\n                return \"Delete : \" + name;\n            }\n        });\n    }\n\n    private void addTask(java.util.concurrent.Callable<java.lang.Void> task) {\n        checkIfClosed(true);\n        queue.add(task);\n        currentTask.onComplete(completionHandler);\n    }\n\n    private void checkIfClosed(boolean throwException) {\n        if (closed) {\n            org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException e = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException((\"IndexCopier found to be closed \" + \"while processing\") + remote.toString());\n            errorInCopy.set(e);\n            copyDone.countDown();\n            if (throwException) {\n                throw e;\n            }\n        }\n    }\n\n    private abstract class COWFileReference {\n        protected final java.lang.String name;\n\n        public COWFileReference(java.lang.String name) {\n            this.name = name;\n        }\n\n        public abstract long fileLength() throws java.io.IOException;\n\n        public abstract org.apache.lucene.store.IndexInput openInput(org.apache.lucene.store.IOContext context) throws java.io.IOException;\n\n        public abstract org.apache.lucene.store.IndexOutput createOutput(org.apache.lucene.store.IOContext context) throws java.io.IOException;\n\n        public abstract void delete() throws java.io.IOException;\n\n        public void sync() throws java.io.IOException {\n        }\n    }\n\n    private class COWRemoteFileReference extends org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference {\n        private boolean validLocalCopyPresent;\n\n        private final long length;\n\n        public COWRemoteFileReference(java.lang.String name) throws java.io.IOException {\n            super(name);\n            this.length = remote.fileLength(name);\n        }\n\n        @java.lang.Override\n        public long fileLength() throws java.io.IOException {\n            return length;\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexInput openInput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            checkIfLocalValid();\n            if (validLocalCopyPresent && (!org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.REMOTE_ONLY.contains(name))) {\n                writerLocalReadCount.incrementAndGet();\n                return local.openInput(name, context);\n            }\n            writerRemoteReadCount.incrementAndGet();\n            return remote.openInput(name, context);\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexOutput createOutput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            throw new java.lang.UnsupportedOperationException(\"Cannot create output for existing remote file \" + name);\n        }\n\n        @java.lang.Override\n        public void delete() throws java.io.IOException {\n            addDeleteTask(name);\n        }\n\n        private void checkIfLocalValid() throws java.io.IOException {\n            validLocalCopyPresent = local.fileExists(name) && (local.fileLength(name) == remote.fileLength(name));\n        }\n    }\n\n    private class COWLocalFileReference extends org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference {\n        public COWLocalFileReference(java.lang.String name) {\n            super(name);\n        }\n\n        @java.lang.Override\n        public long fileLength() throws java.io.IOException {\n            return local.fileLength(name);\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexInput openInput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            return local.openInput(name, context);\n        }\n\n        @java.lang.Override\n        public org.apache.lucene.store.IndexOutput createOutput(org.apache.lucene.store.IOContext context) throws java.io.IOException {\n            log.debug(\"[COW][{}] Creating output {}\", indexPathForLogging, name);\n            return new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWLocalFileReference.CopyOnCloseIndexOutput(local.createOutput(name, context));\n        }\n\n        @java.lang.Override\n        public void delete() throws java.io.IOException {\n            addDeleteTask(name);\n            deletedFilesLocal.add(name);\n        }\n\n        @java.lang.Override\n        public void sync() throws java.io.IOException {\n            local.sync(java.util.Collections.singleton(name));\n        }\n\n        private class CopyOnCloseIndexOutput extends org.apache.lucene.store.IndexOutput {\n            private final org.apache.lucene.store.IndexOutput delegate;\n\n            public CopyOnCloseIndexOutput(org.apache.lucene.store.IndexOutput delegate) {\n                this.delegate = delegate;\n            }\n\n            @java.lang.Override\n            public void flush() throws java.io.IOException {\n                delegate.flush();\n            }\n\n            @java.lang.Override\n            public void close() throws java.io.IOException {\n                delegate.close();\n                addCopyTask(name);\n            }\n\n            @java.lang.Override\n            public long getFilePointer() {\n                return delegate.getFilePointer();\n            }\n\n            @java.lang.Override\n            public void seek(long pos) throws java.io.IOException {\n                delegate.seek(pos);\n            }\n\n            @java.lang.Override\n            public long length() throws java.io.IOException {\n                return delegate.length();\n            }\n\n            @java.lang.Override\n            public void writeByte(byte b) throws java.io.IOException {\n                delegate.writeByte(b);\n            }\n\n            @java.lang.Override\n            public void writeBytes(byte[] b, int offset, int length) throws java.io.IOException {\n                delegate.writeBytes(b, offset, length);\n            }\n\n            @java.lang.Override\n            public void setLength(long length) throws java.io.IOException {\n                delegate.setLength(length);\n            }\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Constructor",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "java.util.Set<java.lang.String> sharedWorkingSet",
            "src_parent": "public CopyOnReadDirectory(org.apache.lucene.store.Directory remote, org.apache.lucene.store.Directory local, boolean prefetch, java.lang.String indexPath, java.util.Set<java.lang.String> sharedWorkingSet) throws java.io.IOException {\n    super(remote);\n    this.remote = remote;\n    this.local = local;\n    this.indexPath = indexPath;\n    this.localFileNames.addAll(java.util.Arrays.asList(local.listAll()));\n    this.localFileNames.removeAll(sharedWorkingSet);\n    if (prefetch) {\n        prefetchIndexFiles();\n    }\n}",
            "src_parent_type": "Constructor",
            "src_type": "Parameter"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Constructor",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "this.localFileNames.removeAll(sharedWorkingSet)",
            "src_parent": "{\n    super(remote);\n    this.remote = remote;\n    this.local = local;\n    this.indexPath = indexPath;\n    this.localFileNames.addAll(java.util.Arrays.asList(local.listAll()));\n    this.localFileNames.removeAll(sharedWorkingSet);\n    if (prefetch) {\n        prefetchIndexFiles();\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Constructor",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "java.util.Set<java.lang.String> sharedWorkingSet",
            "src_parent": "public CopyOnWriteDirectory(org.apache.lucene.store.Directory remote, org.apache.lucene.store.Directory local, boolean reindexMode, java.lang.String indexPathForLogging, java.util.Set<java.lang.String> sharedWorkingSet) throws java.io.IOException {\n    super(local);\n    this.remote = remote;\n    this.local = local;\n    this.indexPathForLogging = indexPathForLogging;\n    this.reindexMode = reindexMode;\n    this.sharedWorkingSet = sharedWorkingSet;\n    initialize();\n}",
            "src_parent_type": "Constructor",
            "src_type": "Parameter"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Constructor",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "this.sharedWorkingSet = sharedWorkingSet",
            "src_parent": "{\n    super(local);\n    this.remote = remote;\n    this.local = local;\n    this.indexPathForLogging = indexPathForLogging;\n    this.reindexMode = reindexMode;\n    this.sharedWorkingSet = sharedWorkingSet;\n    initialize();\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "sharedWorkingSet.add(name)",
            "src_parent": "{\n    org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWFileReference ref = fileMap.remove(name);\n    if (ref != null) {\n        ref.delete();\n    }\n    ref = new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopier.CopyOnWriteDirectory.COWLocalFileReference(name);\n    fileMap.put(name, ref);\n    sharedWorkingSet.add(name);\n    return ref.createOutput(context);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "sharedWorkingSet.clear()",
            "src_parent": "{\n    int pendingCopies = queue.size();\n    addTask(STOP);\n    try {\n        long start = PERF_LOGGER.start();\n        while (!copyDone.await(10, java.util.concurrent.TimeUnit.SECONDS)) {\n            if (closed) {\n                throw new org.apache.jackrabbit.oak.plugins.index.lucene.IndexCopierClosedException((\"IndexCopier found to be closed \" + \"while processing copy task for\") + remote.toString());\n            }\n        } \n        PERF_LOGGER.end(start, -1, \"[COW][{}] Completed pending copying task {}\", indexPathForLogging, pendingCopies);\n    } catch (java.lang.InterruptedException e) {\n        java.lang.Thread.currentThread().interrupt();\n        throw new java.io.IOException(e);\n    }\n    java.lang.Throwable t = errorInCopy.get();\n    if (t != null) {\n        throw new java.io.IOException(\"Error occurred while copying files for \" + indexPathForLogging, t);\n    }\n    com.google.common.base.Preconditions.checkArgument(queue.isEmpty(), \"Copy queue still \" + \"has pending task left [%d]. %s\", queue.size(), queue);\n    long skippedFilesSize = getSkippedFilesSize();\n    for (java.lang.String fileName : deletedFilesLocal) {\n        deleteLocalFile(fileName);\n    }\n    skippedFromUploadSize.addAndGet(skippedFilesSize);\n    java.lang.String msg = \"[COW][{}] CopyOnWrite stats : Skipped copying {} files with total size {}\";\n    if (reindexMode || (skippedFilesSize > (10 * org.apache.commons.io.FileUtils.ONE_MB))) {\n        log.info(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\n    } else {\n        log.debug(msg, indexPathForLogging, skippedFiles.size(), humanReadableByteCount(skippedFilesSize));\n    }\n    if (log.isTraceEnabled()) {\n        log.trace(\"[COW][{}] File listing - Upon completion {}\", indexPathForLogging, java.util.Arrays.toString(remote.listAll()));\n    }\n    local.close();\n    remote.close();\n    sharedWorkingSet.clear();\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        }
      ],
      "file_name": "IndexCopier"
    }
  ],
  "id": "jackrabbit-oak_d10362c0"
}