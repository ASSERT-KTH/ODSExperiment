{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static final java.lang.StringBuffer SBF_NULL = new java.lang.StringBuffer(\"null\");",
            "src_parent": "public final class AppendingStringBuffer implements java.io.Serializable , java.lang.CharSequence {\n    private static final long serialVersionUID = 1L;\n\n    private static final org.apache.wicket.util.string.AppendingStringBuffer NULL = new org.apache.wicket.util.string.AppendingStringBuffer(\"null\");\n\n    private static final java.lang.StringBuilder SB_NULL = new java.lang.StringBuilder(\"null\");\n\n    private static final java.lang.StringBuffer SBF_NULL = new java.lang.StringBuffer(\"null\");\n\n    private char[] value;\n\n    private int count;\n\n    public AppendingStringBuffer() {\n        this(16);\n    }\n\n    public AppendingStringBuffer(final int length) {\n        value = new char[length];\n    }\n\n    public AppendingStringBuffer(final java.lang.CharSequence str) {\n        this(str.length() + 16);\n        append(str);\n    }\n\n    public int length() {\n        return count;\n    }\n\n    public int capacity() {\n        return value.length;\n    }\n\n    public void ensureCapacity(final int minimumCapacity) {\n        if (minimumCapacity > value.length) {\n            expandCapacity(minimumCapacity);\n        }\n    }\n\n    private void expandCapacity(final int minimumCapacity) {\n        int newCapacity = (value.length + 1) * 2;\n        if (newCapacity < 0) {\n            newCapacity = java.lang.Integer.MAX_VALUE;\n        } else if (minimumCapacity > newCapacity) {\n            newCapacity = minimumCapacity;\n        }\n        char[] newValue = new char[newCapacity];\n        java.lang.System.arraycopy(value, 0, newValue, 0, count);\n        value = newValue;\n    }\n\n    public void setLength(final int newLength) {\n        if (newLength < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(newLength);\n        }\n        if (newLength > value.length) {\n            expandCapacity(newLength);\n        }\n        if (count < newLength) {\n            for (; count < newLength; count++) {\n                value[count] = '\\u0000';\n            }\n        } else {\n            count = newLength;\n        }\n    }\n\n    public char charAt(final int index) {\n        if ((index < 0) || (index >= count)) {\n            throw new java.lang.StringIndexOutOfBoundsException(index);\n        }\n        return value[index];\n    }\n\n    public void getChars(final int srcBegin, final int srcEnd, final char[] dst, final int dstBegin) {\n        if (srcBegin < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(srcBegin);\n        }\n        if ((srcEnd < 0) || (srcEnd > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException(srcEnd);\n        }\n        if (srcBegin > srcEnd) {\n            throw new java.lang.StringIndexOutOfBoundsException(\"srcBegin > srcEnd\");\n        }\n        java.lang.System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);\n    }\n\n    public void setCharAt(final int index, final char ch) {\n        if ((index < 0) || (index >= count)) {\n            throw new java.lang.StringIndexOutOfBoundsException(index);\n        }\n        value[index] = ch;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final java.lang.Object obj) {\n        if (obj instanceof org.apache.wicket.util.string.AppendingStringBuffer) {\n            return append(((org.apache.wicket.util.string.AppendingStringBuffer) (obj)));\n        } else if (obj instanceof java.lang.StringBuilder) {\n            return append(((java.lang.StringBuilder) (obj)));\n        } else if (obj instanceof java.lang.StringBuffer) {\n            return append(obj.toString());\n        }\n        return append(java.lang.String.valueOf(obj));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(java.lang.String str) {\n        if (str == null) {\n            str = java.lang.String.valueOf(str);\n        }\n        int len = str.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        str.getChars(0, len, value, count);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(org.apache.wicket.util.string.AppendingStringBuffer sb) {\n        if (sb == null) {\n            sb = org.apache.wicket.util.string.AppendingStringBuffer.NULL;\n        }\n        int len = sb.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        sb.getChars(0, len, value, count);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(java.lang.StringBuilder sb) {\n        if (sb == null) {\n            sb = org.apache.wicket.util.string.AppendingStringBuffer.SB_NULL;\n        }\n        int len = sb.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        sb.getChars(0, len, value, count);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final char[] str) {\n        int len = str.length;\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(str, 0, value, count, len);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final char[] str, final int offset, final int len) {\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(str, offset, value, count, len);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final boolean b) {\n        if (b) {\n            int newcount = count + 4;\n            if (newcount > value.length) {\n                expandCapacity(newcount);\n            }\n            value[count++] = 't';\n            value[count++] = 'r';\n            value[count++] = 'u';\n            value[count++] = 'e';\n        } else {\n            int newcount = count + 5;\n            if (newcount > value.length) {\n                expandCapacity(newcount);\n            }\n            value[count++] = 'f';\n            value[count++] = 'a';\n            value[count++] = 'l';\n            value[count++] = 's';\n            value[count++] = 'e';\n        }\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final char c) {\n        int newcount = count + 1;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        value[count++] = c;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final int i) {\n        return append(java.lang.String.valueOf(i));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final long l) {\n        return append(java.lang.String.valueOf(l));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final float f) {\n        return append(java.lang.String.valueOf(f));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final double d) {\n        return append(java.lang.String.valueOf(d));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer delete(final int start, int end) {\n        if (start < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(start);\n        }\n        if (end > count) {\n            end = count;\n        }\n        if (start > end) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        int len = end - start;\n        if (len > 0) {\n            java.lang.System.arraycopy(value, start + len, value, start, count - end);\n            count -= len;\n        }\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer deleteCharAt(final int index) {\n        if ((index < 0) || (index >= count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        java.lang.System.arraycopy(value, index + 1, value, index, (count - index) - 1);\n        count--;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer replace(final int start, int end, final java.lang.String str) {\n        if (start < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(start);\n        }\n        if (end > count) {\n            end = count;\n        }\n        if (start > end) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        int len = str.length();\n        int newCount = (count + len) - (end - start);\n        if (newCount > value.length) {\n            expandCapacity(newCount);\n        }\n        java.lang.System.arraycopy(value, end, value, start + len, count - end);\n        str.getChars(0, len, value, start);\n        count = newCount;\n        return this;\n    }\n\n    public java.lang.String substring(final int start) {\n        return substring(start, count);\n    }\n\n    public java.lang.CharSequence subSequence(final int start, final int end) {\n        return this.substring(start, end);\n    }\n\n    public java.lang.String substring(final int start, final int end) {\n        if (start < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(start);\n        }\n        if (end > count) {\n            throw new java.lang.StringIndexOutOfBoundsException(end);\n        }\n        if (start > end) {\n            throw new java.lang.StringIndexOutOfBoundsException(end - start);\n        }\n        return new java.lang.String(value, start, end - start);\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int index, final char[] str, final int offset, final int len) {\n        if ((index < 0) || (index > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        if (((offset < 0) || ((offset + len) < 0)) || ((offset + len) > str.length)) {\n            throw new java.lang.StringIndexOutOfBoundsException(offset);\n        }\n        if (len < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(len);\n        }\n        int newCount = count + len;\n        if (newCount > value.length) {\n            expandCapacity(newCount);\n        }\n        java.lang.System.arraycopy(value, index, value, index + len, count - index);\n        java.lang.System.arraycopy(str, offset, value, index, len);\n        count = newCount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final java.lang.Object obj) {\n        if (obj instanceof org.apache.wicket.util.string.AppendingStringBuffer) {\n            org.apache.wicket.util.string.AppendingStringBuffer asb = ((org.apache.wicket.util.string.AppendingStringBuffer) (obj));\n            return insert(offset, asb.value, 0, asb.count);\n        } else if (obj instanceof java.lang.StringBuffer) {\n            return insert(offset, ((java.lang.StringBuffer) (obj)));\n        } else if (obj instanceof java.lang.StringBuilder) {\n            return insert(offset, ((java.lang.StringBuilder) (obj)));\n        }\n        return insert(offset, java.lang.String.valueOf(obj));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, java.lang.String str) {\n        if ((offset < 0) || (offset > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        if (str == null) {\n            str = java.lang.String.valueOf(str);\n        }\n        int len = str.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + len, count - offset);\n        str.getChars(0, len, value, offset);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, java.lang.StringBuilder str) {\n        if ((offset < 0) || (offset > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        if (str == null) {\n            str = org.apache.wicket.util.string.AppendingStringBuffer.SB_NULL;\n        }\n        int len = str.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + len, count - offset);\n        str.getChars(0, len, value, offset);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, java.lang.StringBuffer str) {\n        if ((offset < 0) || (offset > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        if (str == null) {\n            str = org.apache.wicket.util.string.AppendingStringBuffer.SBF_NULL;\n        }\n        int len = str.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + len, count - offset);\n        str.getChars(0, len, value, offset);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final char[] str) {\n        if ((offset < 0) || (offset > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        int len = str.length;\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + len, count - offset);\n        java.lang.System.arraycopy(str, 0, value, offset, len);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final boolean b) {\n        return insert(offset, java.lang.String.valueOf(b));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final char c) {\n        int newcount = count + 1;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + 1, count - offset);\n        value[offset] = c;\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final int i) {\n        return insert(offset, java.lang.String.valueOf(i));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final long l) {\n        return insert(offset, java.lang.String.valueOf(l));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final float f) {\n        return insert(offset, java.lang.String.valueOf(f));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final double d) {\n        return insert(offset, java.lang.String.valueOf(d));\n    }\n\n    public int indexOf(final java.lang.String str) {\n        return indexOf(str, 0);\n    }\n\n    public int indexOf(final java.lang.String str, final int fromIndex) {\n        return org.apache.wicket.util.string.AppendingStringBuffer.indexOf(value, 0, count, str.toCharArray(), 0, str.length(), fromIndex);\n    }\n\n    static int indexOf(final char[] source, final int sourceOffset, final int sourceCount, final char[] target, final int targetOffset, final int targetCount, int fromIndex) {\n        if (fromIndex >= sourceCount) {\n            return targetCount == 0 ? sourceCount : -1;\n        }\n        if (fromIndex < 0) {\n            fromIndex = 0;\n        }\n        if (targetCount == 0) {\n            return fromIndex;\n        }\n        char first = target[targetOffset];\n        int i = sourceOffset + fromIndex;\n        int max = sourceOffset + (sourceCount - targetCount);\n        startSearchForFirstChar : while (true) {\n            while ((i <= max) && (source[i] != first)) {\n                i++;\n            } \n            if (i > max) {\n                return -1;\n            }\n            int j = i + 1;\n            int end = (j + targetCount) - 1;\n            int k = targetOffset + 1;\n            while (j < end) {\n                if (source[j++] != target[k++]) {\n                    i++;\n                    continue startSearchForFirstChar;\n                }\n            } \n            return i - sourceOffset;\n        } \n    }\n\n    public int lastIndexOf(final java.lang.String str) {\n        return lastIndexOf(str, count);\n    }\n\n    public int lastIndexOf(final java.lang.String str, final int fromIndex) {\n        return org.apache.wicket.util.string.AppendingStringBuffer.lastIndexOf(value, 0, count, str.toCharArray(), 0, str.length(), fromIndex);\n    }\n\n    static int lastIndexOf(final char[] source, final int sourceOffset, final int sourceCount, final char[] target, final int targetOffset, final int targetCount, int fromIndex) {\n        int rightIndex = sourceCount - targetCount;\n        if (fromIndex < 0) {\n            return -1;\n        }\n        if (fromIndex > rightIndex) {\n            fromIndex = rightIndex;\n        }\n        if (targetCount == 0) {\n            return fromIndex;\n        }\n        int strLastIndex = (targetOffset + targetCount) - 1;\n        char strLastChar = target[strLastIndex];\n        int min = (sourceOffset + targetCount) - 1;\n        int i = min + fromIndex;\n        startSearchForLastChar : while (true) {\n            while ((i >= min) && (source[i] != strLastChar)) {\n                i--;\n            } \n            if (i < min) {\n                return -1;\n            }\n            int j = i - 1;\n            int start = j - (targetCount - 1);\n            int k = strLastIndex - 1;\n            while (j > start) {\n                if (source[j--] != target[k--]) {\n                    i--;\n                    continue startSearchForLastChar;\n                }\n            } \n            return (start - sourceOffset) + 1;\n        } \n    }\n\n    public boolean startsWith(final java.lang.CharSequence prefix, final int toffset) {\n        char[] ta = value;\n        int to = toffset;\n        int po = 0;\n        int pc = prefix.length();\n        if ((toffset < 0) || (toffset > (count - pc))) {\n            return false;\n        }\n        while ((--pc) >= 0) {\n            if (ta[to++] != prefix.charAt(po++)) {\n                return false;\n            }\n        } \n        return true;\n    }\n\n    public boolean startsWith(final java.lang.CharSequence prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    public boolean endsWith(final java.lang.CharSequence suffix) {\n        return startsWith(suffix, count - suffix.length());\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return new java.lang.String(value, 0, count);\n    }\n\n    public final char[] getValue() {\n        return value;\n    }\n\n    private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, java.lang.ClassNotFoundException {\n        s.defaultReadObject();\n        value = value.clone();\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof org.apache.wicket.util.string.AppendingStringBuffer) {\n            org.apache.wicket.util.string.AppendingStringBuffer anotherString = ((org.apache.wicket.util.string.AppendingStringBuffer) (anObject));\n            int n = count;\n            if (n == anotherString.count) {\n                char[] v1 = value;\n                char[] v2 = anotherString.value;\n                int i = 0;\n                while ((n--) != 0) {\n                    if (v1[i] != v2[i++]) {\n                        return false;\n                    }\n                } \n                return true;\n            }\n        } else if (anObject instanceof java.lang.CharSequence) {\n            java.lang.CharSequence sequence = ((java.lang.CharSequence) (anObject));\n            int n = count;\n            if (sequence.length() == count) {\n                char[] v1 = value;\n                int i = 0;\n                while ((n--) != 0) {\n                    if (v1[i] != sequence.charAt(i++)) {\n                        return false;\n                    }\n                } \n                return true;\n            }\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n        int h = 0;\n        if (h == 0) {\n            int off = 0;\n            char[] val = value;\n            int len = count;\n            for (int i = 0; i < len; i++) {\n                h = (31 * h) + val[off++];\n            }\n        }\n        return h;\n    }\n\n    public void clear() {\n        count = 0;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, java.lang.StringBuffer str) {\n    if ((offset < 0) || (offset > count)) {\n        throw new java.lang.StringIndexOutOfBoundsException();\n    }\n    if (str == null) {\n        str = org.apache.wicket.util.string.AppendingStringBuffer.SBF_NULL;\n    }\n    int len = str.length();\n    int newcount = count + len;\n    if (newcount > value.length) {\n        expandCapacity(newcount);\n    }\n    java.lang.System.arraycopy(value, offset, value, offset + len, count - offset);\n    str.getChars(0, len, value, offset);\n    count = newcount;\n    return this;\n}",
            "src_parent": "public final class AppendingStringBuffer implements java.io.Serializable , java.lang.CharSequence {\n    private static final long serialVersionUID = 1L;\n\n    private static final org.apache.wicket.util.string.AppendingStringBuffer NULL = new org.apache.wicket.util.string.AppendingStringBuffer(\"null\");\n\n    private static final java.lang.StringBuilder SB_NULL = new java.lang.StringBuilder(\"null\");\n\n    private static final java.lang.StringBuffer SBF_NULL = new java.lang.StringBuffer(\"null\");\n\n    private char[] value;\n\n    private int count;\n\n    public AppendingStringBuffer() {\n        this(16);\n    }\n\n    public AppendingStringBuffer(final int length) {\n        value = new char[length];\n    }\n\n    public AppendingStringBuffer(final java.lang.CharSequence str) {\n        this(str.length() + 16);\n        append(str);\n    }\n\n    public int length() {\n        return count;\n    }\n\n    public int capacity() {\n        return value.length;\n    }\n\n    public void ensureCapacity(final int minimumCapacity) {\n        if (minimumCapacity > value.length) {\n            expandCapacity(minimumCapacity);\n        }\n    }\n\n    private void expandCapacity(final int minimumCapacity) {\n        int newCapacity = (value.length + 1) * 2;\n        if (newCapacity < 0) {\n            newCapacity = java.lang.Integer.MAX_VALUE;\n        } else if (minimumCapacity > newCapacity) {\n            newCapacity = minimumCapacity;\n        }\n        char[] newValue = new char[newCapacity];\n        java.lang.System.arraycopy(value, 0, newValue, 0, count);\n        value = newValue;\n    }\n\n    public void setLength(final int newLength) {\n        if (newLength < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(newLength);\n        }\n        if (newLength > value.length) {\n            expandCapacity(newLength);\n        }\n        if (count < newLength) {\n            for (; count < newLength; count++) {\n                value[count] = '\\u0000';\n            }\n        } else {\n            count = newLength;\n        }\n    }\n\n    public char charAt(final int index) {\n        if ((index < 0) || (index >= count)) {\n            throw new java.lang.StringIndexOutOfBoundsException(index);\n        }\n        return value[index];\n    }\n\n    public void getChars(final int srcBegin, final int srcEnd, final char[] dst, final int dstBegin) {\n        if (srcBegin < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(srcBegin);\n        }\n        if ((srcEnd < 0) || (srcEnd > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException(srcEnd);\n        }\n        if (srcBegin > srcEnd) {\n            throw new java.lang.StringIndexOutOfBoundsException(\"srcBegin > srcEnd\");\n        }\n        java.lang.System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);\n    }\n\n    public void setCharAt(final int index, final char ch) {\n        if ((index < 0) || (index >= count)) {\n            throw new java.lang.StringIndexOutOfBoundsException(index);\n        }\n        value[index] = ch;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final java.lang.Object obj) {\n        if (obj instanceof org.apache.wicket.util.string.AppendingStringBuffer) {\n            return append(((org.apache.wicket.util.string.AppendingStringBuffer) (obj)));\n        } else if (obj instanceof java.lang.StringBuilder) {\n            return append(((java.lang.StringBuilder) (obj)));\n        } else if (obj instanceof java.lang.StringBuffer) {\n            return append(obj.toString());\n        }\n        return append(java.lang.String.valueOf(obj));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(java.lang.String str) {\n        if (str == null) {\n            str = java.lang.String.valueOf(str);\n        }\n        int len = str.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        str.getChars(0, len, value, count);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(org.apache.wicket.util.string.AppendingStringBuffer sb) {\n        if (sb == null) {\n            sb = org.apache.wicket.util.string.AppendingStringBuffer.NULL;\n        }\n        int len = sb.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        sb.getChars(0, len, value, count);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(java.lang.StringBuilder sb) {\n        if (sb == null) {\n            sb = org.apache.wicket.util.string.AppendingStringBuffer.SB_NULL;\n        }\n        int len = sb.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        sb.getChars(0, len, value, count);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final char[] str) {\n        int len = str.length;\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(str, 0, value, count, len);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final char[] str, final int offset, final int len) {\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(str, offset, value, count, len);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final boolean b) {\n        if (b) {\n            int newcount = count + 4;\n            if (newcount > value.length) {\n                expandCapacity(newcount);\n            }\n            value[count++] = 't';\n            value[count++] = 'r';\n            value[count++] = 'u';\n            value[count++] = 'e';\n        } else {\n            int newcount = count + 5;\n            if (newcount > value.length) {\n                expandCapacity(newcount);\n            }\n            value[count++] = 'f';\n            value[count++] = 'a';\n            value[count++] = 'l';\n            value[count++] = 's';\n            value[count++] = 'e';\n        }\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final char c) {\n        int newcount = count + 1;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        value[count++] = c;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final int i) {\n        return append(java.lang.String.valueOf(i));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final long l) {\n        return append(java.lang.String.valueOf(l));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final float f) {\n        return append(java.lang.String.valueOf(f));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer append(final double d) {\n        return append(java.lang.String.valueOf(d));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer delete(final int start, int end) {\n        if (start < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(start);\n        }\n        if (end > count) {\n            end = count;\n        }\n        if (start > end) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        int len = end - start;\n        if (len > 0) {\n            java.lang.System.arraycopy(value, start + len, value, start, count - end);\n            count -= len;\n        }\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer deleteCharAt(final int index) {\n        if ((index < 0) || (index >= count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        java.lang.System.arraycopy(value, index + 1, value, index, (count - index) - 1);\n        count--;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer replace(final int start, int end, final java.lang.String str) {\n        if (start < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(start);\n        }\n        if (end > count) {\n            end = count;\n        }\n        if (start > end) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        int len = str.length();\n        int newCount = (count + len) - (end - start);\n        if (newCount > value.length) {\n            expandCapacity(newCount);\n        }\n        java.lang.System.arraycopy(value, end, value, start + len, count - end);\n        str.getChars(0, len, value, start);\n        count = newCount;\n        return this;\n    }\n\n    public java.lang.String substring(final int start) {\n        return substring(start, count);\n    }\n\n    public java.lang.CharSequence subSequence(final int start, final int end) {\n        return this.substring(start, end);\n    }\n\n    public java.lang.String substring(final int start, final int end) {\n        if (start < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(start);\n        }\n        if (end > count) {\n            throw new java.lang.StringIndexOutOfBoundsException(end);\n        }\n        if (start > end) {\n            throw new java.lang.StringIndexOutOfBoundsException(end - start);\n        }\n        return new java.lang.String(value, start, end - start);\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int index, final char[] str, final int offset, final int len) {\n        if ((index < 0) || (index > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        if (((offset < 0) || ((offset + len) < 0)) || ((offset + len) > str.length)) {\n            throw new java.lang.StringIndexOutOfBoundsException(offset);\n        }\n        if (len < 0) {\n            throw new java.lang.StringIndexOutOfBoundsException(len);\n        }\n        int newCount = count + len;\n        if (newCount > value.length) {\n            expandCapacity(newCount);\n        }\n        java.lang.System.arraycopy(value, index, value, index + len, count - index);\n        java.lang.System.arraycopy(str, offset, value, index, len);\n        count = newCount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final java.lang.Object obj) {\n        if (obj instanceof org.apache.wicket.util.string.AppendingStringBuffer) {\n            org.apache.wicket.util.string.AppendingStringBuffer asb = ((org.apache.wicket.util.string.AppendingStringBuffer) (obj));\n            return insert(offset, asb.value, 0, asb.count);\n        } else if (obj instanceof java.lang.StringBuffer) {\n            return insert(offset, ((java.lang.StringBuffer) (obj)));\n        } else if (obj instanceof java.lang.StringBuilder) {\n            return insert(offset, ((java.lang.StringBuilder) (obj)));\n        }\n        return insert(offset, java.lang.String.valueOf(obj));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, java.lang.String str) {\n        if ((offset < 0) || (offset > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        if (str == null) {\n            str = java.lang.String.valueOf(str);\n        }\n        int len = str.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + len, count - offset);\n        str.getChars(0, len, value, offset);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, java.lang.StringBuilder str) {\n        if ((offset < 0) || (offset > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        if (str == null) {\n            str = org.apache.wicket.util.string.AppendingStringBuffer.SB_NULL;\n        }\n        int len = str.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + len, count - offset);\n        str.getChars(0, len, value, offset);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, java.lang.StringBuffer str) {\n        if ((offset < 0) || (offset > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        if (str == null) {\n            str = org.apache.wicket.util.string.AppendingStringBuffer.SBF_NULL;\n        }\n        int len = str.length();\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + len, count - offset);\n        str.getChars(0, len, value, offset);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final char[] str) {\n        if ((offset < 0) || (offset > count)) {\n            throw new java.lang.StringIndexOutOfBoundsException();\n        }\n        int len = str.length;\n        int newcount = count + len;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + len, count - offset);\n        java.lang.System.arraycopy(str, 0, value, offset, len);\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final boolean b) {\n        return insert(offset, java.lang.String.valueOf(b));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final char c) {\n        int newcount = count + 1;\n        if (newcount > value.length) {\n            expandCapacity(newcount);\n        }\n        java.lang.System.arraycopy(value, offset, value, offset + 1, count - offset);\n        value[offset] = c;\n        count = newcount;\n        return this;\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final int i) {\n        return insert(offset, java.lang.String.valueOf(i));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final long l) {\n        return insert(offset, java.lang.String.valueOf(l));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final float f) {\n        return insert(offset, java.lang.String.valueOf(f));\n    }\n\n    public org.apache.wicket.util.string.AppendingStringBuffer insert(final int offset, final double d) {\n        return insert(offset, java.lang.String.valueOf(d));\n    }\n\n    public int indexOf(final java.lang.String str) {\n        return indexOf(str, 0);\n    }\n\n    public int indexOf(final java.lang.String str, final int fromIndex) {\n        return org.apache.wicket.util.string.AppendingStringBuffer.indexOf(value, 0, count, str.toCharArray(), 0, str.length(), fromIndex);\n    }\n\n    static int indexOf(final char[] source, final int sourceOffset, final int sourceCount, final char[] target, final int targetOffset, final int targetCount, int fromIndex) {\n        if (fromIndex >= sourceCount) {\n            return targetCount == 0 ? sourceCount : -1;\n        }\n        if (fromIndex < 0) {\n            fromIndex = 0;\n        }\n        if (targetCount == 0) {\n            return fromIndex;\n        }\n        char first = target[targetOffset];\n        int i = sourceOffset + fromIndex;\n        int max = sourceOffset + (sourceCount - targetCount);\n        startSearchForFirstChar : while (true) {\n            while ((i <= max) && (source[i] != first)) {\n                i++;\n            } \n            if (i > max) {\n                return -1;\n            }\n            int j = i + 1;\n            int end = (j + targetCount) - 1;\n            int k = targetOffset + 1;\n            while (j < end) {\n                if (source[j++] != target[k++]) {\n                    i++;\n                    continue startSearchForFirstChar;\n                }\n            } \n            return i - sourceOffset;\n        } \n    }\n\n    public int lastIndexOf(final java.lang.String str) {\n        return lastIndexOf(str, count);\n    }\n\n    public int lastIndexOf(final java.lang.String str, final int fromIndex) {\n        return org.apache.wicket.util.string.AppendingStringBuffer.lastIndexOf(value, 0, count, str.toCharArray(), 0, str.length(), fromIndex);\n    }\n\n    static int lastIndexOf(final char[] source, final int sourceOffset, final int sourceCount, final char[] target, final int targetOffset, final int targetCount, int fromIndex) {\n        int rightIndex = sourceCount - targetCount;\n        if (fromIndex < 0) {\n            return -1;\n        }\n        if (fromIndex > rightIndex) {\n            fromIndex = rightIndex;\n        }\n        if (targetCount == 0) {\n            return fromIndex;\n        }\n        int strLastIndex = (targetOffset + targetCount) - 1;\n        char strLastChar = target[strLastIndex];\n        int min = (sourceOffset + targetCount) - 1;\n        int i = min + fromIndex;\n        startSearchForLastChar : while (true) {\n            while ((i >= min) && (source[i] != strLastChar)) {\n                i--;\n            } \n            if (i < min) {\n                return -1;\n            }\n            int j = i - 1;\n            int start = j - (targetCount - 1);\n            int k = strLastIndex - 1;\n            while (j > start) {\n                if (source[j--] != target[k--]) {\n                    i--;\n                    continue startSearchForLastChar;\n                }\n            } \n            return (start - sourceOffset) + 1;\n        } \n    }\n\n    public boolean startsWith(final java.lang.CharSequence prefix, final int toffset) {\n        char[] ta = value;\n        int to = toffset;\n        int po = 0;\n        int pc = prefix.length();\n        if ((toffset < 0) || (toffset > (count - pc))) {\n            return false;\n        }\n        while ((--pc) >= 0) {\n            if (ta[to++] != prefix.charAt(po++)) {\n                return false;\n            }\n        } \n        return true;\n    }\n\n    public boolean startsWith(final java.lang.CharSequence prefix) {\n        return startsWith(prefix, 0);\n    }\n\n    public boolean endsWith(final java.lang.CharSequence suffix) {\n        return startsWith(suffix, count - suffix.length());\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return new java.lang.String(value, 0, count);\n    }\n\n    public final char[] getValue() {\n        return value;\n    }\n\n    private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, java.lang.ClassNotFoundException {\n        s.defaultReadObject();\n        value = value.clone();\n    }\n\n    @java.lang.Override\n    public boolean equals(final java.lang.Object anObject) {\n        if (this == anObject) {\n            return true;\n        }\n        if (anObject instanceof org.apache.wicket.util.string.AppendingStringBuffer) {\n            org.apache.wicket.util.string.AppendingStringBuffer anotherString = ((org.apache.wicket.util.string.AppendingStringBuffer) (anObject));\n            int n = count;\n            if (n == anotherString.count) {\n                char[] v1 = value;\n                char[] v2 = anotherString.value;\n                int i = 0;\n                while ((n--) != 0) {\n                    if (v1[i] != v2[i++]) {\n                        return false;\n                    }\n                } \n                return true;\n            }\n        } else if (anObject instanceof java.lang.CharSequence) {\n            java.lang.CharSequence sequence = ((java.lang.CharSequence) (anObject));\n            int n = count;\n            if (sequence.length() == count) {\n                char[] v1 = value;\n                int i = 0;\n                while ((n--) != 0) {\n                    if (v1[i] != sequence.charAt(i++)) {\n                        return false;\n                    }\n                } \n                return true;\n            }\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n        int h = 0;\n        if (h == 0) {\n            int off = 0;\n            char[] val = value;\n            int len = count;\n            for (int i = 0; i < len; i++) {\n                h = (31 * h) + val[off++];\n            }\n        }\n        return h;\n    }\n\n    public void clear() {\n        count = 0;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "{\n    if (obj instanceof java.lang.StringBuffer) {\n        return insert(offset, ((java.lang.StringBuffer) (obj)));\n    } else if (obj instanceof java.lang.StringBuilder) {\n        return insert(offset, ((java.lang.StringBuilder) (obj)));\n    }\n}",
            "src_parent": "if (obj instanceof org.apache.wicket.util.string.AppendingStringBuffer) {\n    org.apache.wicket.util.string.AppendingStringBuffer asb = ((org.apache.wicket.util.string.AppendingStringBuffer) (obj));\n    return insert(offset, asb.value, 0, asb.count);\n} else if (obj instanceof java.lang.StringBuffer) {\n    return insert(offset, ((java.lang.StringBuffer) (obj)));\n} else if (obj instanceof java.lang.StringBuilder) {\n    return insert(offset, ((java.lang.StringBuilder) (obj)));\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "obj instanceof java.lang.StringBuilder",
            "src_parent": "if (obj instanceof java.lang.StringBuilder) {\n    return insert(offset, ((java.lang.StringBuilder) (obj)));\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "{\n    return insert(offset, ((java.lang.StringBuilder) (obj)));\n}",
            "src_parent": "if (obj instanceof java.lang.StringBuilder) {\n    return insert(offset, ((java.lang.StringBuilder) (obj)));\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "obj instanceof java.lang.StringBuffer",
            "dst_parent": "if (obj instanceof java.lang.StringBuffer) {\n    return insert(offset, ((java.lang.StringBuffer) (obj)));\n} else if (obj instanceof java.lang.StringBuilder) {\n    return insert(offset, ((java.lang.StringBuilder) (obj)));\n}",
            "dst_parent_type": "If",
            "dst_type": "BinaryOperator",
            "operator": "MOV",
            "src": "obj instanceof java.lang.StringBuffer",
            "src_parent": "if (obj instanceof java.lang.StringBuffer) {\n    return insert(offset, obj);\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    return insert(offset, ((java.lang.StringBuffer) (obj)));\n}",
            "dst_parent": "if (obj instanceof java.lang.StringBuffer) {\n    return insert(offset, ((java.lang.StringBuffer) (obj)));\n} else if (obj instanceof java.lang.StringBuilder) {\n    return insert(offset, ((java.lang.StringBuilder) (obj)));\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    return insert(offset, obj);\n}",
            "src_parent": "if (obj instanceof java.lang.StringBuffer) {\n    return insert(offset, obj);\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    if (obj instanceof java.lang.StringBuilder) {\n        return insert(offset, ((java.lang.StringBuilder) (obj)));\n    }\n}",
            "dst_parent": "if (obj instanceof java.lang.StringBuffer) {\n    return insert(offset, ((java.lang.StringBuffer) (obj)));\n} else if (obj instanceof java.lang.StringBuilder) {\n    return insert(offset, ((java.lang.StringBuilder) (obj)));\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    if (obj instanceof java.lang.StringBuffer) {\n        return insert(offset, obj);\n    }\n}",
            "src_parent": "if (obj instanceof org.apache.wicket.util.string.AppendingStringBuffer) {\n    org.apache.wicket.util.string.AppendingStringBuffer asb = ((org.apache.wicket.util.string.AppendingStringBuffer) (obj));\n    return insert(offset, asb.value, 0, asb.count);\n} else if (obj instanceof java.lang.StringBuffer) {\n    return insert(offset, obj);\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        }
      ],
      "file_name": "AppendingStringBuffer"
    }
  ],
  "id": "wicket_a0150366"
}