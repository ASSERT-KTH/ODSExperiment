{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private synchronized void internalRunBackgroundOperations() {\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent": "public final class DocumentNodeStore implements org.apache.jackrabbit.oak.plugins.document.RevisionContext , org.apache.jackrabbit.oak.spi.commit.Observable , org.apache.jackrabbit.oak.spi.state.NodeStore {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.class);\n\n    private static final org.apache.jackrabbit.oak.util.PerfLogger PERFLOG = new org.apache.jackrabbit.oak.util.PerfLogger(org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.class.getName() + \".perf\"));\n\n    static final int NUM_CHILDREN_CACHE_LIMIT = java.lang.Integer.getInteger(\"oak.documentMK.childrenCacheLimit\", 16 * 1024);\n\n    private static final int WARN_REVISION_AGE = java.lang.Integer.getInteger(\"oak.documentMK.revisionAge\", 60 * 1000);\n\n    static final int REMEMBER_REVISION_ORDER_MILLIS = (60 * 60) * 1000;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState missing;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.CommitQueue commitQueue;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue batchCommitQueue;\n\n    protected final org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher dispatcher;\n\n    protected int asyncDelay = 1000;\n\n    protected int maxBackOffMillis = asyncDelay * 2;\n\n    private final java.util.concurrent.atomic.AtomicBoolean isDisposed = new java.util.concurrent.atomic.AtomicBoolean();\n\n    private final org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo clusterNodeInfo;\n\n    private final int clusterId;\n\n    private final java.util.concurrent.ConcurrentMap<java.lang.Integer, java.lang.Long> inactiveClusterNodes = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, java.lang.Long>();\n\n    private final Revision.RevisionComparator revisionComparator;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnmergedBranches branches;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnsavedModifications unsavedLastRevisions = new org.apache.jackrabbit.oak.plugins.document.UnsavedModifications();\n\n    private final java.util.Map<java.lang.String, java.lang.String> splitCandidates = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastKnownRevision = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision>();\n\n    private volatile org.apache.jackrabbit.oak.plugins.document.Revision headRevision;\n\n    private java.lang.Thread backgroundThread;\n\n    private java.lang.Thread leaseUpdateThread;\n\n    private final java.util.concurrent.locks.ReadWriteLock backgroundOperationLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private final java.util.concurrent.locks.ReadWriteLock mergeLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private java.util.concurrent.atomic.AtomicInteger simpleRevisionCounter;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> nodeCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children> nodeChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeChildrenCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.util.StringValue, org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children> docChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats docChildrenCacheStats;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DiffCache diffCache;\n\n    private final org.apache.jackrabbit.oak.spi.blob.BlobStore blobStore;\n\n    private final org.apache.jackrabbit.oak.json.BlobSerializer blobSerializer = new org.apache.jackrabbit.oak.json.BlobSerializer() {\n        @java.lang.Override\n        public java.lang.String serialize(org.apache.jackrabbit.oak.api.Blob blob) {\n            if (blob instanceof org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) {\n                return ((org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) (blob)).getBlobId();\n            }\n            java.lang.String id;\n            java.lang.String reference = blob.getReference();\n            if (reference != null) {\n                id = blobStore.getBlobId(reference);\n                if (id != null) {\n                    return id;\n                }\n            }\n            try {\n                id = createBlob(blob.getNewStream()).getBlobId();\n            } catch (java.io.IOException e) {\n                throw new java.lang.IllegalStateException(e);\n            }\n            return id;\n        }\n    };\n\n    private final org.apache.jackrabbit.oak.stats.Clock clock;\n\n    private final org.apache.jackrabbit.oak.plugins.document.Checkpoints checkpoints;\n\n    private final org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector versionGarbageCollector;\n\n    private final java.util.concurrent.Executor executor;\n\n    private final org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent lastRevRecoveryAgent;\n\n    private final boolean disableBranches;\n\n    private org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean mbean;\n\n    public DocumentNodeStore(org.apache.jackrabbit.oak.plugins.document.DocumentMK.Builder builder) {\n        this.blobStore = builder.getBlobStore();\n        if (builder.isUseSimpleRevision()) {\n            this.simpleRevisionCounter = new java.util.concurrent.atomic.AtomicInteger(0);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentStore s = builder.getDocumentStore();\n        if (builder.getTiming()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.TimingDocumentStoreWrapper(s);\n        }\n        if (builder.getLogging()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.LoggingDocumentStoreWrapper(s);\n        }\n        this.store = s;\n        this.executor = builder.getExecutor();\n        this.clock = builder.getClock();\n        int cid = builder.getClusterId();\n        cid = java.lang.Integer.getInteger(\"oak.documentMK.clusterId\", cid);\n        if (cid == 0) {\n            clusterNodeInfo = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getInstance(store);\n            cid = clusterNodeInfo.getId();\n        } else {\n            clusterNodeInfo = null;\n        }\n        this.clusterId = cid;\n        this.revisionComparator = new org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator(clusterId);\n        this.branches = new org.apache.jackrabbit.oak.plugins.document.UnmergedBranches(getRevisionComparator());\n        this.asyncDelay = builder.getAsyncDelay();\n        this.versionGarbageCollector = new org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector(this, builder.createVersionGCSupport());\n        this.lastRevRecoveryAgent = new org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent(this);\n        this.disableBranches = builder.isDisableBranches();\n        this.missing = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"MISSING\", new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, 0)) {\n            @java.lang.Override\n            public int getMemory() {\n                return 8;\n            }\n        };\n        nodeCache = builder.buildNodeCache(this);\n        nodeCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeCache, \"Document-NodeState\", builder.getWeigher(), builder.getNodeCacheSize());\n        nodeChildrenCache = builder.buildChildrenCache();\n        nodeChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeChildrenCache, \"Document-NodeChildren\", builder.getWeigher(), builder.getChildrenCacheSize());\n        docChildrenCache = builder.buildDocChildrenCache();\n        docChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(docChildrenCache, \"Document-DocChildren\", builder.getWeigher(), builder.getDocChildrenCacheSize());\n        diffCache = builder.getDiffCache();\n        checkpoints = new org.apache.jackrabbit.oak.plugins.document.Checkpoints(this);\n        if (store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\")) == null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision();\n            org.apache.jackrabbit.oak.plugins.document.Commit commit = new org.apache.jackrabbit.oak.plugins.document.Commit(this, head, null, null);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"/\", head);\n            commit.addNode(n);\n            commit.applyToDocumentStore();\n            commit.applyToCache(new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId), false);\n            setHeadRevision(commit.getRevision());\n            backgroundWrite();\n        } else {\n            branches.init(store, this);\n            backgroundRead(false);\n            if (headRevision == null) {\n                setHeadRevision(newRevision());\n            }\n        }\n        getRevisionComparator().add(headRevision, org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0));\n        dispatcher = new org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher(getRoot());\n        commitQueue = new org.apache.jackrabbit.oak.plugins.document.CommitQueue(this, dispatcher);\n        batchCommitQueue = new org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue(store, revisionComparator);\n        backgroundThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundOperation(this, isDisposed), \"DocumentNodeStore background thread\");\n        backgroundThread.setDaemon(true);\n        checkLastRevRecovery();\n        renewClusterIdLease();\n        backgroundThread.start();\n        if (clusterNodeInfo != null) {\n            leaseUpdateThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundLeaseUpdate(this, isDisposed), \"DocumentNodeStore lease update thread\");\n            leaseUpdateThread.setDaemon(true);\n            leaseUpdateThread.start();\n        }\n        this.mbean = createMBean();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Initialized DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    }\n\n    private void checkLastRevRecovery() {\n        lastRevRecoveryAgent.recover(clusterId);\n    }\n\n    public void dispose() {\n        if (isDisposed.getAndSet(true)) {\n            return;\n        }\n        synchronized(isDisposed) {\n            isDisposed.notifyAll();\n        }\n        try {\n            backgroundThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n        internalRunBackgroundOperations();\n        if (leaseUpdateThread != null) {\n            try {\n                leaseUpdateThread.join();\n            } catch (java.lang.InterruptedException e) {\n            }\n        }\n        if (clusterNodeInfo != null) {\n            clusterNodeInfo.dispose();\n        }\n        store.dispose();\n        if (blobStore instanceof java.io.Closeable) {\n            try {\n                ((java.io.Closeable) (blobStore)).close();\n            } catch (java.io.IOException ex) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n            }\n        }\n        if (persistentCache != null) {\n            persistentCache.close();\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.Revision setHeadRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newHead) {\n        com.google.common.base.Preconditions.checkArgument(!newHead.isBranch());\n        org.apache.jackrabbit.oak.plugins.document.Revision previous = headRevision;\n        if (!com.google.common.base.Preconditions.checkNotNull(newHead).equals(previous)) {\n            headRevision = newHead;\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentStore getDocumentStore() {\n        return store;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newRevision() {\n        if (simpleRevisionCounter != null) {\n            return new org.apache.jackrabbit.oak.plugins.document.Revision(simpleRevisionCounter.getAndIncrement(), 0, clusterId);\n        }\n        return org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(clusterId);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit newCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        checkOpen();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.Commit(this, commitQueue.createRevision(), base, branch);\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.MergeCommit newMergeCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base, int numBranchCommits) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        checkOpen();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    void done(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit c, boolean isBranch, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) {\n        try {\n            commitQueue.done(c, isBranch, info);\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    void canceled(org.apache.jackrabbit.oak.plugins.document.Commit c) {\n        try {\n            commitQueue.canceled(c.getRevision());\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    public void setAsyncDelay(int delay) {\n        this.asyncDelay = delay;\n    }\n\n    public int getAsyncDelay() {\n        return asyncDelay;\n    }\n\n    public void setMaxBackOffMillis(int time) {\n        maxBackOffMillis = time;\n    }\n\n    public int getMaxBackOffMillis() {\n        return maxBackOffMillis;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo getClusterInfo() {\n        return clusterNodeInfo;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeCacheStats() {\n        return nodeCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeChildrenCacheStats() {\n        return nodeChildrenCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getDocChildrenCacheStats() {\n        return docChildrenCacheStats;\n    }\n\n    void invalidateDocChildrenCache() {\n        docChildrenCache.invalidateAll();\n    }\n\n    void invalidateNodeChildrenCache() {\n        nodeChildrenCache.invalidateAll();\n    }\n\n    void invalidateNodeCache(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        nodeCache.invalidate(new org.apache.jackrabbit.oak.plugins.document.PathRev(path, revision));\n    }\n\n    public int getPendingWriteCount() {\n        return unsavedLastRevisions.getPaths().size();\n    }\n\n    public boolean isDisableBranches() {\n        return disableBranches;\n    }\n\n    boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    void addSplitCandidate(java.lang.String id) {\n        splitCandidates.put(id, id);\n    }\n\n    void copyNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(false, source, targetPath, commit);\n    }\n\n    void moveNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(true, source, targetPath, commit);\n    }\n\n    void markAsDeleted(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, org.apache.jackrabbit.oak.plugins.document.Commit commit, boolean subTreeAlso) {\n        commit.removeNode(node.getPath());\n        if (subTreeAlso) {\n            for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(node, null, java.lang.Integer.MAX_VALUE)) {\n                markAsDeleted(child, commit, true);\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNode(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        checkRevisionAge(com.google.common.base.Preconditions.checkNotNull(rev), com.google.common.base.Preconditions.checkNotNull(path));\n        final long start = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.start();\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = new org.apache.jackrabbit.oak.plugins.document.PathRev(path, rev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node = nodeCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState call() throws java.lang.Exception {\n                    boolean nodeDoesNotExist = checkNodeNotExistsFromChildrenCache(path, rev);\n                    if (nodeDoesNotExist) {\n                        return missing;\n                    }\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = readNode(path, rev);\n                    if (n == null) {\n                        n = missing;\n                    }\n                    return n;\n                }\n            });\n            final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = ((node == missing) || node.equals(missing)) ? null : node;\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"getNode: path={}, rev={}\", path, rev);\n            return result;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        }\n    }\n\n    DocumentNodeState.Children getChildren(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return DocumentNodeState.NO_CHILDREN;\n        }\n        final java.lang.String path = com.google.common.base.Preconditions.checkNotNull(parent).getPath();\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, readRevision, name);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children children = nodeChildrenCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children>() {\n                @java.lang.Override\n                public DocumentNodeState.Children call() throws java.lang.Exception {\n                    return readChildren(parent, name, limit);\n                }\n            });\n            if ((children.children.size() < limit) && children.hasMore) {\n                children = readChildren(parent, name, limit);\n                nodeChildrenCache.put(key, children);\n            }\n            return children;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        }\n    }\n\n    DocumentNodeState.Children readChildren(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, java.lang.String name, int limit) {\n        java.lang.String queriedName = name;\n        java.lang.String path = parent.getPath();\n        org.apache.jackrabbit.oak.plugins.document.Revision rev = parent.getLastRevision();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"Reading children for [{}] ast rev [{}]\", path, rev);\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n        int rawLimit = ((int) (java.lang.Math.min(java.lang.Integer.MAX_VALUE, ((long) (limit)) + 1)));\n        for (; ;) {\n            docs = readChildDocs(path, name, rawLimit);\n            int numReturned = 0;\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                numReturned++;\n                java.lang.String p = doc.getPath();\n                name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child = getNode(p, rev);\n                if (child == null) {\n                    continue;\n                }\n                if (c.children.size() < limit) {\n                    c.children.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n                } else {\n                    c.hasMore = true;\n                    return c;\n                }\n            }\n            if (numReturned < rawLimit) {\n                c.hasMore = false;\n                if (queriedName == null) {\n                    java.util.Collections.sort(c.children);\n                }\n                return c;\n            }\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> readChildDocs(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nullable\n    java.lang.String name, int limit) {\n        java.lang.String to = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(com.google.common.base.Preconditions.checkNotNull(path));\n        java.lang.String from;\n        if (name != null) {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(concat(path, name));\n        } else {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        }\n        if ((name != null) || (limit > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NUM_CHILDREN_CACHE_LIMIT)) {\n            return store.query(Collection.NODES, from, to, limit);\n        }\n        org.apache.jackrabbit.oak.plugins.document.util.StringValue key = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children c = docChildrenCache.getIfPresent(key);\n        if (c == null) {\n            c = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, limit);\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                c.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            c.isComplete = docs.size() < limit;\n            docChildrenCache.put(key, c);\n            return docs;\n        } else if ((c.childNames.size() < limit) && (!c.isComplete)) {\n            java.lang.String lastName = c.childNames.get(c.childNames.size() - 1);\n            java.lang.String lastPath = concat(path, lastName);\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(lastPath);\n            int remainingLimit = limit - c.childNames.size();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, remainingLimit);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = c.clone();\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                clone.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            clone.isComplete = docs.size() < remainingLimit;\n            docChildrenCache.put(key, clone);\n            c = clone;\n        }\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> it = com.google.common.collect.Iterables.transform(c.childNames, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.lang.String name) {\n                java.lang.String p = concat(path, name);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(p));\n                if (doc == null) {\n                    docChildrenCache.invalidateAll();\n                    throw new java.lang.NullPointerException((\"Document \" + p) + \" not found\");\n                }\n                return doc;\n            }\n        });\n        if (c.childNames.size() > (limit * 2)) {\n            it = com.google.common.collect.Iterables.limit(it, limit * 2);\n        }\n        return it;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> getChildNodes(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return java.util.Collections.emptyList();\n        }\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        return com.google.common.collect.Iterables.transform(getChildren(parent, name, limit).children, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState apply(java.lang.String input) {\n                java.lang.String p = concat(parent.getPath(), input);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = getNode(p, readRevision);\n                if (result == null) {\n                    throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((((\"DocumentNodeState is null for revision \" + readRevision) + \" of \") + p) + \" (aborting getChildNodes())\");\n                }\n                return result;\n            }\n        });\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState readNode(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        final long start = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.start();\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(path);\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = getPendingModifications().get(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n        if (doc == null) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"readNode: (document not found) path={}, readRevision={}\", path, readRevision);\n            return null;\n        }\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = doc.getNodeAtRevision(this, readRevision, lastRevision);\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"readNode: path={}, readRevision={}\", path, readRevision);\n        return result;\n    }\n\n    public void applyChanges(org.apache.jackrabbit.oak.plugins.document.Revision rev, java.lang.String path, boolean isNew, java.util.List<java.lang.String> added, java.util.List<java.lang.String> removed, java.util.List<java.lang.String> changed, org.apache.jackrabbit.oak.plugins.document.DiffCache.Entry cacheEntry) {\n        if (isNew && (!added.isEmpty())) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n            java.util.Set<java.lang.String> set = com.google.common.collect.Sets.newTreeSet();\n            for (java.lang.String p : added) {\n                set.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n            }\n            c.children.addAll(set);\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, rev, null);\n            nodeChildrenCache.put(key, c);\n        }\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        for (java.lang.String p : added) {\n            w.tag('+').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        for (java.lang.String p : removed) {\n            w.tag('-').value(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).newline();\n        }\n        for (java.lang.String p : changed) {\n            w.tag('^').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        cacheEntry.append(path, w.toString());\n        if (!added.isEmpty()) {\n            org.apache.jackrabbit.oak.plugins.document.util.StringValue docChildrenKey = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children docChildren = docChildrenCache.getIfPresent(docChildrenKey);\n            if (docChildren != null) {\n                int currentSize = docChildren.childNames.size();\n                java.util.NavigableSet<java.lang.String> names = com.google.common.collect.Sets.newTreeSet(docChildren.childNames);\n                if (!docChildren.isComplete) {\n                    for (java.lang.String childPath : added) {\n                        java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath);\n                        if (names.higher(name) != null) {\n                            names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(name));\n                        }\n                    }\n                } else {\n                    for (java.lang.String childPath : added) {\n                        names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath)));\n                    }\n                }\n                if (names.size() != currentSize) {\n                    boolean complete = docChildren.isComplete;\n                    docChildren = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n                    docChildren.isComplete = complete;\n                    docChildren.childNames.addAll(names);\n                    docChildrenCache.put(docChildrenKey, docChildren);\n                }\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument updateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        boolean batch = true;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> op : commit.getChanges().entrySet()) {\n            java.lang.String name = op.getKey().getName();\n            if ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name)) || NodeDocument.COLLISIONS.equals(name)) {\n                continue;\n            }\n            batch = false;\n            break;\n        }\n        if (batch) {\n            return batchUpdateCommitRoot(commit);\n        } else {\n            return store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, commit);\n        }\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument batchUpdateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        try {\n            return batchCommitQueue.updateDocument(commit).call();\n        } catch (java.lang.InterruptedException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Interrupted while updating commit root document\");\n        } catch (java.lang.Exception e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Update of commit root document failed\");\n        }\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState root = getNode(\"/\", revision);\n        if (root == null) {\n            throw new java.lang.IllegalStateException(\"root node does not exist at revision \" + revision);\n        }\n        return root;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch createBranch(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch b = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch.getCurrentBranch();\n        if (b != null) {\n            return b;\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch(this, base, mergeLock);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision base) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(base);\n        if (disableBranches) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            return base.asBranchRevision();\n        }\n        if (b.getBase(branchHead).equals(base)) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision().asBranchRevision();\n        b.rebase(head, base);\n        return head;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision ancestor, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(ancestor);\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(\"Empty branch cannot be reset\");\n        }\n        if (!b.getCommits().last().equals(branchHead)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((branchHead + \" is not the head \") + \"of a branch\");\n        }\n        if (!b.containsCommit(ancestor)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(((ancestor + \" is not \") + \"an ancestor revision of \") + branchHead);\n        }\n        if (branchHead.equals(ancestor)) {\n            return branchHead;\n        }\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit commit = newCommit(branchHead, branch);\n        try {\n            java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> it = b.getCommits().tailSet(ancestor).iterator();\n            org.apache.jackrabbit.oak.plugins.document.Revision base = it.next();\n            java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.document.UpdateOp> operations = com.google.common.collect.Maps.newHashMap();\n            while (it.hasNext()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision reset = it.next();\n                getRoot(reset).compareAgainstBaseState(getRoot(base), new org.apache.jackrabbit.oak.plugins.document.ResetDiff(reset.asTrunkRevision(), operations));\n                org.apache.jackrabbit.oak.plugins.document.UpdateOp rootOp = operations.get(\"/\");\n                if (rootOp == null) {\n                    rootOp = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(rootOp, commit.getRevision());\n                    operations.put(\"/\", rootOp);\n                }\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n            } \n            if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n                java.util.List<org.apache.jackrabbit.oak.plugins.document.Revision> revs = com.google.common.collect.Lists.newArrayList(b.getCommits().tailSet(ancestor));\n                for (org.apache.jackrabbit.oak.plugins.document.Revision r : revs.subList(1, revs.size())) {\n                    b.removeCommit(r);\n                }\n                success = true;\n            }\n            operations.remove(\"/\");\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : operations.values()) {\n                store.findAndUpdate(Collection.NODES, op);\n            }\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, true, null);\n            }\n        }\n        return ancestor;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        org.apache.jackrabbit.oak.plugins.document.Revision base = branchHead;\n        if (b != null) {\n            base = b.getBase(branchHead);\n        }\n        int numBranchCommits = (b != null) ? b.getCommits().size() : 1;\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit commit = newMergeCommit(base, numBranchCommits);\n        try {\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(op, commit.getRevision());\n            if (b != null) {\n                java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> mergeCommits = commit.getMergeRevisions().iterator();\n                for (org.apache.jackrabbit.oak.plugins.document.Revision rev : b.getCommits()) {\n                    rev = rev.asTrunkRevision();\n                    java.lang.String commitTag = \"c-\" + mergeCommits.next();\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setRevision(op, rev, commitTag);\n                    op.containsMapEntry(NodeDocument.COLLISIONS, rev, false);\n                }\n                if (store.findAndUpdate(Collection.NODES, op) != null) {\n                    b.applyTo(getPendingModifications(), commit.getRevision());\n                    getBranches().remove(b);\n                } else {\n                    throw new org.apache.jackrabbit.oak.api.CommitFailedException(MERGE, 2, \"Conflicting concurrent change. Update operation failed: \" + op);\n                }\n            } else {\n            }\n            success = true;\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, false, info);\n            }\n        }\n        return commit.getRevision();\n    }\n\n    boolean compare(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.spi.state.NodeStateDiff diff) {\n        if (!org.apache.jackrabbit.oak.spi.state.AbstractNodeState.comparePropertiesAgainstBaseState(node, base, diff)) {\n            return false;\n        }\n        if (node.hasNoChildren() && base.hasNoChildren()) {\n            return true;\n        }\n        boolean useReadRevision = true;\n        java.lang.String jsop = diffCache.getChanges(base.getRevision(), node.getRevision(), node.getPath(), null);\n        if (jsop == null) {\n            useReadRevision = false;\n            jsop = diffCache.getChanges(base.getLastRevision(), node.getLastRevision(), node.getPath(), new org.apache.jackrabbit.oak.plugins.document.DiffCache.Loader() {\n                @java.lang.Override\n                public java.lang.String call() {\n                    return diffImpl(base, node);\n                }\n            });\n        }\n        return dispatch(jsop, node, base, diff, useReadRevision);\n    }\n\n    java.lang.String diff(@javax.annotation.Nonnull\n    final java.lang.String fromRevisionId, @javax.annotation.Nonnull\n    final java.lang.String toRevisionId, @javax.annotation.Nonnull\n    final java.lang.String path) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (fromRevisionId.equals(toRevisionId)) {\n            return \"\";\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision fromRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(fromRevisionId);\n        org.apache.jackrabbit.oak.plugins.document.Revision toRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(toRevisionId);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from = getNode(path, fromRev);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to = getNode(path, toRev);\n        if ((from == null) || (to == null)) {\n            java.lang.String msg = java.lang.String.format(\"Diff is only supported if the node exists in both cases. \" + \"Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s\", path, fromRev, from != null, toRev, to != null);\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(msg);\n        }\n        java.lang.String compactDiff = diffCache.getChanges(fromRev, toRev, path, new org.apache.jackrabbit.oak.plugins.document.DiffCache.Loader() {\n            @java.lang.Override\n            public java.lang.String call() {\n                return diffImpl(from, to);\n            }\n        });\n        org.apache.jackrabbit.oak.commons.json.JsopWriter writer = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.diffProperties(from, to, writer);\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer t = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(compactDiff);\n        int r;\n        do {\n            r = t.read();\n            switch (r) {\n                case '+' :\n                case '^' :\n                    {\n                        java.lang.String name = t.readString();\n                        t.read(':');\n                        t.read('{');\n                        t.read('}');\n                        writer.tag(((char) (r))).key(concat(path, name));\n                        writer.object().endObject().newline();\n                        break;\n                    }\n                case '-' :\n                    {\n                        java.lang.String name = t.readString();\n                        writer.tag('-').value(concat(path, name));\n                        writer.newline();\n                    }\n            }\n        } while (r != org.apache.jackrabbit.oak.commons.json.JsopReader.END );\n        return writer.toString();\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.LastRevTracker createTracker(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision r, final boolean isBranchCommit) {\n        if (isBranchCommit && (!disableBranches)) {\n            org.apache.jackrabbit.oak.plugins.document.Revision branchRev = r.asBranchRevision();\n            return branches.getBranchCommit(branchRev);\n        } else {\n            return new org.apache.jackrabbit.oak.plugins.document.LastRevTracker() {\n                @java.lang.Override\n                public void track(java.lang.String path) {\n                    unsavedLastRevisions.put(path, r);\n                }\n            };\n        }\n    }\n\n    @java.lang.Override\n    public java.io.Closeable addObserver(org.apache.jackrabbit.oak.spi.commit.Observer observer) {\n        return dispatcher.addObserver(observer);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot() {\n        return getRoot(headRevision);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitHook commitHook, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).merge(commitHook, info);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).rebase();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).reset();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob createBlob(java.io.InputStream inputStream) throws java.io.IOException {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobStore.writeBlob(inputStream));\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.api.Blob getBlob(java.lang.String reference) {\n        java.lang.String blobId = blobStore.getBlobId(reference);\n        if (blobId != null) {\n            return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"No blobId found matching reference [{}]\", reference);\n        return null;\n    }\n\n    public org.apache.jackrabbit.oak.api.Blob getBlobFromBlobId(java.lang.String blobId) {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime, @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> properties) {\n        return checkpoints.create(lifetime, properties).toString();\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime) {\n        java.util.Map<java.lang.String, java.lang.String> empty = java.util.Collections.emptyMap();\n        return checkpoint(lifetime, empty);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.util.Map<java.lang.String, java.lang.String> checkpointInfo(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info info = checkpoints.getCheckpoints().get(r);\n        if (info == null) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return info.get();\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState retrieve(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info> checkpoints = this.checkpoints.getCheckpoints();\n        if ((checkpoints != null) && checkpoints.containsKey(r)) {\n            return getRoot(r);\n        } else {\n            return null;\n        }\n    }\n\n    @java.lang.Override\n    public boolean release(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        checkpoints.release(checkpoint);\n        return true;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnmergedBranches getBranches() {\n        return branches;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnsavedModifications getPendingModifications() {\n        return unsavedLastRevisions;\n    }\n\n    @java.lang.Override\n    public Revision.RevisionComparator getRevisionComparator() {\n        return revisionComparator;\n    }\n\n    @java.lang.Override\n    public int getClusterId() {\n        return clusterId;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getHeadRevision() {\n        return headRevision;\n    }\n\n    public void runBackgroundOperations() {\n        if (isDisposed.get()) {\n            return;\n        }\n        try {\n            internalRunBackgroundOperations();\n        } catch (java.lang.RuntimeException e) {\n            if (isDisposed.get()) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + e.toString(), e);\n                return;\n            }\n            throw e;\n        }\n    }\n\n    private synchronized void internalRunBackgroundOperations() {\n        long start = clock.getTime();\n        long time = start;\n        cleanOrphanedBranches();\n        cleanCollisions();\n        long cleanTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundSplit();\n        long splitTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundWrite();\n        long writeTime = clock.getTime() - time;\n        time = clock.getTime();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n        long readTime = clock.getTime() - time;\n        java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n        if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        }\n    }\n\n    boolean renewClusterIdLease() {\n        return (clusterNodeInfo != null) && clusterNodeInfo.renewLease();\n    }\n\n    void updateClusterState() {\n        long now = clock.getTime();\n        java.util.Set<java.lang.Integer> inactive = com.google.common.collect.Sets.newHashSet();\n        for (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument doc : org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument.all(store)) {\n            int cId = doc.getClusterId();\n            if ((cId != this.clusterId) && (!doc.isActive())) {\n                inactive.add(cId);\n            }\n        }\n        inactiveClusterNodes.keySet().retainAll(inactive);\n        for (java.lang.Integer clusterId : inactive) {\n            inactiveClusterNodes.putIfAbsent(clusterId, now);\n        }\n    }\n\n    java.util.Map<java.lang.Integer, java.lang.Long> getInactiveClusterNodes() {\n        return new java.util.HashMap<java.lang.Integer, java.lang.Long>(inactiveClusterNodes);\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats backgroundRead(boolean dispatchChange) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats stats = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats();\n        long time = clock.getTime();\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\");\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\n        if (doc == null) {\n            return stats;\n        }\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevMap = doc.getLastRev();\n        org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator revisionComparator = getRevisionComparator();\n        org.apache.jackrabbit.oak.plugins.document.Revision headSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        org.apache.jackrabbit.oak.plugins.document.Revision otherSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> externalChanges = com.google.common.collect.Maps.newHashMap();\n        for (java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> e : lastRevMap.entrySet()) {\n            int machineId = e.getKey();\n            if (machineId == clusterId) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.Revision r = e.getValue();\n            org.apache.jackrabbit.oak.plugins.document.Revision last = lastKnownRevision.get(machineId);\n            if ((last == null) || (r.compareRevisionTime(last) > 0)) {\n                lastKnownRevision.put(machineId, r);\n                if ((last != null) || (r.getTimestamp() > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())) {\n                    externalChanges.put(r, otherSeen);\n                }\n            }\n        }\n        stats.readHead = clock.getTime() - time;\n        time = clock.getTime();\n        if (!externalChanges.isEmpty()) {\n            stats.cacheStats = store.invalidateCache();\n            stats.cacheInvalidationTime = clock.getTime() - time;\n            time = clock.getTime();\n            docChildrenCache.invalidateAll();\n            backgroundOperationLock.writeLock().lock();\n            try {\n                revisionComparator.add(newRevision(), headSeen);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> e : externalChanges.entrySet()) {\n                    revisionComparator.add(e.getKey(), e.getValue());\n                }\n                setHeadRevision(newRevision());\n                if (dispatchChange) {\n                    dispatcher.contentChanged(getRoot(), null);\n                }\n            } finally {\n                backgroundOperationLock.writeLock().unlock();\n            }\n            stats.dispatchChanges = clock.getTime() - time;\n            time = clock.getTime();\n        }\n        revisionComparator.purge(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis());\n        stats.purge = clock.getTime() - time;\n        return stats;\n    }\n\n    private static class BackgroundReadStats {\n        org.apache.jackrabbit.oak.plugins.document.cache.CacheInvalidationStats cacheStats;\n\n        long readHead;\n\n        long cacheInvalidationTime;\n\n        long dispatchChanges;\n\n        long purge;\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            java.lang.String cacheStatsMsg = \"NOP\";\n            if (cacheStats != null) {\n                cacheStatsMsg = cacheStats.summaryReport();\n            }\n            return ((((((((((\"ReadStats{\" + \"cacheStats:\") + cacheStatsMsg) + \", head:\") + readHead) + \", cache:\") + cacheInvalidationTime) + \", dispatch:\") + dispatchChanges) + \", purge:\") + purge) + '}';\n        }\n    }\n\n    private static long revisionPurgeMillis() {\n        return org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS;\n    }\n\n    private void cleanOrphanedBranches() {\n        org.apache.jackrabbit.oak.plugins.document.Branch b;\n        while ((b = branches.pollOrphanedBranch()) != null) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Cleaning up orphaned branch with base revision: {}, \" + \"commits: {}\", b.getBase(), b.getCommits());\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n            for (org.apache.jackrabbit.oak.plugins.document.Revision r : b.getCommits()) {\n                r = r.asTrunkRevision();\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeRevision(op, r);\n            }\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, op);\n        } \n    }\n\n    private void cleanCollisions() {\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\");\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument root = store.find(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, id);\n        if (root == null) {\n            return;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision head = getHeadRevision();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = root.getLocalMap(NodeDocument.COLLISIONS);\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : map.keySet()) {\n            if (r.getClusterId() == clusterId) {\n                if ((branches.getBranchCommit(r) == null) && isRevisionNewer(head, r)) {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(op, r);\n                }\n            }\n        }\n        if (op.hasChanges()) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Removing collisions {}\", op.getChanges().keySet());\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, op);\n        }\n    }\n\n    private void backgroundSplit() {\n        for (java.util.Iterator<java.lang.String> it = splitCandidates.keySet().iterator(); it.hasNext();) {\n            java.lang.String id = it.next();\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n            if (doc == null) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : doc.split(this)) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument before = store.createOrUpdate(Collection.NODES, op);\n                if (before != null) {\n                    if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument after = store.find(Collection.NODES, op.getId());\n                        if (after != null) {\n                            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation on {}. Size before: {}, after: {}\", id, before.getMemory(), after.getMemory());\n                        }\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation created {}\", op.getId());\n                }\n            }\n            it.remove();\n        }\n    }\n\n    void backgroundWrite() {\n        unsavedLastRevisions.persist(this, backgroundOperationLock.writeLock());\n    }\n\n    private void checkOpen() throws java.lang.IllegalStateException {\n        if (isDisposed.get()) {\n            throw new java.lang.IllegalStateException(\"This DocumentNodeStore is disposed\");\n        }\n    }\n\n    private boolean dispatch(@javax.annotation.Nonnull\n    java.lang.String jsonDiff, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeStateDiff diff, boolean useReadRevision) {\n        if (jsonDiff.trim().isEmpty()) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision nodeRev = (useReadRevision) ? node.getRevision() : node.getLastRevision();\n        org.apache.jackrabbit.oak.plugins.document.Revision baseRev = (useReadRevision) ? base.getRevision() : base.getLastRevision();\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer t = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(jsonDiff);\n        boolean continueComparison = true;\n        while (continueComparison) {\n            int r = t.read();\n            if (r == org.apache.jackrabbit.oak.commons.json.JsopReader.END) {\n                break;\n            }\n            switch (r) {\n                case '+' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        t.read(':');\n                        t.read('{');\n                        while (t.read() != '}') {\n                        } \n                        org.apache.jackrabbit.oak.spi.state.NodeState child = getNode(concat(node.getPath(), name), nodeRev);\n                        continueComparison = diff.childNodeAdded(name, child);\n                        break;\n                    }\n                case '-' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        org.apache.jackrabbit.oak.spi.state.NodeState child = getNode(concat(base.getPath(), name), baseRev);\n                        continueComparison = diff.childNodeDeleted(name, child);\n                        break;\n                    }\n                case '^' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        t.read(':');\n                        if (t.matches('{')) {\n                            t.read('}');\n                            org.apache.jackrabbit.oak.spi.state.NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\n                            org.apache.jackrabbit.oak.spi.state.NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\n                            continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);\n                        } else if (t.matches('[')) {\n                            while (t.read() != ']') {\n                            } \n                        } else {\n                            t.read();\n                        }\n                        break;\n                    }\n                default :\n                    throw new java.lang.IllegalArgumentException(((((\"jsonDiff: illegal token '\" + t.getToken()) + \"' at pos: \") + t.getLastPos()) + ' ') + jsonDiff);\n            }\n        } \n        return continueComparison;\n    }\n\n    private boolean checkNodeNotExistsFromChildrenCache(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(path)) {\n            return false;\n        }\n        final java.lang.String parentPath = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(path);\n        org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(parentPath, rev, null);\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children children = nodeChildrenCache.getIfPresent(key);\n        java.lang.String lookupChildName = org.apache.jackrabbit.oak.commons.PathUtils.getName(path);\n        if (children == null) {\n            return false;\n        }\n        if (children.hasMore) {\n            return false;\n        }\n        int childPosition = java.util.Collections.binarySearch(children.children, lookupChildName);\n        if (childPosition < 0) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"Child node as per path {} does not exist at revision {}\", path, rev);\n            return true;\n        }\n        return false;\n    }\n\n    private static void diffProperties(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to, org.apache.jackrabbit.oak.commons.json.JsopWriter w) {\n        for (org.apache.jackrabbit.oak.api.PropertyState fromValue : from.getProperties()) {\n            java.lang.String name = fromValue.getName();\n            org.apache.jackrabbit.oak.api.PropertyState toValue = to.getProperty(name);\n            if (!fromValue.equals(toValue)) {\n                w.tag('^').key(concat(from.getPath(), name));\n                if (toValue == null) {\n                    w.value(null);\n                } else {\n                    w.encodedValue(to.getPropertyAsString(name)).newline();\n                }\n            }\n        }\n        for (java.lang.String name : to.getPropertyNames()) {\n            if (!from.hasProperty(name)) {\n                w.tag('^').key(concat(from.getPath(), name)).encodedValue(to.getPropertyAsString(name)).newline();\n            }\n        }\n    }\n\n    private java.lang.String diffImpl(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        int max = org.apache.jackrabbit.oak.plugins.document.DocumentMK.MANY_CHILDREN_THRESHOLD;\n        final boolean debug = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled();\n        final long start = (debug) ? org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now() : 0;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren;\n        fromChildren = getChildren(from, null, max);\n        toChildren = getChildren(to, null, max);\n        final long getChildrenDoneIn = (debug) ? org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now() : 0;\n        java.lang.String diffAlgo;\n        if ((!fromChildren.hasMore) && (!toChildren.hasMore)) {\n            diffAlgo = \"diffFewChildren\";\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        } else if (org.apache.jackrabbit.oak.plugins.document.DocumentMK.FAST_DIFF) {\n            diffAlgo = \"diffManyChildren\";\n            diffManyChildren(w, from.getPath(), from.getLastRevision(), to.getLastRevision());\n        } else {\n            diffAlgo = \"diffAllChildren\";\n            max = java.lang.Integer.MAX_VALUE;\n            fromChildren = getChildren(from, null, max);\n            toChildren = getChildren(to, null, max);\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        }\n        if (debug) {\n            long end = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now();\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Diff performed via '{}' at [{}] between revisions [{}] => [{}] took {} ms ({} ms)\", diffAlgo, from.getPath(), from.getLastRevision(), to.getLastRevision(), end - start, getChildrenDoneIn - start);\n        }\n        return w.toString();\n    }\n\n    private void diffManyChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        long minTimestamp = java.lang.Math.min(revisionComparator.getMinimumTimestamp(fromRev, inactiveClusterNodes), revisionComparator.getMinimumTimestamp(toRev, inactiveClusterNodes));\n        long minValue = org.apache.jackrabbit.oak.plugins.document.NodeDocument.getModifiedInSecs(minTimestamp);\n        java.lang.String fromKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        java.lang.String toKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(path);\n        java.util.Set<java.lang.String> paths = com.google.common.collect.Sets.newHashSet();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"diffManyChildren: path: {}, fromRev: {}, toRev: {}\", path, fromRev, toRev);\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED_IN_SECS, minValue, java.lang.Integer.MAX_VALUE)) {\n            paths.add(doc.getPath());\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"diffManyChildren: Affected paths: {}\", paths.size());\n        org.apache.jackrabbit.oak.plugins.document.Revision minRev = new org.apache.jackrabbit.oak.plugins.document.Revision(minTimestamp, 0, getClusterId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, getPendingModifications().getPaths(minRev));\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : new org.apache.jackrabbit.oak.plugins.document.Revision[]{ fromRev, toRev }) {\n            if (r.isBranch()) {\n                org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit c = getBranches().getBranchCommit(r);\n                if (c != null) {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, c.getModifiedPaths());\n                }\n            }\n        }\n        for (java.lang.String p : paths) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState fromNode = getNode(p, fromRev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState toNode = getNode(p, toRev);\n            java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"diffManyChildren: Changed Path {}\", path);\n            if (fromNode != null) {\n                if (toNode != null) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision a = fromNode.getLastRevision();\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = toNode.getLastRevision();\n                    if ((a == null) && (b == null)) {\n                    } else if (((a == null) || (b == null)) || (!a.equals(b))) {\n                        w.tag('^').key(name).object().endObject().newline();\n                    }\n                } else {\n                    w.tag('-').value(name).newline();\n                }\n            } else if (toNode != null) {\n                w.tag('+').key(name).object().endObject().newline();\n            } else {\n            }\n        }\n    }\n\n    private static void addPathsForDiff(java.lang.String path, java.util.Set<java.lang.String> paths, java.lang.Iterable<java.lang.String> modified) {\n        for (java.lang.String p : modified) {\n            if (org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(p)) {\n                continue;\n            }\n            java.lang.String parent = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(p);\n            if (path.equals(parent)) {\n                paths.add(p);\n            }\n        }\n    }\n\n    private void diffFewChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String parentPath, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        java.util.Set<java.lang.String> childrenSet = com.google.common.collect.Sets.newHashSet(toChildren.children);\n        for (java.lang.String n : fromChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('-').value(n).newline();\n            } else {\n                java.lang.String path = concat(parentPath, n);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n1 = getNode(path, fromRev);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n2 = getNode(path, toRev);\n                com.google.common.base.Preconditions.checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", path, fromRev);\n                com.google.common.base.Preconditions.checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", path, toRev);\n                if (!n1.getLastRevision().equals(n2.getLastRevision())) {\n                    w.tag('^').key(n).object().endObject().newline();\n                }\n            }\n        }\n        childrenSet = com.google.common.collect.Sets.newHashSet(fromChildren.children);\n        for (java.lang.String n : toChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('+').key(n).object().endObject().newline();\n            }\n        }\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.PathRev childNodeCacheKey(@javax.annotation.Nonnull\n    java.lang.String path, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    java.lang.String name) {\n        java.lang.String p = (name == null ? \"\" : name) + path;\n        return new org.apache.jackrabbit.oak.plugins.document.PathRev(p, readRevision);\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder asDocumentRootBuilder(org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) throws java.lang.IllegalArgumentException {\n        if (!(builder instanceof org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder)) {\n            throw new java.lang.IllegalArgumentException(\"builder must be a \" + org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder.class.getName());\n        }\n        return ((org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder) (builder));\n    }\n\n    private static long now() {\n        return java.lang.System.currentTimeMillis();\n    }\n\n    private void moveOrCopyNode(boolean move, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState newNode = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, targetPath, commit.getRevision());\n        source.copyTo(newNode);\n        commit.addNode(newNode);\n        if (move) {\n            markAsDeleted(source, commit, false);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(source, null, java.lang.Integer.MAX_VALUE)) {\n            java.lang.String childName = org.apache.jackrabbit.oak.commons.PathUtils.getName(child.getPath());\n            java.lang.String destChildPath = concat(targetPath, childName);\n            moveOrCopyNode(move, child, destChildPath, commit);\n        }\n    }\n\n    private void checkRevisionAge(org.apache.jackrabbit.oak.plugins.document.Revision r, java.lang.String path) {\n        if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n            if (\"/\".equals(path) && ((headRevision.getTimestamp() - r.getTimestamp()) > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.WARN_REVISION_AGE)) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug((((\"Requesting an old revision for path \" + path) + \", \") + ((headRevision.getTimestamp() - r.getTimestamp()) / 1000)) + \" seconds old\");\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector createBlobGarbageCollector(long blobGcMaxAgeInSecs, java.lang.String repositoryId) {\n        org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector blobGC = null;\n        if (blobStore instanceof org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) {\n            try {\n                blobGC = new org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector(new org.apache.jackrabbit.oak.plugins.document.DocumentBlobReferenceRetriever(this), ((org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) (blobStore)), executor, java.util.concurrent.TimeUnit.SECONDS.toMillis(blobGcMaxAgeInSecs), repositoryId);\n            } catch (java.io.IOException e) {\n                throw new java.lang.RuntimeException(\"Error occurred while initializing \" + \"the MarkSweepGarbageCollector\", e);\n            }\n        }\n        return blobGC;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean getMBean() {\n        return mbean;\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean createMBean() {\n        try {\n            return new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.MBeanImpl();\n        } catch (javax.management.NotCompliantMBeanException e) {\n            throw new java.lang.IllegalStateException(e);\n        }\n    }\n\n    private class MBeanImpl extends org.apache.jackrabbit.oak.commons.jmx.AnnotatedStandardMBean implements org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean {\n        private final java.lang.String ISO_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss.SSS zzz\";\n\n        private final java.util.TimeZone TZ_UTC = java.util.TimeZone.getTimeZone(\"UTC\");\n\n        protected MBeanImpl() throws javax.management.NotCompliantMBeanException {\n            super(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String getRevisionComparatorState() {\n            return revisionComparator.toString();\n        }\n\n        @java.lang.Override\n        public java.lang.String getHead() {\n            return headRevision.toString();\n        }\n\n        @java.lang.Override\n        public int getClusterId() {\n            return clusterId;\n        }\n\n        @java.lang.Override\n        public int getUnmergedBranchCount() {\n            return branches.size();\n        }\n\n        @java.lang.Override\n        public java.lang.String[] getInactiveClusterNodes() {\n            return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(inactiveClusterNodes.entrySet(), new com.google.common.base.Function<java.util.Map.Entry<java.lang.Integer, java.lang.Long>, java.lang.String>() {\n                @java.lang.Override\n                public java.lang.String apply(java.util.Map.Entry<java.lang.Integer, java.lang.Long> input) {\n                    return input.toString();\n                }\n            }), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String[] getLastKnownRevisions() {\n            return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(lastKnownRevision.entrySet(), new com.google.common.base.Function<java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision>, java.lang.String>() {\n                @java.lang.Override\n                public java.lang.String apply(java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> input) {\n                    return input.toString();\n                }\n            }), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String formatRevision(java.lang.String rev, boolean utc) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(rev);\n            final java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(ISO_FORMAT);\n            if (utc) {\n                sdf.setTimeZone(TZ_UTC);\n            }\n            return sdf.format(r.getTimestamp());\n        }\n    }\n\n    static abstract class NodeStoreTask implements java.lang.Runnable {\n        final java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore> ref;\n\n        private final java.util.concurrent.atomic.AtomicBoolean isDisposed;\n\n        private int delay;\n\n        NodeStoreTask(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            ref = new java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore>(nodeStore);\n            delay = nodeStore.getAsyncDelay();\n            this.isDisposed = isDisposed;\n        }\n\n        protected abstract void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore);\n\n        @java.lang.Override\n        public void run() {\n            while ((delay != 0) && (!isDisposed.get())) {\n                synchronized(isDisposed) {\n                    try {\n                        isDisposed.wait(delay);\n                    } catch (java.lang.InterruptedException e) {\n                    }\n                }\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore = ref.get();\n                if (nodeStore != null) {\n                    try {\n                        execute(nodeStore);\n                    } catch (java.lang.Throwable t) {\n                        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + t.toString(), t);\n                    }\n                    delay = nodeStore.getAsyncDelay();\n                } else {\n                    break;\n                }\n            } \n        }\n    }\n\n    static class BackgroundOperation extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundOperation(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            nodeStore.runBackgroundOperations();\n        }\n    }\n\n    static class BackgroundLeaseUpdate extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundLeaseUpdate(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            if (nodeStore.renewClusterIdLease()) {\n                nodeStore.updateClusterState();\n            }\n        }\n    }\n\n    public org.apache.jackrabbit.oak.spi.blob.BlobStore getBlobStore() {\n        return blobStore;\n    }\n\n    org.apache.jackrabbit.oak.json.BlobSerializer getBlobSerializer() {\n        return blobSerializer;\n    }\n\n    public java.util.Iterator<org.apache.jackrabbit.oak.api.Blob> getReferencedBlobsIterator() {\n        if (store instanceof org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) {\n            return new org.apache.jackrabbit.oak.plugins.document.mongo.MongoBlobReferenceIterator(this, ((org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) (store)));\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.BlobReferenceIterator(this);\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.DiffCache getDiffCache() {\n        return diffCache;\n    }\n\n    public org.apache.jackrabbit.oak.stats.Clock getClock() {\n        return clock;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.Checkpoints getCheckpoints() {\n        return checkpoints;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector getVersionGarbageCollector() {\n        return versionGarbageCollector;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent getLastRevRecoveryAgent() {\n        return lastRevRecoveryAgent;\n    }\n\n    public void setPersistentCache(org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache) {\n        this.persistentCache = persistentCache;\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "public synchronized void runBackgroundOperations() {\n    if (isDisposed.get()) {\n        return;\n    }\n    if (simpleRevisionCounter != null) {\n        return;\n    }\n    try {\n        long start = clock.getTime();\n        long time = start;\n        cleanOrphanedBranches();\n        cleanCollisions();\n        long cleanTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundSplit();\n        long splitTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundWrite();\n        long writeTime = clock.getTime() - time;\n        time = clock.getTime();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n        long readTime = clock.getTime() - time;\n        java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n        if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        }\n    } catch (java.lang.RuntimeException e) {\n        if (isDisposed.get()) {\n            return;\n        }\n        throw e;\n    }\n}",
            "src_parent": "public final class DocumentNodeStore implements org.apache.jackrabbit.oak.plugins.document.RevisionContext , org.apache.jackrabbit.oak.spi.commit.Observable , org.apache.jackrabbit.oak.spi.state.NodeStore {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.class);\n\n    private static final org.apache.jackrabbit.oak.util.PerfLogger PERFLOG = new org.apache.jackrabbit.oak.util.PerfLogger(org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.class.getName() + \".perf\"));\n\n    static final int NUM_CHILDREN_CACHE_LIMIT = java.lang.Integer.getInteger(\"oak.documentMK.childrenCacheLimit\", 16 * 1024);\n\n    private static final int WARN_REVISION_AGE = java.lang.Integer.getInteger(\"oak.documentMK.revisionAge\", 60 * 1000);\n\n    static final int REMEMBER_REVISION_ORDER_MILLIS = (60 * 60) * 1000;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState missing;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.CommitQueue commitQueue;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue batchCommitQueue;\n\n    protected final org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher dispatcher;\n\n    protected int asyncDelay = 1000;\n\n    protected int maxBackOffMillis = asyncDelay * 2;\n\n    private final java.util.concurrent.atomic.AtomicBoolean isDisposed = new java.util.concurrent.atomic.AtomicBoolean();\n\n    private final org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo clusterNodeInfo;\n\n    private final int clusterId;\n\n    private final java.util.concurrent.ConcurrentMap<java.lang.Integer, java.lang.Long> inactiveClusterNodes = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, java.lang.Long>();\n\n    private final Revision.RevisionComparator revisionComparator;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnmergedBranches branches;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnsavedModifications unsavedLastRevisions = new org.apache.jackrabbit.oak.plugins.document.UnsavedModifications();\n\n    private final java.util.Map<java.lang.String, java.lang.String> splitCandidates = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastKnownRevision = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision>();\n\n    private volatile org.apache.jackrabbit.oak.plugins.document.Revision headRevision;\n\n    private java.lang.Thread backgroundThread;\n\n    private java.lang.Thread leaseUpdateThread;\n\n    private final java.util.concurrent.locks.ReadWriteLock backgroundOperationLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private final java.util.concurrent.locks.ReadWriteLock mergeLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private java.util.concurrent.atomic.AtomicInteger simpleRevisionCounter;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> nodeCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children> nodeChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeChildrenCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.util.StringValue, org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children> docChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats docChildrenCacheStats;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DiffCache diffCache;\n\n    private final org.apache.jackrabbit.oak.spi.blob.BlobStore blobStore;\n\n    private final org.apache.jackrabbit.oak.json.BlobSerializer blobSerializer = new org.apache.jackrabbit.oak.json.BlobSerializer() {\n        @java.lang.Override\n        public java.lang.String serialize(org.apache.jackrabbit.oak.api.Blob blob) {\n            if (blob instanceof org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) {\n                return ((org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) (blob)).getBlobId();\n            }\n            java.lang.String id;\n            java.lang.String reference = blob.getReference();\n            if (reference != null) {\n                id = blobStore.getBlobId(reference);\n                if (id != null) {\n                    return id;\n                }\n            }\n            try {\n                id = createBlob(blob.getNewStream()).getBlobId();\n            } catch (java.io.IOException e) {\n                throw new java.lang.IllegalStateException(e);\n            }\n            return id;\n        }\n    };\n\n    private final org.apache.jackrabbit.oak.stats.Clock clock;\n\n    private final org.apache.jackrabbit.oak.plugins.document.Checkpoints checkpoints;\n\n    private final org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector versionGarbageCollector;\n\n    private final java.util.concurrent.Executor executor;\n\n    private final org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent lastRevRecoveryAgent;\n\n    private final boolean disableBranches;\n\n    private org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean mbean;\n\n    public DocumentNodeStore(org.apache.jackrabbit.oak.plugins.document.DocumentMK.Builder builder) {\n        this.blobStore = builder.getBlobStore();\n        if (builder.isUseSimpleRevision()) {\n            this.simpleRevisionCounter = new java.util.concurrent.atomic.AtomicInteger(0);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentStore s = builder.getDocumentStore();\n        if (builder.getTiming()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.TimingDocumentStoreWrapper(s);\n        }\n        if (builder.getLogging()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.LoggingDocumentStoreWrapper(s);\n        }\n        this.store = s;\n        this.executor = builder.getExecutor();\n        this.clock = builder.getClock();\n        int cid = builder.getClusterId();\n        cid = java.lang.Integer.getInteger(\"oak.documentMK.clusterId\", cid);\n        if (cid == 0) {\n            clusterNodeInfo = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getInstance(store);\n            cid = clusterNodeInfo.getId();\n        } else {\n            clusterNodeInfo = null;\n        }\n        this.clusterId = cid;\n        this.revisionComparator = new org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator(clusterId);\n        this.branches = new org.apache.jackrabbit.oak.plugins.document.UnmergedBranches(getRevisionComparator());\n        this.asyncDelay = builder.getAsyncDelay();\n        this.versionGarbageCollector = new org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector(this, builder.createVersionGCSupport());\n        this.lastRevRecoveryAgent = new org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent(this);\n        this.disableBranches = builder.isDisableBranches();\n        this.missing = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"MISSING\", new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, 0)) {\n            @java.lang.Override\n            public int getMemory() {\n                return 8;\n            }\n        };\n        nodeCache = builder.buildNodeCache(this);\n        nodeCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeCache, \"Document-NodeState\", builder.getWeigher(), builder.getNodeCacheSize());\n        nodeChildrenCache = builder.buildChildrenCache();\n        nodeChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeChildrenCache, \"Document-NodeChildren\", builder.getWeigher(), builder.getChildrenCacheSize());\n        docChildrenCache = builder.buildDocChildrenCache();\n        docChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(docChildrenCache, \"Document-DocChildren\", builder.getWeigher(), builder.getDocChildrenCacheSize());\n        diffCache = builder.getDiffCache();\n        checkpoints = new org.apache.jackrabbit.oak.plugins.document.Checkpoints(this);\n        if (store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\")) == null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision();\n            org.apache.jackrabbit.oak.plugins.document.Commit commit = new org.apache.jackrabbit.oak.plugins.document.Commit(this, head, null, null);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"/\", head);\n            commit.addNode(n);\n            commit.applyToDocumentStore();\n            commit.applyToCache(new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId), false);\n            setHeadRevision(commit.getRevision());\n            backgroundWrite();\n        } else {\n            branches.init(store, this);\n            backgroundRead(false);\n            if (headRevision == null) {\n                setHeadRevision(newRevision());\n            }\n        }\n        getRevisionComparator().add(headRevision, org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0));\n        dispatcher = new org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher(getRoot());\n        commitQueue = new org.apache.jackrabbit.oak.plugins.document.CommitQueue(this, dispatcher);\n        batchCommitQueue = new org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue(store, revisionComparator);\n        backgroundThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundOperation(this, isDisposed), \"DocumentNodeStore background thread\");\n        backgroundThread.setDaemon(true);\n        checkLastRevRecovery();\n        renewClusterIdLease();\n        backgroundThread.start();\n        if (clusterNodeInfo != null) {\n            leaseUpdateThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundLeaseUpdate(this, isDisposed), \"DocumentNodeStore lease update thread\");\n            leaseUpdateThread.setDaemon(true);\n            leaseUpdateThread.start();\n        }\n        this.mbean = createMBean();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Initialized DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    }\n\n    private void checkLastRevRecovery() {\n        lastRevRecoveryAgent.recover(clusterId);\n    }\n\n    public void dispose() {\n        runBackgroundOperations();\n        if (!isDisposed.getAndSet(true)) {\n            synchronized(isDisposed) {\n                isDisposed.notifyAll();\n            }\n            try {\n                backgroundThread.join();\n            } catch (java.lang.InterruptedException e) {\n            }\n            if (leaseUpdateThread != null) {\n                try {\n                    leaseUpdateThread.join();\n                } catch (java.lang.InterruptedException e) {\n                }\n            }\n            if (clusterNodeInfo != null) {\n                clusterNodeInfo.dispose();\n            }\n            store.dispose();\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n            if (blobStore instanceof java.io.Closeable) {\n                try {\n                    ((java.io.Closeable) (blobStore)).close();\n                } catch (java.io.IOException ex) {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n                }\n            }\n        }\n        if (persistentCache != null) {\n            persistentCache.close();\n        }\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.Revision setHeadRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newHead) {\n        com.google.common.base.Preconditions.checkArgument(!newHead.isBranch());\n        org.apache.jackrabbit.oak.plugins.document.Revision previous = headRevision;\n        if (!com.google.common.base.Preconditions.checkNotNull(newHead).equals(previous)) {\n            headRevision = newHead;\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentStore getDocumentStore() {\n        return store;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newRevision() {\n        if (simpleRevisionCounter != null) {\n            return new org.apache.jackrabbit.oak.plugins.document.Revision(simpleRevisionCounter.getAndIncrement(), 0, clusterId);\n        }\n        return org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(clusterId);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit newCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.Commit(this, commitQueue.createRevision(), base, branch);\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.MergeCommit newMergeCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base, int numBranchCommits) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    void done(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit c, boolean isBranch, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) {\n        try {\n            commitQueue.done(c, isBranch, info);\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    void canceled(org.apache.jackrabbit.oak.plugins.document.Commit c) {\n        try {\n            commitQueue.canceled(c.getRevision());\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    public void setAsyncDelay(int delay) {\n        this.asyncDelay = delay;\n    }\n\n    public int getAsyncDelay() {\n        return asyncDelay;\n    }\n\n    public void setMaxBackOffMillis(int time) {\n        maxBackOffMillis = time;\n    }\n\n    public int getMaxBackOffMillis() {\n        return maxBackOffMillis;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo getClusterInfo() {\n        return clusterNodeInfo;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeCacheStats() {\n        return nodeCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeChildrenCacheStats() {\n        return nodeChildrenCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getDocChildrenCacheStats() {\n        return docChildrenCacheStats;\n    }\n\n    void invalidateDocChildrenCache() {\n        docChildrenCache.invalidateAll();\n    }\n\n    void invalidateNodeChildrenCache() {\n        nodeChildrenCache.invalidateAll();\n    }\n\n    void invalidateNodeCache(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        nodeCache.invalidate(new org.apache.jackrabbit.oak.plugins.document.PathRev(path, revision));\n    }\n\n    public int getPendingWriteCount() {\n        return unsavedLastRevisions.getPaths().size();\n    }\n\n    public boolean isDisableBranches() {\n        return disableBranches;\n    }\n\n    boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    void addSplitCandidate(java.lang.String id) {\n        splitCandidates.put(id, id);\n    }\n\n    void copyNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(false, source, targetPath, commit);\n    }\n\n    void moveNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(true, source, targetPath, commit);\n    }\n\n    void markAsDeleted(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, org.apache.jackrabbit.oak.plugins.document.Commit commit, boolean subTreeAlso) {\n        commit.removeNode(node.getPath());\n        if (subTreeAlso) {\n            for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(node, null, java.lang.Integer.MAX_VALUE)) {\n                markAsDeleted(child, commit, true);\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNode(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        checkRevisionAge(com.google.common.base.Preconditions.checkNotNull(rev), com.google.common.base.Preconditions.checkNotNull(path));\n        final long start = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.start();\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = new org.apache.jackrabbit.oak.plugins.document.PathRev(path, rev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node = nodeCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState call() throws java.lang.Exception {\n                    boolean nodeDoesNotExist = checkNodeNotExistsFromChildrenCache(path, rev);\n                    if (nodeDoesNotExist) {\n                        return missing;\n                    }\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = readNode(path, rev);\n                    if (n == null) {\n                        n = missing;\n                    }\n                    return n;\n                }\n            });\n            final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = ((node == missing) || node.equals(missing)) ? null : node;\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"getNode: path={}, rev={}\", path, rev);\n            return result;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        }\n    }\n\n    DocumentNodeState.Children getChildren(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return DocumentNodeState.NO_CHILDREN;\n        }\n        final java.lang.String path = com.google.common.base.Preconditions.checkNotNull(parent).getPath();\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, readRevision, name);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children children = nodeChildrenCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children>() {\n                @java.lang.Override\n                public DocumentNodeState.Children call() throws java.lang.Exception {\n                    return readChildren(parent, name, limit);\n                }\n            });\n            if ((children.children.size() < limit) && children.hasMore) {\n                children = readChildren(parent, name, limit);\n                nodeChildrenCache.put(key, children);\n            }\n            return children;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        }\n    }\n\n    DocumentNodeState.Children readChildren(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, java.lang.String name, int limit) {\n        java.lang.String queriedName = name;\n        java.lang.String path = parent.getPath();\n        org.apache.jackrabbit.oak.plugins.document.Revision rev = parent.getLastRevision();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"Reading children for [{}] ast rev [{}]\", path, rev);\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n        int rawLimit = ((int) (java.lang.Math.min(java.lang.Integer.MAX_VALUE, ((long) (limit)) + 1)));\n        for (; ;) {\n            docs = readChildDocs(path, name, rawLimit);\n            int numReturned = 0;\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                numReturned++;\n                java.lang.String p = doc.getPath();\n                name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child = getNode(p, rev);\n                if (child == null) {\n                    continue;\n                }\n                if (c.children.size() < limit) {\n                    c.children.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n                } else {\n                    c.hasMore = true;\n                    return c;\n                }\n            }\n            if (numReturned < rawLimit) {\n                c.hasMore = false;\n                if (queriedName == null) {\n                    java.util.Collections.sort(c.children);\n                }\n                return c;\n            }\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> readChildDocs(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nullable\n    java.lang.String name, int limit) {\n        java.lang.String to = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(com.google.common.base.Preconditions.checkNotNull(path));\n        java.lang.String from;\n        if (name != null) {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(concat(path, name));\n        } else {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        }\n        if ((name != null) || (limit > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NUM_CHILDREN_CACHE_LIMIT)) {\n            return store.query(Collection.NODES, from, to, limit);\n        }\n        org.apache.jackrabbit.oak.plugins.document.util.StringValue key = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children c = docChildrenCache.getIfPresent(key);\n        if (c == null) {\n            c = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, limit);\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                c.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            c.isComplete = docs.size() < limit;\n            docChildrenCache.put(key, c);\n            return docs;\n        } else if ((c.childNames.size() < limit) && (!c.isComplete)) {\n            java.lang.String lastName = c.childNames.get(c.childNames.size() - 1);\n            java.lang.String lastPath = concat(path, lastName);\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(lastPath);\n            int remainingLimit = limit - c.childNames.size();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, remainingLimit);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = c.clone();\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                clone.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            clone.isComplete = docs.size() < remainingLimit;\n            docChildrenCache.put(key, clone);\n            c = clone;\n        }\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> it = com.google.common.collect.Iterables.transform(c.childNames, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.lang.String name) {\n                java.lang.String p = concat(path, name);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(p));\n                if (doc == null) {\n                    docChildrenCache.invalidateAll();\n                    throw new java.lang.NullPointerException((\"Document \" + p) + \" not found\");\n                }\n                return doc;\n            }\n        });\n        if (c.childNames.size() > (limit * 2)) {\n            it = com.google.common.collect.Iterables.limit(it, limit * 2);\n        }\n        return it;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> getChildNodes(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return java.util.Collections.emptyList();\n        }\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        return com.google.common.collect.Iterables.transform(getChildren(parent, name, limit).children, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState apply(java.lang.String input) {\n                java.lang.String p = concat(parent.getPath(), input);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = getNode(p, readRevision);\n                if (result == null) {\n                    throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((((\"DocumentNodeState is null for revision \" + readRevision) + \" of \") + p) + \" (aborting getChildNodes())\");\n                }\n                return result;\n            }\n        });\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState readNode(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        final long start = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.start();\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(path);\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = getPendingModifications().get(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n        if (doc == null) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"readNode: (document not found) path={}, readRevision={}\", path, readRevision);\n            return null;\n        }\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = doc.getNodeAtRevision(this, readRevision, lastRevision);\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"readNode: path={}, readRevision={}\", path, readRevision);\n        return result;\n    }\n\n    public void applyChanges(org.apache.jackrabbit.oak.plugins.document.Revision rev, java.lang.String path, boolean isNew, java.util.List<java.lang.String> added, java.util.List<java.lang.String> removed, java.util.List<java.lang.String> changed, org.apache.jackrabbit.oak.plugins.document.DiffCache.Entry cacheEntry) {\n        if (isNew && (!added.isEmpty())) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n            java.util.Set<java.lang.String> set = com.google.common.collect.Sets.newTreeSet();\n            for (java.lang.String p : added) {\n                set.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n            }\n            c.children.addAll(set);\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, rev, null);\n            nodeChildrenCache.put(key, c);\n        }\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        for (java.lang.String p : added) {\n            w.tag('+').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        for (java.lang.String p : removed) {\n            w.tag('-').value(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).newline();\n        }\n        for (java.lang.String p : changed) {\n            w.tag('^').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        cacheEntry.append(path, w.toString());\n        if (!added.isEmpty()) {\n            org.apache.jackrabbit.oak.plugins.document.util.StringValue docChildrenKey = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children docChildren = docChildrenCache.getIfPresent(docChildrenKey);\n            if (docChildren != null) {\n                int currentSize = docChildren.childNames.size();\n                java.util.NavigableSet<java.lang.String> names = com.google.common.collect.Sets.newTreeSet(docChildren.childNames);\n                if (!docChildren.isComplete) {\n                    for (java.lang.String childPath : added) {\n                        java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath);\n                        if (names.higher(name) != null) {\n                            names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(name));\n                        }\n                    }\n                } else {\n                    for (java.lang.String childPath : added) {\n                        names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath)));\n                    }\n                }\n                if (names.size() != currentSize) {\n                    boolean complete = docChildren.isComplete;\n                    docChildren = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n                    docChildren.isComplete = complete;\n                    docChildren.childNames.addAll(names);\n                    docChildrenCache.put(docChildrenKey, docChildren);\n                }\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument updateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        boolean batch = true;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> op : commit.getChanges().entrySet()) {\n            java.lang.String name = op.getKey().getName();\n            if ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name)) || NodeDocument.COLLISIONS.equals(name)) {\n                continue;\n            }\n            batch = false;\n            break;\n        }\n        if (batch) {\n            return batchUpdateCommitRoot(commit);\n        } else {\n            return store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, commit);\n        }\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument batchUpdateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        try {\n            return batchCommitQueue.updateDocument(commit).call();\n        } catch (java.lang.InterruptedException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Interrupted while updating commit root document\");\n        } catch (java.lang.Exception e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Update of commit root document failed\");\n        }\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState root = getNode(\"/\", revision);\n        if (root == null) {\n            throw new java.lang.IllegalStateException(\"root node does not exist at revision \" + revision);\n        }\n        return root;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch createBranch(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch b = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch.getCurrentBranch();\n        if (b != null) {\n            return b;\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch(this, base, mergeLock);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision base) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(base);\n        if (disableBranches) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            return base.asBranchRevision();\n        }\n        if (b.getBase(branchHead).equals(base)) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision().asBranchRevision();\n        b.rebase(head, base);\n        return head;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision ancestor, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(ancestor);\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(\"Empty branch cannot be reset\");\n        }\n        if (!b.getCommits().last().equals(branchHead)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((branchHead + \" is not the head \") + \"of a branch\");\n        }\n        if (!b.containsCommit(ancestor)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(((ancestor + \" is not \") + \"an ancestor revision of \") + branchHead);\n        }\n        if (branchHead.equals(ancestor)) {\n            return branchHead;\n        }\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit commit = newCommit(branchHead, branch);\n        try {\n            java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> it = b.getCommits().tailSet(ancestor).iterator();\n            org.apache.jackrabbit.oak.plugins.document.Revision base = it.next();\n            java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.document.UpdateOp> operations = com.google.common.collect.Maps.newHashMap();\n            while (it.hasNext()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision reset = it.next();\n                getRoot(reset).compareAgainstBaseState(getRoot(base), new org.apache.jackrabbit.oak.plugins.document.ResetDiff(reset.asTrunkRevision(), operations));\n                org.apache.jackrabbit.oak.plugins.document.UpdateOp rootOp = operations.get(\"/\");\n                if (rootOp == null) {\n                    rootOp = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(rootOp, commit.getRevision());\n                    operations.put(\"/\", rootOp);\n                }\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n            } \n            if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n                java.util.List<org.apache.jackrabbit.oak.plugins.document.Revision> revs = com.google.common.collect.Lists.newArrayList(b.getCommits().tailSet(ancestor));\n                for (org.apache.jackrabbit.oak.plugins.document.Revision r : revs.subList(1, revs.size())) {\n                    b.removeCommit(r);\n                }\n                success = true;\n            }\n            operations.remove(\"/\");\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : operations.values()) {\n                store.findAndUpdate(Collection.NODES, op);\n            }\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, true, null);\n            }\n        }\n        return ancestor;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        org.apache.jackrabbit.oak.plugins.document.Revision base = branchHead;\n        if (b != null) {\n            base = b.getBase(branchHead);\n        }\n        int numBranchCommits = (b != null) ? b.getCommits().size() : 1;\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit commit = newMergeCommit(base, numBranchCommits);\n        try {\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(op, commit.getRevision());\n            if (b != null) {\n                java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> mergeCommits = commit.getMergeRevisions().iterator();\n                for (org.apache.jackrabbit.oak.plugins.document.Revision rev : b.getCommits()) {\n                    rev = rev.asTrunkRevision();\n                    java.lang.String commitTag = \"c-\" + mergeCommits.next();\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setRevision(op, rev, commitTag);\n                    op.containsMapEntry(NodeDocument.COLLISIONS, rev, false);\n                }\n                if (store.findAndUpdate(Collection.NODES, op) != null) {\n                    b.applyTo(getPendingModifications(), commit.getRevision());\n                    getBranches().remove(b);\n                } else {\n                    throw new org.apache.jackrabbit.oak.api.CommitFailedException(MERGE, 2, \"Conflicting concurrent change. Update operation failed: \" + op);\n                }\n            } else {\n            }\n            success = true;\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, false, info);\n            }\n        }\n        return commit.getRevision();\n    }\n\n    boolean compare(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.spi.state.NodeStateDiff diff) {\n        if (!org.apache.jackrabbit.oak.spi.state.AbstractNodeState.comparePropertiesAgainstBaseState(node, base, diff)) {\n            return false;\n        }\n        if (node.hasNoChildren() && base.hasNoChildren()) {\n            return true;\n        }\n        boolean useReadRevision = true;\n        java.lang.String jsop = diffCache.getChanges(base.getRevision(), node.getRevision(), node.getPath(), null);\n        if (jsop == null) {\n            useReadRevision = false;\n            jsop = diffCache.getChanges(base.getLastRevision(), node.getLastRevision(), node.getPath(), new org.apache.jackrabbit.oak.plugins.document.DiffCache.Loader() {\n                @java.lang.Override\n                public java.lang.String call() {\n                    return diffImpl(base, node);\n                }\n            });\n        }\n        return dispatch(jsop, node, base, diff, useReadRevision);\n    }\n\n    java.lang.String diff(@javax.annotation.Nonnull\n    final java.lang.String fromRevisionId, @javax.annotation.Nonnull\n    final java.lang.String toRevisionId, @javax.annotation.Nonnull\n    final java.lang.String path) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (fromRevisionId.equals(toRevisionId)) {\n            return \"\";\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision fromRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(fromRevisionId);\n        org.apache.jackrabbit.oak.plugins.document.Revision toRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(toRevisionId);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from = getNode(path, fromRev);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to = getNode(path, toRev);\n        if ((from == null) || (to == null)) {\n            java.lang.String msg = java.lang.String.format(\"Diff is only supported if the node exists in both cases. \" + \"Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s\", path, fromRev, from != null, toRev, to != null);\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(msg);\n        }\n        java.lang.String compactDiff = diffCache.getChanges(fromRev, toRev, path, new org.apache.jackrabbit.oak.plugins.document.DiffCache.Loader() {\n            @java.lang.Override\n            public java.lang.String call() {\n                return diffImpl(from, to);\n            }\n        });\n        org.apache.jackrabbit.oak.commons.json.JsopWriter writer = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.diffProperties(from, to, writer);\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer t = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(compactDiff);\n        int r;\n        do {\n            r = t.read();\n            switch (r) {\n                case '+' :\n                case '^' :\n                    {\n                        java.lang.String name = t.readString();\n                        t.read(':');\n                        t.read('{');\n                        t.read('}');\n                        writer.tag(((char) (r))).key(concat(path, name));\n                        writer.object().endObject().newline();\n                        break;\n                    }\n                case '-' :\n                    {\n                        java.lang.String name = t.readString();\n                        writer.tag('-').value(concat(path, name));\n                        writer.newline();\n                    }\n            }\n        } while (r != org.apache.jackrabbit.oak.commons.json.JsopReader.END );\n        return writer.toString();\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.LastRevTracker createTracker(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision r, final boolean isBranchCommit) {\n        if (isBranchCommit && (!disableBranches)) {\n            org.apache.jackrabbit.oak.plugins.document.Revision branchRev = r.asBranchRevision();\n            return branches.getBranchCommit(branchRev);\n        } else {\n            return new org.apache.jackrabbit.oak.plugins.document.LastRevTracker() {\n                @java.lang.Override\n                public void track(java.lang.String path) {\n                    unsavedLastRevisions.put(path, r);\n                }\n            };\n        }\n    }\n\n    @java.lang.Override\n    public java.io.Closeable addObserver(org.apache.jackrabbit.oak.spi.commit.Observer observer) {\n        return dispatcher.addObserver(observer);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot() {\n        return getRoot(headRevision);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitHook commitHook, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).merge(commitHook, info);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).rebase();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).reset();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob createBlob(java.io.InputStream inputStream) throws java.io.IOException {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobStore.writeBlob(inputStream));\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.api.Blob getBlob(java.lang.String reference) {\n        java.lang.String blobId = blobStore.getBlobId(reference);\n        if (blobId != null) {\n            return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"No blobId found matching reference [{}]\", reference);\n        return null;\n    }\n\n    public org.apache.jackrabbit.oak.api.Blob getBlobFromBlobId(java.lang.String blobId) {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime, @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> properties) {\n        return checkpoints.create(lifetime, properties).toString();\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime) {\n        java.util.Map<java.lang.String, java.lang.String> empty = java.util.Collections.emptyMap();\n        return checkpoint(lifetime, empty);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.util.Map<java.lang.String, java.lang.String> checkpointInfo(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info info = checkpoints.getCheckpoints().get(r);\n        if (info == null) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return info.get();\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState retrieve(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info> checkpoints = this.checkpoints.getCheckpoints();\n        if ((checkpoints != null) && checkpoints.containsKey(r)) {\n            return getRoot(r);\n        } else {\n            return null;\n        }\n    }\n\n    @java.lang.Override\n    public boolean release(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        checkpoints.release(checkpoint);\n        return true;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnmergedBranches getBranches() {\n        return branches;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnsavedModifications getPendingModifications() {\n        return unsavedLastRevisions;\n    }\n\n    @java.lang.Override\n    public Revision.RevisionComparator getRevisionComparator() {\n        return revisionComparator;\n    }\n\n    @java.lang.Override\n    public int getClusterId() {\n        return clusterId;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getHeadRevision() {\n        return headRevision;\n    }\n\n    public synchronized void runBackgroundOperations() {\n        if (isDisposed.get()) {\n            return;\n        }\n        if (simpleRevisionCounter != null) {\n            return;\n        }\n        try {\n            long start = clock.getTime();\n            long time = start;\n            cleanOrphanedBranches();\n            cleanCollisions();\n            long cleanTime = clock.getTime() - time;\n            time = clock.getTime();\n            backgroundSplit();\n            long splitTime = clock.getTime() - time;\n            time = clock.getTime();\n            backgroundWrite();\n            long writeTime = clock.getTime() - time;\n            time = clock.getTime();\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n            long readTime = clock.getTime() - time;\n            java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n            if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n            } else {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n            }\n        } catch (java.lang.RuntimeException e) {\n            if (isDisposed.get()) {\n                return;\n            }\n            throw e;\n        }\n    }\n\n    boolean renewClusterIdLease() {\n        return (clusterNodeInfo != null) && clusterNodeInfo.renewLease();\n    }\n\n    void updateClusterState() {\n        long now = clock.getTime();\n        java.util.Set<java.lang.Integer> inactive = com.google.common.collect.Sets.newHashSet();\n        for (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument doc : org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument.all(store)) {\n            int cId = doc.getClusterId();\n            if ((cId != this.clusterId) && (!doc.isActive())) {\n                inactive.add(cId);\n            }\n        }\n        inactiveClusterNodes.keySet().retainAll(inactive);\n        for (java.lang.Integer clusterId : inactive) {\n            inactiveClusterNodes.putIfAbsent(clusterId, now);\n        }\n    }\n\n    java.util.Map<java.lang.Integer, java.lang.Long> getInactiveClusterNodes() {\n        return new java.util.HashMap<java.lang.Integer, java.lang.Long>(inactiveClusterNodes);\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats backgroundRead(boolean dispatchChange) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats stats = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats();\n        long time = clock.getTime();\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\");\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\n        if (doc == null) {\n            return stats;\n        }\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevMap = doc.getLastRev();\n        org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator revisionComparator = getRevisionComparator();\n        org.apache.jackrabbit.oak.plugins.document.Revision headSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        org.apache.jackrabbit.oak.plugins.document.Revision otherSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> externalChanges = com.google.common.collect.Maps.newHashMap();\n        for (java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> e : lastRevMap.entrySet()) {\n            int machineId = e.getKey();\n            if (machineId == clusterId) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.Revision r = e.getValue();\n            org.apache.jackrabbit.oak.plugins.document.Revision last = lastKnownRevision.get(machineId);\n            if ((last == null) || (r.compareRevisionTime(last) > 0)) {\n                lastKnownRevision.put(machineId, r);\n                if ((last != null) || (r.getTimestamp() > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())) {\n                    externalChanges.put(r, otherSeen);\n                }\n            }\n        }\n        stats.readHead = clock.getTime() - time;\n        time = clock.getTime();\n        if (!externalChanges.isEmpty()) {\n            stats.cacheStats = store.invalidateCache();\n            stats.cacheInvalidationTime = clock.getTime() - time;\n            time = clock.getTime();\n            docChildrenCache.invalidateAll();\n            backgroundOperationLock.writeLock().lock();\n            try {\n                revisionComparator.add(newRevision(), headSeen);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> e : externalChanges.entrySet()) {\n                    revisionComparator.add(e.getKey(), e.getValue());\n                }\n                setHeadRevision(newRevision());\n                if (dispatchChange) {\n                    dispatcher.contentChanged(getRoot(), null);\n                }\n            } finally {\n                backgroundOperationLock.writeLock().unlock();\n            }\n            stats.dispatchChanges = clock.getTime() - time;\n            time = clock.getTime();\n        }\n        revisionComparator.purge(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis());\n        stats.purge = clock.getTime() - time;\n        return stats;\n    }\n\n    private static class BackgroundReadStats {\n        org.apache.jackrabbit.oak.plugins.document.cache.CacheInvalidationStats cacheStats;\n\n        long readHead;\n\n        long cacheInvalidationTime;\n\n        long dispatchChanges;\n\n        long purge;\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            java.lang.String cacheStatsMsg = \"NOP\";\n            if (cacheStats != null) {\n                cacheStatsMsg = cacheStats.summaryReport();\n            }\n            return ((((((((((\"ReadStats{\" + \"cacheStats:\") + cacheStatsMsg) + \", head:\") + readHead) + \", cache:\") + cacheInvalidationTime) + \", dispatch:\") + dispatchChanges) + \", purge:\") + purge) + '}';\n        }\n    }\n\n    private static long revisionPurgeMillis() {\n        return org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS;\n    }\n\n    private void cleanOrphanedBranches() {\n        org.apache.jackrabbit.oak.plugins.document.Branch b;\n        while ((b = branches.pollOrphanedBranch()) != null) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Cleaning up orphaned branch with base revision: {}, \" + \"commits: {}\", b.getBase(), b.getCommits());\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n            for (org.apache.jackrabbit.oak.plugins.document.Revision r : b.getCommits()) {\n                r = r.asTrunkRevision();\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeRevision(op, r);\n            }\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, op);\n        } \n    }\n\n    private void cleanCollisions() {\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\");\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument root = store.find(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, id);\n        if (root == null) {\n            return;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision head = getHeadRevision();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = root.getLocalMap(NodeDocument.COLLISIONS);\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : map.keySet()) {\n            if (r.getClusterId() == clusterId) {\n                if ((branches.getBranchCommit(r) == null) && isRevisionNewer(head, r)) {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(op, r);\n                }\n            }\n        }\n        if (op.hasChanges()) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Removing collisions {}\", op.getChanges().keySet());\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, op);\n        }\n    }\n\n    private void backgroundSplit() {\n        for (java.util.Iterator<java.lang.String> it = splitCandidates.keySet().iterator(); it.hasNext();) {\n            java.lang.String id = it.next();\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n            if (doc == null) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : doc.split(this)) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument before = store.createOrUpdate(Collection.NODES, op);\n                if (before != null) {\n                    if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument after = store.find(Collection.NODES, op.getId());\n                        if (after != null) {\n                            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation on {}. Size before: {}, after: {}\", id, before.getMemory(), after.getMemory());\n                        }\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation created {}\", op.getId());\n                }\n            }\n            it.remove();\n        }\n    }\n\n    void backgroundWrite() {\n        unsavedLastRevisions.persist(this, backgroundOperationLock.writeLock());\n    }\n\n    private boolean dispatch(@javax.annotation.Nonnull\n    java.lang.String jsonDiff, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeStateDiff diff, boolean useReadRevision) {\n        if (jsonDiff.trim().isEmpty()) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision nodeRev = (useReadRevision) ? node.getRevision() : node.getLastRevision();\n        org.apache.jackrabbit.oak.plugins.document.Revision baseRev = (useReadRevision) ? base.getRevision() : base.getLastRevision();\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer t = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(jsonDiff);\n        boolean continueComparison = true;\n        while (continueComparison) {\n            int r = t.read();\n            if (r == org.apache.jackrabbit.oak.commons.json.JsopReader.END) {\n                break;\n            }\n            switch (r) {\n                case '+' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        t.read(':');\n                        t.read('{');\n                        while (t.read() != '}') {\n                        } \n                        org.apache.jackrabbit.oak.spi.state.NodeState child = getNode(concat(node.getPath(), name), nodeRev);\n                        continueComparison = diff.childNodeAdded(name, child);\n                        break;\n                    }\n                case '-' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        org.apache.jackrabbit.oak.spi.state.NodeState child = getNode(concat(base.getPath(), name), baseRev);\n                        continueComparison = diff.childNodeDeleted(name, child);\n                        break;\n                    }\n                case '^' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        t.read(':');\n                        if (t.matches('{')) {\n                            t.read('}');\n                            org.apache.jackrabbit.oak.spi.state.NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\n                            org.apache.jackrabbit.oak.spi.state.NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\n                            continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);\n                        } else if (t.matches('[')) {\n                            while (t.read() != ']') {\n                            } \n                        } else {\n                            t.read();\n                        }\n                        break;\n                    }\n                default :\n                    throw new java.lang.IllegalArgumentException(((((\"jsonDiff: illegal token '\" + t.getToken()) + \"' at pos: \") + t.getLastPos()) + ' ') + jsonDiff);\n            }\n        } \n        return continueComparison;\n    }\n\n    private boolean checkNodeNotExistsFromChildrenCache(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(path)) {\n            return false;\n        }\n        final java.lang.String parentPath = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(path);\n        org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(parentPath, rev, null);\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children children = nodeChildrenCache.getIfPresent(key);\n        java.lang.String lookupChildName = org.apache.jackrabbit.oak.commons.PathUtils.getName(path);\n        if (children == null) {\n            return false;\n        }\n        if (children.hasMore) {\n            return false;\n        }\n        int childPosition = java.util.Collections.binarySearch(children.children, lookupChildName);\n        if (childPosition < 0) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"Child node as per path {} does not exist at revision {}\", path, rev);\n            return true;\n        }\n        return false;\n    }\n\n    private static void diffProperties(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to, org.apache.jackrabbit.oak.commons.json.JsopWriter w) {\n        for (org.apache.jackrabbit.oak.api.PropertyState fromValue : from.getProperties()) {\n            java.lang.String name = fromValue.getName();\n            org.apache.jackrabbit.oak.api.PropertyState toValue = to.getProperty(name);\n            if (!fromValue.equals(toValue)) {\n                w.tag('^').key(concat(from.getPath(), name));\n                if (toValue == null) {\n                    w.value(null);\n                } else {\n                    w.encodedValue(to.getPropertyAsString(name)).newline();\n                }\n            }\n        }\n        for (java.lang.String name : to.getPropertyNames()) {\n            if (!from.hasProperty(name)) {\n                w.tag('^').key(concat(from.getPath(), name)).encodedValue(to.getPropertyAsString(name)).newline();\n            }\n        }\n    }\n\n    private java.lang.String diffImpl(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        int max = org.apache.jackrabbit.oak.plugins.document.DocumentMK.MANY_CHILDREN_THRESHOLD;\n        final boolean debug = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled();\n        final long start = (debug) ? org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now() : 0;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren;\n        fromChildren = getChildren(from, null, max);\n        toChildren = getChildren(to, null, max);\n        final long getChildrenDoneIn = (debug) ? org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now() : 0;\n        java.lang.String diffAlgo;\n        if ((!fromChildren.hasMore) && (!toChildren.hasMore)) {\n            diffAlgo = \"diffFewChildren\";\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        } else if (org.apache.jackrabbit.oak.plugins.document.DocumentMK.FAST_DIFF) {\n            diffAlgo = \"diffManyChildren\";\n            diffManyChildren(w, from.getPath(), from.getLastRevision(), to.getLastRevision());\n        } else {\n            diffAlgo = \"diffAllChildren\";\n            max = java.lang.Integer.MAX_VALUE;\n            fromChildren = getChildren(from, null, max);\n            toChildren = getChildren(to, null, max);\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        }\n        if (debug) {\n            long end = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now();\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Diff performed via '{}' at [{}] between revisions [{}] => [{}] took {} ms ({} ms)\", diffAlgo, from.getPath(), from.getLastRevision(), to.getLastRevision(), end - start, getChildrenDoneIn - start);\n        }\n        return w.toString();\n    }\n\n    private void diffManyChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        long minTimestamp = java.lang.Math.min(revisionComparator.getMinimumTimestamp(fromRev, inactiveClusterNodes), revisionComparator.getMinimumTimestamp(toRev, inactiveClusterNodes));\n        long minValue = org.apache.jackrabbit.oak.plugins.document.NodeDocument.getModifiedInSecs(minTimestamp);\n        java.lang.String fromKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        java.lang.String toKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(path);\n        java.util.Set<java.lang.String> paths = com.google.common.collect.Sets.newHashSet();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"diffManyChildren: path: {}, fromRev: {}, toRev: {}\", path, fromRev, toRev);\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED_IN_SECS, minValue, java.lang.Integer.MAX_VALUE)) {\n            paths.add(doc.getPath());\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"diffManyChildren: Affected paths: {}\", paths.size());\n        org.apache.jackrabbit.oak.plugins.document.Revision minRev = new org.apache.jackrabbit.oak.plugins.document.Revision(minTimestamp, 0, getClusterId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, getPendingModifications().getPaths(minRev));\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : new org.apache.jackrabbit.oak.plugins.document.Revision[]{ fromRev, toRev }) {\n            if (r.isBranch()) {\n                org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit c = getBranches().getBranchCommit(r);\n                if (c != null) {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, c.getModifiedPaths());\n                }\n            }\n        }\n        for (java.lang.String p : paths) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState fromNode = getNode(p, fromRev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState toNode = getNode(p, toRev);\n            java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"diffManyChildren: Changed Path {}\", path);\n            if (fromNode != null) {\n                if (toNode != null) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision a = fromNode.getLastRevision();\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = toNode.getLastRevision();\n                    if ((a == null) && (b == null)) {\n                    } else if (((a == null) || (b == null)) || (!a.equals(b))) {\n                        w.tag('^').key(name).object().endObject().newline();\n                    }\n                } else {\n                    w.tag('-').value(name).newline();\n                }\n            } else if (toNode != null) {\n                w.tag('+').key(name).object().endObject().newline();\n            } else {\n            }\n        }\n    }\n\n    private static void addPathsForDiff(java.lang.String path, java.util.Set<java.lang.String> paths, java.lang.Iterable<java.lang.String> modified) {\n        for (java.lang.String p : modified) {\n            if (org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(p)) {\n                continue;\n            }\n            java.lang.String parent = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(p);\n            if (path.equals(parent)) {\n                paths.add(p);\n            }\n        }\n    }\n\n    private void diffFewChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String parentPath, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        java.util.Set<java.lang.String> childrenSet = com.google.common.collect.Sets.newHashSet(toChildren.children);\n        for (java.lang.String n : fromChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('-').value(n).newline();\n            } else {\n                java.lang.String path = concat(parentPath, n);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n1 = getNode(path, fromRev);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n2 = getNode(path, toRev);\n                com.google.common.base.Preconditions.checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", path, fromRev);\n                com.google.common.base.Preconditions.checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", path, toRev);\n                if (!n1.getLastRevision().equals(n2.getLastRevision())) {\n                    w.tag('^').key(n).object().endObject().newline();\n                }\n            }\n        }\n        childrenSet = com.google.common.collect.Sets.newHashSet(fromChildren.children);\n        for (java.lang.String n : toChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('+').key(n).object().endObject().newline();\n            }\n        }\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.PathRev childNodeCacheKey(@javax.annotation.Nonnull\n    java.lang.String path, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    java.lang.String name) {\n        java.lang.String p = (name == null ? \"\" : name) + path;\n        return new org.apache.jackrabbit.oak.plugins.document.PathRev(p, readRevision);\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder asDocumentRootBuilder(org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) throws java.lang.IllegalArgumentException {\n        if (!(builder instanceof org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder)) {\n            throw new java.lang.IllegalArgumentException(\"builder must be a \" + org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder.class.getName());\n        }\n        return ((org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder) (builder));\n    }\n\n    private static long now() {\n        return java.lang.System.currentTimeMillis();\n    }\n\n    private void moveOrCopyNode(boolean move, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState newNode = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, targetPath, commit.getRevision());\n        source.copyTo(newNode);\n        commit.addNode(newNode);\n        if (move) {\n            markAsDeleted(source, commit, false);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(source, null, java.lang.Integer.MAX_VALUE)) {\n            java.lang.String childName = org.apache.jackrabbit.oak.commons.PathUtils.getName(child.getPath());\n            java.lang.String destChildPath = concat(targetPath, childName);\n            moveOrCopyNode(move, child, destChildPath, commit);\n        }\n    }\n\n    private void checkRevisionAge(org.apache.jackrabbit.oak.plugins.document.Revision r, java.lang.String path) {\n        if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n            if (\"/\".equals(path) && ((headRevision.getTimestamp() - r.getTimestamp()) > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.WARN_REVISION_AGE)) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug((((\"Requesting an old revision for path \" + path) + \", \") + ((headRevision.getTimestamp() - r.getTimestamp()) / 1000)) + \" seconds old\");\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector createBlobGarbageCollector(long blobGcMaxAgeInSecs, java.lang.String repositoryId) {\n        org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector blobGC = null;\n        if (blobStore instanceof org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) {\n            try {\n                blobGC = new org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector(new org.apache.jackrabbit.oak.plugins.document.DocumentBlobReferenceRetriever(this), ((org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) (blobStore)), executor, java.util.concurrent.TimeUnit.SECONDS.toMillis(blobGcMaxAgeInSecs), repositoryId);\n            } catch (java.io.IOException e) {\n                throw new java.lang.RuntimeException(\"Error occurred while initializing \" + \"the MarkSweepGarbageCollector\", e);\n            }\n        }\n        return blobGC;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean getMBean() {\n        return mbean;\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean createMBean() {\n        try {\n            return new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.MBeanImpl();\n        } catch (javax.management.NotCompliantMBeanException e) {\n            throw new java.lang.IllegalStateException(e);\n        }\n    }\n\n    private class MBeanImpl extends org.apache.jackrabbit.oak.commons.jmx.AnnotatedStandardMBean implements org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean {\n        private final java.lang.String ISO_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss.SSS zzz\";\n\n        private final java.util.TimeZone TZ_UTC = java.util.TimeZone.getTimeZone(\"UTC\");\n\n        protected MBeanImpl() throws javax.management.NotCompliantMBeanException {\n            super(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String getRevisionComparatorState() {\n            return revisionComparator.toString();\n        }\n\n        @java.lang.Override\n        public java.lang.String getHead() {\n            return headRevision.toString();\n        }\n\n        @java.lang.Override\n        public int getClusterId() {\n            return clusterId;\n        }\n\n        @java.lang.Override\n        public int getUnmergedBranchCount() {\n            return branches.size();\n        }\n\n        @java.lang.Override\n        public java.lang.String[] getInactiveClusterNodes() {\n            return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(inactiveClusterNodes.entrySet(), new com.google.common.base.Function<java.util.Map.Entry<java.lang.Integer, java.lang.Long>, java.lang.String>() {\n                @java.lang.Override\n                public java.lang.String apply(java.util.Map.Entry<java.lang.Integer, java.lang.Long> input) {\n                    return input.toString();\n                }\n            }), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String[] getLastKnownRevisions() {\n            return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(lastKnownRevision.entrySet(), new com.google.common.base.Function<java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision>, java.lang.String>() {\n                @java.lang.Override\n                public java.lang.String apply(java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> input) {\n                    return input.toString();\n                }\n            }), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String formatRevision(java.lang.String rev, boolean utc) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(rev);\n            final java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(ISO_FORMAT);\n            if (utc) {\n                sdf.setTimeZone(TZ_UTC);\n            }\n            return sdf.format(r.getTimestamp());\n        }\n    }\n\n    static abstract class NodeStoreTask implements java.lang.Runnable {\n        final java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore> ref;\n\n        private final java.util.concurrent.atomic.AtomicBoolean isDisposed;\n\n        private int delay;\n\n        NodeStoreTask(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            ref = new java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore>(nodeStore);\n            delay = nodeStore.getAsyncDelay();\n            this.isDisposed = isDisposed;\n        }\n\n        protected abstract void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore);\n\n        @java.lang.Override\n        public void run() {\n            while ((delay != 0) && (!isDisposed.get())) {\n                synchronized(isDisposed) {\n                    try {\n                        isDisposed.wait(delay);\n                    } catch (java.lang.InterruptedException e) {\n                    }\n                }\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore = ref.get();\n                if (nodeStore != null) {\n                    try {\n                        execute(nodeStore);\n                    } catch (java.lang.Throwable t) {\n                        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + t.toString(), t);\n                    }\n                    delay = nodeStore.getAsyncDelay();\n                } else {\n                    break;\n                }\n            } \n        }\n    }\n\n    static class BackgroundOperation extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundOperation(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            nodeStore.runBackgroundOperations();\n        }\n    }\n\n    static class BackgroundLeaseUpdate extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundLeaseUpdate(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            if (nodeStore.renewClusterIdLease()) {\n                nodeStore.updateClusterState();\n            }\n        }\n    }\n\n    public org.apache.jackrabbit.oak.spi.blob.BlobStore getBlobStore() {\n        return blobStore;\n    }\n\n    org.apache.jackrabbit.oak.json.BlobSerializer getBlobSerializer() {\n        return blobSerializer;\n    }\n\n    public java.util.Iterator<org.apache.jackrabbit.oak.api.Blob> getReferencedBlobsIterator() {\n        if (store instanceof org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) {\n            return new org.apache.jackrabbit.oak.plugins.document.mongo.MongoBlobReferenceIterator(this, ((org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) (store)));\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.BlobReferenceIterator(this);\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.DiffCache getDiffCache() {\n        return diffCache;\n    }\n\n    public org.apache.jackrabbit.oak.stats.Clock getClock() {\n        return clock;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.Checkpoints getCheckpoints() {\n        return checkpoints;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector getVersionGarbageCollector() {\n        return versionGarbageCollector;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent getLastRevRecoveryAgent() {\n        return lastRevRecoveryAgent;\n    }\n\n    public void setPersistentCache(org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache) {\n        this.persistentCache = persistentCache;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Wrapper",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "private",
            "dst_parent": "private synchronized void internalRunBackgroundOperations() {\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Method",
            "dst_type": "Wra",
            "operator": "UPD",
            "src": "public",
            "src_parent": "public synchronized void runBackgroundOperations() {\n    if (isDisposed.get()) {\n        return;\n    }\n    if (simpleRevisionCounter != null) {\n        return;\n    }\n    try {\n        long start = clock.getTime();\n        long time = start;\n        cleanOrphanedBranches();\n        cleanCollisions();\n        long cleanTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundSplit();\n        long splitTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundWrite();\n        long writeTime = clock.getTime() - time;\n        time = clock.getTime();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n        long readTime = clock.getTime() - time;\n        java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n        if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        }\n    } catch (java.lang.RuntimeException e) {\n        if (isDisposed.get()) {\n            return;\n        }\n        throw e;\n    }\n}",
            "src_parent_type": "Method",
            "src_type": "Wra"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "runBackgroundOperations()",
            "src_parent": "{\n    runBackgroundOperations();\n    if (!isDisposed.getAndSet(true)) {\n        synchronized(isDisposed) {\n            isDisposed.notifyAll();\n        }\n        try {\n            backgroundThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n        if (leaseUpdateThread != null) {\n            try {\n                leaseUpdateThread.join();\n            } catch (java.lang.InterruptedException e) {\n            }\n        }\n        if (clusterNodeInfo != null) {\n            clusterNodeInfo.dispose();\n        }\n        store.dispose();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n        if (blobStore instanceof java.io.Closeable) {\n            try {\n                ((java.io.Closeable) (blobStore)).close();\n            } catch (java.io.IOException ex) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n            }\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "!isDisposed.getAndSet(true)",
            "src_parent": "if (!isDisposed.getAndSet(true)) {\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n}",
            "src_parent_type": "If",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "public void runBackgroundOperations() {\n    if (isDisposed.get()) {\n        return;\n    }\n    try {\n        internalRunBackgroundOperations();\n    } catch (java.lang.RuntimeException e) {\n        if (isDisposed.get()) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + e.toString(), e);\n            return;\n        }\n        throw e;\n    }\n}",
            "src_parent": "public final class DocumentNodeStore implements org.apache.jackrabbit.oak.plugins.document.RevisionContext , org.apache.jackrabbit.oak.spi.commit.Observable , org.apache.jackrabbit.oak.spi.state.NodeStore {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.class);\n\n    private static final org.apache.jackrabbit.oak.util.PerfLogger PERFLOG = new org.apache.jackrabbit.oak.util.PerfLogger(org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.class.getName() + \".perf\"));\n\n    static final int NUM_CHILDREN_CACHE_LIMIT = java.lang.Integer.getInteger(\"oak.documentMK.childrenCacheLimit\", 16 * 1024);\n\n    private static final int WARN_REVISION_AGE = java.lang.Integer.getInteger(\"oak.documentMK.revisionAge\", 60 * 1000);\n\n    static final int REMEMBER_REVISION_ORDER_MILLIS = (60 * 60) * 1000;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState missing;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.CommitQueue commitQueue;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue batchCommitQueue;\n\n    protected final org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher dispatcher;\n\n    protected int asyncDelay = 1000;\n\n    protected int maxBackOffMillis = asyncDelay * 2;\n\n    private final java.util.concurrent.atomic.AtomicBoolean isDisposed = new java.util.concurrent.atomic.AtomicBoolean();\n\n    private final org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo clusterNodeInfo;\n\n    private final int clusterId;\n\n    private final java.util.concurrent.ConcurrentMap<java.lang.Integer, java.lang.Long> inactiveClusterNodes = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, java.lang.Long>();\n\n    private final Revision.RevisionComparator revisionComparator;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnmergedBranches branches;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnsavedModifications unsavedLastRevisions = new org.apache.jackrabbit.oak.plugins.document.UnsavedModifications();\n\n    private final java.util.Map<java.lang.String, java.lang.String> splitCandidates = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastKnownRevision = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision>();\n\n    private volatile org.apache.jackrabbit.oak.plugins.document.Revision headRevision;\n\n    private java.lang.Thread backgroundThread;\n\n    private java.lang.Thread leaseUpdateThread;\n\n    private final java.util.concurrent.locks.ReadWriteLock backgroundOperationLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private final java.util.concurrent.locks.ReadWriteLock mergeLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private java.util.concurrent.atomic.AtomicInteger simpleRevisionCounter;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> nodeCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children> nodeChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeChildrenCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.util.StringValue, org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children> docChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats docChildrenCacheStats;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DiffCache diffCache;\n\n    private final org.apache.jackrabbit.oak.spi.blob.BlobStore blobStore;\n\n    private final org.apache.jackrabbit.oak.json.BlobSerializer blobSerializer = new org.apache.jackrabbit.oak.json.BlobSerializer() {\n        @java.lang.Override\n        public java.lang.String serialize(org.apache.jackrabbit.oak.api.Blob blob) {\n            if (blob instanceof org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) {\n                return ((org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) (blob)).getBlobId();\n            }\n            java.lang.String id;\n            java.lang.String reference = blob.getReference();\n            if (reference != null) {\n                id = blobStore.getBlobId(reference);\n                if (id != null) {\n                    return id;\n                }\n            }\n            try {\n                id = createBlob(blob.getNewStream()).getBlobId();\n            } catch (java.io.IOException e) {\n                throw new java.lang.IllegalStateException(e);\n            }\n            return id;\n        }\n    };\n\n    private final org.apache.jackrabbit.oak.stats.Clock clock;\n\n    private final org.apache.jackrabbit.oak.plugins.document.Checkpoints checkpoints;\n\n    private final org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector versionGarbageCollector;\n\n    private final java.util.concurrent.Executor executor;\n\n    private final org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent lastRevRecoveryAgent;\n\n    private final boolean disableBranches;\n\n    private org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean mbean;\n\n    public DocumentNodeStore(org.apache.jackrabbit.oak.plugins.document.DocumentMK.Builder builder) {\n        this.blobStore = builder.getBlobStore();\n        if (builder.isUseSimpleRevision()) {\n            this.simpleRevisionCounter = new java.util.concurrent.atomic.AtomicInteger(0);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentStore s = builder.getDocumentStore();\n        if (builder.getTiming()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.TimingDocumentStoreWrapper(s);\n        }\n        if (builder.getLogging()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.LoggingDocumentStoreWrapper(s);\n        }\n        this.store = s;\n        this.executor = builder.getExecutor();\n        this.clock = builder.getClock();\n        int cid = builder.getClusterId();\n        cid = java.lang.Integer.getInteger(\"oak.documentMK.clusterId\", cid);\n        if (cid == 0) {\n            clusterNodeInfo = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getInstance(store);\n            cid = clusterNodeInfo.getId();\n        } else {\n            clusterNodeInfo = null;\n        }\n        this.clusterId = cid;\n        this.revisionComparator = new org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator(clusterId);\n        this.branches = new org.apache.jackrabbit.oak.plugins.document.UnmergedBranches(getRevisionComparator());\n        this.asyncDelay = builder.getAsyncDelay();\n        this.versionGarbageCollector = new org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector(this, builder.createVersionGCSupport());\n        this.lastRevRecoveryAgent = new org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent(this);\n        this.disableBranches = builder.isDisableBranches();\n        this.missing = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"MISSING\", new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, 0)) {\n            @java.lang.Override\n            public int getMemory() {\n                return 8;\n            }\n        };\n        nodeCache = builder.buildNodeCache(this);\n        nodeCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeCache, \"Document-NodeState\", builder.getWeigher(), builder.getNodeCacheSize());\n        nodeChildrenCache = builder.buildChildrenCache();\n        nodeChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeChildrenCache, \"Document-NodeChildren\", builder.getWeigher(), builder.getChildrenCacheSize());\n        docChildrenCache = builder.buildDocChildrenCache();\n        docChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(docChildrenCache, \"Document-DocChildren\", builder.getWeigher(), builder.getDocChildrenCacheSize());\n        diffCache = builder.getDiffCache();\n        checkpoints = new org.apache.jackrabbit.oak.plugins.document.Checkpoints(this);\n        if (store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\")) == null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision();\n            org.apache.jackrabbit.oak.plugins.document.Commit commit = new org.apache.jackrabbit.oak.plugins.document.Commit(this, head, null, null);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"/\", head);\n            commit.addNode(n);\n            commit.applyToDocumentStore();\n            commit.applyToCache(new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId), false);\n            setHeadRevision(commit.getRevision());\n            backgroundWrite();\n        } else {\n            branches.init(store, this);\n            backgroundRead(false);\n            if (headRevision == null) {\n                setHeadRevision(newRevision());\n            }\n        }\n        getRevisionComparator().add(headRevision, org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0));\n        dispatcher = new org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher(getRoot());\n        commitQueue = new org.apache.jackrabbit.oak.plugins.document.CommitQueue(this, dispatcher);\n        batchCommitQueue = new org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue(store, revisionComparator);\n        backgroundThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundOperation(this, isDisposed), \"DocumentNodeStore background thread\");\n        backgroundThread.setDaemon(true);\n        checkLastRevRecovery();\n        renewClusterIdLease();\n        backgroundThread.start();\n        if (clusterNodeInfo != null) {\n            leaseUpdateThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundLeaseUpdate(this, isDisposed), \"DocumentNodeStore lease update thread\");\n            leaseUpdateThread.setDaemon(true);\n            leaseUpdateThread.start();\n        }\n        this.mbean = createMBean();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Initialized DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    }\n\n    private void checkLastRevRecovery() {\n        lastRevRecoveryAgent.recover(clusterId);\n    }\n\n    public void dispose() {\n        if (isDisposed.getAndSet(true)) {\n            return;\n        }\n        synchronized(isDisposed) {\n            isDisposed.notifyAll();\n        }\n        try {\n            backgroundThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n        internalRunBackgroundOperations();\n        if (leaseUpdateThread != null) {\n            try {\n                leaseUpdateThread.join();\n            } catch (java.lang.InterruptedException e) {\n            }\n        }\n        if (clusterNodeInfo != null) {\n            clusterNodeInfo.dispose();\n        }\n        store.dispose();\n        if (blobStore instanceof java.io.Closeable) {\n            try {\n                ((java.io.Closeable) (blobStore)).close();\n            } catch (java.io.IOException ex) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n            }\n        }\n        if (persistentCache != null) {\n            persistentCache.close();\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.Revision setHeadRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newHead) {\n        com.google.common.base.Preconditions.checkArgument(!newHead.isBranch());\n        org.apache.jackrabbit.oak.plugins.document.Revision previous = headRevision;\n        if (!com.google.common.base.Preconditions.checkNotNull(newHead).equals(previous)) {\n            headRevision = newHead;\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentStore getDocumentStore() {\n        return store;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newRevision() {\n        if (simpleRevisionCounter != null) {\n            return new org.apache.jackrabbit.oak.plugins.document.Revision(simpleRevisionCounter.getAndIncrement(), 0, clusterId);\n        }\n        return org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(clusterId);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit newCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        checkOpen();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.Commit(this, commitQueue.createRevision(), base, branch);\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.MergeCommit newMergeCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base, int numBranchCommits) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        checkOpen();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    void done(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit c, boolean isBranch, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) {\n        try {\n            commitQueue.done(c, isBranch, info);\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    void canceled(org.apache.jackrabbit.oak.plugins.document.Commit c) {\n        try {\n            commitQueue.canceled(c.getRevision());\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    public void setAsyncDelay(int delay) {\n        this.asyncDelay = delay;\n    }\n\n    public int getAsyncDelay() {\n        return asyncDelay;\n    }\n\n    public void setMaxBackOffMillis(int time) {\n        maxBackOffMillis = time;\n    }\n\n    public int getMaxBackOffMillis() {\n        return maxBackOffMillis;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo getClusterInfo() {\n        return clusterNodeInfo;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeCacheStats() {\n        return nodeCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeChildrenCacheStats() {\n        return nodeChildrenCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getDocChildrenCacheStats() {\n        return docChildrenCacheStats;\n    }\n\n    void invalidateDocChildrenCache() {\n        docChildrenCache.invalidateAll();\n    }\n\n    void invalidateNodeChildrenCache() {\n        nodeChildrenCache.invalidateAll();\n    }\n\n    void invalidateNodeCache(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        nodeCache.invalidate(new org.apache.jackrabbit.oak.plugins.document.PathRev(path, revision));\n    }\n\n    public int getPendingWriteCount() {\n        return unsavedLastRevisions.getPaths().size();\n    }\n\n    public boolean isDisableBranches() {\n        return disableBranches;\n    }\n\n    boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    void addSplitCandidate(java.lang.String id) {\n        splitCandidates.put(id, id);\n    }\n\n    void copyNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(false, source, targetPath, commit);\n    }\n\n    void moveNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(true, source, targetPath, commit);\n    }\n\n    void markAsDeleted(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, org.apache.jackrabbit.oak.plugins.document.Commit commit, boolean subTreeAlso) {\n        commit.removeNode(node.getPath());\n        if (subTreeAlso) {\n            for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(node, null, java.lang.Integer.MAX_VALUE)) {\n                markAsDeleted(child, commit, true);\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNode(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        checkRevisionAge(com.google.common.base.Preconditions.checkNotNull(rev), com.google.common.base.Preconditions.checkNotNull(path));\n        final long start = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.start();\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = new org.apache.jackrabbit.oak.plugins.document.PathRev(path, rev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node = nodeCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState call() throws java.lang.Exception {\n                    boolean nodeDoesNotExist = checkNodeNotExistsFromChildrenCache(path, rev);\n                    if (nodeDoesNotExist) {\n                        return missing;\n                    }\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = readNode(path, rev);\n                    if (n == null) {\n                        n = missing;\n                    }\n                    return n;\n                }\n            });\n            final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = ((node == missing) || node.equals(missing)) ? null : node;\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"getNode: path={}, rev={}\", path, rev);\n            return result;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        }\n    }\n\n    DocumentNodeState.Children getChildren(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return DocumentNodeState.NO_CHILDREN;\n        }\n        final java.lang.String path = com.google.common.base.Preconditions.checkNotNull(parent).getPath();\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, readRevision, name);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children children = nodeChildrenCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children>() {\n                @java.lang.Override\n                public DocumentNodeState.Children call() throws java.lang.Exception {\n                    return readChildren(parent, name, limit);\n                }\n            });\n            if ((children.children.size() < limit) && children.hasMore) {\n                children = readChildren(parent, name, limit);\n                nodeChildrenCache.put(key, children);\n            }\n            return children;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        }\n    }\n\n    DocumentNodeState.Children readChildren(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, java.lang.String name, int limit) {\n        java.lang.String queriedName = name;\n        java.lang.String path = parent.getPath();\n        org.apache.jackrabbit.oak.plugins.document.Revision rev = parent.getLastRevision();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"Reading children for [{}] ast rev [{}]\", path, rev);\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n        int rawLimit = ((int) (java.lang.Math.min(java.lang.Integer.MAX_VALUE, ((long) (limit)) + 1)));\n        for (; ;) {\n            docs = readChildDocs(path, name, rawLimit);\n            int numReturned = 0;\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                numReturned++;\n                java.lang.String p = doc.getPath();\n                name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child = getNode(p, rev);\n                if (child == null) {\n                    continue;\n                }\n                if (c.children.size() < limit) {\n                    c.children.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n                } else {\n                    c.hasMore = true;\n                    return c;\n                }\n            }\n            if (numReturned < rawLimit) {\n                c.hasMore = false;\n                if (queriedName == null) {\n                    java.util.Collections.sort(c.children);\n                }\n                return c;\n            }\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> readChildDocs(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nullable\n    java.lang.String name, int limit) {\n        java.lang.String to = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(com.google.common.base.Preconditions.checkNotNull(path));\n        java.lang.String from;\n        if (name != null) {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(concat(path, name));\n        } else {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        }\n        if ((name != null) || (limit > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NUM_CHILDREN_CACHE_LIMIT)) {\n            return store.query(Collection.NODES, from, to, limit);\n        }\n        org.apache.jackrabbit.oak.plugins.document.util.StringValue key = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children c = docChildrenCache.getIfPresent(key);\n        if (c == null) {\n            c = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, limit);\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                c.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            c.isComplete = docs.size() < limit;\n            docChildrenCache.put(key, c);\n            return docs;\n        } else if ((c.childNames.size() < limit) && (!c.isComplete)) {\n            java.lang.String lastName = c.childNames.get(c.childNames.size() - 1);\n            java.lang.String lastPath = concat(path, lastName);\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(lastPath);\n            int remainingLimit = limit - c.childNames.size();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, remainingLimit);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = c.clone();\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                clone.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            clone.isComplete = docs.size() < remainingLimit;\n            docChildrenCache.put(key, clone);\n            c = clone;\n        }\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> it = com.google.common.collect.Iterables.transform(c.childNames, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.lang.String name) {\n                java.lang.String p = concat(path, name);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(p));\n                if (doc == null) {\n                    docChildrenCache.invalidateAll();\n                    throw new java.lang.NullPointerException((\"Document \" + p) + \" not found\");\n                }\n                return doc;\n            }\n        });\n        if (c.childNames.size() > (limit * 2)) {\n            it = com.google.common.collect.Iterables.limit(it, limit * 2);\n        }\n        return it;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> getChildNodes(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return java.util.Collections.emptyList();\n        }\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        return com.google.common.collect.Iterables.transform(getChildren(parent, name, limit).children, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState apply(java.lang.String input) {\n                java.lang.String p = concat(parent.getPath(), input);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = getNode(p, readRevision);\n                if (result == null) {\n                    throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((((\"DocumentNodeState is null for revision \" + readRevision) + \" of \") + p) + \" (aborting getChildNodes())\");\n                }\n                return result;\n            }\n        });\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState readNode(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        final long start = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.start();\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(path);\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = getPendingModifications().get(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n        if (doc == null) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"readNode: (document not found) path={}, readRevision={}\", path, readRevision);\n            return null;\n        }\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = doc.getNodeAtRevision(this, readRevision, lastRevision);\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"readNode: path={}, readRevision={}\", path, readRevision);\n        return result;\n    }\n\n    public void applyChanges(org.apache.jackrabbit.oak.plugins.document.Revision rev, java.lang.String path, boolean isNew, java.util.List<java.lang.String> added, java.util.List<java.lang.String> removed, java.util.List<java.lang.String> changed, org.apache.jackrabbit.oak.plugins.document.DiffCache.Entry cacheEntry) {\n        if (isNew && (!added.isEmpty())) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n            java.util.Set<java.lang.String> set = com.google.common.collect.Sets.newTreeSet();\n            for (java.lang.String p : added) {\n                set.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n            }\n            c.children.addAll(set);\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, rev, null);\n            nodeChildrenCache.put(key, c);\n        }\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        for (java.lang.String p : added) {\n            w.tag('+').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        for (java.lang.String p : removed) {\n            w.tag('-').value(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).newline();\n        }\n        for (java.lang.String p : changed) {\n            w.tag('^').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        cacheEntry.append(path, w.toString());\n        if (!added.isEmpty()) {\n            org.apache.jackrabbit.oak.plugins.document.util.StringValue docChildrenKey = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children docChildren = docChildrenCache.getIfPresent(docChildrenKey);\n            if (docChildren != null) {\n                int currentSize = docChildren.childNames.size();\n                java.util.NavigableSet<java.lang.String> names = com.google.common.collect.Sets.newTreeSet(docChildren.childNames);\n                if (!docChildren.isComplete) {\n                    for (java.lang.String childPath : added) {\n                        java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath);\n                        if (names.higher(name) != null) {\n                            names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(name));\n                        }\n                    }\n                } else {\n                    for (java.lang.String childPath : added) {\n                        names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath)));\n                    }\n                }\n                if (names.size() != currentSize) {\n                    boolean complete = docChildren.isComplete;\n                    docChildren = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n                    docChildren.isComplete = complete;\n                    docChildren.childNames.addAll(names);\n                    docChildrenCache.put(docChildrenKey, docChildren);\n                }\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument updateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        boolean batch = true;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> op : commit.getChanges().entrySet()) {\n            java.lang.String name = op.getKey().getName();\n            if ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name)) || NodeDocument.COLLISIONS.equals(name)) {\n                continue;\n            }\n            batch = false;\n            break;\n        }\n        if (batch) {\n            return batchUpdateCommitRoot(commit);\n        } else {\n            return store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, commit);\n        }\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument batchUpdateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        try {\n            return batchCommitQueue.updateDocument(commit).call();\n        } catch (java.lang.InterruptedException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Interrupted while updating commit root document\");\n        } catch (java.lang.Exception e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Update of commit root document failed\");\n        }\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState root = getNode(\"/\", revision);\n        if (root == null) {\n            throw new java.lang.IllegalStateException(\"root node does not exist at revision \" + revision);\n        }\n        return root;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch createBranch(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch b = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch.getCurrentBranch();\n        if (b != null) {\n            return b;\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch(this, base, mergeLock);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision base) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(base);\n        if (disableBranches) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            return base.asBranchRevision();\n        }\n        if (b.getBase(branchHead).equals(base)) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision().asBranchRevision();\n        b.rebase(head, base);\n        return head;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision ancestor, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(ancestor);\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(\"Empty branch cannot be reset\");\n        }\n        if (!b.getCommits().last().equals(branchHead)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((branchHead + \" is not the head \") + \"of a branch\");\n        }\n        if (!b.containsCommit(ancestor)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(((ancestor + \" is not \") + \"an ancestor revision of \") + branchHead);\n        }\n        if (branchHead.equals(ancestor)) {\n            return branchHead;\n        }\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit commit = newCommit(branchHead, branch);\n        try {\n            java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> it = b.getCommits().tailSet(ancestor).iterator();\n            org.apache.jackrabbit.oak.plugins.document.Revision base = it.next();\n            java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.document.UpdateOp> operations = com.google.common.collect.Maps.newHashMap();\n            while (it.hasNext()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision reset = it.next();\n                getRoot(reset).compareAgainstBaseState(getRoot(base), new org.apache.jackrabbit.oak.plugins.document.ResetDiff(reset.asTrunkRevision(), operations));\n                org.apache.jackrabbit.oak.plugins.document.UpdateOp rootOp = operations.get(\"/\");\n                if (rootOp == null) {\n                    rootOp = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(rootOp, commit.getRevision());\n                    operations.put(\"/\", rootOp);\n                }\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n            } \n            if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n                java.util.List<org.apache.jackrabbit.oak.plugins.document.Revision> revs = com.google.common.collect.Lists.newArrayList(b.getCommits().tailSet(ancestor));\n                for (org.apache.jackrabbit.oak.plugins.document.Revision r : revs.subList(1, revs.size())) {\n                    b.removeCommit(r);\n                }\n                success = true;\n            }\n            operations.remove(\"/\");\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : operations.values()) {\n                store.findAndUpdate(Collection.NODES, op);\n            }\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, true, null);\n            }\n        }\n        return ancestor;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        org.apache.jackrabbit.oak.plugins.document.Revision base = branchHead;\n        if (b != null) {\n            base = b.getBase(branchHead);\n        }\n        int numBranchCommits = (b != null) ? b.getCommits().size() : 1;\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit commit = newMergeCommit(base, numBranchCommits);\n        try {\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(op, commit.getRevision());\n            if (b != null) {\n                java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> mergeCommits = commit.getMergeRevisions().iterator();\n                for (org.apache.jackrabbit.oak.plugins.document.Revision rev : b.getCommits()) {\n                    rev = rev.asTrunkRevision();\n                    java.lang.String commitTag = \"c-\" + mergeCommits.next();\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setRevision(op, rev, commitTag);\n                    op.containsMapEntry(NodeDocument.COLLISIONS, rev, false);\n                }\n                if (store.findAndUpdate(Collection.NODES, op) != null) {\n                    b.applyTo(getPendingModifications(), commit.getRevision());\n                    getBranches().remove(b);\n                } else {\n                    throw new org.apache.jackrabbit.oak.api.CommitFailedException(MERGE, 2, \"Conflicting concurrent change. Update operation failed: \" + op);\n                }\n            } else {\n            }\n            success = true;\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, false, info);\n            }\n        }\n        return commit.getRevision();\n    }\n\n    boolean compare(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.spi.state.NodeStateDiff diff) {\n        if (!org.apache.jackrabbit.oak.spi.state.AbstractNodeState.comparePropertiesAgainstBaseState(node, base, diff)) {\n            return false;\n        }\n        if (node.hasNoChildren() && base.hasNoChildren()) {\n            return true;\n        }\n        boolean useReadRevision = true;\n        java.lang.String jsop = diffCache.getChanges(base.getRevision(), node.getRevision(), node.getPath(), null);\n        if (jsop == null) {\n            useReadRevision = false;\n            jsop = diffCache.getChanges(base.getLastRevision(), node.getLastRevision(), node.getPath(), new org.apache.jackrabbit.oak.plugins.document.DiffCache.Loader() {\n                @java.lang.Override\n                public java.lang.String call() {\n                    return diffImpl(base, node);\n                }\n            });\n        }\n        return dispatch(jsop, node, base, diff, useReadRevision);\n    }\n\n    java.lang.String diff(@javax.annotation.Nonnull\n    final java.lang.String fromRevisionId, @javax.annotation.Nonnull\n    final java.lang.String toRevisionId, @javax.annotation.Nonnull\n    final java.lang.String path) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (fromRevisionId.equals(toRevisionId)) {\n            return \"\";\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision fromRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(fromRevisionId);\n        org.apache.jackrabbit.oak.plugins.document.Revision toRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(toRevisionId);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from = getNode(path, fromRev);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to = getNode(path, toRev);\n        if ((from == null) || (to == null)) {\n            java.lang.String msg = java.lang.String.format(\"Diff is only supported if the node exists in both cases. \" + \"Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s\", path, fromRev, from != null, toRev, to != null);\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(msg);\n        }\n        java.lang.String compactDiff = diffCache.getChanges(fromRev, toRev, path, new org.apache.jackrabbit.oak.plugins.document.DiffCache.Loader() {\n            @java.lang.Override\n            public java.lang.String call() {\n                return diffImpl(from, to);\n            }\n        });\n        org.apache.jackrabbit.oak.commons.json.JsopWriter writer = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.diffProperties(from, to, writer);\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer t = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(compactDiff);\n        int r;\n        do {\n            r = t.read();\n            switch (r) {\n                case '+' :\n                case '^' :\n                    {\n                        java.lang.String name = t.readString();\n                        t.read(':');\n                        t.read('{');\n                        t.read('}');\n                        writer.tag(((char) (r))).key(concat(path, name));\n                        writer.object().endObject().newline();\n                        break;\n                    }\n                case '-' :\n                    {\n                        java.lang.String name = t.readString();\n                        writer.tag('-').value(concat(path, name));\n                        writer.newline();\n                    }\n            }\n        } while (r != org.apache.jackrabbit.oak.commons.json.JsopReader.END );\n        return writer.toString();\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.LastRevTracker createTracker(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision r, final boolean isBranchCommit) {\n        if (isBranchCommit && (!disableBranches)) {\n            org.apache.jackrabbit.oak.plugins.document.Revision branchRev = r.asBranchRevision();\n            return branches.getBranchCommit(branchRev);\n        } else {\n            return new org.apache.jackrabbit.oak.plugins.document.LastRevTracker() {\n                @java.lang.Override\n                public void track(java.lang.String path) {\n                    unsavedLastRevisions.put(path, r);\n                }\n            };\n        }\n    }\n\n    @java.lang.Override\n    public java.io.Closeable addObserver(org.apache.jackrabbit.oak.spi.commit.Observer observer) {\n        return dispatcher.addObserver(observer);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot() {\n        return getRoot(headRevision);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitHook commitHook, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).merge(commitHook, info);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).rebase();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).reset();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob createBlob(java.io.InputStream inputStream) throws java.io.IOException {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobStore.writeBlob(inputStream));\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.api.Blob getBlob(java.lang.String reference) {\n        java.lang.String blobId = blobStore.getBlobId(reference);\n        if (blobId != null) {\n            return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"No blobId found matching reference [{}]\", reference);\n        return null;\n    }\n\n    public org.apache.jackrabbit.oak.api.Blob getBlobFromBlobId(java.lang.String blobId) {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime, @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> properties) {\n        return checkpoints.create(lifetime, properties).toString();\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime) {\n        java.util.Map<java.lang.String, java.lang.String> empty = java.util.Collections.emptyMap();\n        return checkpoint(lifetime, empty);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.util.Map<java.lang.String, java.lang.String> checkpointInfo(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info info = checkpoints.getCheckpoints().get(r);\n        if (info == null) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return info.get();\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState retrieve(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info> checkpoints = this.checkpoints.getCheckpoints();\n        if ((checkpoints != null) && checkpoints.containsKey(r)) {\n            return getRoot(r);\n        } else {\n            return null;\n        }\n    }\n\n    @java.lang.Override\n    public boolean release(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        checkpoints.release(checkpoint);\n        return true;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnmergedBranches getBranches() {\n        return branches;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnsavedModifications getPendingModifications() {\n        return unsavedLastRevisions;\n    }\n\n    @java.lang.Override\n    public Revision.RevisionComparator getRevisionComparator() {\n        return revisionComparator;\n    }\n\n    @java.lang.Override\n    public int getClusterId() {\n        return clusterId;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getHeadRevision() {\n        return headRevision;\n    }\n\n    public void runBackgroundOperations() {\n        if (isDisposed.get()) {\n            return;\n        }\n        try {\n            internalRunBackgroundOperations();\n        } catch (java.lang.RuntimeException e) {\n            if (isDisposed.get()) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + e.toString(), e);\n                return;\n            }\n            throw e;\n        }\n    }\n\n    private synchronized void internalRunBackgroundOperations() {\n        long start = clock.getTime();\n        long time = start;\n        cleanOrphanedBranches();\n        cleanCollisions();\n        long cleanTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundSplit();\n        long splitTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundWrite();\n        long writeTime = clock.getTime() - time;\n        time = clock.getTime();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n        long readTime = clock.getTime() - time;\n        java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n        if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        }\n    }\n\n    boolean renewClusterIdLease() {\n        return (clusterNodeInfo != null) && clusterNodeInfo.renewLease();\n    }\n\n    void updateClusterState() {\n        long now = clock.getTime();\n        java.util.Set<java.lang.Integer> inactive = com.google.common.collect.Sets.newHashSet();\n        for (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument doc : org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument.all(store)) {\n            int cId = doc.getClusterId();\n            if ((cId != this.clusterId) && (!doc.isActive())) {\n                inactive.add(cId);\n            }\n        }\n        inactiveClusterNodes.keySet().retainAll(inactive);\n        for (java.lang.Integer clusterId : inactive) {\n            inactiveClusterNodes.putIfAbsent(clusterId, now);\n        }\n    }\n\n    java.util.Map<java.lang.Integer, java.lang.Long> getInactiveClusterNodes() {\n        return new java.util.HashMap<java.lang.Integer, java.lang.Long>(inactiveClusterNodes);\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats backgroundRead(boolean dispatchChange) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats stats = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats();\n        long time = clock.getTime();\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\");\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\n        if (doc == null) {\n            return stats;\n        }\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevMap = doc.getLastRev();\n        org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator revisionComparator = getRevisionComparator();\n        org.apache.jackrabbit.oak.plugins.document.Revision headSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        org.apache.jackrabbit.oak.plugins.document.Revision otherSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> externalChanges = com.google.common.collect.Maps.newHashMap();\n        for (java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> e : lastRevMap.entrySet()) {\n            int machineId = e.getKey();\n            if (machineId == clusterId) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.Revision r = e.getValue();\n            org.apache.jackrabbit.oak.plugins.document.Revision last = lastKnownRevision.get(machineId);\n            if ((last == null) || (r.compareRevisionTime(last) > 0)) {\n                lastKnownRevision.put(machineId, r);\n                if ((last != null) || (r.getTimestamp() > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())) {\n                    externalChanges.put(r, otherSeen);\n                }\n            }\n        }\n        stats.readHead = clock.getTime() - time;\n        time = clock.getTime();\n        if (!externalChanges.isEmpty()) {\n            stats.cacheStats = store.invalidateCache();\n            stats.cacheInvalidationTime = clock.getTime() - time;\n            time = clock.getTime();\n            docChildrenCache.invalidateAll();\n            backgroundOperationLock.writeLock().lock();\n            try {\n                revisionComparator.add(newRevision(), headSeen);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> e : externalChanges.entrySet()) {\n                    revisionComparator.add(e.getKey(), e.getValue());\n                }\n                setHeadRevision(newRevision());\n                if (dispatchChange) {\n                    dispatcher.contentChanged(getRoot(), null);\n                }\n            } finally {\n                backgroundOperationLock.writeLock().unlock();\n            }\n            stats.dispatchChanges = clock.getTime() - time;\n            time = clock.getTime();\n        }\n        revisionComparator.purge(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis());\n        stats.purge = clock.getTime() - time;\n        return stats;\n    }\n\n    private static class BackgroundReadStats {\n        org.apache.jackrabbit.oak.plugins.document.cache.CacheInvalidationStats cacheStats;\n\n        long readHead;\n\n        long cacheInvalidationTime;\n\n        long dispatchChanges;\n\n        long purge;\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            java.lang.String cacheStatsMsg = \"NOP\";\n            if (cacheStats != null) {\n                cacheStatsMsg = cacheStats.summaryReport();\n            }\n            return ((((((((((\"ReadStats{\" + \"cacheStats:\") + cacheStatsMsg) + \", head:\") + readHead) + \", cache:\") + cacheInvalidationTime) + \", dispatch:\") + dispatchChanges) + \", purge:\") + purge) + '}';\n        }\n    }\n\n    private static long revisionPurgeMillis() {\n        return org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS;\n    }\n\n    private void cleanOrphanedBranches() {\n        org.apache.jackrabbit.oak.plugins.document.Branch b;\n        while ((b = branches.pollOrphanedBranch()) != null) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Cleaning up orphaned branch with base revision: {}, \" + \"commits: {}\", b.getBase(), b.getCommits());\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n            for (org.apache.jackrabbit.oak.plugins.document.Revision r : b.getCommits()) {\n                r = r.asTrunkRevision();\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeRevision(op, r);\n            }\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, op);\n        } \n    }\n\n    private void cleanCollisions() {\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\");\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument root = store.find(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, id);\n        if (root == null) {\n            return;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision head = getHeadRevision();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = root.getLocalMap(NodeDocument.COLLISIONS);\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : map.keySet()) {\n            if (r.getClusterId() == clusterId) {\n                if ((branches.getBranchCommit(r) == null) && isRevisionNewer(head, r)) {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(op, r);\n                }\n            }\n        }\n        if (op.hasChanges()) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Removing collisions {}\", op.getChanges().keySet());\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, op);\n        }\n    }\n\n    private void backgroundSplit() {\n        for (java.util.Iterator<java.lang.String> it = splitCandidates.keySet().iterator(); it.hasNext();) {\n            java.lang.String id = it.next();\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n            if (doc == null) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : doc.split(this)) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument before = store.createOrUpdate(Collection.NODES, op);\n                if (before != null) {\n                    if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument after = store.find(Collection.NODES, op.getId());\n                        if (after != null) {\n                            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation on {}. Size before: {}, after: {}\", id, before.getMemory(), after.getMemory());\n                        }\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation created {}\", op.getId());\n                }\n            }\n            it.remove();\n        }\n    }\n\n    void backgroundWrite() {\n        unsavedLastRevisions.persist(this, backgroundOperationLock.writeLock());\n    }\n\n    private void checkOpen() throws java.lang.IllegalStateException {\n        if (isDisposed.get()) {\n            throw new java.lang.IllegalStateException(\"This DocumentNodeStore is disposed\");\n        }\n    }\n\n    private boolean dispatch(@javax.annotation.Nonnull\n    java.lang.String jsonDiff, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeStateDiff diff, boolean useReadRevision) {\n        if (jsonDiff.trim().isEmpty()) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision nodeRev = (useReadRevision) ? node.getRevision() : node.getLastRevision();\n        org.apache.jackrabbit.oak.plugins.document.Revision baseRev = (useReadRevision) ? base.getRevision() : base.getLastRevision();\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer t = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(jsonDiff);\n        boolean continueComparison = true;\n        while (continueComparison) {\n            int r = t.read();\n            if (r == org.apache.jackrabbit.oak.commons.json.JsopReader.END) {\n                break;\n            }\n            switch (r) {\n                case '+' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        t.read(':');\n                        t.read('{');\n                        while (t.read() != '}') {\n                        } \n                        org.apache.jackrabbit.oak.spi.state.NodeState child = getNode(concat(node.getPath(), name), nodeRev);\n                        continueComparison = diff.childNodeAdded(name, child);\n                        break;\n                    }\n                case '-' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        org.apache.jackrabbit.oak.spi.state.NodeState child = getNode(concat(base.getPath(), name), baseRev);\n                        continueComparison = diff.childNodeDeleted(name, child);\n                        break;\n                    }\n                case '^' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        t.read(':');\n                        if (t.matches('{')) {\n                            t.read('}');\n                            org.apache.jackrabbit.oak.spi.state.NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\n                            org.apache.jackrabbit.oak.spi.state.NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\n                            continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);\n                        } else if (t.matches('[')) {\n                            while (t.read() != ']') {\n                            } \n                        } else {\n                            t.read();\n                        }\n                        break;\n                    }\n                default :\n                    throw new java.lang.IllegalArgumentException(((((\"jsonDiff: illegal token '\" + t.getToken()) + \"' at pos: \") + t.getLastPos()) + ' ') + jsonDiff);\n            }\n        } \n        return continueComparison;\n    }\n\n    private boolean checkNodeNotExistsFromChildrenCache(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(path)) {\n            return false;\n        }\n        final java.lang.String parentPath = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(path);\n        org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(parentPath, rev, null);\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children children = nodeChildrenCache.getIfPresent(key);\n        java.lang.String lookupChildName = org.apache.jackrabbit.oak.commons.PathUtils.getName(path);\n        if (children == null) {\n            return false;\n        }\n        if (children.hasMore) {\n            return false;\n        }\n        int childPosition = java.util.Collections.binarySearch(children.children, lookupChildName);\n        if (childPosition < 0) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"Child node as per path {} does not exist at revision {}\", path, rev);\n            return true;\n        }\n        return false;\n    }\n\n    private static void diffProperties(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to, org.apache.jackrabbit.oak.commons.json.JsopWriter w) {\n        for (org.apache.jackrabbit.oak.api.PropertyState fromValue : from.getProperties()) {\n            java.lang.String name = fromValue.getName();\n            org.apache.jackrabbit.oak.api.PropertyState toValue = to.getProperty(name);\n            if (!fromValue.equals(toValue)) {\n                w.tag('^').key(concat(from.getPath(), name));\n                if (toValue == null) {\n                    w.value(null);\n                } else {\n                    w.encodedValue(to.getPropertyAsString(name)).newline();\n                }\n            }\n        }\n        for (java.lang.String name : to.getPropertyNames()) {\n            if (!from.hasProperty(name)) {\n                w.tag('^').key(concat(from.getPath(), name)).encodedValue(to.getPropertyAsString(name)).newline();\n            }\n        }\n    }\n\n    private java.lang.String diffImpl(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        int max = org.apache.jackrabbit.oak.plugins.document.DocumentMK.MANY_CHILDREN_THRESHOLD;\n        final boolean debug = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled();\n        final long start = (debug) ? org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now() : 0;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren;\n        fromChildren = getChildren(from, null, max);\n        toChildren = getChildren(to, null, max);\n        final long getChildrenDoneIn = (debug) ? org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now() : 0;\n        java.lang.String diffAlgo;\n        if ((!fromChildren.hasMore) && (!toChildren.hasMore)) {\n            diffAlgo = \"diffFewChildren\";\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        } else if (org.apache.jackrabbit.oak.plugins.document.DocumentMK.FAST_DIFF) {\n            diffAlgo = \"diffManyChildren\";\n            diffManyChildren(w, from.getPath(), from.getLastRevision(), to.getLastRevision());\n        } else {\n            diffAlgo = \"diffAllChildren\";\n            max = java.lang.Integer.MAX_VALUE;\n            fromChildren = getChildren(from, null, max);\n            toChildren = getChildren(to, null, max);\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        }\n        if (debug) {\n            long end = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now();\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Diff performed via '{}' at [{}] between revisions [{}] => [{}] took {} ms ({} ms)\", diffAlgo, from.getPath(), from.getLastRevision(), to.getLastRevision(), end - start, getChildrenDoneIn - start);\n        }\n        return w.toString();\n    }\n\n    private void diffManyChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        long minTimestamp = java.lang.Math.min(revisionComparator.getMinimumTimestamp(fromRev, inactiveClusterNodes), revisionComparator.getMinimumTimestamp(toRev, inactiveClusterNodes));\n        long minValue = org.apache.jackrabbit.oak.plugins.document.NodeDocument.getModifiedInSecs(minTimestamp);\n        java.lang.String fromKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        java.lang.String toKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(path);\n        java.util.Set<java.lang.String> paths = com.google.common.collect.Sets.newHashSet();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"diffManyChildren: path: {}, fromRev: {}, toRev: {}\", path, fromRev, toRev);\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED_IN_SECS, minValue, java.lang.Integer.MAX_VALUE)) {\n            paths.add(doc.getPath());\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"diffManyChildren: Affected paths: {}\", paths.size());\n        org.apache.jackrabbit.oak.plugins.document.Revision minRev = new org.apache.jackrabbit.oak.plugins.document.Revision(minTimestamp, 0, getClusterId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, getPendingModifications().getPaths(minRev));\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : new org.apache.jackrabbit.oak.plugins.document.Revision[]{ fromRev, toRev }) {\n            if (r.isBranch()) {\n                org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit c = getBranches().getBranchCommit(r);\n                if (c != null) {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, c.getModifiedPaths());\n                }\n            }\n        }\n        for (java.lang.String p : paths) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState fromNode = getNode(p, fromRev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState toNode = getNode(p, toRev);\n            java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"diffManyChildren: Changed Path {}\", path);\n            if (fromNode != null) {\n                if (toNode != null) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision a = fromNode.getLastRevision();\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = toNode.getLastRevision();\n                    if ((a == null) && (b == null)) {\n                    } else if (((a == null) || (b == null)) || (!a.equals(b))) {\n                        w.tag('^').key(name).object().endObject().newline();\n                    }\n                } else {\n                    w.tag('-').value(name).newline();\n                }\n            } else if (toNode != null) {\n                w.tag('+').key(name).object().endObject().newline();\n            } else {\n            }\n        }\n    }\n\n    private static void addPathsForDiff(java.lang.String path, java.util.Set<java.lang.String> paths, java.lang.Iterable<java.lang.String> modified) {\n        for (java.lang.String p : modified) {\n            if (org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(p)) {\n                continue;\n            }\n            java.lang.String parent = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(p);\n            if (path.equals(parent)) {\n                paths.add(p);\n            }\n        }\n    }\n\n    private void diffFewChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String parentPath, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        java.util.Set<java.lang.String> childrenSet = com.google.common.collect.Sets.newHashSet(toChildren.children);\n        for (java.lang.String n : fromChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('-').value(n).newline();\n            } else {\n                java.lang.String path = concat(parentPath, n);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n1 = getNode(path, fromRev);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n2 = getNode(path, toRev);\n                com.google.common.base.Preconditions.checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", path, fromRev);\n                com.google.common.base.Preconditions.checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", path, toRev);\n                if (!n1.getLastRevision().equals(n2.getLastRevision())) {\n                    w.tag('^').key(n).object().endObject().newline();\n                }\n            }\n        }\n        childrenSet = com.google.common.collect.Sets.newHashSet(fromChildren.children);\n        for (java.lang.String n : toChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('+').key(n).object().endObject().newline();\n            }\n        }\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.PathRev childNodeCacheKey(@javax.annotation.Nonnull\n    java.lang.String path, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    java.lang.String name) {\n        java.lang.String p = (name == null ? \"\" : name) + path;\n        return new org.apache.jackrabbit.oak.plugins.document.PathRev(p, readRevision);\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder asDocumentRootBuilder(org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) throws java.lang.IllegalArgumentException {\n        if (!(builder instanceof org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder)) {\n            throw new java.lang.IllegalArgumentException(\"builder must be a \" + org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder.class.getName());\n        }\n        return ((org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder) (builder));\n    }\n\n    private static long now() {\n        return java.lang.System.currentTimeMillis();\n    }\n\n    private void moveOrCopyNode(boolean move, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState newNode = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, targetPath, commit.getRevision());\n        source.copyTo(newNode);\n        commit.addNode(newNode);\n        if (move) {\n            markAsDeleted(source, commit, false);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(source, null, java.lang.Integer.MAX_VALUE)) {\n            java.lang.String childName = org.apache.jackrabbit.oak.commons.PathUtils.getName(child.getPath());\n            java.lang.String destChildPath = concat(targetPath, childName);\n            moveOrCopyNode(move, child, destChildPath, commit);\n        }\n    }\n\n    private void checkRevisionAge(org.apache.jackrabbit.oak.plugins.document.Revision r, java.lang.String path) {\n        if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n            if (\"/\".equals(path) && ((headRevision.getTimestamp() - r.getTimestamp()) > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.WARN_REVISION_AGE)) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug((((\"Requesting an old revision for path \" + path) + \", \") + ((headRevision.getTimestamp() - r.getTimestamp()) / 1000)) + \" seconds old\");\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector createBlobGarbageCollector(long blobGcMaxAgeInSecs, java.lang.String repositoryId) {\n        org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector blobGC = null;\n        if (blobStore instanceof org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) {\n            try {\n                blobGC = new org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector(new org.apache.jackrabbit.oak.plugins.document.DocumentBlobReferenceRetriever(this), ((org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) (blobStore)), executor, java.util.concurrent.TimeUnit.SECONDS.toMillis(blobGcMaxAgeInSecs), repositoryId);\n            } catch (java.io.IOException e) {\n                throw new java.lang.RuntimeException(\"Error occurred while initializing \" + \"the MarkSweepGarbageCollector\", e);\n            }\n        }\n        return blobGC;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean getMBean() {\n        return mbean;\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean createMBean() {\n        try {\n            return new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.MBeanImpl();\n        } catch (javax.management.NotCompliantMBeanException e) {\n            throw new java.lang.IllegalStateException(e);\n        }\n    }\n\n    private class MBeanImpl extends org.apache.jackrabbit.oak.commons.jmx.AnnotatedStandardMBean implements org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean {\n        private final java.lang.String ISO_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss.SSS zzz\";\n\n        private final java.util.TimeZone TZ_UTC = java.util.TimeZone.getTimeZone(\"UTC\");\n\n        protected MBeanImpl() throws javax.management.NotCompliantMBeanException {\n            super(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String getRevisionComparatorState() {\n            return revisionComparator.toString();\n        }\n\n        @java.lang.Override\n        public java.lang.String getHead() {\n            return headRevision.toString();\n        }\n\n        @java.lang.Override\n        public int getClusterId() {\n            return clusterId;\n        }\n\n        @java.lang.Override\n        public int getUnmergedBranchCount() {\n            return branches.size();\n        }\n\n        @java.lang.Override\n        public java.lang.String[] getInactiveClusterNodes() {\n            return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(inactiveClusterNodes.entrySet(), new com.google.common.base.Function<java.util.Map.Entry<java.lang.Integer, java.lang.Long>, java.lang.String>() {\n                @java.lang.Override\n                public java.lang.String apply(java.util.Map.Entry<java.lang.Integer, java.lang.Long> input) {\n                    return input.toString();\n                }\n            }), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String[] getLastKnownRevisions() {\n            return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(lastKnownRevision.entrySet(), new com.google.common.base.Function<java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision>, java.lang.String>() {\n                @java.lang.Override\n                public java.lang.String apply(java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> input) {\n                    return input.toString();\n                }\n            }), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String formatRevision(java.lang.String rev, boolean utc) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(rev);\n            final java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(ISO_FORMAT);\n            if (utc) {\n                sdf.setTimeZone(TZ_UTC);\n            }\n            return sdf.format(r.getTimestamp());\n        }\n    }\n\n    static abstract class NodeStoreTask implements java.lang.Runnable {\n        final java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore> ref;\n\n        private final java.util.concurrent.atomic.AtomicBoolean isDisposed;\n\n        private int delay;\n\n        NodeStoreTask(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            ref = new java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore>(nodeStore);\n            delay = nodeStore.getAsyncDelay();\n            this.isDisposed = isDisposed;\n        }\n\n        protected abstract void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore);\n\n        @java.lang.Override\n        public void run() {\n            while ((delay != 0) && (!isDisposed.get())) {\n                synchronized(isDisposed) {\n                    try {\n                        isDisposed.wait(delay);\n                    } catch (java.lang.InterruptedException e) {\n                    }\n                }\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore = ref.get();\n                if (nodeStore != null) {\n                    try {\n                        execute(nodeStore);\n                    } catch (java.lang.Throwable t) {\n                        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + t.toString(), t);\n                    }\n                    delay = nodeStore.getAsyncDelay();\n                } else {\n                    break;\n                }\n            } \n        }\n    }\n\n    static class BackgroundOperation extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundOperation(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            nodeStore.runBackgroundOperations();\n        }\n    }\n\n    static class BackgroundLeaseUpdate extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundLeaseUpdate(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            if (nodeStore.renewClusterIdLease()) {\n                nodeStore.updateClusterState();\n            }\n        }\n    }\n\n    public org.apache.jackrabbit.oak.spi.blob.BlobStore getBlobStore() {\n        return blobStore;\n    }\n\n    org.apache.jackrabbit.oak.json.BlobSerializer getBlobSerializer() {\n        return blobSerializer;\n    }\n\n    public java.util.Iterator<org.apache.jackrabbit.oak.api.Blob> getReferencedBlobsIterator() {\n        if (store instanceof org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) {\n            return new org.apache.jackrabbit.oak.plugins.document.mongo.MongoBlobReferenceIterator(this, ((org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) (store)));\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.BlobReferenceIterator(this);\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.DiffCache getDiffCache() {\n        return diffCache;\n    }\n\n    public org.apache.jackrabbit.oak.stats.Clock getClock() {\n        return clock;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.Checkpoints getCheckpoints() {\n        return checkpoints;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector getVersionGarbageCollector() {\n        return versionGarbageCollector;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent getLastRevRecoveryAgent() {\n        return lastRevRecoveryAgent;\n    }\n\n    public void setPersistentCache(org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache) {\n        this.persistentCache = persistentCache;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private void checkOpen() throws java.lang.IllegalStateException {\n    if (isDisposed.get()) {\n        throw new java.lang.IllegalStateException(\"This DocumentNodeStore is disposed\");\n    }\n}",
            "src_parent": "public final class DocumentNodeStore implements org.apache.jackrabbit.oak.plugins.document.RevisionContext , org.apache.jackrabbit.oak.spi.commit.Observable , org.apache.jackrabbit.oak.spi.state.NodeStore {\n    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.class);\n\n    private static final org.apache.jackrabbit.oak.util.PerfLogger PERFLOG = new org.apache.jackrabbit.oak.util.PerfLogger(org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.class.getName() + \".perf\"));\n\n    static final int NUM_CHILDREN_CACHE_LIMIT = java.lang.Integer.getInteger(\"oak.documentMK.childrenCacheLimit\", 16 * 1024);\n\n    private static final int WARN_REVISION_AGE = java.lang.Integer.getInteger(\"oak.documentMK.revisionAge\", 60 * 1000);\n\n    static final int REMEMBER_REVISION_ORDER_MILLIS = (60 * 60) * 1000;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState missing;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.CommitQueue commitQueue;\n\n    protected final org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue batchCommitQueue;\n\n    protected final org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher dispatcher;\n\n    protected int asyncDelay = 1000;\n\n    protected int maxBackOffMillis = asyncDelay * 2;\n\n    private final java.util.concurrent.atomic.AtomicBoolean isDisposed = new java.util.concurrent.atomic.AtomicBoolean();\n\n    private final org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo clusterNodeInfo;\n\n    private final int clusterId;\n\n    private final java.util.concurrent.ConcurrentMap<java.lang.Integer, java.lang.Long> inactiveClusterNodes = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, java.lang.Long>();\n\n    private final Revision.RevisionComparator revisionComparator;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnmergedBranches branches;\n\n    private final org.apache.jackrabbit.oak.plugins.document.UnsavedModifications unsavedLastRevisions = new org.apache.jackrabbit.oak.plugins.document.UnsavedModifications();\n\n    private final java.util.Map<java.lang.String, java.lang.String> splitCandidates = com.google.common.collect.Maps.newConcurrentMap();\n\n    private final java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastKnownRevision = new java.util.concurrent.ConcurrentHashMap<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision>();\n\n    private volatile org.apache.jackrabbit.oak.plugins.document.Revision headRevision;\n\n    private java.lang.Thread backgroundThread;\n\n    private java.lang.Thread leaseUpdateThread;\n\n    private final java.util.concurrent.locks.ReadWriteLock backgroundOperationLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private final java.util.concurrent.locks.ReadWriteLock mergeLock = new java.util.concurrent.locks.ReentrantReadWriteLock();\n\n    private java.util.concurrent.atomic.AtomicInteger simpleRevisionCounter;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> nodeCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.PathRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children> nodeChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats nodeChildrenCacheStats;\n\n    private final com.google.common.cache.Cache<org.apache.jackrabbit.oak.plugins.document.util.StringValue, org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children> docChildrenCache;\n\n    private final org.apache.jackrabbit.oak.cache.CacheStats docChildrenCacheStats;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DiffCache diffCache;\n\n    private final org.apache.jackrabbit.oak.spi.blob.BlobStore blobStore;\n\n    private final org.apache.jackrabbit.oak.json.BlobSerializer blobSerializer = new org.apache.jackrabbit.oak.json.BlobSerializer() {\n        @java.lang.Override\n        public java.lang.String serialize(org.apache.jackrabbit.oak.api.Blob blob) {\n            if (blob instanceof org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) {\n                return ((org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob) (blob)).getBlobId();\n            }\n            java.lang.String id;\n            java.lang.String reference = blob.getReference();\n            if (reference != null) {\n                id = blobStore.getBlobId(reference);\n                if (id != null) {\n                    return id;\n                }\n            }\n            try {\n                id = createBlob(blob.getNewStream()).getBlobId();\n            } catch (java.io.IOException e) {\n                throw new java.lang.IllegalStateException(e);\n            }\n            return id;\n        }\n    };\n\n    private final org.apache.jackrabbit.oak.stats.Clock clock;\n\n    private final org.apache.jackrabbit.oak.plugins.document.Checkpoints checkpoints;\n\n    private final org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector versionGarbageCollector;\n\n    private final java.util.concurrent.Executor executor;\n\n    private final org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent lastRevRecoveryAgent;\n\n    private final boolean disableBranches;\n\n    private org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache;\n\n    private final org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean mbean;\n\n    public DocumentNodeStore(org.apache.jackrabbit.oak.plugins.document.DocumentMK.Builder builder) {\n        this.blobStore = builder.getBlobStore();\n        if (builder.isUseSimpleRevision()) {\n            this.simpleRevisionCounter = new java.util.concurrent.atomic.AtomicInteger(0);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentStore s = builder.getDocumentStore();\n        if (builder.getTiming()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.TimingDocumentStoreWrapper(s);\n        }\n        if (builder.getLogging()) {\n            s = new org.apache.jackrabbit.oak.plugins.document.util.LoggingDocumentStoreWrapper(s);\n        }\n        this.store = s;\n        this.executor = builder.getExecutor();\n        this.clock = builder.getClock();\n        int cid = builder.getClusterId();\n        cid = java.lang.Integer.getInteger(\"oak.documentMK.clusterId\", cid);\n        if (cid == 0) {\n            clusterNodeInfo = org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo.getInstance(store);\n            cid = clusterNodeInfo.getId();\n        } else {\n            clusterNodeInfo = null;\n        }\n        this.clusterId = cid;\n        this.revisionComparator = new org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator(clusterId);\n        this.branches = new org.apache.jackrabbit.oak.plugins.document.UnmergedBranches(getRevisionComparator());\n        this.asyncDelay = builder.getAsyncDelay();\n        this.versionGarbageCollector = new org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector(this, builder.createVersionGCSupport());\n        this.lastRevRecoveryAgent = new org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent(this);\n        this.disableBranches = builder.isDisableBranches();\n        this.missing = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"MISSING\", new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, 0)) {\n            @java.lang.Override\n            public int getMemory() {\n                return 8;\n            }\n        };\n        nodeCache = builder.buildNodeCache(this);\n        nodeCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeCache, \"Document-NodeState\", builder.getWeigher(), builder.getNodeCacheSize());\n        nodeChildrenCache = builder.buildChildrenCache();\n        nodeChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(nodeChildrenCache, \"Document-NodeChildren\", builder.getWeigher(), builder.getChildrenCacheSize());\n        docChildrenCache = builder.buildDocChildrenCache();\n        docChildrenCacheStats = new org.apache.jackrabbit.oak.cache.CacheStats(docChildrenCache, \"Document-DocChildren\", builder.getWeigher(), builder.getDocChildrenCacheSize());\n        diffCache = builder.getDiffCache();\n        checkpoints = new org.apache.jackrabbit.oak.plugins.document.Checkpoints(this);\n        if (store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\")) == null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision();\n            org.apache.jackrabbit.oak.plugins.document.Commit commit = new org.apache.jackrabbit.oak.plugins.document.Commit(this, head, null, null);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, \"/\", head);\n            commit.addNode(n);\n            commit.applyToDocumentStore();\n            commit.applyToCache(new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId), false);\n            setHeadRevision(commit.getRevision());\n            backgroundWrite();\n        } else {\n            branches.init(store, this);\n            backgroundRead(false);\n            if (headRevision == null) {\n                setHeadRevision(newRevision());\n            }\n        }\n        getRevisionComparator().add(headRevision, org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0));\n        dispatcher = new org.apache.jackrabbit.oak.spi.commit.ChangeDispatcher(getRoot());\n        commitQueue = new org.apache.jackrabbit.oak.plugins.document.CommitQueue(this, dispatcher);\n        batchCommitQueue = new org.apache.jackrabbit.oak.plugins.document.BatchCommitQueue(store, revisionComparator);\n        backgroundThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundOperation(this, isDisposed), \"DocumentNodeStore background thread\");\n        backgroundThread.setDaemon(true);\n        checkLastRevRecovery();\n        renewClusterIdLease();\n        backgroundThread.start();\n        if (clusterNodeInfo != null) {\n            leaseUpdateThread = new java.lang.Thread(new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundLeaseUpdate(this, isDisposed), \"DocumentNodeStore lease update thread\");\n            leaseUpdateThread.setDaemon(true);\n            leaseUpdateThread.start();\n        }\n        this.mbean = createMBean();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Initialized DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    }\n\n    private void checkLastRevRecovery() {\n        lastRevRecoveryAgent.recover(clusterId);\n    }\n\n    public void dispose() {\n        if (isDisposed.getAndSet(true)) {\n            return;\n        }\n        synchronized(isDisposed) {\n            isDisposed.notifyAll();\n        }\n        try {\n            backgroundThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n        internalRunBackgroundOperations();\n        if (leaseUpdateThread != null) {\n            try {\n                leaseUpdateThread.join();\n            } catch (java.lang.InterruptedException e) {\n            }\n        }\n        if (clusterNodeInfo != null) {\n            clusterNodeInfo.dispose();\n        }\n        store.dispose();\n        if (blobStore instanceof java.io.Closeable) {\n            try {\n                ((java.io.Closeable) (blobStore)).close();\n            } catch (java.io.IOException ex) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n            }\n        }\n        if (persistentCache != null) {\n            persistentCache.close();\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.Revision setHeadRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newHead) {\n        com.google.common.base.Preconditions.checkArgument(!newHead.isBranch());\n        org.apache.jackrabbit.oak.plugins.document.Revision previous = headRevision;\n        if (!com.google.common.base.Preconditions.checkNotNull(newHead).equals(previous)) {\n            headRevision = newHead;\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentStore getDocumentStore() {\n        return store;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision newRevision() {\n        if (simpleRevisionCounter != null) {\n            return new org.apache.jackrabbit.oak.plugins.document.Revision(simpleRevisionCounter.getAndIncrement(), 0, clusterId);\n        }\n        return org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(clusterId);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit newCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        checkOpen();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.Commit(this, commitQueue.createRevision(), base, branch);\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.MergeCommit newMergeCommit(@javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision base, int numBranchCommits) {\n        if (base == null) {\n            base = headRevision;\n        }\n        backgroundOperationLock.readLock().lock();\n        checkOpen();\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit c;\n        try {\n            c = new org.apache.jackrabbit.oak.plugins.document.MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));\n            success = true;\n        } finally {\n            if (!success) {\n                backgroundOperationLock.readLock().unlock();\n            }\n        }\n        return c;\n    }\n\n    void done(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Commit c, boolean isBranch, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) {\n        try {\n            commitQueue.done(c, isBranch, info);\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    void canceled(org.apache.jackrabbit.oak.plugins.document.Commit c) {\n        try {\n            commitQueue.canceled(c.getRevision());\n        } finally {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n\n    public void setAsyncDelay(int delay) {\n        this.asyncDelay = delay;\n    }\n\n    public int getAsyncDelay() {\n        return asyncDelay;\n    }\n\n    public void setMaxBackOffMillis(int time) {\n        maxBackOffMillis = time;\n    }\n\n    public int getMaxBackOffMillis() {\n        return maxBackOffMillis;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfo getClusterInfo() {\n        return clusterNodeInfo;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeCacheStats() {\n        return nodeCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getNodeChildrenCacheStats() {\n        return nodeChildrenCacheStats;\n    }\n\n    public org.apache.jackrabbit.oak.cache.CacheStats getDocChildrenCacheStats() {\n        return docChildrenCacheStats;\n    }\n\n    void invalidateDocChildrenCache() {\n        docChildrenCache.invalidateAll();\n    }\n\n    void invalidateNodeChildrenCache() {\n        nodeChildrenCache.invalidateAll();\n    }\n\n    void invalidateNodeCache(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        nodeCache.invalidate(new org.apache.jackrabbit.oak.plugins.document.PathRev(path, revision));\n    }\n\n    public int getPendingWriteCount() {\n        return unsavedLastRevisions.getPaths().size();\n    }\n\n    public boolean isDisableBranches() {\n        return disableBranches;\n    }\n\n    boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    void addSplitCandidate(java.lang.String id) {\n        splitCandidates.put(id, id);\n    }\n\n    void copyNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(false, source, targetPath, commit);\n    }\n\n    void moveNode(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        moveOrCopyNode(true, source, targetPath, commit);\n    }\n\n    void markAsDeleted(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, org.apache.jackrabbit.oak.plugins.document.Commit commit, boolean subTreeAlso) {\n        commit.removeNode(node.getPath());\n        if (subTreeAlso) {\n            for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(node, null, java.lang.Integer.MAX_VALUE)) {\n                markAsDeleted(child, commit, true);\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNode(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        checkRevisionAge(com.google.common.base.Preconditions.checkNotNull(rev), com.google.common.base.Preconditions.checkNotNull(path));\n        final long start = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.start();\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = new org.apache.jackrabbit.oak.plugins.document.PathRev(path, rev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node = nodeCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState call() throws java.lang.Exception {\n                    boolean nodeDoesNotExist = checkNodeNotExistsFromChildrenCache(path, rev);\n                    if (nodeDoesNotExist) {\n                        return missing;\n                    }\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = readNode(path, rev);\n                    if (n == null) {\n                        n = missing;\n                    }\n                    return n;\n                }\n            });\n            final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = ((node == missing) || node.equals(missing)) ? null : node;\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"getNode: path={}, rev={}\", path, rev);\n            return result;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause());\n        }\n    }\n\n    DocumentNodeState.Children getChildren(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return DocumentNodeState.NO_CHILDREN;\n        }\n        final java.lang.String path = com.google.common.base.Preconditions.checkNotNull(parent).getPath();\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        try {\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, readRevision, name);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children children = nodeChildrenCache.get(key, new java.util.concurrent.Callable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children>() {\n                @java.lang.Override\n                public DocumentNodeState.Children call() throws java.lang.Exception {\n                    return readChildren(parent, name, limit);\n                }\n            });\n            if ((children.children.size() < limit) && children.hasMore) {\n                children = readChildren(parent, name, limit);\n                nodeChildrenCache.put(key, children);\n            }\n            return children;\n        } catch (com.google.common.util.concurrent.UncheckedExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        } catch (java.util.concurrent.ExecutionException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e.getCause(), \"Error occurred while fetching children for path \" + path);\n        }\n    }\n\n    DocumentNodeState.Children readChildren(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, java.lang.String name, int limit) {\n        java.lang.String queriedName = name;\n        java.lang.String path = parent.getPath();\n        org.apache.jackrabbit.oak.plugins.document.Revision rev = parent.getLastRevision();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"Reading children for [{}] ast rev [{}]\", path, rev);\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n        int rawLimit = ((int) (java.lang.Math.min(java.lang.Integer.MAX_VALUE, ((long) (limit)) + 1)));\n        for (; ;) {\n            docs = readChildDocs(path, name, rawLimit);\n            int numReturned = 0;\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                numReturned++;\n                java.lang.String p = doc.getPath();\n                name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child = getNode(p, rev);\n                if (child == null) {\n                    continue;\n                }\n                if (c.children.size() < limit) {\n                    c.children.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n                } else {\n                    c.hasMore = true;\n                    return c;\n                }\n            }\n            if (numReturned < rawLimit) {\n                c.hasMore = false;\n                if (queriedName == null) {\n                    java.util.Collections.sort(c.children);\n                }\n                return c;\n            }\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> readChildDocs(@javax.annotation.Nonnull\n    final java.lang.String path, @javax.annotation.Nullable\n    java.lang.String name, int limit) {\n        java.lang.String to = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(com.google.common.base.Preconditions.checkNotNull(path));\n        java.lang.String from;\n        if (name != null) {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(concat(path, name));\n        } else {\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        }\n        if ((name != null) || (limit > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NUM_CHILDREN_CACHE_LIMIT)) {\n            return store.query(Collection.NODES, from, to, limit);\n        }\n        org.apache.jackrabbit.oak.plugins.document.util.StringValue key = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children c = docChildrenCache.getIfPresent(key);\n        if (c == null) {\n            c = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, limit);\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                c.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            c.isComplete = docs.size() < limit;\n            docChildrenCache.put(key, c);\n            return docs;\n        } else if ((c.childNames.size() < limit) && (!c.isComplete)) {\n            java.lang.String lastName = c.childNames.get(c.childNames.size() - 1);\n            java.lang.String lastPath = concat(path, lastName);\n            from = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(lastPath);\n            int remainingLimit = limit - c.childNames.size();\n            java.util.List<org.apache.jackrabbit.oak.plugins.document.NodeDocument> docs = store.query(Collection.NODES, from, to, remainingLimit);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = c.clone();\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : docs) {\n                java.lang.String p = doc.getPath();\n                clone.childNames.add(org.apache.jackrabbit.oak.commons.PathUtils.getName(p));\n            }\n            clone.isComplete = docs.size() < remainingLimit;\n            docChildrenCache.put(key, clone);\n            c = clone;\n        }\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> it = com.google.common.collect.Iterables.transform(c.childNames, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.lang.String name) {\n                java.lang.String p = concat(path, name);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(p));\n                if (doc == null) {\n                    docChildrenCache.invalidateAll();\n                    throw new java.lang.NullPointerException((\"Document \" + p) + \" not found\");\n                }\n                return doc;\n            }\n        });\n        if (c.childNames.size() > (limit * 2)) {\n            it = com.google.common.collect.Iterables.limit(it, limit * 2);\n        }\n        return it;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.DocumentNodeState> getChildNodes(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState parent, @javax.annotation.Nullable\n    final java.lang.String name, final int limit) {\n        if (com.google.common.base.Preconditions.checkNotNull(parent).hasNoChildren()) {\n            return java.util.Collections.emptyList();\n        }\n        final org.apache.jackrabbit.oak.plugins.document.Revision readRevision = parent.getLastRevision();\n        return com.google.common.collect.Iterables.transform(getChildren(parent, name, limit).children, new com.google.common.base.Function<java.lang.String, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState>() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState apply(java.lang.String input) {\n                java.lang.String p = concat(parent.getPath(), input);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = getNode(p, readRevision);\n                if (result == null) {\n                    throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((((\"DocumentNodeState is null for revision \" + readRevision) + \" of \") + p) + \" (aborting getChildNodes())\");\n                }\n                return result;\n            }\n        });\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState readNode(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        final long start = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.start();\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(path);\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = getPendingModifications().get(path);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n        if (doc == null) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"readNode: (document not found) path={}, readRevision={}\", path, readRevision);\n            return null;\n        }\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState result = doc.getNodeAtRevision(this, readRevision, lastRevision);\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.PERFLOG.end(start, 1, \"readNode: path={}, readRevision={}\", path, readRevision);\n        return result;\n    }\n\n    public void applyChanges(org.apache.jackrabbit.oak.plugins.document.Revision rev, java.lang.String path, boolean isNew, java.util.List<java.lang.String> added, java.util.List<java.lang.String> removed, java.util.List<java.lang.String> changed, org.apache.jackrabbit.oak.plugins.document.DiffCache.Entry cacheEntry) {\n        if (isNew && (!added.isEmpty())) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children c = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children();\n            java.util.Set<java.lang.String> set = com.google.common.collect.Sets.newTreeSet();\n            for (java.lang.String p : added) {\n                set.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)));\n            }\n            c.children.addAll(set);\n            org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(path, rev, null);\n            nodeChildrenCache.put(key, c);\n        }\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        for (java.lang.String p : added) {\n            w.tag('+').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        for (java.lang.String p : removed) {\n            w.tag('-').value(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).newline();\n        }\n        for (java.lang.String p : changed) {\n            w.tag('^').key(org.apache.jackrabbit.oak.commons.PathUtils.getName(p)).object().endObject().newline();\n        }\n        cacheEntry.append(path, w.toString());\n        if (!added.isEmpty()) {\n            org.apache.jackrabbit.oak.plugins.document.util.StringValue docChildrenKey = new org.apache.jackrabbit.oak.plugins.document.util.StringValue(path);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children docChildren = docChildrenCache.getIfPresent(docChildrenKey);\n            if (docChildren != null) {\n                int currentSize = docChildren.childNames.size();\n                java.util.NavigableSet<java.lang.String> names = com.google.common.collect.Sets.newTreeSet(docChildren.childNames);\n                if (!docChildren.isComplete) {\n                    for (java.lang.String childPath : added) {\n                        java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath);\n                        if (names.higher(name) != null) {\n                            names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(name));\n                        }\n                    }\n                } else {\n                    for (java.lang.String childPath : added) {\n                        names.add(org.apache.jackrabbit.oak.plugins.document.util.Utils.unshareString(org.apache.jackrabbit.oak.commons.PathUtils.getName(childPath)));\n                    }\n                }\n                if (names.size() != currentSize) {\n                    boolean complete = docChildren.isComplete;\n                    docChildren = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n                    docChildren.isComplete = complete;\n                    docChildren.childNames.addAll(names);\n                    docChildrenCache.put(docChildrenKey, docChildren);\n                }\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument updateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        boolean batch = true;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> op : commit.getChanges().entrySet()) {\n            java.lang.String name = op.getKey().getName();\n            if ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionsEntry(name) || NodeDocument.MODIFIED_IN_SECS.equals(name)) || NodeDocument.COLLISIONS.equals(name)) {\n                continue;\n            }\n            batch = false;\n            break;\n        }\n        if (batch) {\n            return batchUpdateCommitRoot(commit);\n        } else {\n            return store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, commit);\n        }\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument batchUpdateCommitRoot(org.apache.jackrabbit.oak.plugins.document.UpdateOp commit) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        try {\n            return batchCommitQueue.updateDocument(commit).call();\n        } catch (java.lang.InterruptedException e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Interrupted while updating commit root document\");\n        } catch (java.lang.Exception e) {\n            throw org.apache.jackrabbit.oak.plugins.document.DocumentStoreException.convert(e, \"Update of commit root document failed\");\n        }\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState root = getNode(\"/\", revision);\n        if (root == null) {\n            throw new java.lang.IllegalStateException(\"root node does not exist at revision \" + revision);\n        }\n        return root;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch createBranch(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch b = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch.getCurrentBranch();\n        if (b != null) {\n            return b;\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch(this, base, mergeLock);\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision base) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(base);\n        if (disableBranches) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            return base.asBranchRevision();\n        }\n        if (b.getBase(branchHead).equals(base)) {\n            return branchHead;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision head = newRevision().asBranchRevision();\n        b.rebase(head, base);\n        return head;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision ancestor, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreBranch branch) {\n        com.google.common.base.Preconditions.checkNotNull(branchHead);\n        com.google.common.base.Preconditions.checkNotNull(ancestor);\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        if (b == null) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(\"Empty branch cannot be reset\");\n        }\n        if (!b.getCommits().last().equals(branchHead)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException((branchHead + \" is not the head \") + \"of a branch\");\n        }\n        if (!b.containsCommit(ancestor)) {\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(((ancestor + \" is not \") + \"an ancestor revision of \") + branchHead);\n        }\n        if (branchHead.equals(ancestor)) {\n            return branchHead;\n        }\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.Commit commit = newCommit(branchHead, branch);\n        try {\n            java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> it = b.getCommits().tailSet(ancestor).iterator();\n            org.apache.jackrabbit.oak.plugins.document.Revision base = it.next();\n            java.util.Map<java.lang.String, org.apache.jackrabbit.oak.plugins.document.UpdateOp> operations = com.google.common.collect.Maps.newHashMap();\n            while (it.hasNext()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision reset = it.next();\n                getRoot(reset).compareAgainstBaseState(getRoot(base), new org.apache.jackrabbit.oak.plugins.document.ResetDiff(reset.asTrunkRevision(), operations));\n                org.apache.jackrabbit.oak.plugins.document.UpdateOp rootOp = operations.get(\"/\");\n                if (rootOp == null) {\n                    rootOp = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(rootOp, commit.getRevision());\n                    operations.put(\"/\", rootOp);\n                }\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n            } \n            if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n                java.util.List<org.apache.jackrabbit.oak.plugins.document.Revision> revs = com.google.common.collect.Lists.newArrayList(b.getCommits().tailSet(ancestor));\n                for (org.apache.jackrabbit.oak.plugins.document.Revision r : revs.subList(1, revs.size())) {\n                    b.removeCommit(r);\n                }\n                success = true;\n            }\n            operations.remove(\"/\");\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : operations.values()) {\n                store.findAndUpdate(Collection.NODES, op);\n            }\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, true, null);\n            }\n        }\n        return ancestor;\n    }\n\n    @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision branchHead, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = getBranches().getBranch(branchHead);\n        org.apache.jackrabbit.oak.plugins.document.Revision base = branchHead;\n        if (b != null) {\n            base = b.getBase(branchHead);\n        }\n        int numBranchCommits = (b != null) ? b.getCommits().size() : 1;\n        boolean success = false;\n        org.apache.jackrabbit.oak.plugins.document.MergeCommit commit = newMergeCommit(base, numBranchCommits);\n        try {\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setModified(op, commit.getRevision());\n            if (b != null) {\n                java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> mergeCommits = commit.getMergeRevisions().iterator();\n                for (org.apache.jackrabbit.oak.plugins.document.Revision rev : b.getCommits()) {\n                    rev = rev.asTrunkRevision();\n                    java.lang.String commitTag = \"c-\" + mergeCommits.next();\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.setRevision(op, rev, commitTag);\n                    op.containsMapEntry(NodeDocument.COLLISIONS, rev, false);\n                }\n                if (store.findAndUpdate(Collection.NODES, op) != null) {\n                    b.applyTo(getPendingModifications(), commit.getRevision());\n                    getBranches().remove(b);\n                } else {\n                    throw new org.apache.jackrabbit.oak.api.CommitFailedException(MERGE, 2, \"Conflicting concurrent change. Update operation failed: \" + op);\n                }\n            } else {\n            }\n            success = true;\n        } finally {\n            if (!success) {\n                canceled(commit);\n            } else {\n                done(commit, false, info);\n            }\n        }\n        return commit.getRevision();\n    }\n\n    boolean compare(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base, @javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.spi.state.NodeStateDiff diff) {\n        if (!org.apache.jackrabbit.oak.spi.state.AbstractNodeState.comparePropertiesAgainstBaseState(node, base, diff)) {\n            return false;\n        }\n        if (node.hasNoChildren() && base.hasNoChildren()) {\n            return true;\n        }\n        boolean useReadRevision = true;\n        java.lang.String jsop = diffCache.getChanges(base.getRevision(), node.getRevision(), node.getPath(), null);\n        if (jsop == null) {\n            useReadRevision = false;\n            jsop = diffCache.getChanges(base.getLastRevision(), node.getLastRevision(), node.getPath(), new org.apache.jackrabbit.oak.plugins.document.DiffCache.Loader() {\n                @java.lang.Override\n                public java.lang.String call() {\n                    return diffImpl(base, node);\n                }\n            });\n        }\n        return dispatch(jsop, node, base, diff, useReadRevision);\n    }\n\n    java.lang.String diff(@javax.annotation.Nonnull\n    final java.lang.String fromRevisionId, @javax.annotation.Nonnull\n    final java.lang.String toRevisionId, @javax.annotation.Nonnull\n    final java.lang.String path) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        if (fromRevisionId.equals(toRevisionId)) {\n            return \"\";\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision fromRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(fromRevisionId);\n        org.apache.jackrabbit.oak.plugins.document.Revision toRev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(toRevisionId);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from = getNode(path, fromRev);\n        final org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to = getNode(path, toRev);\n        if ((from == null) || (to == null)) {\n            java.lang.String msg = java.lang.String.format(\"Diff is only supported if the node exists in both cases. \" + \"Node [%s], fromRev [%s] -> %s, toRev [%s] -> %s\", path, fromRev, from != null, toRev, to != null);\n            throw new org.apache.jackrabbit.oak.plugins.document.DocumentStoreException(msg);\n        }\n        java.lang.String compactDiff = diffCache.getChanges(fromRev, toRev, path, new org.apache.jackrabbit.oak.plugins.document.DiffCache.Loader() {\n            @java.lang.Override\n            public java.lang.String call() {\n                return diffImpl(from, to);\n            }\n        });\n        org.apache.jackrabbit.oak.commons.json.JsopWriter writer = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.diffProperties(from, to, writer);\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer t = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(compactDiff);\n        int r;\n        do {\n            r = t.read();\n            switch (r) {\n                case '+' :\n                case '^' :\n                    {\n                        java.lang.String name = t.readString();\n                        t.read(':');\n                        t.read('{');\n                        t.read('}');\n                        writer.tag(((char) (r))).key(concat(path, name));\n                        writer.object().endObject().newline();\n                        break;\n                    }\n                case '-' :\n                    {\n                        java.lang.String name = t.readString();\n                        writer.tag('-').value(concat(path, name));\n                        writer.newline();\n                    }\n            }\n        } while (r != org.apache.jackrabbit.oak.commons.json.JsopReader.END );\n        return writer.toString();\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.LastRevTracker createTracker(@javax.annotation.Nonnull\n    final org.apache.jackrabbit.oak.plugins.document.Revision r, final boolean isBranchCommit) {\n        if (isBranchCommit && (!disableBranches)) {\n            org.apache.jackrabbit.oak.plugins.document.Revision branchRev = r.asBranchRevision();\n            return branches.getBranchCommit(branchRev);\n        } else {\n            return new org.apache.jackrabbit.oak.plugins.document.LastRevTracker() {\n                @java.lang.Override\n                public void track(java.lang.String path) {\n                    unsavedLastRevisions.put(path, r);\n                }\n            };\n        }\n    }\n\n    @java.lang.Override\n    public java.io.Closeable addObserver(org.apache.jackrabbit.oak.spi.commit.Observer observer) {\n        return dispatcher.addObserver(observer);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getRoot() {\n        return getRoot(headRevision);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState merge(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitHook commitHook, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).merge(commitHook, info);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState rebase(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).rebase();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState reset(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) {\n        return org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.asDocumentRootBuilder(builder).reset();\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob createBlob(java.io.InputStream inputStream) throws java.io.IOException {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobStore.writeBlob(inputStream));\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.api.Blob getBlob(java.lang.String reference) {\n        java.lang.String blobId = blobStore.getBlobId(reference);\n        if (blobId != null) {\n            return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"No blobId found matching reference [{}]\", reference);\n        return null;\n    }\n\n    public org.apache.jackrabbit.oak.api.Blob getBlobFromBlobId(java.lang.String blobId) {\n        return new org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob(blobStore, blobId);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime, @javax.annotation.Nonnull\n    java.util.Map<java.lang.String, java.lang.String> properties) {\n        return checkpoints.create(lifetime, properties).toString();\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.lang.String checkpoint(long lifetime) {\n        java.util.Map<java.lang.String, java.lang.String> empty = java.util.Collections.emptyMap();\n        return checkpoint(lifetime, empty);\n    }\n\n    @javax.annotation.Nonnull\n    @java.lang.Override\n    public java.util.Map<java.lang.String, java.lang.String> checkpointInfo(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info info = checkpoints.getCheckpoints().get(r);\n        if (info == null) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return info.get();\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.spi.state.NodeState retrieve(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(checkpoint);\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Checkpoints.Info> checkpoints = this.checkpoints.getCheckpoints();\n        if ((checkpoints != null) && checkpoints.containsKey(r)) {\n            return getRoot(r);\n        } else {\n            return null;\n        }\n    }\n\n    @java.lang.Override\n    public boolean release(@javax.annotation.Nonnull\n    java.lang.String checkpoint) {\n        checkpoints.release(checkpoint);\n        return true;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnmergedBranches getBranches() {\n        return branches;\n    }\n\n    @java.lang.Override\n    public org.apache.jackrabbit.oak.plugins.document.UnsavedModifications getPendingModifications() {\n        return unsavedLastRevisions;\n    }\n\n    @java.lang.Override\n    public Revision.RevisionComparator getRevisionComparator() {\n        return revisionComparator;\n    }\n\n    @java.lang.Override\n    public int getClusterId() {\n        return clusterId;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getHeadRevision() {\n        return headRevision;\n    }\n\n    public void runBackgroundOperations() {\n        if (isDisposed.get()) {\n            return;\n        }\n        try {\n            internalRunBackgroundOperations();\n        } catch (java.lang.RuntimeException e) {\n            if (isDisposed.get()) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + e.toString(), e);\n                return;\n            }\n            throw e;\n        }\n    }\n\n    private synchronized void internalRunBackgroundOperations() {\n        long start = clock.getTime();\n        long time = start;\n        cleanOrphanedBranches();\n        cleanCollisions();\n        long cleanTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundSplit();\n        long splitTime = clock.getTime() - time;\n        time = clock.getTime();\n        backgroundWrite();\n        long writeTime = clock.getTime() - time;\n        time = clock.getTime();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n        long readTime = clock.getTime() - time;\n        java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n        if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n        }\n    }\n\n    boolean renewClusterIdLease() {\n        return (clusterNodeInfo != null) && clusterNodeInfo.renewLease();\n    }\n\n    void updateClusterState() {\n        long now = clock.getTime();\n        java.util.Set<java.lang.Integer> inactive = com.google.common.collect.Sets.newHashSet();\n        for (org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument doc : org.apache.jackrabbit.oak.plugins.document.ClusterNodeInfoDocument.all(store)) {\n            int cId = doc.getClusterId();\n            if ((cId != this.clusterId) && (!doc.isActive())) {\n                inactive.add(cId);\n            }\n        }\n        inactiveClusterNodes.keySet().retainAll(inactive);\n        for (java.lang.Integer clusterId : inactive) {\n            inactiveClusterNodes.putIfAbsent(clusterId, now);\n        }\n    }\n\n    java.util.Map<java.lang.Integer, java.lang.Long> getInactiveClusterNodes() {\n        return new java.util.HashMap<java.lang.Integer, java.lang.Long>(inactiveClusterNodes);\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats backgroundRead(boolean dispatchChange) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats stats = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats();\n        long time = clock.getTime();\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\");\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id, asyncDelay);\n        if (doc == null) {\n            return stats;\n        }\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevMap = doc.getLastRev();\n        org.apache.jackrabbit.oak.plugins.document.Revision.RevisionComparator revisionComparator = getRevisionComparator();\n        org.apache.jackrabbit.oak.plugins.document.Revision headSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        org.apache.jackrabbit.oak.plugins.document.Revision otherSeen = org.apache.jackrabbit.oak.plugins.document.Revision.newRevision(0);\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> externalChanges = com.google.common.collect.Maps.newHashMap();\n        for (java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> e : lastRevMap.entrySet()) {\n            int machineId = e.getKey();\n            if (machineId == clusterId) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.Revision r = e.getValue();\n            org.apache.jackrabbit.oak.plugins.document.Revision last = lastKnownRevision.get(machineId);\n            if ((last == null) || (r.compareRevisionTime(last) > 0)) {\n                lastKnownRevision.put(machineId, r);\n                if ((last != null) || (r.getTimestamp() > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis())) {\n                    externalChanges.put(r, otherSeen);\n                }\n            }\n        }\n        stats.readHead = clock.getTime() - time;\n        time = clock.getTime();\n        if (!externalChanges.isEmpty()) {\n            stats.cacheStats = store.invalidateCache();\n            stats.cacheInvalidationTime = clock.getTime() - time;\n            time = clock.getTime();\n            docChildrenCache.invalidateAll();\n            backgroundOperationLock.writeLock().lock();\n            try {\n                revisionComparator.add(newRevision(), headSeen);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> e : externalChanges.entrySet()) {\n                    revisionComparator.add(e.getKey(), e.getValue());\n                }\n                setHeadRevision(newRevision());\n                if (dispatchChange) {\n                    dispatcher.contentChanged(getRoot(), null);\n                }\n            } finally {\n                backgroundOperationLock.writeLock().unlock();\n            }\n            stats.dispatchChanges = clock.getTime() - time;\n            time = clock.getTime();\n        }\n        revisionComparator.purge(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.revisionPurgeMillis());\n        stats.purge = clock.getTime() - time;\n        return stats;\n    }\n\n    private static class BackgroundReadStats {\n        org.apache.jackrabbit.oak.plugins.document.cache.CacheInvalidationStats cacheStats;\n\n        long readHead;\n\n        long cacheInvalidationTime;\n\n        long dispatchChanges;\n\n        long purge;\n\n        @java.lang.Override\n        public java.lang.String toString() {\n            java.lang.String cacheStatsMsg = \"NOP\";\n            if (cacheStats != null) {\n                cacheStatsMsg = cacheStats.summaryReport();\n            }\n            return ((((((((((\"ReadStats{\" + \"cacheStats:\") + cacheStatsMsg) + \", head:\") + readHead) + \", cache:\") + cacheInvalidationTime) + \", dispatch:\") + dispatchChanges) + \", purge:\") + purge) + '}';\n        }\n    }\n\n    private static long revisionPurgeMillis() {\n        return org.apache.jackrabbit.oak.plugins.document.Revision.getCurrentTimestamp() - org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.REMEMBER_REVISION_ORDER_MILLIS;\n    }\n\n    private void cleanOrphanedBranches() {\n        org.apache.jackrabbit.oak.plugins.document.Branch b;\n        while ((b = branches.pollOrphanedBranch()) != null) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Cleaning up orphaned branch with base revision: {}, \" + \"commits: {}\", b.getBase(), b.getCommits());\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\"), false);\n            for (org.apache.jackrabbit.oak.plugins.document.Revision r : b.getCommits()) {\n                r = r.asTrunkRevision();\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeRevision(op, r);\n            }\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, op);\n        } \n    }\n\n    private void cleanCollisions() {\n        java.lang.String id = org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(\"/\");\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument root = store.find(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, id);\n        if (root == null) {\n            return;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision head = getHeadRevision();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = root.getLocalMap(NodeDocument.COLLISIONS);\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : map.keySet()) {\n            if (r.getClusterId() == clusterId) {\n                if ((branches.getBranchCommit(r) == null) && isRevisionNewer(head, r)) {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(op, r);\n                }\n            }\n        }\n        if (op.hasChanges()) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Removing collisions {}\", op.getChanges().keySet());\n            store.findAndUpdate(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, op);\n        }\n    }\n\n    private void backgroundSplit() {\n        for (java.util.Iterator<java.lang.String> it = splitCandidates.keySet().iterator(); it.hasNext();) {\n            java.lang.String id = it.next();\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = store.find(Collection.NODES, id);\n            if (doc == null) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.UpdateOp op : doc.split(this)) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument before = store.createOrUpdate(Collection.NODES, op);\n                if (before != null) {\n                    if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument after = store.find(Collection.NODES, op.getId());\n                        if (after != null) {\n                            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation on {}. Size before: {}, after: {}\", id, before.getMemory(), after.getMemory());\n                        }\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Split operation created {}\", op.getId());\n                }\n            }\n            it.remove();\n        }\n    }\n\n    void backgroundWrite() {\n        unsavedLastRevisions.persist(this, backgroundOperationLock.writeLock());\n    }\n\n    private void checkOpen() throws java.lang.IllegalStateException {\n        if (isDisposed.get()) {\n            throw new java.lang.IllegalStateException(\"This DocumentNodeStore is disposed\");\n        }\n    }\n\n    private boolean dispatch(@javax.annotation.Nonnull\n    java.lang.String jsonDiff, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState node, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeState base, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.spi.state.NodeStateDiff diff, boolean useReadRevision) {\n        if (jsonDiff.trim().isEmpty()) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision nodeRev = (useReadRevision) ? node.getRevision() : node.getLastRevision();\n        org.apache.jackrabbit.oak.plugins.document.Revision baseRev = (useReadRevision) ? base.getRevision() : base.getLastRevision();\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer t = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(jsonDiff);\n        boolean continueComparison = true;\n        while (continueComparison) {\n            int r = t.read();\n            if (r == org.apache.jackrabbit.oak.commons.json.JsopReader.END) {\n                break;\n            }\n            switch (r) {\n                case '+' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        t.read(':');\n                        t.read('{');\n                        while (t.read() != '}') {\n                        } \n                        org.apache.jackrabbit.oak.spi.state.NodeState child = getNode(concat(node.getPath(), name), nodeRev);\n                        continueComparison = diff.childNodeAdded(name, child);\n                        break;\n                    }\n                case '-' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        org.apache.jackrabbit.oak.spi.state.NodeState child = getNode(concat(base.getPath(), name), baseRev);\n                        continueComparison = diff.childNodeDeleted(name, child);\n                        break;\n                    }\n                case '^' :\n                    {\n                        java.lang.String name = unshareString(t.readString());\n                        t.read(':');\n                        if (t.matches('{')) {\n                            t.read('}');\n                            org.apache.jackrabbit.oak.spi.state.NodeState nodeChild = getNode(concat(node.getPath(), name), nodeRev);\n                            org.apache.jackrabbit.oak.spi.state.NodeState baseChild = getNode(concat(base.getPath(), name), baseRev);\n                            continueComparison = diff.childNodeChanged(name, baseChild, nodeChild);\n                        } else if (t.matches('[')) {\n                            while (t.read() != ']') {\n                            } \n                        } else {\n                            t.read();\n                        }\n                        break;\n                    }\n                default :\n                    throw new java.lang.IllegalArgumentException(((((\"jsonDiff: illegal token '\" + t.getToken()) + \"' at pos: \") + t.getLastPos()) + ' ') + jsonDiff);\n            }\n        } \n        return continueComparison;\n    }\n\n    private boolean checkNodeNotExistsFromChildrenCache(java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(path)) {\n            return false;\n        }\n        final java.lang.String parentPath = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(path);\n        org.apache.jackrabbit.oak.plugins.document.PathRev key = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.childNodeCacheKey(parentPath, rev, null);\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children children = nodeChildrenCache.getIfPresent(key);\n        java.lang.String lookupChildName = org.apache.jackrabbit.oak.commons.PathUtils.getName(path);\n        if (children == null) {\n            return false;\n        }\n        if (children.hasMore) {\n            return false;\n        }\n        int childPosition = java.util.Collections.binarySearch(children.children, lookupChildName);\n        if (childPosition < 0) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"Child node as per path {} does not exist at revision {}\", path, rev);\n            return true;\n        }\n        return false;\n    }\n\n    private static void diffProperties(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to, org.apache.jackrabbit.oak.commons.json.JsopWriter w) {\n        for (org.apache.jackrabbit.oak.api.PropertyState fromValue : from.getProperties()) {\n            java.lang.String name = fromValue.getName();\n            org.apache.jackrabbit.oak.api.PropertyState toValue = to.getProperty(name);\n            if (!fromValue.equals(toValue)) {\n                w.tag('^').key(concat(from.getPath(), name));\n                if (toValue == null) {\n                    w.value(null);\n                } else {\n                    w.encodedValue(to.getPropertyAsString(name)).newline();\n                }\n            }\n        }\n        for (java.lang.String name : to.getPropertyNames()) {\n            if (!from.hasProperty(name)) {\n                w.tag('^').key(concat(from.getPath(), name)).encodedValue(to.getPropertyAsString(name)).newline();\n            }\n        }\n    }\n\n    private java.lang.String diffImpl(org.apache.jackrabbit.oak.plugins.document.DocumentNodeState from, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState to) throws org.apache.jackrabbit.oak.plugins.document.DocumentStoreException {\n        org.apache.jackrabbit.oak.commons.json.JsopWriter w = new org.apache.jackrabbit.oak.commons.json.JsopStream();\n        int max = org.apache.jackrabbit.oak.plugins.document.DocumentMK.MANY_CHILDREN_THRESHOLD;\n        final boolean debug = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled();\n        final long start = (debug) ? org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now() : 0;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren;\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren;\n        fromChildren = getChildren(from, null, max);\n        toChildren = getChildren(to, null, max);\n        final long getChildrenDoneIn = (debug) ? org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now() : 0;\n        java.lang.String diffAlgo;\n        if ((!fromChildren.hasMore) && (!toChildren.hasMore)) {\n            diffAlgo = \"diffFewChildren\";\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        } else if (org.apache.jackrabbit.oak.plugins.document.DocumentMK.FAST_DIFF) {\n            diffAlgo = \"diffManyChildren\";\n            diffManyChildren(w, from.getPath(), from.getLastRevision(), to.getLastRevision());\n        } else {\n            diffAlgo = \"diffAllChildren\";\n            max = java.lang.Integer.MAX_VALUE;\n            fromChildren = getChildren(from, null, max);\n            toChildren = getChildren(to, null, max);\n            diffFewChildren(w, from.getPath(), fromChildren, from.getLastRevision(), toChildren, to.getLastRevision());\n        }\n        if (debug) {\n            long end = org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.now();\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Diff performed via '{}' at [{}] between revisions [{}] => [{}] took {} ms ({} ms)\", diffAlgo, from.getPath(), from.getLastRevision(), to.getLastRevision(), end - start, getChildrenDoneIn - start);\n        }\n        return w.toString();\n    }\n\n    private void diffManyChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String path, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        long minTimestamp = java.lang.Math.min(revisionComparator.getMinimumTimestamp(fromRev, inactiveClusterNodes), revisionComparator.getMinimumTimestamp(toRev, inactiveClusterNodes));\n        long minValue = org.apache.jackrabbit.oak.plugins.document.NodeDocument.getModifiedInSecs(minTimestamp);\n        java.lang.String fromKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyLowerLimit(path);\n        java.lang.String toKey = org.apache.jackrabbit.oak.plugins.document.util.Utils.getKeyUpperLimit(path);\n        java.util.Set<java.lang.String> paths = com.google.common.collect.Sets.newHashSet();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"diffManyChildren: path: {}, fromRev: {}, toRev: {}\", path, fromRev, toRev);\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument doc : store.query(Collection.NODES, fromKey, toKey, NodeDocument.MODIFIED_IN_SECS, minValue, java.lang.Integer.MAX_VALUE)) {\n            paths.add(doc.getPath());\n        }\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"diffManyChildren: Affected paths: {}\", paths.size());\n        org.apache.jackrabbit.oak.plugins.document.Revision minRev = new org.apache.jackrabbit.oak.plugins.document.Revision(minTimestamp, 0, getClusterId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, getPendingModifications().getPaths(minRev));\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : new org.apache.jackrabbit.oak.plugins.document.Revision[]{ fromRev, toRev }) {\n            if (r.isBranch()) {\n                org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit c = getBranches().getBranchCommit(r);\n                if (c != null) {\n                    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.addPathsForDiff(path, paths, c.getModifiedPaths());\n                }\n            }\n        }\n        for (java.lang.String p : paths) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState fromNode = getNode(p, fromRev);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeState toNode = getNode(p, toRev);\n            java.lang.String name = org.apache.jackrabbit.oak.commons.PathUtils.getName(p);\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.trace(\"diffManyChildren: Changed Path {}\", path);\n            if (fromNode != null) {\n                if (toNode != null) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision a = fromNode.getLastRevision();\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = toNode.getLastRevision();\n                    if ((a == null) && (b == null)) {\n                    } else if (((a == null) || (b == null)) || (!a.equals(b))) {\n                        w.tag('^').key(name).object().endObject().newline();\n                    }\n                } else {\n                    w.tag('-').value(name).newline();\n                }\n            } else if (toNode != null) {\n                w.tag('+').key(name).object().endObject().newline();\n            } else {\n            }\n        }\n    }\n\n    private static void addPathsForDiff(java.lang.String path, java.util.Set<java.lang.String> paths, java.lang.Iterable<java.lang.String> modified) {\n        for (java.lang.String p : modified) {\n            if (org.apache.jackrabbit.oak.commons.PathUtils.denotesRoot(p)) {\n                continue;\n            }\n            java.lang.String parent = org.apache.jackrabbit.oak.commons.PathUtils.getParentPath(p);\n            if (path.equals(parent)) {\n                paths.add(p);\n            }\n        }\n    }\n\n    private void diffFewChildren(org.apache.jackrabbit.oak.commons.json.JsopWriter w, java.lang.String parentPath, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children fromChildren, org.apache.jackrabbit.oak.plugins.document.Revision fromRev, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState.Children toChildren, org.apache.jackrabbit.oak.plugins.document.Revision toRev) {\n        java.util.Set<java.lang.String> childrenSet = com.google.common.collect.Sets.newHashSet(toChildren.children);\n        for (java.lang.String n : fromChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('-').value(n).newline();\n            } else {\n                java.lang.String path = concat(parentPath, n);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n1 = getNode(path, fromRev);\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n2 = getNode(path, toRev);\n                com.google.common.base.Preconditions.checkNotNull(n1, \"Node at [%s] not found for fromRev [%s]\", path, fromRev);\n                com.google.common.base.Preconditions.checkNotNull(n2, \"Node at [%s] not found for toRev [%s]\", path, toRev);\n                if (!n1.getLastRevision().equals(n2.getLastRevision())) {\n                    w.tag('^').key(n).object().endObject().newline();\n                }\n            }\n        }\n        childrenSet = com.google.common.collect.Sets.newHashSet(fromChildren.children);\n        for (java.lang.String n : toChildren.children) {\n            if (!childrenSet.contains(n)) {\n                w.tag('+').key(n).object().endObject().newline();\n            }\n        }\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.PathRev childNodeCacheKey(@javax.annotation.Nonnull\n    java.lang.String path, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    java.lang.String name) {\n        java.lang.String p = (name == null ? \"\" : name) + path;\n        return new org.apache.jackrabbit.oak.plugins.document.PathRev(p, readRevision);\n    }\n\n    private static org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder asDocumentRootBuilder(org.apache.jackrabbit.oak.spi.state.NodeBuilder builder) throws java.lang.IllegalArgumentException {\n        if (!(builder instanceof org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder)) {\n            throw new java.lang.IllegalArgumentException(\"builder must be a \" + org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder.class.getName());\n        }\n        return ((org.apache.jackrabbit.oak.plugins.document.DocumentRootBuilder) (builder));\n    }\n\n    private static long now() {\n        return java.lang.System.currentTimeMillis();\n    }\n\n    private void moveOrCopyNode(boolean move, org.apache.jackrabbit.oak.plugins.document.DocumentNodeState source, java.lang.String targetPath, org.apache.jackrabbit.oak.plugins.document.Commit commit) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState newNode = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(this, targetPath, commit.getRevision());\n        source.copyTo(newNode);\n        commit.addNode(newNode);\n        if (move) {\n            markAsDeleted(source, commit, false);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.DocumentNodeState child : getChildNodes(source, null, java.lang.Integer.MAX_VALUE)) {\n            java.lang.String childName = org.apache.jackrabbit.oak.commons.PathUtils.getName(child.getPath());\n            java.lang.String destChildPath = concat(targetPath, childName);\n            moveOrCopyNode(move, child, destChildPath, commit);\n        }\n    }\n\n    private void checkRevisionAge(org.apache.jackrabbit.oak.plugins.document.Revision r, java.lang.String path) {\n        if (org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.isDebugEnabled()) {\n            if (\"/\".equals(path) && ((headRevision.getTimestamp() - r.getTimestamp()) > org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.WARN_REVISION_AGE)) {\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug((((\"Requesting an old revision for path \" + path) + \", \") + ((headRevision.getTimestamp() - r.getTimestamp()) / 1000)) + \" seconds old\");\n            }\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector createBlobGarbageCollector(long blobGcMaxAgeInSecs, java.lang.String repositoryId) {\n        org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector blobGC = null;\n        if (blobStore instanceof org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) {\n            try {\n                blobGC = new org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector(new org.apache.jackrabbit.oak.plugins.document.DocumentBlobReferenceRetriever(this), ((org.apache.jackrabbit.oak.spi.blob.GarbageCollectableBlobStore) (blobStore)), executor, java.util.concurrent.TimeUnit.SECONDS.toMillis(blobGcMaxAgeInSecs), repositoryId);\n            } catch (java.io.IOException e) {\n                throw new java.lang.RuntimeException(\"Error occurred while initializing \" + \"the MarkSweepGarbageCollector\", e);\n            }\n        }\n        return blobGC;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean getMBean() {\n        return mbean;\n    }\n\n    private org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean createMBean() {\n        try {\n            return new org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.MBeanImpl();\n        } catch (javax.management.NotCompliantMBeanException e) {\n            throw new java.lang.IllegalStateException(e);\n        }\n    }\n\n    private class MBeanImpl extends org.apache.jackrabbit.oak.commons.jmx.AnnotatedStandardMBean implements org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean {\n        private final java.lang.String ISO_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss.SSS zzz\";\n\n        private final java.util.TimeZone TZ_UTC = java.util.TimeZone.getTimeZone(\"UTC\");\n\n        protected MBeanImpl() throws javax.management.NotCompliantMBeanException {\n            super(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStoreMBean.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String getRevisionComparatorState() {\n            return revisionComparator.toString();\n        }\n\n        @java.lang.Override\n        public java.lang.String getHead() {\n            return headRevision.toString();\n        }\n\n        @java.lang.Override\n        public int getClusterId() {\n            return clusterId;\n        }\n\n        @java.lang.Override\n        public int getUnmergedBranchCount() {\n            return branches.size();\n        }\n\n        @java.lang.Override\n        public java.lang.String[] getInactiveClusterNodes() {\n            return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(inactiveClusterNodes.entrySet(), new com.google.common.base.Function<java.util.Map.Entry<java.lang.Integer, java.lang.Long>, java.lang.String>() {\n                @java.lang.Override\n                public java.lang.String apply(java.util.Map.Entry<java.lang.Integer, java.lang.Long> input) {\n                    return input.toString();\n                }\n            }), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String[] getLastKnownRevisions() {\n            return com.google.common.collect.Iterables.toArray(com.google.common.collect.Iterables.transform(lastKnownRevision.entrySet(), new com.google.common.base.Function<java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision>, java.lang.String>() {\n                @java.lang.Override\n                public java.lang.String apply(java.util.Map.Entry<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> input) {\n                    return input.toString();\n                }\n            }), java.lang.String.class);\n        }\n\n        @java.lang.Override\n        public java.lang.String formatRevision(java.lang.String rev, boolean utc) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(rev);\n            final java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(ISO_FORMAT);\n            if (utc) {\n                sdf.setTimeZone(TZ_UTC);\n            }\n            return sdf.format(r.getTimestamp());\n        }\n    }\n\n    static abstract class NodeStoreTask implements java.lang.Runnable {\n        final java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore> ref;\n\n        private final java.util.concurrent.atomic.AtomicBoolean isDisposed;\n\n        private int delay;\n\n        NodeStoreTask(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            ref = new java.lang.ref.WeakReference<org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore>(nodeStore);\n            delay = nodeStore.getAsyncDelay();\n            this.isDisposed = isDisposed;\n        }\n\n        protected abstract void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore);\n\n        @java.lang.Override\n        public void run() {\n            while ((delay != 0) && (!isDisposed.get())) {\n                synchronized(isDisposed) {\n                    try {\n                        isDisposed.wait(delay);\n                    } catch (java.lang.InterruptedException e) {\n                    }\n                }\n                org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore = ref.get();\n                if (nodeStore != null) {\n                    try {\n                        execute(nodeStore);\n                    } catch (java.lang.Throwable t) {\n                        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + t.toString(), t);\n                    }\n                    delay = nodeStore.getAsyncDelay();\n                } else {\n                    break;\n                }\n            } \n        }\n    }\n\n    static class BackgroundOperation extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundOperation(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            nodeStore.runBackgroundOperations();\n        }\n    }\n\n    static class BackgroundLeaseUpdate extends org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.NodeStoreTask {\n        BackgroundLeaseUpdate(org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, java.util.concurrent.atomic.AtomicBoolean isDisposed) {\n            super(nodeStore, isDisposed);\n        }\n\n        @java.lang.Override\n        protected void execute(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore) {\n            if (nodeStore.renewClusterIdLease()) {\n                nodeStore.updateClusterState();\n            }\n        }\n    }\n\n    public org.apache.jackrabbit.oak.spi.blob.BlobStore getBlobStore() {\n        return blobStore;\n    }\n\n    org.apache.jackrabbit.oak.json.BlobSerializer getBlobSerializer() {\n        return blobSerializer;\n    }\n\n    public java.util.Iterator<org.apache.jackrabbit.oak.api.Blob> getReferencedBlobsIterator() {\n        if (store instanceof org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) {\n            return new org.apache.jackrabbit.oak.plugins.document.mongo.MongoBlobReferenceIterator(this, ((org.apache.jackrabbit.oak.plugins.document.mongo.MongoDocumentStore) (store)));\n        }\n        return new org.apache.jackrabbit.oak.plugins.document.BlobReferenceIterator(this);\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.DiffCache getDiffCache() {\n        return diffCache;\n    }\n\n    public org.apache.jackrabbit.oak.stats.Clock getClock() {\n        return clock;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.Checkpoints getCheckpoints() {\n        return checkpoints;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.VersionGarbageCollector getVersionGarbageCollector() {\n        return versionGarbageCollector;\n    }\n\n    @javax.annotation.Nonnull\n    public org.apache.jackrabbit.oak.plugins.document.LastRevRecoveryAgent getLastRevRecoveryAgent() {\n        return lastRevRecoveryAgent;\n    }\n\n    public void setPersistentCache(org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache persistentCache) {\n        this.persistentCache = persistentCache;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "internalRunBackgroundOperations()",
            "src_parent": "{\n    if (isDisposed.getAndSet(true)) {\n        return;\n    }\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    internalRunBackgroundOperations();\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "checkOpen()",
            "src_parent": "{\n    if (base == null) {\n        base = headRevision;\n    }\n    backgroundOperationLock.readLock().lock();\n    checkOpen();\n    boolean success = false;\n    org.apache.jackrabbit.oak.plugins.document.Commit c;\n    try {\n        c = new org.apache.jackrabbit.oak.plugins.document.Commit(this, commitQueue.createRevision(), base, branch);\n        success = true;\n    } finally {\n        if (!success) {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n    return c;\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "checkOpen()",
            "src_parent": "{\n    if (base == null) {\n        base = headRevision;\n    }\n    backgroundOperationLock.readLock().lock();\n    checkOpen();\n    boolean success = false;\n    org.apache.jackrabbit.oak.plugins.document.MergeCommit c;\n    try {\n        c = new org.apache.jackrabbit.oak.plugins.document.MergeCommit(this, base, commitQueue.createRevisions(numBranchCommits));\n        success = true;\n    } finally {\n        if (!success) {\n            backgroundOperationLock.readLock().unlock();\n        }\n    }\n    return c;\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "synchronized(isDisposed) {\n    isDisposed.notifyAll();\n}",
            "dst_parent": "{\n    if (isDisposed.getAndSet(true)) {\n        return;\n    }\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    internalRunBackgroundOperations();\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n}",
            "dst_parent_type": "Block",
            "dst_type": "Synchronized",
            "operator": "MOV",
            "src": "synchronized(isDisposed) {\n    isDisposed.notifyAll();\n}",
            "src_parent": "{\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Synchronized"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "try {\n    backgroundThread.join();\n} catch (java.lang.InterruptedException e) {\n}",
            "dst_parent": "{\n    if (isDisposed.getAndSet(true)) {\n        return;\n    }\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    internalRunBackgroundOperations();\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n}",
            "dst_parent_type": "Block",
            "dst_type": "Try",
            "operator": "MOV",
            "src": "try {\n    backgroundThread.join();\n} catch (java.lang.InterruptedException e) {\n}",
            "src_parent": "{\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Try"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if (leaseUpdateThread != null) {\n    try {\n        leaseUpdateThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n}",
            "dst_parent": "{\n    if (isDisposed.getAndSet(true)) {\n        return;\n    }\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    internalRunBackgroundOperations();\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if (leaseUpdateThread != null) {\n    try {\n        leaseUpdateThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n}",
            "src_parent": "{\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if (clusterNodeInfo != null) {\n    clusterNodeInfo.dispose();\n}",
            "dst_parent": "{\n    if (isDisposed.getAndSet(true)) {\n        return;\n    }\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    internalRunBackgroundOperations();\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if (clusterNodeInfo != null) {\n    clusterNodeInfo.dispose();\n}",
            "src_parent": "{\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "store.dispose()",
            "dst_parent": "{\n    if (isDisposed.getAndSet(true)) {\n        return;\n    }\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    internalRunBackgroundOperations();\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "store.dispose()",
            "src_parent": "{\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if (blobStore instanceof java.io.Closeable) {\n    try {\n        ((java.io.Closeable) (blobStore)).close();\n    } catch (java.io.IOException ex) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n    }\n}",
            "dst_parent": "{\n    if (isDisposed.getAndSet(true)) {\n        return;\n    }\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    internalRunBackgroundOperations();\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if (blobStore instanceof java.io.Closeable) {\n    try {\n        ((java.io.Closeable) (blobStore)).close();\n    } catch (java.io.IOException ex) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n    }\n}",
            "src_parent": "{\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId)",
            "dst_parent": "{\n    if (isDisposed.getAndSet(true)) {\n        return;\n    }\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    internalRunBackgroundOperations();\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n    if (persistentCache != null) {\n        persistentCache.close();\n    }\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId)",
            "src_parent": "{\n    synchronized(isDisposed) {\n        isDisposed.notifyAll();\n    }\n    try {\n        backgroundThread.join();\n    } catch (java.lang.InterruptedException e) {\n    }\n    if (leaseUpdateThread != null) {\n        try {\n            leaseUpdateThread.join();\n        } catch (java.lang.InterruptedException e) {\n        }\n    }\n    if (clusterNodeInfo != null) {\n        clusterNodeInfo.dispose();\n    }\n    store.dispose();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(\"Disposed DocumentNodeStore with clusterNodeId: {}\", clusterId);\n    if (blobStore instanceof java.io.Closeable) {\n        try {\n            ((java.io.Closeable) (blobStore)).close();\n        } catch (java.io.IOException ex) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(\"Error closing blob store \" + blobStore, ex);\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if (isDisposed.get()) {\n    return;\n}",
            "dst_parent": "{\n    if (isDisposed.get()) {\n        return;\n    }\n    try {\n        internalRunBackgroundOperations();\n    } catch (java.lang.RuntimeException e) {\n        if (isDisposed.get()) {\n            org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + e.toString(), e);\n            return;\n        }\n        throw e;\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if (isDisposed.get()) {\n    return;\n}",
            "src_parent": "{\n    if (isDisposed.get()) {\n        return;\n    }\n    throw e;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "long start = clock.getTime()",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "long start = clock.getTime()",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "long time = start",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "long time = start",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "cleanOrphanedBranches()",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "cleanOrphanedBranches()",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "cleanCollisions()",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "cleanCollisions()",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "long cleanTime = clock.getTime() - time",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "long cleanTime = clock.getTime() - time",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "time = clock.getTime()",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "Assignment",
            "operator": "MOV",
            "src": "time = clock.getTime()",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "backgroundSplit()",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "backgroundSplit()",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "long splitTime = clock.getTime() - time",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "long splitTime = clock.getTime() - time",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "time = clock.getTime()",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "Assignment",
            "operator": "MOV",
            "src": "time = clock.getTime()",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "backgroundWrite()",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "backgroundWrite()",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "long writeTime = clock.getTime() - time",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "long writeTime = clock.getTime() - time",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "time = clock.getTime()",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "Assignment",
            "operator": "MOV",
            "src": "time = clock.getTime()",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true)",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true)",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "long readTime = clock.getTime() - time",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "long readTime = clock.getTime() - time",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\"",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\"",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n} else {\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n}",
            "dst_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n} else {\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n}",
            "src_parent": "{\n    long start = clock.getTime();\n    long time = start;\n    cleanOrphanedBranches();\n    cleanCollisions();\n    long cleanTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundSplit();\n    long splitTime = clock.getTime() - time;\n    time = clock.getTime();\n    backgroundWrite();\n    long writeTime = clock.getTime() - time;\n    time = clock.getTime();\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.BackgroundReadStats readStats = backgroundRead(true);\n    long readTime = clock.getTime() - time;\n    java.lang.String msg = \"Background operations stats (clean:{}, split:{}, write:{}, read:{} {})\";\n    if ((clock.getTime() - start) > java.util.concurrent.TimeUnit.SECONDS.toMillis(10)) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.info(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    } else {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "isDisposed.getAndSet(true)",
            "dst_parent": "if (isDisposed.getAndSet(true)) {\n    return;\n}",
            "dst_parent_type": "If",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "isDisposed.getAndSet(true)",
            "src_parent": "!isDisposed.getAndSet(true)",
            "src_parent_type": "UnaryOperator",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Try",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    return;\n}",
            "dst_parent": "if (isDisposed.getAndSet(true)) {\n    return;\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    return;\n}",
            "src_parent": "if (simpleRevisionCounter != null) {\n    return;\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "java.lang.RuntimeException e",
            "dst_parent": "catch (java.lang.RuntimeException e) {\n    if (isDisposed.get()) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + e.toString(), e);\n        return;\n    }\n    throw e;\n}",
            "dst_parent_type": "Catch",
            "dst_type": "CatchVariable",
            "operator": "MOV",
            "src": "java.lang.RuntimeException e",
            "src_parent": "catch (java.lang.RuntimeException e) {\n    if (isDisposed.get()) {\n        return;\n    }\n    throw e;\n}",
            "src_parent_type": "Catch",
            "src_type": "CatchVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "true",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "throw e",
            "dst_parent": "{\n    if (isDisposed.get()) {\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore.LOG.warn(\"Background operation failed: \" + e.toString(), e);\n        return;\n    }\n    throw e;\n}",
            "dst_parent_type": "Block",
            "dst_type": "Throw",
            "operator": "MOV",
            "src": "throw e",
            "src_parent": "{\n    if (isDisposed.get()) {\n        return;\n    }\n    throw e;\n}",
            "src_parent_type": "Block",
            "src_type": "Throw"
          }
        }
      ],
      "file_name": "DocumentNodeStore"
    }
  ],
  "id": "jackrabbit-oak_36fe017c"
}