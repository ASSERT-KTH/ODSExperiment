{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private volatile boolean canceled;",
            "src_parent": "public abstract class StreamTask<OUT, Operator extends org.apache.flink.streaming.api.operators.StreamOperator<OUT>> extends org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable implements org.apache.flink.runtime.jobgraph.tasks.StatefulTask<org.apache.flink.streaming.runtime.tasks.StreamTaskStateList> {\n    public static final java.lang.ThreadGroup TRIGGER_THREAD_GROUP = new java.lang.ThreadGroup(\"Triggers\");\n\n    protected static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.flink.streaming.runtime.tasks.StreamTask.class);\n\n    private final java.lang.Object lock = new java.lang.Object();\n\n    protected Operator headOperator;\n\n    private org.apache.flink.streaming.runtime.tasks.OperatorChain<OUT> operatorChain;\n\n    private org.apache.flink.streaming.api.graph.StreamConfig configuration;\n\n    private java.lang.ClassLoader userClassLoader;\n\n    private org.apache.flink.runtime.state.StateBackend<?> stateBackend;\n\n    private java.util.concurrent.ScheduledExecutorService timerService;\n\n    private java.util.Map<java.lang.String, org.apache.flink.api.common.accumulators.Accumulator<?, ?>> accumulatorMap;\n\n    private org.apache.flink.streaming.runtime.tasks.StreamTaskStateList lazyRestoreState;\n\n    private volatile org.apache.flink.streaming.runtime.tasks.AsynchronousException asyncException;\n\n    private final java.util.Set<java.lang.Thread> asyncCheckpointThreads = java.util.Collections.synchronizedSet(new java.util.HashSet<java.lang.Thread>());\n\n    private volatile boolean isRunning;\n\n    private volatile boolean canceled;\n\n    private long recoveryTimestamp;\n\n    protected abstract void init() throws java.lang.Exception;\n\n    protected abstract void run() throws java.lang.Exception;\n\n    protected abstract void cleanup() throws java.lang.Exception;\n\n    protected abstract void cancelTask() throws java.lang.Exception;\n\n    @java.lang.Override\n    public final void invoke() throws java.lang.Exception {\n        boolean disposed = false;\n        try {\n            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Initializing {}\", getName());\n            userClassLoader = org.apache.flink.streaming.runtime.tasks.StreamTask.getUserCodeClassLoader();\n            configuration = new org.apache.flink.streaming.api.graph.StreamConfig(org.apache.flink.streaming.runtime.tasks.StreamTask.getTaskConfiguration());\n            accumulatorMap = org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getAccumulatorRegistry().getUserMap();\n            headOperator = configuration.getStreamOperator(userClassLoader);\n            operatorChain = new org.apache.flink.streaming.runtime.tasks.OperatorChain(this, headOperator, org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getAccumulatorRegistry().getReadWriteReporter());\n            if (headOperator != null) {\n                headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());\n            }\n            timerService = java.util.concurrent.Executors.newSingleThreadScheduledExecutor(new org.apache.flink.runtime.taskmanager.DispatcherThreadFactory(org.apache.flink.streaming.runtime.tasks.StreamTask.TRIGGER_THREAD_GROUP, \"Time Trigger for \" + getName()));\n            init();\n            if (canceled) {\n                throw new org.apache.flink.runtime.execution.CancelTaskException();\n            }\n            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Invoking {}\", getName());\n            stateBackend = createStateBackend();\n            stateBackend.initializeForJob(org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment());\n            restoreState();\n            synchronized(lock) {\n                openAllOperators();\n            }\n            if (canceled) {\n                throw new org.apache.flink.runtime.execution.CancelTaskException();\n            }\n            isRunning = true;\n            run();\n            isRunning = false;\n            if (org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.isDebugEnabled()) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Finished task {}\", getName());\n            }\n            synchronized(lock) {\n                closeAllOperators();\n            }\n            operatorChain.flushOutputs();\n            tryDisposeAllOperators();\n            disposed = true;\n        } finally {\n            isRunning = false;\n            if (timerService != null) {\n                try {\n                    timerService.shutdownNow();\n                } catch (java.lang.Throwable t) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Could not shut down timer service\", t);\n                }\n            }\n            try {\n                for (java.lang.Thread checkpointThread : asyncCheckpointThreads) {\n                    checkpointThread.interrupt();\n                }\n                asyncCheckpointThreads.clear();\n            } catch (java.lang.Throwable t) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Could not shut down async checkpoint threads\", t);\n            }\n            if (operatorChain != null) {\n                operatorChain.releaseOutputs();\n            }\n            try {\n                cleanup();\n            } catch (java.lang.Throwable t) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Error during cleanup of stream task\", t);\n            }\n            if (!disposed) {\n                disposeAllOperators();\n            }\n            try {\n                if (stateBackend != null) {\n                    stateBackend.close();\n                }\n            } catch (java.lang.Throwable t) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Error while closing the state backend\", t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public final void cancel() throws java.lang.Exception {\n        isRunning = false;\n        canceled = true;\n        cancelTask();\n    }\n\n    public final boolean isRunning() {\n        return isRunning;\n    }\n\n    public final boolean isCanceled() {\n        return canceled;\n    }\n\n    private void openAllOperators() throws java.lang.Exception {\n        for (org.apache.flink.streaming.api.operators.StreamOperator<?> operator : operatorChain.getAllOperators()) {\n            if (operator != null) {\n                operator.open();\n            }\n        }\n    }\n\n    private void closeAllOperators() throws java.lang.Exception {\n        org.apache.flink.streaming.api.operators.StreamOperator<?>[] allOperators = operatorChain.getAllOperators();\n        for (int i = allOperators.length - 1; i >= 0; i--) {\n            org.apache.flink.streaming.api.operators.StreamOperator<?> operator = allOperators[i];\n            if (operator != null) {\n                operator.close();\n            }\n        }\n    }\n\n    private void tryDisposeAllOperators() throws java.lang.Exception {\n        for (org.apache.flink.streaming.api.operators.StreamOperator<?> operator : operatorChain.getAllOperators()) {\n            if (operator != null) {\n                operator.dispose();\n            }\n        }\n    }\n\n    private void disposeAllOperators() {\n        if (operatorChain != null) {\n            for (org.apache.flink.streaming.api.operators.StreamOperator<?> operator : operatorChain.getAllOperators()) {\n                try {\n                    if (operator != null) {\n                        operator.dispose();\n                    }\n                } catch (java.lang.Throwable t) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Error during disposal of stream operator.\", t);\n                }\n            }\n        }\n    }\n\n    @java.lang.Override\n    protected void finalize() throws java.lang.Throwable {\n        super.finalize();\n        if (timerService != null) {\n            if (!timerService.isTerminated()) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.warn(\"Timer service was not shut down. Shutting down in finalize().\");\n            }\n            timerService.shutdownNow();\n        }\n        for (java.lang.Thread checkpointThread : asyncCheckpointThreads) {\n            checkpointThread.interrupt();\n        }\n    }\n\n    public java.lang.String getName() {\n        return org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getTaskInfo().getTaskNameWithSubtasks();\n    }\n\n    public java.lang.Object getCheckpointLock() {\n        return lock;\n    }\n\n    public org.apache.flink.streaming.api.graph.StreamConfig getConfiguration() {\n        return configuration;\n    }\n\n    public java.util.Map<java.lang.String, org.apache.flink.api.common.accumulators.Accumulator<?, ?>> getAccumulatorMap() {\n        return accumulatorMap;\n    }\n\n    public org.apache.flink.streaming.api.operators.Output<org.apache.flink.streaming.runtime.streamrecord.StreamRecord<OUT>> getHeadOutput() {\n        return operatorChain.getChainEntryPoint();\n    }\n\n    public org.apache.flink.streaming.runtime.io.RecordWriterOutput<?>[] getStreamOutputs() {\n        return operatorChain.getStreamOutputs();\n    }\n\n    @java.lang.Override\n    public void setInitialState(org.apache.flink.streaming.runtime.tasks.StreamTaskStateList initialState, long recoveryTimestamp) {\n        lazyRestoreState = initialState;\n        this.recoveryTimestamp = recoveryTimestamp;\n    }\n\n    private void restoreState() throws java.lang.Exception {\n        if (lazyRestoreState != null) {\n            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.info(\"Restoring checkpointed state to task {}\", getName());\n            try {\n                final org.apache.flink.streaming.api.operators.StreamOperator<?>[] allOperators = operatorChain.getAllOperators();\n                final org.apache.flink.streaming.runtime.tasks.StreamTaskState[] states = lazyRestoreState.getState(userClassLoader);\n                lazyRestoreState = null;\n                for (int i = 0; i < states.length; i++) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTaskState state = states[i];\n                    org.apache.flink.streaming.api.operators.StreamOperator<?> operator = allOperators[i];\n                    if ((state != null) && (operator != null)) {\n                        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Task {} in chain ({}) has checkpointed state\", i, getName());\n                        operator.restoreState(state, recoveryTimestamp);\n                    } else if (operator != null) {\n                        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Task {} in chain ({}) does not have checkpointed state\", i, getName());\n                    }\n                }\n            } catch (java.lang.Exception e) {\n                throw new java.lang.Exception(\"Could not restore checkpointed state to operators and functions\", e);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public boolean triggerCheckpoint(final long checkpointId, final long timestamp) throws java.lang.Exception {\n        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Starting checkpoint {} on task {}\", checkpointId, getName());\n        synchronized(lock) {\n            if (isRunning) {\n                operatorChain.broadcastCheckpointBarrier(checkpointId, timestamp);\n                final org.apache.flink.streaming.api.operators.StreamOperator<?>[] allOperators = operatorChain.getAllOperators();\n                final org.apache.flink.streaming.runtime.tasks.StreamTaskState[] states = new org.apache.flink.streaming.runtime.tasks.StreamTaskState[allOperators.length];\n                boolean hasAsyncStates = false;\n                for (int i = 0; i < states.length; i++) {\n                    org.apache.flink.streaming.api.operators.StreamOperator<?> operator = allOperators[i];\n                    if (operator != null) {\n                        org.apache.flink.streaming.runtime.tasks.StreamTaskState state = operator.snapshotOperatorState(checkpointId, timestamp);\n                        if (state.getOperatorState() instanceof org.apache.flink.runtime.state.AsynchronousStateHandle) {\n                            hasAsyncStates = true;\n                        }\n                        if (state.getFunctionState() instanceof org.apache.flink.runtime.state.AsynchronousStateHandle) {\n                            hasAsyncStates = true;\n                        }\n                        states[i] = (state.isEmpty()) ? null : state;\n                    }\n                }\n                if (!isRunning) {\n                    throw new org.apache.flink.runtime.execution.CancelTaskException();\n                }\n                org.apache.flink.streaming.runtime.tasks.StreamTaskStateList allStates = new org.apache.flink.streaming.runtime.tasks.StreamTaskStateList(states);\n                if (allStates.isEmpty()) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().acknowledgeCheckpoint(checkpointId);\n                } else if (!hasAsyncStates) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().acknowledgeCheckpoint(checkpointId, allStates);\n                } else {\n                    java.lang.String threadName = ((\"Materialize checkpoint \" + checkpointId) + \" for \") + getName();\n                    java.lang.Thread checkpointThread = new java.lang.Thread(threadName) {\n                        @java.lang.Override\n                        public void run() {\n                            try {\n                                for (org.apache.flink.streaming.runtime.tasks.StreamTaskState state : states) {\n                                    if (state != null) {\n                                        if (state.getFunctionState() instanceof org.apache.flink.runtime.state.AsynchronousStateHandle) {\n                                            org.apache.flink.runtime.state.AsynchronousStateHandle<java.io.Serializable> asyncState = ((org.apache.flink.runtime.state.AsynchronousStateHandle<java.io.Serializable>) (state.getFunctionState()));\n                                            state.setFunctionState(asyncState.materialize());\n                                        }\n                                        if (state.getOperatorState() instanceof org.apache.flink.runtime.state.AsynchronousStateHandle) {\n                                            org.apache.flink.runtime.state.AsynchronousStateHandle<?> asyncState = ((org.apache.flink.runtime.state.AsynchronousStateHandle<?>) (state.getOperatorState()));\n                                            state.setOperatorState(asyncState.materialize());\n                                        }\n                                    }\n                                }\n                                org.apache.flink.streaming.runtime.tasks.StreamTaskStateList allStates = new org.apache.flink.streaming.runtime.tasks.StreamTaskStateList(states);\n                                org.apache.flink.streaming.runtime.tasks.StreamTask.1.getEnvironment().acknowledgeCheckpoint(checkpointId, allStates);\n                            } catch (java.lang.Exception e) {\n                                if (isRunning()) {\n                                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Caught exception while materializing asynchronous checkpoints.\", e);\n                                }\n                                if (asyncException == null) {\n                                    asyncException = new org.apache.flink.streaming.runtime.tasks.AsynchronousException(e);\n                                }\n                            }\n                            asyncCheckpointThreads.remove(this);\n                            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Finished asynchronous checkpoints for checkpoint {} on task {}\", checkpointId, getName());\n                        }\n                    };\n                    asyncCheckpointThreads.add(checkpointThread);\n                    checkpointThread.setDaemon(true);\n                    checkpointThread.start();\n                }\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void notifyCheckpointComplete(long checkpointId) throws java.lang.Exception {\n        synchronized(lock) {\n            if (isRunning) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Notification of complete checkpoint for task {}\", getName());\n                if (stateBackend instanceof org.apache.flink.streaming.api.checkpoint.CheckpointNotifier) {\n                    ((org.apache.flink.streaming.api.checkpoint.CheckpointNotifier) (stateBackend)).notifyCheckpointComplete(checkpointId);\n                }\n                for (org.apache.flink.streaming.api.operators.StreamOperator<?> operator : operatorChain.getAllOperators()) {\n                    if (operator != null) {\n                        operator.notifyOfCompletedCheckpoint(checkpointId);\n                    }\n                }\n            } else {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Ignoring notification of complete checkpoint for not-running task {}\", getName());\n            }\n        }\n    }\n\n    public org.apache.flink.runtime.state.StateBackend<?> getStateBackend() {\n        return stateBackend;\n    }\n\n    private org.apache.flink.runtime.state.StateBackend<?> createStateBackend() throws java.lang.Exception {\n        org.apache.flink.runtime.state.StateBackend<?> configuredBackend = configuration.getStateBackend(userClassLoader);\n        if (configuredBackend != null) {\n            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.info(\"Using user-defined state backend: \" + configuredBackend);\n            return configuredBackend;\n        } else {\n            org.apache.flink.configuration.Configuration flinkConfig = org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getTaskManagerInfo().getConfiguration();\n            java.lang.String backendName = flinkConfig.getString(ConfigConstants.STATE_BACKEND, null);\n            if (backendName == null) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.warn(\"No state backend has been specified, using default state backend (Memory / JobManager)\");\n                backendName = \"jobmanager\";\n            }\n            backendName = backendName.toLowerCase();\n            switch (backendName) {\n                case \"jobmanager\" :\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.info(\"State backend is set to heap memory (checkpoint to jobmanager)\");\n                    return org.apache.flink.runtime.state.memory.MemoryStateBackend.defaultInstance();\n                case \"filesystem\" :\n                    org.apache.flink.runtime.state.filesystem.FsStateBackend backend = new org.apache.flink.runtime.state.filesystem.FsStateBackendFactory().createFromConfig(flinkConfig);\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.info((\"State backend is set to filesystem (checkpoints to filesystem \\\"\" + backend.getBasePath()) + \"\\\")\");\n                    return backend;\n                default :\n                    try {\n                        @java.lang.SuppressWarnings(\"rawtypes\")\n                        java.lang.Class<? extends org.apache.flink.runtime.state.StateBackendFactory> clazz = java.lang.Class.forName(backendName, false, userClassLoader).asSubclass(org.apache.flink.runtime.state.StateBackendFactory.class);\n                        return clazz.newInstance().createFromConfig(flinkConfig);\n                    } catch (java.lang.ClassNotFoundException e) {\n                        throw new org.apache.flink.configuration.IllegalConfigurationException(\"Cannot find configured state backend: \" + backendName);\n                    } catch (java.lang.ClassCastException e) {\n                        throw new org.apache.flink.configuration.IllegalConfigurationException((((\"The class configured under '\" + org.apache.flink.configuration.ConfigConstants.STATE_BACKEND) + \"' is not a valid state backend factory (\") + backendName) + ')');\n                    } catch (java.lang.Throwable t) {\n                        throw new org.apache.flink.configuration.IllegalConfigurationException(\"Cannot create configured state backend\", t);\n                    }\n            }\n        }\n    }\n\n    public void registerTimer(final long timestamp, final org.apache.flink.streaming.runtime.operators.Triggerable target) {\n        long delay = java.lang.Math.max(timestamp - java.lang.System.currentTimeMillis(), 0);\n        timerService.schedule(new org.apache.flink.streaming.runtime.tasks.StreamTask.TriggerTask(this, lock, target, timestamp), delay, java.util.concurrent.TimeUnit.MILLISECONDS);\n    }\n\n    public void checkTimerException() throws org.apache.flink.streaming.runtime.tasks.TimerException {\n        if (asyncException != null) {\n            throw asyncException;\n        }\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return getName();\n    }\n\n    protected final org.apache.flink.runtime.util.event.EventListener<org.apache.flink.runtime.io.network.api.CheckpointBarrier> getCheckpointBarrierListener() {\n        return new org.apache.flink.runtime.util.event.EventListener<org.apache.flink.runtime.io.network.api.CheckpointBarrier>() {\n            @java.lang.Override\n            public void onEvent(org.apache.flink.runtime.io.network.api.CheckpointBarrier barrier) {\n                try {\n                    triggerCheckpoint(barrier.getId(), barrier.getTimestamp());\n                } catch (java.lang.Exception e) {\n                    throw new java.lang.RuntimeException(\"Error triggering a checkpoint as the result of receiving checkpoint barrier\", e);\n                }\n            }\n        };\n    }\n\n    private static final class TriggerTask implements java.lang.Runnable {\n        private final java.lang.Object lock;\n\n        private final org.apache.flink.streaming.runtime.operators.Triggerable target;\n\n        private final long timestamp;\n\n        private final org.apache.flink.streaming.runtime.tasks.StreamTask<?, ?> task;\n\n        TriggerTask(org.apache.flink.streaming.runtime.tasks.StreamTask<?, ?> task, final java.lang.Object lock, org.apache.flink.streaming.runtime.operators.Triggerable target, long timestamp) {\n            this.task = task;\n            this.lock = lock;\n            this.target = target;\n            this.timestamp = timestamp;\n        }\n\n        @java.lang.Override\n        public void run() {\n            synchronized(lock) {\n                try {\n                    target.trigger(timestamp);\n                } catch (java.lang.Throwable t) {\n                    if (task.isRunning) {\n                        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Caught exception while processing timer.\", t);\n                    }\n                    if (task.asyncException == null) {\n                        task.asyncException = new org.apache.flink.streaming.runtime.tasks.TimerException(t);\n                    }\n                }\n            }\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "public final boolean isCanceled() {\n    return canceled;\n}",
            "src_parent": "public abstract class StreamTask<OUT, Operator extends org.apache.flink.streaming.api.operators.StreamOperator<OUT>> extends org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable implements org.apache.flink.runtime.jobgraph.tasks.StatefulTask<org.apache.flink.streaming.runtime.tasks.StreamTaskStateList> {\n    public static final java.lang.ThreadGroup TRIGGER_THREAD_GROUP = new java.lang.ThreadGroup(\"Triggers\");\n\n    protected static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.flink.streaming.runtime.tasks.StreamTask.class);\n\n    private final java.lang.Object lock = new java.lang.Object();\n\n    protected Operator headOperator;\n\n    private org.apache.flink.streaming.runtime.tasks.OperatorChain<OUT> operatorChain;\n\n    private org.apache.flink.streaming.api.graph.StreamConfig configuration;\n\n    private java.lang.ClassLoader userClassLoader;\n\n    private org.apache.flink.runtime.state.StateBackend<?> stateBackend;\n\n    private java.util.concurrent.ScheduledExecutorService timerService;\n\n    private java.util.Map<java.lang.String, org.apache.flink.api.common.accumulators.Accumulator<?, ?>> accumulatorMap;\n\n    private org.apache.flink.streaming.runtime.tasks.StreamTaskStateList lazyRestoreState;\n\n    private volatile org.apache.flink.streaming.runtime.tasks.AsynchronousException asyncException;\n\n    private final java.util.Set<java.lang.Thread> asyncCheckpointThreads = java.util.Collections.synchronizedSet(new java.util.HashSet<java.lang.Thread>());\n\n    private volatile boolean isRunning;\n\n    private volatile boolean canceled;\n\n    private long recoveryTimestamp;\n\n    protected abstract void init() throws java.lang.Exception;\n\n    protected abstract void run() throws java.lang.Exception;\n\n    protected abstract void cleanup() throws java.lang.Exception;\n\n    protected abstract void cancelTask() throws java.lang.Exception;\n\n    @java.lang.Override\n    public final void invoke() throws java.lang.Exception {\n        boolean disposed = false;\n        try {\n            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Initializing {}\", getName());\n            userClassLoader = org.apache.flink.streaming.runtime.tasks.StreamTask.getUserCodeClassLoader();\n            configuration = new org.apache.flink.streaming.api.graph.StreamConfig(org.apache.flink.streaming.runtime.tasks.StreamTask.getTaskConfiguration());\n            accumulatorMap = org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getAccumulatorRegistry().getUserMap();\n            headOperator = configuration.getStreamOperator(userClassLoader);\n            operatorChain = new org.apache.flink.streaming.runtime.tasks.OperatorChain(this, headOperator, org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getAccumulatorRegistry().getReadWriteReporter());\n            if (headOperator != null) {\n                headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());\n            }\n            timerService = java.util.concurrent.Executors.newSingleThreadScheduledExecutor(new org.apache.flink.runtime.taskmanager.DispatcherThreadFactory(org.apache.flink.streaming.runtime.tasks.StreamTask.TRIGGER_THREAD_GROUP, \"Time Trigger for \" + getName()));\n            init();\n            if (canceled) {\n                throw new org.apache.flink.runtime.execution.CancelTaskException();\n            }\n            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Invoking {}\", getName());\n            stateBackend = createStateBackend();\n            stateBackend.initializeForJob(org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment());\n            restoreState();\n            synchronized(lock) {\n                openAllOperators();\n            }\n            if (canceled) {\n                throw new org.apache.flink.runtime.execution.CancelTaskException();\n            }\n            isRunning = true;\n            run();\n            isRunning = false;\n            if (org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.isDebugEnabled()) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Finished task {}\", getName());\n            }\n            synchronized(lock) {\n                closeAllOperators();\n            }\n            operatorChain.flushOutputs();\n            tryDisposeAllOperators();\n            disposed = true;\n        } finally {\n            isRunning = false;\n            if (timerService != null) {\n                try {\n                    timerService.shutdownNow();\n                } catch (java.lang.Throwable t) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Could not shut down timer service\", t);\n                }\n            }\n            try {\n                for (java.lang.Thread checkpointThread : asyncCheckpointThreads) {\n                    checkpointThread.interrupt();\n                }\n                asyncCheckpointThreads.clear();\n            } catch (java.lang.Throwable t) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Could not shut down async checkpoint threads\", t);\n            }\n            if (operatorChain != null) {\n                operatorChain.releaseOutputs();\n            }\n            try {\n                cleanup();\n            } catch (java.lang.Throwable t) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Error during cleanup of stream task\", t);\n            }\n            if (!disposed) {\n                disposeAllOperators();\n            }\n            try {\n                if (stateBackend != null) {\n                    stateBackend.close();\n                }\n            } catch (java.lang.Throwable t) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Error while closing the state backend\", t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public final void cancel() throws java.lang.Exception {\n        isRunning = false;\n        canceled = true;\n        cancelTask();\n    }\n\n    public final boolean isRunning() {\n        return isRunning;\n    }\n\n    public final boolean isCanceled() {\n        return canceled;\n    }\n\n    private void openAllOperators() throws java.lang.Exception {\n        for (org.apache.flink.streaming.api.operators.StreamOperator<?> operator : operatorChain.getAllOperators()) {\n            if (operator != null) {\n                operator.open();\n            }\n        }\n    }\n\n    private void closeAllOperators() throws java.lang.Exception {\n        org.apache.flink.streaming.api.operators.StreamOperator<?>[] allOperators = operatorChain.getAllOperators();\n        for (int i = allOperators.length - 1; i >= 0; i--) {\n            org.apache.flink.streaming.api.operators.StreamOperator<?> operator = allOperators[i];\n            if (operator != null) {\n                operator.close();\n            }\n        }\n    }\n\n    private void tryDisposeAllOperators() throws java.lang.Exception {\n        for (org.apache.flink.streaming.api.operators.StreamOperator<?> operator : operatorChain.getAllOperators()) {\n            if (operator != null) {\n                operator.dispose();\n            }\n        }\n    }\n\n    private void disposeAllOperators() {\n        if (operatorChain != null) {\n            for (org.apache.flink.streaming.api.operators.StreamOperator<?> operator : operatorChain.getAllOperators()) {\n                try {\n                    if (operator != null) {\n                        operator.dispose();\n                    }\n                } catch (java.lang.Throwable t) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Error during disposal of stream operator.\", t);\n                }\n            }\n        }\n    }\n\n    @java.lang.Override\n    protected void finalize() throws java.lang.Throwable {\n        super.finalize();\n        if (timerService != null) {\n            if (!timerService.isTerminated()) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.warn(\"Timer service was not shut down. Shutting down in finalize().\");\n            }\n            timerService.shutdownNow();\n        }\n        for (java.lang.Thread checkpointThread : asyncCheckpointThreads) {\n            checkpointThread.interrupt();\n        }\n    }\n\n    public java.lang.String getName() {\n        return org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getTaskInfo().getTaskNameWithSubtasks();\n    }\n\n    public java.lang.Object getCheckpointLock() {\n        return lock;\n    }\n\n    public org.apache.flink.streaming.api.graph.StreamConfig getConfiguration() {\n        return configuration;\n    }\n\n    public java.util.Map<java.lang.String, org.apache.flink.api.common.accumulators.Accumulator<?, ?>> getAccumulatorMap() {\n        return accumulatorMap;\n    }\n\n    public org.apache.flink.streaming.api.operators.Output<org.apache.flink.streaming.runtime.streamrecord.StreamRecord<OUT>> getHeadOutput() {\n        return operatorChain.getChainEntryPoint();\n    }\n\n    public org.apache.flink.streaming.runtime.io.RecordWriterOutput<?>[] getStreamOutputs() {\n        return operatorChain.getStreamOutputs();\n    }\n\n    @java.lang.Override\n    public void setInitialState(org.apache.flink.streaming.runtime.tasks.StreamTaskStateList initialState, long recoveryTimestamp) {\n        lazyRestoreState = initialState;\n        this.recoveryTimestamp = recoveryTimestamp;\n    }\n\n    private void restoreState() throws java.lang.Exception {\n        if (lazyRestoreState != null) {\n            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.info(\"Restoring checkpointed state to task {}\", getName());\n            try {\n                final org.apache.flink.streaming.api.operators.StreamOperator<?>[] allOperators = operatorChain.getAllOperators();\n                final org.apache.flink.streaming.runtime.tasks.StreamTaskState[] states = lazyRestoreState.getState(userClassLoader);\n                lazyRestoreState = null;\n                for (int i = 0; i < states.length; i++) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTaskState state = states[i];\n                    org.apache.flink.streaming.api.operators.StreamOperator<?> operator = allOperators[i];\n                    if ((state != null) && (operator != null)) {\n                        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Task {} in chain ({}) has checkpointed state\", i, getName());\n                        operator.restoreState(state, recoveryTimestamp);\n                    } else if (operator != null) {\n                        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Task {} in chain ({}) does not have checkpointed state\", i, getName());\n                    }\n                }\n            } catch (java.lang.Exception e) {\n                throw new java.lang.Exception(\"Could not restore checkpointed state to operators and functions\", e);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public boolean triggerCheckpoint(final long checkpointId, final long timestamp) throws java.lang.Exception {\n        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Starting checkpoint {} on task {}\", checkpointId, getName());\n        synchronized(lock) {\n            if (isRunning) {\n                operatorChain.broadcastCheckpointBarrier(checkpointId, timestamp);\n                final org.apache.flink.streaming.api.operators.StreamOperator<?>[] allOperators = operatorChain.getAllOperators();\n                final org.apache.flink.streaming.runtime.tasks.StreamTaskState[] states = new org.apache.flink.streaming.runtime.tasks.StreamTaskState[allOperators.length];\n                boolean hasAsyncStates = false;\n                for (int i = 0; i < states.length; i++) {\n                    org.apache.flink.streaming.api.operators.StreamOperator<?> operator = allOperators[i];\n                    if (operator != null) {\n                        org.apache.flink.streaming.runtime.tasks.StreamTaskState state = operator.snapshotOperatorState(checkpointId, timestamp);\n                        if (state.getOperatorState() instanceof org.apache.flink.runtime.state.AsynchronousStateHandle) {\n                            hasAsyncStates = true;\n                        }\n                        if (state.getFunctionState() instanceof org.apache.flink.runtime.state.AsynchronousStateHandle) {\n                            hasAsyncStates = true;\n                        }\n                        states[i] = (state.isEmpty()) ? null : state;\n                    }\n                }\n                if (!isRunning) {\n                    throw new org.apache.flink.runtime.execution.CancelTaskException();\n                }\n                org.apache.flink.streaming.runtime.tasks.StreamTaskStateList allStates = new org.apache.flink.streaming.runtime.tasks.StreamTaskStateList(states);\n                if (allStates.isEmpty()) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().acknowledgeCheckpoint(checkpointId);\n                } else if (!hasAsyncStates) {\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().acknowledgeCheckpoint(checkpointId, allStates);\n                } else {\n                    java.lang.String threadName = ((\"Materialize checkpoint \" + checkpointId) + \" for \") + getName();\n                    java.lang.Thread checkpointThread = new java.lang.Thread(threadName) {\n                        @java.lang.Override\n                        public void run() {\n                            try {\n                                for (org.apache.flink.streaming.runtime.tasks.StreamTaskState state : states) {\n                                    if (state != null) {\n                                        if (state.getFunctionState() instanceof org.apache.flink.runtime.state.AsynchronousStateHandle) {\n                                            org.apache.flink.runtime.state.AsynchronousStateHandle<java.io.Serializable> asyncState = ((org.apache.flink.runtime.state.AsynchronousStateHandle<java.io.Serializable>) (state.getFunctionState()));\n                                            state.setFunctionState(asyncState.materialize());\n                                        }\n                                        if (state.getOperatorState() instanceof org.apache.flink.runtime.state.AsynchronousStateHandle) {\n                                            org.apache.flink.runtime.state.AsynchronousStateHandle<?> asyncState = ((org.apache.flink.runtime.state.AsynchronousStateHandle<?>) (state.getOperatorState()));\n                                            state.setOperatorState(asyncState.materialize());\n                                        }\n                                    }\n                                }\n                                org.apache.flink.streaming.runtime.tasks.StreamTaskStateList allStates = new org.apache.flink.streaming.runtime.tasks.StreamTaskStateList(states);\n                                org.apache.flink.streaming.runtime.tasks.StreamTask.1.getEnvironment().acknowledgeCheckpoint(checkpointId, allStates);\n                            } catch (java.lang.Exception e) {\n                                if (isRunning()) {\n                                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Caught exception while materializing asynchronous checkpoints.\", e);\n                                }\n                                if (asyncException == null) {\n                                    asyncException = new org.apache.flink.streaming.runtime.tasks.AsynchronousException(e);\n                                }\n                            }\n                            asyncCheckpointThreads.remove(this);\n                            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Finished asynchronous checkpoints for checkpoint {} on task {}\", checkpointId, getName());\n                        }\n                    };\n                    asyncCheckpointThreads.add(checkpointThread);\n                    checkpointThread.setDaemon(true);\n                    checkpointThread.start();\n                }\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void notifyCheckpointComplete(long checkpointId) throws java.lang.Exception {\n        synchronized(lock) {\n            if (isRunning) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Notification of complete checkpoint for task {}\", getName());\n                if (stateBackend instanceof org.apache.flink.streaming.api.checkpoint.CheckpointNotifier) {\n                    ((org.apache.flink.streaming.api.checkpoint.CheckpointNotifier) (stateBackend)).notifyCheckpointComplete(checkpointId);\n                }\n                for (org.apache.flink.streaming.api.operators.StreamOperator<?> operator : operatorChain.getAllOperators()) {\n                    if (operator != null) {\n                        operator.notifyOfCompletedCheckpoint(checkpointId);\n                    }\n                }\n            } else {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Ignoring notification of complete checkpoint for not-running task {}\", getName());\n            }\n        }\n    }\n\n    public org.apache.flink.runtime.state.StateBackend<?> getStateBackend() {\n        return stateBackend;\n    }\n\n    private org.apache.flink.runtime.state.StateBackend<?> createStateBackend() throws java.lang.Exception {\n        org.apache.flink.runtime.state.StateBackend<?> configuredBackend = configuration.getStateBackend(userClassLoader);\n        if (configuredBackend != null) {\n            org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.info(\"Using user-defined state backend: \" + configuredBackend);\n            return configuredBackend;\n        } else {\n            org.apache.flink.configuration.Configuration flinkConfig = org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getTaskManagerInfo().getConfiguration();\n            java.lang.String backendName = flinkConfig.getString(ConfigConstants.STATE_BACKEND, null);\n            if (backendName == null) {\n                org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.warn(\"No state backend has been specified, using default state backend (Memory / JobManager)\");\n                backendName = \"jobmanager\";\n            }\n            backendName = backendName.toLowerCase();\n            switch (backendName) {\n                case \"jobmanager\" :\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.info(\"State backend is set to heap memory (checkpoint to jobmanager)\");\n                    return org.apache.flink.runtime.state.memory.MemoryStateBackend.defaultInstance();\n                case \"filesystem\" :\n                    org.apache.flink.runtime.state.filesystem.FsStateBackend backend = new org.apache.flink.runtime.state.filesystem.FsStateBackendFactory().createFromConfig(flinkConfig);\n                    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.info((\"State backend is set to filesystem (checkpoints to filesystem \\\"\" + backend.getBasePath()) + \"\\\")\");\n                    return backend;\n                default :\n                    try {\n                        @java.lang.SuppressWarnings(\"rawtypes\")\n                        java.lang.Class<? extends org.apache.flink.runtime.state.StateBackendFactory> clazz = java.lang.Class.forName(backendName, false, userClassLoader).asSubclass(org.apache.flink.runtime.state.StateBackendFactory.class);\n                        return clazz.newInstance().createFromConfig(flinkConfig);\n                    } catch (java.lang.ClassNotFoundException e) {\n                        throw new org.apache.flink.configuration.IllegalConfigurationException(\"Cannot find configured state backend: \" + backendName);\n                    } catch (java.lang.ClassCastException e) {\n                        throw new org.apache.flink.configuration.IllegalConfigurationException((((\"The class configured under '\" + org.apache.flink.configuration.ConfigConstants.STATE_BACKEND) + \"' is not a valid state backend factory (\") + backendName) + ')');\n                    } catch (java.lang.Throwable t) {\n                        throw new org.apache.flink.configuration.IllegalConfigurationException(\"Cannot create configured state backend\", t);\n                    }\n            }\n        }\n    }\n\n    public void registerTimer(final long timestamp, final org.apache.flink.streaming.runtime.operators.Triggerable target) {\n        long delay = java.lang.Math.max(timestamp - java.lang.System.currentTimeMillis(), 0);\n        timerService.schedule(new org.apache.flink.streaming.runtime.tasks.StreamTask.TriggerTask(this, lock, target, timestamp), delay, java.util.concurrent.TimeUnit.MILLISECONDS);\n    }\n\n    public void checkTimerException() throws org.apache.flink.streaming.runtime.tasks.TimerException {\n        if (asyncException != null) {\n            throw asyncException;\n        }\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return getName();\n    }\n\n    protected final org.apache.flink.runtime.util.event.EventListener<org.apache.flink.runtime.io.network.api.CheckpointBarrier> getCheckpointBarrierListener() {\n        return new org.apache.flink.runtime.util.event.EventListener<org.apache.flink.runtime.io.network.api.CheckpointBarrier>() {\n            @java.lang.Override\n            public void onEvent(org.apache.flink.runtime.io.network.api.CheckpointBarrier barrier) {\n                try {\n                    triggerCheckpoint(barrier.getId(), barrier.getTimestamp());\n                } catch (java.lang.Exception e) {\n                    throw new java.lang.RuntimeException(\"Error triggering a checkpoint as the result of receiving checkpoint barrier\", e);\n                }\n            }\n        };\n    }\n\n    private static final class TriggerTask implements java.lang.Runnable {\n        private final java.lang.Object lock;\n\n        private final org.apache.flink.streaming.runtime.operators.Triggerable target;\n\n        private final long timestamp;\n\n        private final org.apache.flink.streaming.runtime.tasks.StreamTask<?, ?> task;\n\n        TriggerTask(org.apache.flink.streaming.runtime.tasks.StreamTask<?, ?> task, final java.lang.Object lock, org.apache.flink.streaming.runtime.operators.Triggerable target, long timestamp) {\n            this.task = task;\n            this.lock = lock;\n            this.target = target;\n            this.timestamp = timestamp;\n        }\n\n        @java.lang.Override\n        public void run() {\n            synchronized(lock) {\n                try {\n                    target.trigger(timestamp);\n                } catch (java.lang.Throwable t) {\n                    if (task.isRunning) {\n                        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.error(\"Caught exception while processing timer.\", t);\n                    }\n                    if (task.asyncException == null) {\n                        task.asyncException = new org.apache.flink.streaming.runtime.tasks.TimerException(t);\n                    }\n                }\n            }\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "canceled = true",
            "src_parent": "{\n    isRunning = false;\n    canceled = true;\n    cancelTask();\n}",
            "src_parent_type": "Block",
            "src_type": "Assignment"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (canceled) {\n    throw new org.apache.flink.runtime.execution.CancelTaskException();\n}",
            "src_parent": "{\n    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Initializing {}\", getName());\n    userClassLoader = org.apache.flink.streaming.runtime.tasks.StreamTask.getUserCodeClassLoader();\n    configuration = new org.apache.flink.streaming.api.graph.StreamConfig(org.apache.flink.streaming.runtime.tasks.StreamTask.getTaskConfiguration());\n    accumulatorMap = org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getAccumulatorRegistry().getUserMap();\n    headOperator = configuration.getStreamOperator(userClassLoader);\n    operatorChain = new org.apache.flink.streaming.runtime.tasks.OperatorChain(this, headOperator, org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getAccumulatorRegistry().getReadWriteReporter());\n    if (headOperator != null) {\n        headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());\n    }\n    timerService = java.util.concurrent.Executors.newSingleThreadScheduledExecutor(new org.apache.flink.runtime.taskmanager.DispatcherThreadFactory(org.apache.flink.streaming.runtime.tasks.StreamTask.TRIGGER_THREAD_GROUP, \"Time Trigger for \" + getName()));\n    init();\n    if (canceled) {\n        throw new org.apache.flink.runtime.execution.CancelTaskException();\n    }\n    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Invoking {}\", getName());\n    stateBackend = createStateBackend();\n    stateBackend.initializeForJob(org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment());\n    restoreState();\n    synchronized(lock) {\n        openAllOperators();\n    }\n    if (canceled) {\n        throw new org.apache.flink.runtime.execution.CancelTaskException();\n    }\n    isRunning = true;\n    run();\n    isRunning = false;\n    if (org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.isDebugEnabled()) {\n        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Finished task {}\", getName());\n    }\n    synchronized(lock) {\n        closeAllOperators();\n    }\n    operatorChain.flushOutputs();\n    tryDisposeAllOperators();\n    disposed = true;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "true",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (canceled) {\n    throw new org.apache.flink.runtime.execution.CancelTaskException();\n}",
            "src_parent": "{\n    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Initializing {}\", getName());\n    userClassLoader = org.apache.flink.streaming.runtime.tasks.StreamTask.getUserCodeClassLoader();\n    configuration = new org.apache.flink.streaming.api.graph.StreamConfig(org.apache.flink.streaming.runtime.tasks.StreamTask.getTaskConfiguration());\n    accumulatorMap = org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getAccumulatorRegistry().getUserMap();\n    headOperator = configuration.getStreamOperator(userClassLoader);\n    operatorChain = new org.apache.flink.streaming.runtime.tasks.OperatorChain(this, headOperator, org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment().getAccumulatorRegistry().getReadWriteReporter());\n    if (headOperator != null) {\n        headOperator.setup(this, configuration, operatorChain.getChainEntryPoint());\n    }\n    timerService = java.util.concurrent.Executors.newSingleThreadScheduledExecutor(new org.apache.flink.runtime.taskmanager.DispatcherThreadFactory(org.apache.flink.streaming.runtime.tasks.StreamTask.TRIGGER_THREAD_GROUP, \"Time Trigger for \" + getName()));\n    init();\n    if (canceled) {\n        throw new org.apache.flink.runtime.execution.CancelTaskException();\n    }\n    org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Invoking {}\", getName());\n    stateBackend = createStateBackend();\n    stateBackend.initializeForJob(org.apache.flink.streaming.runtime.tasks.StreamTask.getEnvironment());\n    restoreState();\n    synchronized(lock) {\n        openAllOperators();\n    }\n    if (canceled) {\n        throw new org.apache.flink.runtime.execution.CancelTaskException();\n    }\n    isRunning = true;\n    run();\n    isRunning = false;\n    if (org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.isDebugEnabled()) {\n        org.apache.flink.streaming.runtime.tasks.StreamTask.LOG.debug(\"Finished task {}\", getName());\n    }\n    synchronized(lock) {\n        closeAllOperators();\n    }\n    operatorChain.flushOutputs();\n    tryDisposeAllOperators();\n    disposed = true;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        }
      ],
      "file_name": "StreamTask"
    }
  ],
  "id": "flink_8fc7e7af"
}