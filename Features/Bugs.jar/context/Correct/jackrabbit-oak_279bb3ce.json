{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@javax.annotation.CheckForNull\nprivate java.lang.String getCommitRootDepth(@javax.annotation.Nonnull\norg.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n    java.lang.String depth = local.get(revision);\n    if (depth == null) {\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n            depth = prev.getCommitRootDepth(revision);\n            if (depth != null) {\n                break;\n            }\n        }\n    }\n    return depth;\n}",
            "dst_parent": "public final class NodeDocument extends org.apache.jackrabbit.oak.plugins.document.Document implements org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument {\n    public static final org.apache.jackrabbit.oak.plugins.document.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(new org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore());\n\n    static {\n        NULL.seal();\n    }\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.NodeDocument.class);\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 8 * 1024;\n\n    static final int DOC_SIZE_THRESHOLD = 256 * 1024;\n\n    static final int NUM_REVS_THRESHOLD = 100;\n\n    static final float SPLIT_RATIO = 0.3F;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    public static final java.lang.String MODIFIED = \"_modified\";\n\n    private static final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> EMPTY_RANGE_MAP = com.google.common.collect.Maps.unmodifiableNavigableMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    private static final java.lang.String CHILDREN_FLAG = \"_children\";\n\n    private static final java.util.Set<java.lang.String> IGNORE_ON_SPLIT = com.google.common.collect.ImmutableSet.of(org.apache.jackrabbit.oak.plugins.document.ID, org.apache.jackrabbit.oak.plugins.document.MOD_COUNT, org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG);\n\n    final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous;\n\n    private final java.util.concurrent.atomic.AtomicLong lastCheckTime = new java.util.concurrent.atomic.AtomicLong(java.lang.System.currentTimeMillis());\n\n    private final long creationTime;\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store) {\n        this(store, java.lang.System.currentTimeMillis());\n    }\n\n    public NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store, long creationTime) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n        this.creationTime = creationTime;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getValueMap(@javax.annotation.Nonnull\n    java.lang.String key) {\n        java.lang.Object value = super.get(key);\n        if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(key) || (!(value instanceof java.util.Map))) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, key);\n        }\n    }\n\n    @java.lang.Override\n    public long getCreated() {\n        return creationTime;\n    }\n\n    public boolean hasChildren() {\n        java.lang.Boolean childrenFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG)));\n        return childrenFlag != null ? childrenFlag.booleanValue() : false;\n    }\n\n    @java.lang.Override\n    public void markUpToDate(long checkTime) {\n        lastCheckTime.set(checkTime);\n    }\n\n    @java.lang.Override\n    public boolean isUpToDate(long lastCheckTime) {\n        return lastCheckTime <= this.lastCheckTime.get();\n    }\n\n    @java.lang.Override\n    public long getLastCheckTime() {\n        return lastCheckTime.get();\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> map = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> e : valueMap.entrySet()) {\n            int clusterId = e.getKey().getClusterId();\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(e.getValue());\n            map.put(clusterId, rev);\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(revision);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : commitRootDoc.getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getLocalRevisions().containsKey(revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String depth = getCommitRootDepth(revision);\n        if (depth != null) {\n            if (depth.equals(\"0\")) {\n                return \"/\";\n            }\n            java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getNewestRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision changeRev, org.apache.jackrabbit.oak.plugins.document.CollisionHandler handler) {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> revisions = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commitRoots = getLocalCommitRoot();\n        org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : com.google.common.collect.Iterables.mergeSorted(java.util.Arrays.asList(revisions.keySet(), commitRoots.keySet()), revisions.comparator())) {\n            if (!r.equals(changeRev)) {\n                if (isValidRevision(context, r, null, changeRev, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>())) {\n                    newestRev = r;\n                    break;\n                } else {\n                    handler.concurrentModification(r);\n                }\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.lang.String value = getDeleted().get(newestRev);\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, commitValue, readRevision)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNodeAtRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision lastModified) {\n        java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions = new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>();\n        org.apache.jackrabbit.oak.plugins.document.Revision min = getLiveRevision(nodeStore, readRevision, validRevisions);\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = min;\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions);\n            if ((value == null) && (!getPreviousRanges().isEmpty())) {\n                value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions);\n            }\n            java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.document.util.Utils.unescapePropertyName(key);\n            java.lang.String v = (value != null) ? value.value : null;\n            n.setProperty(propertyName, v);\n            if ((value != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n                lastRevision = value.revision;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch branch = nodeStore.getBranches().getBranch(readRevision);\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        if (lastModified != null) {\n            lastRevs.put(nodeStore.getClusterId(), lastModified);\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision branchBase = null;\n        if (branch != null) {\n            branchBase = branch.getBase(readRevision);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, readRevision)) {\n                lastRevision = readRevision;\n                continue;\n            } else if ((branchBase != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, branchBase)) {\n                r = branchBase;\n            }\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r.asBranchRevision();\n            }\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision maxRev, java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions);\n        if ((value == null) && (!getPreviousRanges().isEmpty())) {\n            value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions);\n        }\n        return (value != null) && value.value.equals(\"false\") ? value.revision : null;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getDeleted();\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, entry.getKey(), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> entry : op.getChanges().entrySet()) {\n            if (entry.getValue().type != Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            java.lang.String name = entry.getKey().getName();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.Revision rev : getValueMap(name).keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        if (((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) && (getMemory() < org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD)) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String id = getId();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous = getPreviousRanges();\n        org.apache.jackrabbit.oak.plugins.document.Revision recentPrevious = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision rev : previous.keySet()) {\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                recentPrevious = rev;\n            }\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>>();\n        for (java.lang.String property : data.keySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(property)) {\n                continue;\n            }\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision rev = entry.getKey();\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                    if (isCommitted(rev)) {\n                        splitMap.put(rev, entry.getValue());\n                    }\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.document.UpdateOp> splitOps = java.util.Collections.emptyList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.document.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        if (((high != null) && (low != null)) && ((numValues >= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) || (getMemory() > org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD))) {\n            splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp>(2);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp main = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setPrevious(main, high, low);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp old = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(id, high), true);\n            old.set(org.apache.jackrabbit.oak.plugins.document.ID, old.getId());\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument oldDoc = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(store);\n            org.apache.jackrabbit.oak.plugins.document.UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\n            if (oldDoc.getMemory() > (getMemory() * org.apache.jackrabbit.oak.plugins.document.NodeDocument.SPLIT_RATIO)) {\n                splitOps.add(old);\n                splitOps.add(main);\n            }\n        }\n        return splitOps;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.document.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>(StableRevisionComparator.REVERSE);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision high = entry.getKey();\n                    org.apache.jackrabbit.oak.plugins.document.Revision low = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(entry.getValue());\n                    transformed.put(high, new org.apache.jackrabbit.oak.plugins.document.Range(high, low));\n                }\n                previous = com.google.common.collect.Maps.unmodifiableNavigableMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocs(@javax.annotation.Nonnull\n    final java.lang.String property, @javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getPreviousRanges().isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        if (revision == null) {\n            return new org.apache.jackrabbit.oak.plugins.document.PropertyHistory(store, this, property);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = getPreviousRanges().floorKey(revision);\n            if (r != null) {\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev != null) {\n                    if (prev.getValueMap(property).containsKey(revision)) {\n                        return java.util.Collections.singleton(prev);\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n            }\n            return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(getPreviousRanges().headMap(revision).entrySet(), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> input) {\n                    if (input.getValue().includes(revision)) {\n                        org.apache.jackrabbit.oak.plugins.document.Revision r = input.getKey();\n                        java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                        if (prev != null) {\n                            return prev;\n                        } else {\n                            org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                        }\n                    }\n                    return null;\n                }\n            }), new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public boolean apply(@javax.annotation.Nullable\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument input) {\n                    return (input != null) && input.getValueMap(property).containsKey(revision);\n                }\n            });\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>) (data.get(key)));\n        if (map == null) {\n            map = ValueMap.EMPTY;\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    public static void setChildrenFlag(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, boolean hasChildNode) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, java.lang.Boolean.valueOf(hasChildNode));\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.Commit.getModified(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static boolean isRevisionsEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS.equals(name);\n    }\n\n    public static void removeRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void removeCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, revision.getClusterId()), revision.toString());\n    }\n\n    public static boolean hasLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        return com.google.common.base.Preconditions.checkNotNull(op).getChanges().containsKey(new org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId)));\n    }\n\n    public static void unsetLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId));\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void removeCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision);\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, boolean deleted) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(deleted));\n    }\n\n    public static void removeDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, revision);\n    }\n\n    public static void setPrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision high, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision low) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(high), com.google.common.base.Preconditions.checkNotNull(low).toString());\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev);\n        if (commitRootPath == null) {\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitRootDepth(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n        java.lang.String depth = local.get(revision);\n        if (depth == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n                depth = prev.getCommitRootDepth(revision);\n                if (depth != null) {\n                    break;\n                }\n            }\n        }\n        return depth;\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        if (commitValue == null) {\n            commitValue = getCommitValue(revision);\n        }\n        if (commitValue == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue);\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String value = getLocalRevisions().get(revision);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n                value = prev.getCommitValue(revision);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision x, org.apache.jackrabbit.oak.plugins.document.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision latestRev = null;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision propRev = entry.getKey();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, propRev, readRevision)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(propRev);\n            if (commitRoot == null) {\n                continue;\n            }\n            java.lang.String commitValue = commitRoot.getCommitValue(propRev);\n            if (commitValue == null) {\n                continue;\n            }\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, min, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue))) {\n                continue;\n            }\n            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                latestRev = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue);\n                value = entry.getValue();\n                break;\n            }\n        }\n        return value != null ? new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(value, latestRev) : null;\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getCommitRoot() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    static final class Children implements java.lang.Cloneable , org.apache.jackrabbit.oak.cache.CacheValue {\n        java.util.ArrayList<java.lang.String> childNames = new java.util.ArrayList<java.lang.String>();\n\n        boolean isComplete;\n\n        @java.lang.Override\n        public int getMemory() {\n            int size = 114;\n            for (java.lang.String name : childNames) {\n                size += (name.length() * 2) + 56;\n            }\n            return size;\n        }\n\n        @java.lang.SuppressWarnings(\"unchecked\")\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone() {\n            try {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children) (super.clone()));\n                clone.childNames = ((java.util.ArrayList<java.lang.String>) (childNames.clone()));\n                return clone;\n            } catch (java.lang.CloneNotSupportedException e) {\n                throw new java.lang.RuntimeException();\n            }\n        }\n    }\n\n    private static final class Value {\n        final java.lang.String value;\n\n        final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n        Value(@javax.annotation.Nonnull\n        java.lang.String value, @javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n            this.value = com.google.common.base.Preconditions.checkNotNull(value);\n            this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n        }\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "@javax.annotation.CheckForNull\npublic java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n    java.lang.String depth = local.get(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n        java.lang.String path = prev.getCommitRootPath(revision);\n        if (path != null) {\n            return path;\n        }\n    }\n    return null;\n}",
            "src_parent": "public final class NodeDocument extends org.apache.jackrabbit.oak.plugins.document.Document implements org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument {\n    public static final org.apache.jackrabbit.oak.plugins.document.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(new org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore());\n\n    static {\n        NULL.seal();\n    }\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.NodeDocument.class);\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 8 * 1024;\n\n    static final int DOC_SIZE_THRESHOLD = 256 * 1024;\n\n    static final int NUM_REVS_THRESHOLD = 100;\n\n    static final float SPLIT_RATIO = 0.3F;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    public static final java.lang.String MODIFIED = \"_modified\";\n\n    private static final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> EMPTY_RANGE_MAP = com.google.common.collect.Maps.unmodifiableNavigableMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    private static final java.lang.String CHILDREN_FLAG = \"_children\";\n\n    private static final java.util.Set<java.lang.String> IGNORE_ON_SPLIT = com.google.common.collect.ImmutableSet.of(org.apache.jackrabbit.oak.plugins.document.ID, org.apache.jackrabbit.oak.plugins.document.MOD_COUNT, org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG);\n\n    final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous;\n\n    private final java.util.concurrent.atomic.AtomicLong lastCheckTime = new java.util.concurrent.atomic.AtomicLong(java.lang.System.currentTimeMillis());\n\n    private final long creationTime;\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store) {\n        this(store, java.lang.System.currentTimeMillis());\n    }\n\n    public NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store, long creationTime) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n        this.creationTime = creationTime;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getValueMap(@javax.annotation.Nonnull\n    java.lang.String key) {\n        java.lang.Object value = super.get(key);\n        if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(key) || (!(value instanceof java.util.Map))) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, key);\n        }\n    }\n\n    @java.lang.Override\n    public long getCreated() {\n        return creationTime;\n    }\n\n    public boolean hasChildren() {\n        java.lang.Boolean childrenFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG)));\n        return childrenFlag != null ? childrenFlag.booleanValue() : false;\n    }\n\n    @java.lang.Override\n    public void markUpToDate(long checkTime) {\n        lastCheckTime.set(checkTime);\n    }\n\n    @java.lang.Override\n    public boolean isUpToDate(long lastCheckTime) {\n        return lastCheckTime <= this.lastCheckTime.get();\n    }\n\n    @java.lang.Override\n    public long getLastCheckTime() {\n        return lastCheckTime.get();\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> map = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> e : valueMap.entrySet()) {\n            int clusterId = e.getKey().getClusterId();\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(e.getValue());\n            map.put(clusterId, rev);\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(revision);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : commitRootDoc.getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getLocalRevisions().containsKey(revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n        java.lang.String depth = local.get(revision);\n        if (depth != null) {\n            if (depth.equals(\"0\")) {\n                return \"/\";\n            }\n            java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n            java.lang.String path = prev.getCommitRootPath(revision);\n            if (path != null) {\n                return path;\n            }\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getNewestRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision changeRev, org.apache.jackrabbit.oak.plugins.document.CollisionHandler handler) {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> revisions = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commitRoots = getLocalCommitRoot();\n        org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : com.google.common.collect.Iterables.mergeSorted(java.util.Arrays.asList(revisions.keySet(), commitRoots.keySet()), revisions.comparator())) {\n            if (!r.equals(changeRev)) {\n                if (isValidRevision(context, r, null, changeRev, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>())) {\n                    newestRev = r;\n                    break;\n                } else {\n                    handler.concurrentModification(r);\n                }\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.lang.String value = getDeleted().get(newestRev);\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, commitValue, readRevision)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNodeAtRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision lastModified) {\n        java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions = new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>();\n        org.apache.jackrabbit.oak.plugins.document.Revision min = getLiveRevision(nodeStore, readRevision, validRevisions);\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = min;\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions);\n            if ((value == null) && (!getPreviousRanges().isEmpty())) {\n                value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions);\n            }\n            java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.document.util.Utils.unescapePropertyName(key);\n            java.lang.String v = (value != null) ? value.value : null;\n            n.setProperty(propertyName, v);\n            if ((value != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n                lastRevision = value.revision;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch branch = nodeStore.getBranches().getBranch(readRevision);\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        if (lastModified != null) {\n            lastRevs.put(nodeStore.getClusterId(), lastModified);\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision branchBase = null;\n        if (branch != null) {\n            branchBase = branch.getBase(readRevision);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, readRevision)) {\n                lastRevision = readRevision;\n                continue;\n            } else if ((branchBase != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, branchBase)) {\n                r = branchBase;\n            }\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r.asBranchRevision();\n            }\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision maxRev, java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions);\n        if ((value == null) && (!getPreviousRanges().isEmpty())) {\n            value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions);\n        }\n        return (value != null) && value.value.equals(\"false\") ? value.revision : null;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getDeleted();\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, entry.getKey(), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> entry : op.getChanges().entrySet()) {\n            if (entry.getValue().type != Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            java.lang.String name = entry.getKey().getName();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.Revision rev : getValueMap(name).keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        if (((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) && (getMemory() < org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD)) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String id = getId();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous = getPreviousRanges();\n        org.apache.jackrabbit.oak.plugins.document.Revision recentPrevious = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision rev : previous.keySet()) {\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                recentPrevious = rev;\n            }\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>>();\n        for (java.lang.String property : data.keySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(property)) {\n                continue;\n            }\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision rev = entry.getKey();\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                    if (isCommitted(rev)) {\n                        splitMap.put(rev, entry.getValue());\n                    }\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.document.UpdateOp> splitOps = java.util.Collections.emptyList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.document.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        if (((high != null) && (low != null)) && ((numValues >= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) || (getMemory() > org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD))) {\n            splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp>(2);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp main = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setPrevious(main, high, low);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp old = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(id, high), true);\n            old.set(org.apache.jackrabbit.oak.plugins.document.ID, old.getId());\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument oldDoc = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(store);\n            org.apache.jackrabbit.oak.plugins.document.UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\n            if (oldDoc.getMemory() > (getMemory() * org.apache.jackrabbit.oak.plugins.document.NodeDocument.SPLIT_RATIO)) {\n                splitOps.add(old);\n                splitOps.add(main);\n            }\n        }\n        return splitOps;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.document.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>(StableRevisionComparator.REVERSE);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision high = entry.getKey();\n                    org.apache.jackrabbit.oak.plugins.document.Revision low = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(entry.getValue());\n                    transformed.put(high, new org.apache.jackrabbit.oak.plugins.document.Range(high, low));\n                }\n                previous = com.google.common.collect.Maps.unmodifiableNavigableMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocs(@javax.annotation.Nonnull\n    final java.lang.String property, @javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getPreviousRanges().isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        if (revision == null) {\n            return new org.apache.jackrabbit.oak.plugins.document.PropertyHistory(store, this, property);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = getPreviousRanges().floorKey(revision);\n            if (r != null) {\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev != null) {\n                    if (prev.getValueMap(property).containsKey(revision)) {\n                        return java.util.Collections.singleton(prev);\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n            }\n            return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(getPreviousRanges().headMap(revision).entrySet(), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> input) {\n                    if (input.getValue().includes(revision)) {\n                        org.apache.jackrabbit.oak.plugins.document.Revision r = input.getKey();\n                        java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                        if (prev != null) {\n                            return prev;\n                        } else {\n                            org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                        }\n                    }\n                    return null;\n                }\n            }), new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public boolean apply(@javax.annotation.Nullable\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument input) {\n                    return (input != null) && input.getValueMap(property).containsKey(revision);\n                }\n            });\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>) (data.get(key)));\n        if (map == null) {\n            map = ValueMap.EMPTY;\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    public static void setChildrenFlag(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, boolean hasChildNode) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, java.lang.Boolean.valueOf(hasChildNode));\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.Commit.getModified(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static boolean isRevisionsEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS.equals(name);\n    }\n\n    public static void removeRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void removeCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, revision.getClusterId()), revision.toString());\n    }\n\n    public static boolean hasLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        return com.google.common.base.Preconditions.checkNotNull(op).getChanges().containsKey(new org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId)));\n    }\n\n    public static void unsetLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId));\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void removeCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision);\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, boolean deleted) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(deleted));\n    }\n\n    public static void removeDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, revision);\n    }\n\n    public static void setPrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision high, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision low) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(high), com.google.common.base.Preconditions.checkNotNull(low).toString());\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev);\n        if (commitRootPath == null) {\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        if (commitValue == null) {\n            commitValue = getCommitValue(revision);\n        }\n        if (commitValue == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue);\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String value = getLocalRevisions().get(revision);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n                value = prev.getCommitValue(revision);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision x, org.apache.jackrabbit.oak.plugins.document.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision latestRev = null;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision propRev = entry.getKey();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, propRev, readRevision)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(propRev);\n            if (commitRoot == null) {\n                continue;\n            }\n            java.lang.String commitValue = commitRoot.getCommitValue(propRev);\n            if (commitValue == null) {\n                continue;\n            }\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, min, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue))) {\n                continue;\n            }\n            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                latestRev = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue);\n                value = entry.getValue();\n                break;\n            }\n        }\n        return value != null ? new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(value, latestRev) : null;\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getCommitRoot() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    static final class Children implements java.lang.Cloneable , org.apache.jackrabbit.oak.cache.CacheValue {\n        java.util.ArrayList<java.lang.String> childNames = new java.util.ArrayList<java.lang.String>();\n\n        boolean isComplete;\n\n        @java.lang.Override\n        public int getMemory() {\n            int size = 114;\n            for (java.lang.String name : childNames) {\n                size += (name.length() * 2) + 56;\n            }\n            return size;\n        }\n\n        @java.lang.SuppressWarnings(\"unchecked\")\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone() {\n            try {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children) (super.clone()));\n                clone.childNames = ((java.util.ArrayList<java.lang.String>) (childNames.clone()));\n                return clone;\n            } catch (java.lang.CloneNotSupportedException e) {\n                throw new java.lang.RuntimeException();\n            }\n        }\n    }\n\n    private static final class Value {\n        final java.lang.String value;\n\n        final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n        Value(@javax.annotation.Nonnull\n        java.lang.String value, @javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n            this.value = com.google.common.base.Preconditions.checkNotNull(value);\n            this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "depth",
            "dst_parent": "depth != null",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "VariableRead",
            "operator": "UPD",
            "src": "path",
            "src_parent": "path != null",
            "src_parent_type": "BinaryOperator",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "return path",
            "src_parent": "{\n    return path;\n}",
            "src_parent_type": "Block",
            "src_type": "Return"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "@javax.annotation.CheckForNull\npublic java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    java.lang.String depth = getCommitRootDepth(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    return null;\n}",
            "src_parent": "public final class NodeDocument extends org.apache.jackrabbit.oak.plugins.document.Document implements org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument {\n    public static final org.apache.jackrabbit.oak.plugins.document.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(new org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore());\n\n    static {\n        NULL.seal();\n    }\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.NodeDocument.class);\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 8 * 1024;\n\n    static final int DOC_SIZE_THRESHOLD = 256 * 1024;\n\n    static final int NUM_REVS_THRESHOLD = 100;\n\n    static final float SPLIT_RATIO = 0.3F;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    public static final java.lang.String MODIFIED = \"_modified\";\n\n    private static final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> EMPTY_RANGE_MAP = com.google.common.collect.Maps.unmodifiableNavigableMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    private static final java.lang.String CHILDREN_FLAG = \"_children\";\n\n    private static final java.util.Set<java.lang.String> IGNORE_ON_SPLIT = com.google.common.collect.ImmutableSet.of(org.apache.jackrabbit.oak.plugins.document.ID, org.apache.jackrabbit.oak.plugins.document.MOD_COUNT, org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG);\n\n    final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous;\n\n    private final java.util.concurrent.atomic.AtomicLong lastCheckTime = new java.util.concurrent.atomic.AtomicLong(java.lang.System.currentTimeMillis());\n\n    private final long creationTime;\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store) {\n        this(store, java.lang.System.currentTimeMillis());\n    }\n\n    public NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store, long creationTime) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n        this.creationTime = creationTime;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getValueMap(@javax.annotation.Nonnull\n    java.lang.String key) {\n        java.lang.Object value = super.get(key);\n        if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(key) || (!(value instanceof java.util.Map))) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, key);\n        }\n    }\n\n    @java.lang.Override\n    public long getCreated() {\n        return creationTime;\n    }\n\n    public boolean hasChildren() {\n        java.lang.Boolean childrenFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG)));\n        return childrenFlag != null ? childrenFlag.booleanValue() : false;\n    }\n\n    @java.lang.Override\n    public void markUpToDate(long checkTime) {\n        lastCheckTime.set(checkTime);\n    }\n\n    @java.lang.Override\n    public boolean isUpToDate(long lastCheckTime) {\n        return lastCheckTime <= this.lastCheckTime.get();\n    }\n\n    @java.lang.Override\n    public long getLastCheckTime() {\n        return lastCheckTime.get();\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> map = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> e : valueMap.entrySet()) {\n            int clusterId = e.getKey().getClusterId();\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(e.getValue());\n            map.put(clusterId, rev);\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(revision);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : commitRootDoc.getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getLocalRevisions().containsKey(revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String depth = getCommitRootDepth(revision);\n        if (depth != null) {\n            if (depth.equals(\"0\")) {\n                return \"/\";\n            }\n            java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getNewestRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision changeRev, org.apache.jackrabbit.oak.plugins.document.CollisionHandler handler) {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> revisions = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commitRoots = getLocalCommitRoot();\n        org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : com.google.common.collect.Iterables.mergeSorted(java.util.Arrays.asList(revisions.keySet(), commitRoots.keySet()), revisions.comparator())) {\n            if (!r.equals(changeRev)) {\n                if (isValidRevision(context, r, null, changeRev, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>())) {\n                    newestRev = r;\n                    break;\n                } else {\n                    handler.concurrentModification(r);\n                }\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.lang.String value = getDeleted().get(newestRev);\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, commitValue, readRevision)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNodeAtRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision lastModified) {\n        java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions = new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>();\n        org.apache.jackrabbit.oak.plugins.document.Revision min = getLiveRevision(nodeStore, readRevision, validRevisions);\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = min;\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions);\n            if ((value == null) && (!getPreviousRanges().isEmpty())) {\n                value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions);\n            }\n            java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.document.util.Utils.unescapePropertyName(key);\n            java.lang.String v = (value != null) ? value.value : null;\n            n.setProperty(propertyName, v);\n            if ((value != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n                lastRevision = value.revision;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch branch = nodeStore.getBranches().getBranch(readRevision);\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        if (lastModified != null) {\n            lastRevs.put(nodeStore.getClusterId(), lastModified);\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision branchBase = null;\n        if (branch != null) {\n            branchBase = branch.getBase(readRevision);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, readRevision)) {\n                lastRevision = readRevision;\n                continue;\n            } else if ((branchBase != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, branchBase)) {\n                r = branchBase;\n            }\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r.asBranchRevision();\n            }\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision maxRev, java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions);\n        if ((value == null) && (!getPreviousRanges().isEmpty())) {\n            value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions);\n        }\n        return (value != null) && value.value.equals(\"false\") ? value.revision : null;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getDeleted();\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, entry.getKey(), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> entry : op.getChanges().entrySet()) {\n            if (entry.getValue().type != Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            java.lang.String name = entry.getKey().getName();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.Revision rev : getValueMap(name).keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        if (((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) && (getMemory() < org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD)) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String id = getId();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous = getPreviousRanges();\n        org.apache.jackrabbit.oak.plugins.document.Revision recentPrevious = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision rev : previous.keySet()) {\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                recentPrevious = rev;\n            }\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>>();\n        for (java.lang.String property : data.keySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(property)) {\n                continue;\n            }\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision rev = entry.getKey();\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                    if (isCommitted(rev)) {\n                        splitMap.put(rev, entry.getValue());\n                    }\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.document.UpdateOp> splitOps = java.util.Collections.emptyList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.document.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        if (((high != null) && (low != null)) && ((numValues >= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) || (getMemory() > org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD))) {\n            splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp>(2);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp main = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setPrevious(main, high, low);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp old = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(id, high), true);\n            old.set(org.apache.jackrabbit.oak.plugins.document.ID, old.getId());\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument oldDoc = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(store);\n            org.apache.jackrabbit.oak.plugins.document.UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\n            if (oldDoc.getMemory() > (getMemory() * org.apache.jackrabbit.oak.plugins.document.NodeDocument.SPLIT_RATIO)) {\n                splitOps.add(old);\n                splitOps.add(main);\n            }\n        }\n        return splitOps;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.document.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>(StableRevisionComparator.REVERSE);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision high = entry.getKey();\n                    org.apache.jackrabbit.oak.plugins.document.Revision low = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(entry.getValue());\n                    transformed.put(high, new org.apache.jackrabbit.oak.plugins.document.Range(high, low));\n                }\n                previous = com.google.common.collect.Maps.unmodifiableNavigableMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocs(@javax.annotation.Nonnull\n    final java.lang.String property, @javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getPreviousRanges().isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        if (revision == null) {\n            return new org.apache.jackrabbit.oak.plugins.document.PropertyHistory(store, this, property);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = getPreviousRanges().floorKey(revision);\n            if (r != null) {\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev != null) {\n                    if (prev.getValueMap(property).containsKey(revision)) {\n                        return java.util.Collections.singleton(prev);\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n            }\n            return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(getPreviousRanges().headMap(revision).entrySet(), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> input) {\n                    if (input.getValue().includes(revision)) {\n                        org.apache.jackrabbit.oak.plugins.document.Revision r = input.getKey();\n                        java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                        if (prev != null) {\n                            return prev;\n                        } else {\n                            org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                        }\n                    }\n                    return null;\n                }\n            }), new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public boolean apply(@javax.annotation.Nullable\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument input) {\n                    return (input != null) && input.getValueMap(property).containsKey(revision);\n                }\n            });\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>) (data.get(key)));\n        if (map == null) {\n            map = ValueMap.EMPTY;\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    public static void setChildrenFlag(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, boolean hasChildNode) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, java.lang.Boolean.valueOf(hasChildNode));\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.Commit.getModified(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static boolean isRevisionsEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS.equals(name);\n    }\n\n    public static void removeRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void removeCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, revision.getClusterId()), revision.toString());\n    }\n\n    public static boolean hasLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        return com.google.common.base.Preconditions.checkNotNull(op).getChanges().containsKey(new org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId)));\n    }\n\n    public static void unsetLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId));\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void removeCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision);\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, boolean deleted) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(deleted));\n    }\n\n    public static void removeDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, revision);\n    }\n\n    public static void setPrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision high, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision low) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(high), com.google.common.base.Preconditions.checkNotNull(low).toString());\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev);\n        if (commitRootPath == null) {\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitRootDepth(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n        java.lang.String depth = local.get(revision);\n        if (depth == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n                depth = prev.getCommitRootDepth(revision);\n                if (depth != null) {\n                    break;\n                }\n            }\n        }\n        return depth;\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        if (commitValue == null) {\n            commitValue = getCommitValue(revision);\n        }\n        if (commitValue == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue);\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String value = getLocalRevisions().get(revision);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n                value = prev.getCommitValue(revision);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision x, org.apache.jackrabbit.oak.plugins.document.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision latestRev = null;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision propRev = entry.getKey();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, propRev, readRevision)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(propRev);\n            if (commitRoot == null) {\n                continue;\n            }\n            java.lang.String commitValue = commitRoot.getCommitValue(propRev);\n            if (commitValue == null) {\n                continue;\n            }\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, min, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue))) {\n                continue;\n            }\n            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                latestRev = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue);\n                value = entry.getValue();\n                break;\n            }\n        }\n        return value != null ? new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(value, latestRev) : null;\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getCommitRoot() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    static final class Children implements java.lang.Cloneable , org.apache.jackrabbit.oak.cache.CacheValue {\n        java.util.ArrayList<java.lang.String> childNames = new java.util.ArrayList<java.lang.String>();\n\n        boolean isComplete;\n\n        @java.lang.Override\n        public int getMemory() {\n            int size = 114;\n            for (java.lang.String name : childNames) {\n                size += (name.length() * 2) + 56;\n            }\n            return size;\n        }\n\n        @java.lang.SuppressWarnings(\"unchecked\")\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone() {\n            try {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children) (super.clone()));\n                clone.childNames = ((java.util.ArrayList<java.lang.String>) (childNames.clone()));\n                return clone;\n            } catch (java.lang.CloneNotSupportedException e) {\n                throw new java.lang.RuntimeException();\n            }\n        }\n    }\n\n    private static final class Value {\n        final java.lang.String value;\n\n        final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n        Value(@javax.annotation.Nonnull\n        java.lang.String value, @javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n            this.value = com.google.common.base.Preconditions.checkNotNull(value);\n            this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "break",
            "src_parent": "{\n    break;\n}",
            "src_parent_type": "Block",
            "src_type": "Break"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@javax.annotation.CheckForNull\nprivate java.lang.String getCommitRootDepth(@javax.annotation.Nonnull\norg.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n    java.lang.String depth = local.get(revision);\n    if (depth == null) {\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n            depth = prev.getCommitRootDepth(revision);\n            if (depth != null) {\n                break;\n            }\n        }\n    }\n    return depth;\n}",
            "dst_parent": "public final class NodeDocument extends org.apache.jackrabbit.oak.plugins.document.Document implements org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument {\n    public static final org.apache.jackrabbit.oak.plugins.document.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(new org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore());\n\n    static {\n        NULL.seal();\n    }\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.NodeDocument.class);\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 8 * 1024;\n\n    static final int DOC_SIZE_THRESHOLD = 256 * 1024;\n\n    static final int NUM_REVS_THRESHOLD = 100;\n\n    static final float SPLIT_RATIO = 0.3F;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    public static final java.lang.String MODIFIED = \"_modified\";\n\n    private static final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> EMPTY_RANGE_MAP = com.google.common.collect.Maps.unmodifiableNavigableMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    private static final java.lang.String CHILDREN_FLAG = \"_children\";\n\n    private static final java.util.Set<java.lang.String> IGNORE_ON_SPLIT = com.google.common.collect.ImmutableSet.of(org.apache.jackrabbit.oak.plugins.document.ID, org.apache.jackrabbit.oak.plugins.document.MOD_COUNT, org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG);\n\n    final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous;\n\n    private final java.util.concurrent.atomic.AtomicLong lastCheckTime = new java.util.concurrent.atomic.AtomicLong(java.lang.System.currentTimeMillis());\n\n    private final long creationTime;\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store) {\n        this(store, java.lang.System.currentTimeMillis());\n    }\n\n    public NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store, long creationTime) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n        this.creationTime = creationTime;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getValueMap(@javax.annotation.Nonnull\n    java.lang.String key) {\n        java.lang.Object value = super.get(key);\n        if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(key) || (!(value instanceof java.util.Map))) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, key);\n        }\n    }\n\n    @java.lang.Override\n    public long getCreated() {\n        return creationTime;\n    }\n\n    public boolean hasChildren() {\n        java.lang.Boolean childrenFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG)));\n        return childrenFlag != null ? childrenFlag.booleanValue() : false;\n    }\n\n    @java.lang.Override\n    public void markUpToDate(long checkTime) {\n        lastCheckTime.set(checkTime);\n    }\n\n    @java.lang.Override\n    public boolean isUpToDate(long lastCheckTime) {\n        return lastCheckTime <= this.lastCheckTime.get();\n    }\n\n    @java.lang.Override\n    public long getLastCheckTime() {\n        return lastCheckTime.get();\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> map = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> e : valueMap.entrySet()) {\n            int clusterId = e.getKey().getClusterId();\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(e.getValue());\n            map.put(clusterId, rev);\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(revision);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : commitRootDoc.getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getLocalRevisions().containsKey(revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String depth = getCommitRootDepth(revision);\n        if (depth != null) {\n            if (depth.equals(\"0\")) {\n                return \"/\";\n            }\n            java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getNewestRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision changeRev, org.apache.jackrabbit.oak.plugins.document.CollisionHandler handler) {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> revisions = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commitRoots = getLocalCommitRoot();\n        org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : com.google.common.collect.Iterables.mergeSorted(java.util.Arrays.asList(revisions.keySet(), commitRoots.keySet()), revisions.comparator())) {\n            if (!r.equals(changeRev)) {\n                if (isValidRevision(context, r, null, changeRev, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>())) {\n                    newestRev = r;\n                    break;\n                } else {\n                    handler.concurrentModification(r);\n                }\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.lang.String value = getDeleted().get(newestRev);\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, commitValue, readRevision)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNodeAtRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision lastModified) {\n        java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions = new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>();\n        org.apache.jackrabbit.oak.plugins.document.Revision min = getLiveRevision(nodeStore, readRevision, validRevisions);\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = min;\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions);\n            if ((value == null) && (!getPreviousRanges().isEmpty())) {\n                value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions);\n            }\n            java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.document.util.Utils.unescapePropertyName(key);\n            java.lang.String v = (value != null) ? value.value : null;\n            n.setProperty(propertyName, v);\n            if ((value != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n                lastRevision = value.revision;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch branch = nodeStore.getBranches().getBranch(readRevision);\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        if (lastModified != null) {\n            lastRevs.put(nodeStore.getClusterId(), lastModified);\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision branchBase = null;\n        if (branch != null) {\n            branchBase = branch.getBase(readRevision);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, readRevision)) {\n                lastRevision = readRevision;\n                continue;\n            } else if ((branchBase != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, branchBase)) {\n                r = branchBase;\n            }\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r.asBranchRevision();\n            }\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision maxRev, java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions);\n        if ((value == null) && (!getPreviousRanges().isEmpty())) {\n            value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions);\n        }\n        return (value != null) && value.value.equals(\"false\") ? value.revision : null;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getDeleted();\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, entry.getKey(), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> entry : op.getChanges().entrySet()) {\n            if (entry.getValue().type != Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            java.lang.String name = entry.getKey().getName();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.Revision rev : getValueMap(name).keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        if (((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) && (getMemory() < org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD)) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String id = getId();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous = getPreviousRanges();\n        org.apache.jackrabbit.oak.plugins.document.Revision recentPrevious = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision rev : previous.keySet()) {\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                recentPrevious = rev;\n            }\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>>();\n        for (java.lang.String property : data.keySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(property)) {\n                continue;\n            }\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision rev = entry.getKey();\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                    if (isCommitted(rev)) {\n                        splitMap.put(rev, entry.getValue());\n                    }\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.document.UpdateOp> splitOps = java.util.Collections.emptyList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.document.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        if (((high != null) && (low != null)) && ((numValues >= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) || (getMemory() > org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD))) {\n            splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp>(2);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp main = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setPrevious(main, high, low);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp old = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(id, high), true);\n            old.set(org.apache.jackrabbit.oak.plugins.document.ID, old.getId());\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument oldDoc = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(store);\n            org.apache.jackrabbit.oak.plugins.document.UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\n            if (oldDoc.getMemory() > (getMemory() * org.apache.jackrabbit.oak.plugins.document.NodeDocument.SPLIT_RATIO)) {\n                splitOps.add(old);\n                splitOps.add(main);\n            }\n        }\n        return splitOps;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.document.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>(StableRevisionComparator.REVERSE);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision high = entry.getKey();\n                    org.apache.jackrabbit.oak.plugins.document.Revision low = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(entry.getValue());\n                    transformed.put(high, new org.apache.jackrabbit.oak.plugins.document.Range(high, low));\n                }\n                previous = com.google.common.collect.Maps.unmodifiableNavigableMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocs(@javax.annotation.Nonnull\n    final java.lang.String property, @javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getPreviousRanges().isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        if (revision == null) {\n            return new org.apache.jackrabbit.oak.plugins.document.PropertyHistory(store, this, property);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = getPreviousRanges().floorKey(revision);\n            if (r != null) {\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev != null) {\n                    if (prev.getValueMap(property).containsKey(revision)) {\n                        return java.util.Collections.singleton(prev);\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n            }\n            return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(getPreviousRanges().headMap(revision).entrySet(), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> input) {\n                    if (input.getValue().includes(revision)) {\n                        org.apache.jackrabbit.oak.plugins.document.Revision r = input.getKey();\n                        java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                        if (prev != null) {\n                            return prev;\n                        } else {\n                            org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                        }\n                    }\n                    return null;\n                }\n            }), new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public boolean apply(@javax.annotation.Nullable\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument input) {\n                    return (input != null) && input.getValueMap(property).containsKey(revision);\n                }\n            });\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>) (data.get(key)));\n        if (map == null) {\n            map = ValueMap.EMPTY;\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    public static void setChildrenFlag(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, boolean hasChildNode) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, java.lang.Boolean.valueOf(hasChildNode));\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.Commit.getModified(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static boolean isRevisionsEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS.equals(name);\n    }\n\n    public static void removeRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void removeCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, revision.getClusterId()), revision.toString());\n    }\n\n    public static boolean hasLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        return com.google.common.base.Preconditions.checkNotNull(op).getChanges().containsKey(new org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId)));\n    }\n\n    public static void unsetLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId));\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void removeCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision);\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, boolean deleted) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(deleted));\n    }\n\n    public static void removeDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, revision);\n    }\n\n    public static void setPrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision high, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision low) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(high), com.google.common.base.Preconditions.checkNotNull(low).toString());\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev);\n        if (commitRootPath == null) {\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitRootDepth(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n        java.lang.String depth = local.get(revision);\n        if (depth == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n                depth = prev.getCommitRootDepth(revision);\n                if (depth != null) {\n                    break;\n                }\n            }\n        }\n        return depth;\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        if (commitValue == null) {\n            commitValue = getCommitValue(revision);\n        }\n        if (commitValue == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue);\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String value = getLocalRevisions().get(revision);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n                value = prev.getCommitValue(revision);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision x, org.apache.jackrabbit.oak.plugins.document.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision latestRev = null;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision propRev = entry.getKey();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, propRev, readRevision)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(propRev);\n            if (commitRoot == null) {\n                continue;\n            }\n            java.lang.String commitValue = commitRoot.getCommitValue(propRev);\n            if (commitValue == null) {\n                continue;\n            }\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, min, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue))) {\n                continue;\n            }\n            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                latestRev = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue);\n                value = entry.getValue();\n                break;\n            }\n        }\n        return value != null ? new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(value, latestRev) : null;\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getCommitRoot() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    static final class Children implements java.lang.Cloneable , org.apache.jackrabbit.oak.cache.CacheValue {\n        java.util.ArrayList<java.lang.String> childNames = new java.util.ArrayList<java.lang.String>();\n\n        boolean isComplete;\n\n        @java.lang.Override\n        public int getMemory() {\n            int size = 114;\n            for (java.lang.String name : childNames) {\n                size += (name.length() * 2) + 56;\n            }\n            return size;\n        }\n\n        @java.lang.SuppressWarnings(\"unchecked\")\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone() {\n            try {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children) (super.clone()));\n                clone.childNames = ((java.util.ArrayList<java.lang.String>) (childNames.clone()));\n                return clone;\n            } catch (java.lang.CloneNotSupportedException e) {\n                throw new java.lang.RuntimeException();\n            }\n        }\n    }\n\n    private static final class Value {\n        final java.lang.String value;\n\n        final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n        Value(@javax.annotation.Nonnull\n        java.lang.String value, @javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n            this.value = com.google.common.base.Preconditions.checkNotNull(value);\n            this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n        }\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "MOV",
            "src": "@javax.annotation.CheckForNull\npublic java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n    java.lang.String depth = local.get(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n        java.lang.String path = prev.getCommitRootPath(revision);\n        if (path != null) {\n            return path;\n        }\n    }\n    return null;\n}",
            "src_parent": "public final class NodeDocument extends org.apache.jackrabbit.oak.plugins.document.Document implements org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument {\n    public static final org.apache.jackrabbit.oak.plugins.document.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(new org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore());\n\n    static {\n        NULL.seal();\n    }\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.NodeDocument.class);\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 8 * 1024;\n\n    static final int DOC_SIZE_THRESHOLD = 256 * 1024;\n\n    static final int NUM_REVS_THRESHOLD = 100;\n\n    static final float SPLIT_RATIO = 0.3F;\n\n    static final java.lang.String COLLISIONS = \"_collisions\";\n\n    public static final java.lang.String MODIFIED = \"_modified\";\n\n    private static final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> EMPTY_RANGE_MAP = com.google.common.collect.Maps.unmodifiableNavigableMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>());\n\n    private static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    private static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    private static final java.lang.String CHILDREN_FLAG = \"_children\";\n\n    private static final java.util.Set<java.lang.String> IGNORE_ON_SPLIT = com.google.common.collect.ImmutableSet.of(org.apache.jackrabbit.oak.plugins.document.ID, org.apache.jackrabbit.oak.plugins.document.MOD_COUNT, org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG);\n\n    final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous;\n\n    private final java.util.concurrent.atomic.AtomicLong lastCheckTime = new java.util.concurrent.atomic.AtomicLong(java.lang.System.currentTimeMillis());\n\n    private final long creationTime;\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store) {\n        this(store, java.lang.System.currentTimeMillis());\n    }\n\n    public NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store, long creationTime) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n        this.creationTime = creationTime;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getValueMap(@javax.annotation.Nonnull\n    java.lang.String key) {\n        java.lang.Object value = super.get(key);\n        if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(key) || (!(value instanceof java.util.Map))) {\n            return java.util.Collections.emptyMap();\n        } else {\n            return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, key);\n        }\n    }\n\n    @java.lang.Override\n    public long getCreated() {\n        return creationTime;\n    }\n\n    public boolean hasChildren() {\n        java.lang.Boolean childrenFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG)));\n        return childrenFlag != null ? childrenFlag.booleanValue() : false;\n    }\n\n    @java.lang.Override\n    public void markUpToDate(long checkTime) {\n        lastCheckTime.set(checkTime);\n    }\n\n    @java.lang.Override\n    public boolean isUpToDate(long lastCheckTime) {\n        return lastCheckTime <= this.lastCheckTime.get();\n    }\n\n    @java.lang.Override\n    public long getLastCheckTime() {\n        return lastCheckTime.get();\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> map = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> e : valueMap.entrySet()) {\n            int clusterId = e.getKey().getClusterId();\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(e.getValue());\n            map.put(clusterId, rev);\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(revision);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : commitRootDoc.getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getLocalRevisions().containsKey(revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> getUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision> revisions = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Revision>(context.getRevisionComparator());\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n                if (r.getClusterId() == context.getClusterId()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision b = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commit.getValue());\n                    revisions.put(r, b);\n                }\n            }\n        }\n        return revisions;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n        java.lang.String depth = local.get(revision);\n        if (depth != null) {\n            if (depth.equals(\"0\")) {\n                return \"/\";\n            }\n            java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n            return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n            java.lang.String path = prev.getCommitRootPath(revision);\n            if (path != null) {\n                return path;\n            }\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getNewestRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision changeRev, org.apache.jackrabbit.oak.plugins.document.CollisionHandler handler) {\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> revisions = getLocalRevisions();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commitRoots = getLocalCommitRoot();\n        org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : com.google.common.collect.Iterables.mergeSorted(java.util.Arrays.asList(revisions.keySet(), commitRoots.keySet()), revisions.comparator())) {\n            if (!r.equals(changeRev)) {\n                if (isValidRevision(context, r, null, changeRev, new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>())) {\n                    newestRev = r;\n                    break;\n                } else {\n                    handler.concurrentModification(r);\n                }\n            }\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.lang.String value = getDeleted().get(newestRev);\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        if (validRevisions.contains(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, commitValue, readRevision)) {\n            validRevisions.add(rev);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNodeAtRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision lastModified) {\n        java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions = new java.util.HashSet<org.apache.jackrabbit.oak.plugins.document.Revision>();\n        org.apache.jackrabbit.oak.plugins.document.Revision min = getLiveRevision(nodeStore, readRevision, validRevisions);\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = min;\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(nodeStore, getLocalMap(key), min, readRevision, validRevisions);\n            if ((value == null) && (!getPreviousRanges().isEmpty())) {\n                value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions);\n            }\n            java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.document.util.Utils.unescapePropertyName(key);\n            java.lang.String v = (value != null) ? value.value : null;\n            n.setProperty(propertyName, v);\n            if ((value != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n                lastRevision = value.revision;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Branch branch = nodeStore.getBranches().getBranch(readRevision);\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> lastRevs = com.google.common.collect.Maps.newHashMap(getLastRev());\n        if (lastModified != null) {\n            lastRevs.put(nodeStore.getClusterId(), lastModified);\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision branchBase = null;\n        if (branch != null) {\n            branchBase = branch.getBase(readRevision);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : lastRevs.values()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, readRevision)) {\n                lastRevision = readRevision;\n                continue;\n            } else if ((branchBase != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, branchBase)) {\n                r = branchBase;\n            }\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(nodeStore, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = branch.getUnsavedLastRevision(path, readRevision);\n            if (r != null) {\n                lastRevision = r.asBranchRevision();\n            }\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision maxRev, java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions);\n        if ((value == null) && (!getPreviousRanges().isEmpty())) {\n            value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions);\n        }\n        return (value != null) && value.value.equals(\"false\") ? value.revision : null;\n    }\n\n    public boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getDeleted();\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : deleted.entrySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, entry.getKey(), baseRevision)) {\n                return true;\n            }\n        }\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> entry : op.getChanges().entrySet()) {\n            if (entry.getValue().type != Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            java.lang.String name = entry.getKey().getName();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.Revision rev : getValueMap(name).keySet()) {\n                if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        if (((getLocalRevisions().size() + getLocalCommitRoot().size()) <= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) && (getMemory() < org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD)) {\n            return java.util.Collections.emptyList();\n        }\n        java.lang.String id = getId();\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous = getPreviousRanges();\n        org.apache.jackrabbit.oak.plugins.document.Revision recentPrevious = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision rev : previous.keySet()) {\n            if (rev.getClusterId() != context.getClusterId()) {\n                continue;\n            }\n            if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                recentPrevious = rev;\n            }\n        }\n        java.util.Map<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>> splitValues = new java.util.HashMap<java.lang.String, java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>>();\n        for (java.lang.String property : data.keySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.IGNORE_ON_SPLIT.contains(property)) {\n                continue;\n            }\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>(context.getRevisionComparator());\n            splitValues.put(property, splitMap);\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(property);\n            for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.document.Revision rev = entry.getKey();\n                if (rev.getClusterId() != context.getClusterId()) {\n                    continue;\n                }\n                if ((recentPrevious == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, rev, recentPrevious)) {\n                    if (isCommitted(rev)) {\n                        splitMap.put(rev, entry.getValue());\n                    }\n                }\n            }\n        }\n        java.util.List<org.apache.jackrabbit.oak.plugins.document.UpdateOp> splitOps = java.util.Collections.emptyList();\n        int numValues = 0;\n        org.apache.jackrabbit.oak.plugins.document.Revision high = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision low = null;\n        for (java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap : splitValues.values()) {\n            if (!splitMap.isEmpty()) {\n                splitMap.remove(splitMap.lastKey());\n            }\n            if (splitMap.isEmpty()) {\n                continue;\n            }\n            if ((high == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, splitMap.lastKey(), high)) {\n                high = splitMap.lastKey();\n            }\n            if ((low == null) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, low, splitMap.firstKey())) {\n                low = splitMap.firstKey();\n            }\n            numValues += splitMap.size();\n        }\n        if (((high != null) && (low != null)) && ((numValues >= org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD) || (getMemory() > org.apache.jackrabbit.oak.plugins.document.NodeDocument.DOC_SIZE_THRESHOLD))) {\n            splitOps = new java.util.ArrayList<org.apache.jackrabbit.oak.plugins.document.UpdateOp>(2);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp main = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(id, false);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setPrevious(main, high, low);\n            org.apache.jackrabbit.oak.plugins.document.UpdateOp old = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(id, high), true);\n            old.set(org.apache.jackrabbit.oak.plugins.document.ID, old.getId());\n            for (java.lang.String property : splitValues.keySet()) {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> splitMap = splitValues.get(property);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : splitMap.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                    main.removeMapEntry(property, r);\n                    old.setMapEntry(property, r, entry.getValue());\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument oldDoc = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(store);\n            org.apache.jackrabbit.oak.plugins.document.UpdateUtils.applyChanges(oldDoc, old, context.getRevisionComparator());\n            if (oldDoc.getMemory() > (getMemory() * org.apache.jackrabbit.oak.plugins.document.NodeDocument.SPLIT_RATIO)) {\n                splitOps.add(old);\n                splitOps.add(main);\n            }\n        }\n        return splitOps;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges() {\n        if (previous == null) {\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS);\n            if (map.isEmpty()) {\n                previous = org.apache.jackrabbit.oak.plugins.document.NodeDocument.EMPTY_RANGE_MAP;\n            } else {\n                java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>(StableRevisionComparator.REVERSE);\n                for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : map.entrySet()) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision high = entry.getKey();\n                    org.apache.jackrabbit.oak.plugins.document.Revision low = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(entry.getValue());\n                    transformed.put(high, new org.apache.jackrabbit.oak.plugins.document.Range(high, low));\n                }\n                previous = com.google.common.collect.Maps.unmodifiableNavigableMap(transformed);\n            }\n        }\n        return previous;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocs(@javax.annotation.Nonnull\n    final java.lang.String property, @javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getPreviousRanges().isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        if (revision == null) {\n            return new org.apache.jackrabbit.oak.plugins.document.PropertyHistory(store, this, property);\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = getPreviousRanges().floorKey(revision);\n            if (r != null) {\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                if (prev != null) {\n                    if (prev.getValueMap(property).containsKey(revision)) {\n                        return java.util.Collections.singleton(prev);\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n            }\n            return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(getPreviousRanges().headMap(revision).entrySet(), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> input) {\n                    if (input.getValue().includes(revision)) {\n                        org.apache.jackrabbit.oak.plugins.document.Revision r = input.getKey();\n                        java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getId(), r);\n                        org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(Collection.NODES, prevId);\n                        if (prev != null) {\n                            return prev;\n                        } else {\n                            org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                        }\n                    }\n                    return null;\n                }\n            }), new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public boolean apply(@javax.annotation.Nullable\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument input) {\n                    return (input != null) && input.getValueMap(property).containsKey(revision);\n                }\n            });\n        }\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>) (data.get(key)));\n        if (map == null) {\n            map = ValueMap.EMPTY;\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    public static void setChildrenFlag(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, boolean hasChildNode) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, java.lang.Boolean.valueOf(hasChildNode));\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED, org.apache.jackrabbit.oak.plugins.document.Commit.getModified(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static boolean isRevisionsEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS.equals(name);\n    }\n\n    public static void removeRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void removeCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, revision.getClusterId()), revision.toString());\n    }\n\n    public static boolean hasLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        return com.google.common.base.Preconditions.checkNotNull(op).getChanges().containsKey(new org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId)));\n    }\n\n    public static void unsetLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, int clusterId) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, clusterId));\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void removeCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision);\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, boolean deleted) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(deleted));\n    }\n\n    public static void removeDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, revision);\n    }\n\n    public static void setPrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision high, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision low) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(high), com.google.common.base.Preconditions.checkNotNull(low).toString());\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (containsRevision(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath = getCommitRootPath(rev);\n        if (commitRootPath == null) {\n            return null;\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    private static boolean isRevisionNewer(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision x, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision previous) {\n        return context.getRevisionComparator().compare(x, previous) > 0;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        if (revision.equalsIgnoreBranch(readRevision)) {\n            return true;\n        }\n        if (commitValue == null) {\n            commitValue = getCommitValue(revision);\n        }\n        if (commitValue == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue);\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            } else if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.includeRevision(context, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, commitValue), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String value = getLocalRevisions().get(revision);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n                value = prev.getCommitValue(revision);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision x, org.apache.jackrabbit.oak.plugins.document.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> validRevisions) {\n        java.lang.String value = null;\n        org.apache.jackrabbit.oak.plugins.document.Revision latestRev = null;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision propRev = entry.getKey();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, propRev, readRevision)) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(propRev);\n            if (commitRoot == null) {\n                continue;\n            }\n            java.lang.String commitValue = commitRoot.getCommitValue(propRev);\n            if (commitValue == null) {\n                continue;\n            }\n            if ((min != null) && org.apache.jackrabbit.oak.plugins.document.NodeDocument.isRevisionNewer(context, min, org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue))) {\n                continue;\n            }\n            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                latestRev = org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(propRev, commitValue);\n                value = entry.getValue();\n                break;\n            }\n        }\n        return value != null ? new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(value, latestRev) : null;\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getCommitRoot() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    static final class Children implements java.lang.Cloneable , org.apache.jackrabbit.oak.cache.CacheValue {\n        java.util.ArrayList<java.lang.String> childNames = new java.util.ArrayList<java.lang.String>();\n\n        boolean isComplete;\n\n        @java.lang.Override\n        public int getMemory() {\n            int size = 114;\n            for (java.lang.String name : childNames) {\n                size += (name.length() * 2) + 56;\n            }\n            return size;\n        }\n\n        @java.lang.SuppressWarnings(\"unchecked\")\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone() {\n            try {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children) (super.clone()));\n                clone.childNames = ((java.util.ArrayList<java.lang.String>) (childNames.clone()));\n                return clone;\n            } catch (java.lang.CloneNotSupportedException e) {\n                throw new java.lang.RuntimeException();\n            }\n        }\n    }\n\n    private static final class Value {\n        final java.lang.String value;\n\n        final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n        Value(@javax.annotation.Nonnull\n        java.lang.String value, @javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n            this.value = com.google.common.base.Preconditions.checkNotNull(value);\n            this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "VirtualElement",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "VE: Modifiers_Method",
            "dst_parent": "@javax.annotation.CheckForNull\npublic java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    java.lang.String depth = getCommitRootDepth(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    return null;\n}",
            "dst_parent_type": "Method",
            "dst_type": "VirtualEle",
            "operator": "MOV",
            "src": "VE: Modifiers_Method",
            "src_parent": "@javax.annotation.CheckForNull\npublic java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n    java.lang.String depth = local.get(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n        java.lang.String path = prev.getCommitRootPath(revision);\n        if (path != null) {\n            return path;\n        }\n    }\n    return null;\n}",
            "src_parent_type": "Method",
            "src_type": "VirtualEle"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Parameter",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.document.Revision revision",
            "dst_parent": "@javax.annotation.CheckForNull\npublic java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    java.lang.String depth = getCommitRootDepth(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    return null;\n}",
            "dst_parent_type": "Method",
            "dst_type": "Parameter",
            "operator": "MOV",
            "src": "org.apache.jackrabbit.oak.plugins.document.Revision revision",
            "src_parent": "@javax.annotation.CheckForNull\npublic java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n    java.lang.String depth = local.get(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n        java.lang.String path = prev.getCommitRootPath(revision);\n        if (path != null) {\n            return path;\n        }\n    }\n    return null;\n}",
            "src_parent_type": "Method",
            "src_type": "Parameter"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if (depth != null) {\n    if (depth.equals(\"0\")) {\n        return \"/\";\n    }\n    java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n    return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n}",
            "dst_parent": "{\n    java.lang.String depth = getCommitRootDepth(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    return null;\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if (depth != null) {\n    if (depth.equals(\"0\")) {\n        return \"/\";\n    }\n    java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n    return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n}",
            "src_parent": "{\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n    java.lang.String depth = local.get(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n        java.lang.String path = prev.getCommitRootPath(revision);\n        if (path != null) {\n            return path;\n        }\n    }\n    return null;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Return",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "return null",
            "dst_parent": "{\n    java.lang.String depth = getCommitRootDepth(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    return null;\n}",
            "dst_parent_type": "Block",
            "dst_type": "Return",
            "operator": "MOV",
            "src": "return null",
            "src_parent": "{\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n    java.lang.String depth = local.get(revision);\n    if (depth != null) {\n        if (depth.equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n    for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n        java.lang.String path = prev.getCommitRootPath(revision);\n        if (path != null) {\n            return path;\n        }\n    }\n    return null;\n}",
            "src_parent_type": "Block",
            "src_type": "Return"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.document.NodeDocument prev",
            "dst_parent": "for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n    depth = prev.getCommitRootDepth(revision);\n    if (depth != null) {\n        break;\n    }\n}",
            "dst_parent_type": "ForEach",
            "dst_type": "LocalVariable",
            "operator": "MOV",
            "src": "org.apache.jackrabbit.oak.plugins.document.NodeDocument prev",
            "src_parent": "for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n    java.lang.String path = prev.getCommitRootPath(revision);\n    if (path != null) {\n        return path;\n    }\n}",
            "src_parent_type": "ForEach",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)",
            "dst_parent": "for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n    depth = prev.getCommitRootDepth(revision);\n    if (depth != null) {\n        break;\n    }\n}",
            "dst_parent_type": "ForEach",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)",
            "src_parent": "for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n    java.lang.String path = prev.getCommitRootPath(revision);\n    if (path != null) {\n        return path;\n    }\n}",
            "src_parent_type": "ForEach",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "if (depth != null) {\n    break;\n}",
            "dst_parent": "{\n    depth = prev.getCommitRootDepth(revision);\n    if (depth != null) {\n        break;\n    }\n}",
            "dst_parent_type": "Block",
            "dst_type": "If",
            "operator": "MOV",
            "src": "if (path != null) {\n    return path;\n}",
            "src_parent": "{\n    java.lang.String path = prev.getCommitRootPath(revision);\n    if (path != null) {\n        return path;\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "prev",
            "dst_parent": "prev.getCommitRootDepth(revision)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "prev",
            "src_parent": "prev.getCommitRootPath(revision)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "revision",
            "dst_parent": "prev.getCommitRootDepth(revision)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "revision",
            "src_parent": "prev.getCommitRootPath(revision)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        }
      ],
      "file_name": "NodeDocument"
    }
  ],
  "id": "jackrabbit-oak_279bb3ce"
}