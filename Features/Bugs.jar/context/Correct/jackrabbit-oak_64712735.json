{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean overrideEarlyShutdown() {\n    if (earlyShutdown == false) {\n        return false;\n    }\n    final org.apache.jackrabbit.oak.upgrade.version.VersionCopyConfiguration c = this.versionCopyConfiguration;\n    if (c.isCopyVersions() && c.skipOrphanedVersionsCopy()) {\n        org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Overriding early shutdown to false because of the copy versions settings\");\n        return false;\n    }\n    if ((c.isCopyVersions() && (!c.skipOrphanedVersionsCopy())) && c.getOrphanedMinDate().after(c.getVersionsMinDate())) {\n        org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Overriding early shutdown to false because of the copy versions settings\");\n        return false;\n    }\n    return true;\n}",
            "src_parent": "public class RepositoryUpgrade {\n    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.class);\n\n    public static final java.util.Set<java.lang.String> DEFAULT_INCLUDE_PATHS = ALL;\n\n    public static final java.util.Set<java.lang.String> DEFAULT_EXCLUDE_PATHS = NONE;\n\n    public static final java.util.Set<java.lang.String> DEFAULT_MERGE_PATHS = NONE;\n\n    private final org.apache.jackrabbit.core.RepositoryContext source;\n\n    private final org.apache.jackrabbit.oak.spi.state.NodeStore target;\n\n    private java.util.Set<java.lang.String> includePaths = org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.DEFAULT_INCLUDE_PATHS;\n\n    private java.util.Set<java.lang.String> excludePaths = org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.DEFAULT_EXCLUDE_PATHS;\n\n    private java.util.Set<java.lang.String> mergePaths = org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.DEFAULT_MERGE_PATHS;\n\n    private boolean copyBinariesByReference = false;\n\n    private boolean skipOnError = false;\n\n    private boolean earlyShutdown = false;\n\n    private java.util.List<org.apache.jackrabbit.oak.spi.commit.CommitHook> customCommitHooks = null;\n\n    org.apache.jackrabbit.oak.upgrade.version.VersionCopyConfiguration versionCopyConfiguration = new org.apache.jackrabbit.oak.upgrade.version.VersionCopyConfiguration();\n\n    public static void copy(java.io.File source, org.apache.jackrabbit.oak.spi.state.NodeStore target) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.copy(org.apache.jackrabbit.core.config.RepositoryConfig.create(source), target);\n    }\n\n    public static void copy(org.apache.jackrabbit.core.config.RepositoryConfig source, org.apache.jackrabbit.oak.spi.state.NodeStore target) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.core.RepositoryContext context = org.apache.jackrabbit.core.RepositoryContext.create(source);\n        try {\n            new org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade(context, target).copy(null);\n        } finally {\n            context.getRepository().shutdown();\n        }\n    }\n\n    public RepositoryUpgrade(org.apache.jackrabbit.core.RepositoryContext source, org.apache.jackrabbit.oak.spi.state.NodeStore target) {\n        this.source = source;\n        this.target = target;\n    }\n\n    public boolean isCopyBinariesByReference() {\n        return copyBinariesByReference;\n    }\n\n    public void setCopyBinariesByReference(boolean copyBinariesByReference) {\n        this.copyBinariesByReference = copyBinariesByReference;\n    }\n\n    public boolean isSkipOnError() {\n        return skipOnError;\n    }\n\n    public void setSkipOnError(boolean skipOnError) {\n        this.skipOnError = skipOnError;\n    }\n\n    public boolean isEarlyShutdown() {\n        return earlyShutdown;\n    }\n\n    public void setEarlyShutdown(boolean earlyShutdown) {\n        this.earlyShutdown = earlyShutdown;\n    }\n\n    public java.util.List<org.apache.jackrabbit.oak.spi.commit.CommitHook> getCustomCommitHooks() {\n        return customCommitHooks;\n    }\n\n    public void setCustomCommitHooks(java.util.List<org.apache.jackrabbit.oak.spi.commit.CommitHook> customCommitHooks) {\n        this.customCommitHooks = customCommitHooks;\n    }\n\n    public void setIncludes(@javax.annotation.Nonnull\n    java.lang.String... includes) {\n        this.includePaths = com.google.common.collect.ImmutableSet.copyOf(com.google.common.base.Preconditions.checkNotNull(includes));\n    }\n\n    public void setExcludes(@javax.annotation.Nonnull\n    java.lang.String... excludes) {\n        this.excludePaths = com.google.common.collect.ImmutableSet.copyOf(com.google.common.base.Preconditions.checkNotNull(excludes));\n    }\n\n    public void setMerges(@javax.annotation.Nonnull\n    java.lang.String... merges) {\n        this.mergePaths = com.google.common.collect.ImmutableSet.copyOf(com.google.common.base.Preconditions.checkNotNull(merges));\n    }\n\n    public void setCopyVersions(java.util.Calendar minDate) {\n        versionCopyConfiguration.setCopyVersions(minDate);\n    }\n\n    public void setCopyOrphanedVersions(java.util.Calendar minDate) {\n        versionCopyConfiguration.setCopyOrphanedVersions(minDate);\n    }\n\n    public void copy(org.apache.jackrabbit.oak.spi.lifecycle.RepositoryInitializer initializer) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.core.config.RepositoryConfig config = source.getRepositoryConfig();\n        org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Copying repository content from {} to Oak\", config.getHomeDir());\n        try {\n            org.apache.jackrabbit.oak.spi.state.NodeState base = target.getRoot();\n            org.apache.jackrabbit.oak.spi.state.NodeBuilder builder = base.builder();\n            final org.apache.jackrabbit.oak.api.Root upgradeRoot = new org.apache.jackrabbit.oak.upgrade.UpgradeRoot(builder);\n            java.lang.String workspaceName = source.getRepositoryConfig().getDefaultWorkspaceName();\n            org.apache.jackrabbit.oak.security.SecurityProviderImpl security = new org.apache.jackrabbit.oak.security.SecurityProviderImpl(mapSecurityConfig(config.getSecurityConfig()));\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Initializing initial repository content from {}\", config.getHomeDir());\n            new org.apache.jackrabbit.oak.plugins.nodetype.write.InitialContent().initialize(builder);\n            if (initializer != null) {\n                initializer.initialize(builder);\n            }\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"InitialContent completed from {}\", config.getHomeDir());\n            for (org.apache.jackrabbit.oak.spi.security.SecurityConfiguration sc : security.getConfigurations()) {\n                org.apache.jackrabbit.oak.spi.lifecycle.RepositoryInitializer ri = sc.getRepositoryInitializer();\n                ri.initialize(builder);\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug((\"Repository initializer '\" + ri.getClass().getName()) + \"' completed\", config.getHomeDir());\n            }\n            for (org.apache.jackrabbit.oak.spi.security.SecurityConfiguration sc : security.getConfigurations()) {\n                org.apache.jackrabbit.oak.spi.lifecycle.WorkspaceInitializer wi = sc.getWorkspaceInitializer();\n                wi.initialize(builder, workspaceName);\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug((\"Workspace initializer '\" + wi.getClass().getName()) + \"' completed\", config.getHomeDir());\n            }\n            com.google.common.collect.HashBiMap<java.lang.String, java.lang.String> uriToPrefix = com.google.common.collect.HashBiMap.create();\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Copying registered namespaces\");\n            copyNamespaces(builder, uriToPrefix);\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"Namespace registration completed.\");\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Copying registered node types\");\n            javax.jcr.nodetype.NodeTypeManager ntMgr = new org.apache.jackrabbit.oak.plugins.nodetype.write.ReadWriteNodeTypeManager() {\n                @java.lang.Override\n                protected org.apache.jackrabbit.oak.api.Tree getTypes() {\n                    return upgradeRoot.getTree(org.apache.jackrabbit.oak.upgrade.NODE_TYPES_PATH);\n                }\n\n                @javax.annotation.Nonnull\n                @java.lang.Override\n                protected org.apache.jackrabbit.oak.api.Root getWriteRoot() {\n                    return upgradeRoot;\n                }\n            };\n            copyNodeTypes(ntMgr, new org.apache.jackrabbit.oak.plugins.value.ValueFactoryImpl(upgradeRoot, org.apache.jackrabbit.oak.namepath.NamePathMapper.DEFAULT));\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"Node type registration completed.\");\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Copying registered privileges\");\n            org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConfiguration privilegeConfiguration = security.getConfiguration(org.apache.jackrabbit.oak.spi.security.privilege.PrivilegeConfiguration.class);\n            copyCustomPrivileges(privilegeConfiguration.getPrivilegeManager(upgradeRoot, NamePathMapper.DEFAULT));\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"Privilege registration completed.\");\n            new org.apache.jackrabbit.oak.plugins.nodetype.TypeEditorProvider(false).getRootEditor(base, builder.getNodeState(), builder, null);\n            org.apache.jackrabbit.oak.spi.state.NodeState root = builder.getNodeState();\n            final org.apache.jackrabbit.oak.spi.state.NodeState sourceState = org.apache.jackrabbit.oak.upgrade.JackrabbitNodeState.createRootNodeState(source, workspaceName, root, uriToPrefix, copyBinariesByReference, skipOnError);\n            final com.google.common.base.Stopwatch watch = com.google.common.base.Stopwatch.createStarted();\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Copying workspace content\");\n            copyWorkspace(sourceState, builder, workspaceName);\n            builder.getNodeState();\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Upgrading workspace content completed in {}s ({})\", watch.elapsed(java.util.concurrent.TimeUnit.SECONDS), watch);\n            if (!versionCopyConfiguration.skipOrphanedVersionsCopy()) {\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Copying version storage\");\n                watch.reset().start();\n                copyVersionStorage(sourceState, builder, versionCopyConfiguration);\n                builder.getNodeState();\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Version storage copied in {}s ({})\", watch.elapsed(java.util.concurrent.TimeUnit.SECONDS), watch);\n            } else {\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Skipping the version storage as the copyOrphanedVersions is set to false\");\n            }\n            watch.reset().start();\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Applying default commit hooks\");\n            java.util.List<org.apache.jackrabbit.oak.spi.commit.CommitHook> hooks = com.google.common.collect.Lists.newArrayList();\n            org.apache.jackrabbit.oak.spi.security.user.UserConfiguration userConf = security.getConfiguration(org.apache.jackrabbit.oak.spi.security.user.UserConfiguration.class);\n            java.lang.String groupsPath = userConf.getParameters().getConfigValue(UserConstants.PARAM_GROUP_PATH, UserConstants.DEFAULT_GROUP_PATH);\n            hooks.add(new org.apache.jackrabbit.oak.spi.commit.EditorHook(new org.apache.jackrabbit.oak.spi.commit.CompositeEditorProvider(new org.apache.jackrabbit.oak.upgrade.security.RestrictionEditorProvider(), new org.apache.jackrabbit.oak.upgrade.security.GroupEditorProvider(groupsPath), new org.apache.jackrabbit.oak.upgrade.version.VersionableEditor.Provider(sourceState, workspaceName, versionCopyConfiguration))));\n            for (org.apache.jackrabbit.oak.spi.security.SecurityConfiguration sc : security.getConfigurations()) {\n                hooks.addAll(sc.getCommitHooks(workspaceName));\n            }\n            if (customCommitHooks != null) {\n                hooks.addAll(customCommitHooks);\n            }\n            hooks.add(new org.apache.jackrabbit.oak.spi.commit.EditorHook(new org.apache.jackrabbit.oak.spi.commit.CompositeEditorProvider(org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.createTypeEditorProvider(), org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.createIndexEditorProvider())));\n            target.merge(builder, new org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.LoggingCompositeHook(hooks, source, overrideEarlyShutdown()), CommitInfo.EMPTY);\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Processing commit hooks completed in {}s ({})\", watch.elapsed(java.util.concurrent.TimeUnit.SECONDS), watch);\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"Repository upgrade completed.\");\n        } catch (java.lang.Exception e) {\n            throw new javax.jcr.RepositoryException(\"Failed to copy content\", e);\n        }\n    }\n\n    private boolean overrideEarlyShutdown() {\n        if (earlyShutdown == false) {\n            return false;\n        }\n        final org.apache.jackrabbit.oak.upgrade.version.VersionCopyConfiguration c = this.versionCopyConfiguration;\n        if (c.isCopyVersions() && c.skipOrphanedVersionsCopy()) {\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Overriding early shutdown to false because of the copy versions settings\");\n            return false;\n        }\n        if ((c.isCopyVersions() && (!c.skipOrphanedVersionsCopy())) && c.getOrphanedMinDate().after(c.getVersionsMinDate())) {\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Overriding early shutdown to false because of the copy versions settings\");\n            return false;\n        }\n        return true;\n    }\n\n    private static org.apache.jackrabbit.oak.spi.commit.EditorProvider createTypeEditorProvider() {\n        return new org.apache.jackrabbit.oak.spi.commit.EditorProvider() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.commit.Editor getRootEditor(org.apache.jackrabbit.oak.spi.state.NodeState before, org.apache.jackrabbit.oak.spi.state.NodeState after, org.apache.jackrabbit.oak.spi.state.NodeBuilder builder, org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n                org.apache.jackrabbit.oak.spi.commit.Editor rootEditor = new org.apache.jackrabbit.oak.plugins.nodetype.TypeEditorProvider(false).getRootEditor(before, after, builder, info);\n                return org.apache.jackrabbit.oak.spi.commit.ProgressNotificationEditor.wrap(rootEditor, org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger, \"Checking node types:\");\n            }\n\n            @java.lang.Override\n            public java.lang.String toString() {\n                return \"TypeEditorProvider\";\n            }\n        };\n    }\n\n    private static org.apache.jackrabbit.oak.spi.commit.EditorProvider createIndexEditorProvider() {\n        final org.apache.jackrabbit.oak.upgrade.ProgressTicker ticker = new org.apache.jackrabbit.oak.upgrade.AsciiArtTicker();\n        return new org.apache.jackrabbit.oak.spi.commit.EditorProvider() {\n            @java.lang.Override\n            public org.apache.jackrabbit.oak.spi.commit.Editor getRootEditor(org.apache.jackrabbit.oak.spi.state.NodeState before, org.apache.jackrabbit.oak.spi.state.NodeState after, org.apache.jackrabbit.oak.spi.state.NodeBuilder builder, org.apache.jackrabbit.oak.spi.commit.CommitInfo info) {\n                org.apache.jackrabbit.oak.plugins.index.IndexEditorProvider editorProviders = new org.apache.jackrabbit.oak.plugins.index.CompositeIndexEditorProvider(new org.apache.jackrabbit.oak.plugins.index.reference.ReferenceEditorProvider(), new org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexEditorProvider());\n                return new org.apache.jackrabbit.oak.plugins.index.IndexUpdate(editorProviders, null, after, builder, new org.apache.jackrabbit.oak.plugins.index.IndexUpdateCallback() {\n                    java.lang.String progress = \"Updating indexes \";\n\n                    long t0;\n\n                    @java.lang.Override\n                    public void indexUpdate() {\n                        long t = java.lang.System.currentTimeMillis();\n                        if ((t - t0) > 2000) {\n                            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"{} {}\", progress, ticker.tick());\n                            t0 = t;\n                        }\n                    }\n                });\n            }\n\n            @java.lang.Override\n            public java.lang.String toString() {\n                return \"IndexEditorProvider\";\n            }\n        };\n    }\n\n    protected org.apache.jackrabbit.oak.spi.security.ConfigurationParameters mapSecurityConfig(org.apache.jackrabbit.core.config.SecurityConfig config) {\n        org.apache.jackrabbit.oak.spi.security.ConfigurationParameters loginConfig = mapConfigurationParameters(config.getLoginModuleConfig(), LoginModuleConfig.PARAM_ADMIN_ID, UserConstants.PARAM_ADMIN_ID, LoginModuleConfig.PARAM_ANONYMOUS_ID, UserConstants.PARAM_ANONYMOUS_ID);\n        org.apache.jackrabbit.oak.spi.security.ConfigurationParameters userConfig = mapConfigurationParameters(config.getSecurityManagerConfig().getUserManagerConfig(), UserManagerImpl.PARAM_USERS_PATH, UserConstants.PARAM_USER_PATH, UserManagerImpl.PARAM_GROUPS_PATH, UserConstants.PARAM_GROUP_PATH, UserManagerImpl.PARAM_DEFAULT_DEPTH, UserConstants.PARAM_DEFAULT_DEPTH, UserManagerImpl.PARAM_PASSWORD_HASH_ALGORITHM, UserConstants.PARAM_PASSWORD_HASH_ALGORITHM, UserManagerImpl.PARAM_PASSWORD_HASH_ITERATIONS, UserConstants.PARAM_PASSWORD_HASH_ITERATIONS);\n        return org.apache.jackrabbit.oak.spi.security.ConfigurationParameters.of(com.google.common.collect.ImmutableMap.of(UserConfiguration.NAME, org.apache.jackrabbit.oak.spi.security.ConfigurationParameters.of(loginConfig, userConfig)));\n    }\n\n    protected org.apache.jackrabbit.oak.spi.security.ConfigurationParameters mapConfigurationParameters(org.apache.jackrabbit.core.config.BeanConfig config, java.lang.String... mapping) {\n        java.util.Map<java.lang.String, java.lang.String> map = com.google.common.collect.Maps.newHashMap();\n        if (config != null) {\n            java.util.Properties properties = config.getParameters();\n            for (int i = 0; (i + 1) < mapping.length; i += 2) {\n                java.lang.String value = properties.getProperty(mapping[i]);\n                if (value != null) {\n                    map.put(mapping[i + 1], value);\n                }\n            }\n        }\n        return org.apache.jackrabbit.oak.spi.security.ConfigurationParameters.of(map);\n    }\n\n    private java.lang.String getOakName(org.apache.jackrabbit.spi.Name name) throws javax.jcr.NamespaceException {\n        java.lang.String uri = name.getNamespaceURI();\n        java.lang.String local = name.getLocalName();\n        if ((uri == null) || uri.isEmpty()) {\n            return local;\n        } else {\n            return (source.getNamespaceRegistry().getPrefix(uri) + ':') + local;\n        }\n    }\n\n    private void copyNamespaces(org.apache.jackrabbit.oak.spi.state.NodeBuilder root, java.util.Map<java.lang.String, java.lang.String> uriToPrefix) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.oak.spi.state.NodeBuilder system = root.child(org.apache.jackrabbit.JcrConstants.JCR_SYSTEM);\n        org.apache.jackrabbit.oak.spi.state.NodeBuilder namespaces = system.child(NamespaceConstants.REP_NAMESPACES);\n        java.util.Properties registry = loadProperties(\"/namespaces/ns_reg.properties\");\n        for (java.lang.String prefixHint : registry.stringPropertyNames()) {\n            java.lang.String prefix;\n            java.lang.String uri = registry.getProperty(prefixHint);\n            if (\".empty.key\".equals(prefixHint)) {\n                prefix = \"\";\n            } else {\n                prefix = addCustomMapping(namespaces, uri, prefixHint);\n            }\n            com.google.common.base.Preconditions.checkState(uriToPrefix.put(uri, prefix) == null);\n        }\n        org.apache.jackrabbit.oak.plugins.name.Namespaces.buildIndexNode(namespaces);\n    }\n\n    private java.util.Properties loadProperties(java.lang.String path) throws javax.jcr.RepositoryException {\n        java.util.Properties properties = new java.util.Properties();\n        org.apache.jackrabbit.core.fs.FileSystem filesystem = source.getFileSystem();\n        try {\n            if (filesystem.exists(path)) {\n                java.io.InputStream stream = filesystem.getInputStream(path);\n                try {\n                    properties.load(stream);\n                } finally {\n                    stream.close();\n                }\n            }\n        } catch (org.apache.jackrabbit.core.fs.FileSystemException e) {\n            throw new javax.jcr.RepositoryException(e);\n        } catch (java.io.IOException e) {\n            throw new javax.jcr.RepositoryException(e);\n        }\n        return properties;\n    }\n\n    @java.lang.SuppressWarnings(\"deprecation\")\n    private void copyCustomPrivileges(org.apache.jackrabbit.api.security.authorization.PrivilegeManager pMgr) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.core.security.authorization.PrivilegeRegistry registry = source.getPrivilegeRegistry();\n        java.util.List<javax.jcr.security.Privilege> customAggrPrivs = com.google.common.collect.Lists.newArrayList();\n        org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"Registering custom non-aggregated privileges\");\n        for (javax.jcr.security.Privilege privilege : registry.getRegisteredPrivileges()) {\n            java.lang.String privilegeName = privilege.getName();\n            if (hasPrivilege(pMgr, privilegeName)) {\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"Privilege {} already exists\", privilegeName);\n                continue;\n            }\n            if (PrivilegeBits.BUILT_IN.containsKey(privilegeName) || org.apache.jackrabbit.oak.upgrade.JCR_ALL.equals(privilegeName)) {\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"Built-in privilege -> ignore.\");\n            } else if (privilege.isAggregate()) {\n                customAggrPrivs.add(privilege);\n            } else {\n                pMgr.registerPrivilege(privilegeName, privilege.isAbstract(), new java.lang.String[0]);\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"- \" + privilegeName);\n            }\n        }\n        org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"Registering custom aggregated privileges\");\n        while (!customAggrPrivs.isEmpty()) {\n            java.util.Iterator<javax.jcr.security.Privilege> it = customAggrPrivs.iterator();\n            boolean progress = false;\n            while (it.hasNext()) {\n                javax.jcr.security.Privilege aggrPriv = it.next();\n                java.util.List<java.lang.String> aggrNames = com.google.common.collect.Lists.transform(com.google.common.collect.ImmutableList.copyOf(aggrPriv.getDeclaredAggregatePrivileges()), new com.google.common.base.Function<javax.jcr.security.Privilege, java.lang.String>() {\n                    @javax.annotation.Nullable\n                    @java.lang.Override\n                    public java.lang.String apply(@javax.annotation.Nullable\n                    javax.jcr.security.Privilege input) {\n                        return input == null ? null : input.getName();\n                    }\n                });\n                if (org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.allAggregatesRegistered(pMgr, aggrNames)) {\n                    pMgr.registerPrivilege(aggrPriv.getName(), aggrPriv.isAbstract(), aggrNames.toArray(new java.lang.String[aggrNames.size()]));\n                    it.remove();\n                    org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"- \" + aggrPriv.getName());\n                    progress = true;\n                }\n            } \n            if (!progress) {\n                break;\n            }\n        } \n        if (customAggrPrivs.isEmpty()) {\n            org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.debug(\"Registration of custom privileges completed.\");\n        } else {\n            java.lang.StringBuilder invalid = new java.lang.StringBuilder(\"|\");\n            for (javax.jcr.security.Privilege p : customAggrPrivs) {\n                invalid.append(p.getName()).append('|');\n            }\n            throw new javax.jcr.RepositoryException(\"Failed to register custom privileges. The following privileges contained an invalid aggregation:\" + invalid);\n        }\n    }\n\n    private boolean hasPrivilege(org.apache.jackrabbit.api.security.authorization.PrivilegeManager pMgr, java.lang.String privilegeName) throws javax.jcr.RepositoryException {\n        final javax.jcr.security.Privilege[] registeredPrivileges = pMgr.getRegisteredPrivileges();\n        for (javax.jcr.security.Privilege registeredPrivilege : registeredPrivileges) {\n            if (registeredPrivilege.getName().equals(privilegeName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean allAggregatesRegistered(org.apache.jackrabbit.api.security.authorization.PrivilegeManager privilegeManager, java.util.List<java.lang.String> aggrNames) {\n        for (java.lang.String name : aggrNames) {\n            try {\n                privilegeManager.getPrivilege(name);\n            } catch (javax.jcr.RepositoryException e) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void copyNodeTypes(javax.jcr.nodetype.NodeTypeManager ntMgr, javax.jcr.ValueFactory valueFactory) throws javax.jcr.RepositoryException {\n        org.apache.jackrabbit.core.nodetype.NodeTypeRegistry sourceRegistry = source.getNodeTypeRegistry();\n        java.util.List<javax.jcr.nodetype.NodeTypeTemplate> templates = com.google.common.collect.Lists.newArrayList();\n        for (org.apache.jackrabbit.spi.Name name : sourceRegistry.getRegisteredNodeTypes()) {\n            java.lang.String oakName = getOakName(name);\n            if (!ntMgr.hasNodeType(oakName)) {\n                org.apache.jackrabbit.spi.QNodeTypeDefinition def = sourceRegistry.getNodeTypeDef(name);\n                templates.add(createNodeTypeTemplate(valueFactory, ntMgr, oakName, def));\n            }\n        }\n        ntMgr.registerNodeTypes(templates.toArray(new javax.jcr.nodetype.NodeTypeTemplate[templates.size()]), true);\n    }\n\n    private javax.jcr.nodetype.NodeTypeTemplate createNodeTypeTemplate(javax.jcr.ValueFactory valueFactory, javax.jcr.nodetype.NodeTypeManager ntMgr, java.lang.String oakName, org.apache.jackrabbit.spi.QNodeTypeDefinition def) throws javax.jcr.RepositoryException {\n        javax.jcr.nodetype.NodeTypeTemplate tmpl = ntMgr.createNodeTypeTemplate();\n        tmpl.setName(oakName);\n        tmpl.setAbstract(def.isAbstract());\n        tmpl.setMixin(def.isMixin());\n        tmpl.setOrderableChildNodes(def.hasOrderableChildNodes());\n        tmpl.setQueryable(def.isQueryable());\n        org.apache.jackrabbit.spi.Name primaryItemName = def.getPrimaryItemName();\n        if (primaryItemName != null) {\n            tmpl.setPrimaryItemName(getOakName(primaryItemName));\n        }\n        org.apache.jackrabbit.spi.Name[] supertypes = def.getSupertypes();\n        if ((supertypes != null) && (supertypes.length > 0)) {\n            java.util.List<java.lang.String> names = com.google.common.collect.Lists.newArrayListWithCapacity(supertypes.length);\n            for (org.apache.jackrabbit.spi.Name supertype : supertypes) {\n                names.add(getOakName(supertype));\n            }\n            tmpl.setDeclaredSuperTypeNames(names.toArray(new java.lang.String[names.size()]));\n        }\n        java.util.List<javax.jcr.nodetype.PropertyDefinitionTemplate> propertyDefinitionTemplates = tmpl.getPropertyDefinitionTemplates();\n        for (org.apache.jackrabbit.spi.QPropertyDefinition qpd : def.getPropertyDefs()) {\n            javax.jcr.nodetype.PropertyDefinitionTemplate pdt = createPropertyDefinitionTemplate(valueFactory, ntMgr, qpd);\n            propertyDefinitionTemplates.add(pdt);\n        }\n        java.util.List<javax.jcr.nodetype.NodeDefinitionTemplate> nodeDefinitionTemplates = tmpl.getNodeDefinitionTemplates();\n        for (org.apache.jackrabbit.spi.QNodeDefinition qnd : def.getChildNodeDefs()) {\n            javax.jcr.nodetype.NodeDefinitionTemplate ndt = createNodeDefinitionTemplate(ntMgr, qnd);\n            nodeDefinitionTemplates.add(ndt);\n        }\n        return tmpl;\n    }\n\n    private javax.jcr.nodetype.NodeDefinitionTemplate createNodeDefinitionTemplate(javax.jcr.nodetype.NodeTypeManager ntMgr, org.apache.jackrabbit.spi.QNodeDefinition def) throws javax.jcr.RepositoryException {\n        javax.jcr.nodetype.NodeDefinitionTemplate tmpl = ntMgr.createNodeDefinitionTemplate();\n        org.apache.jackrabbit.spi.Name name = def.getName();\n        if (name != null) {\n            tmpl.setName(getOakName(name));\n        }\n        tmpl.setAutoCreated(def.isAutoCreated());\n        tmpl.setMandatory(def.isMandatory());\n        tmpl.setOnParentVersion(def.getOnParentVersion());\n        tmpl.setProtected(def.isProtected());\n        tmpl.setSameNameSiblings(def.allowsSameNameSiblings());\n        java.util.List<java.lang.String> names = com.google.common.collect.Lists.newArrayListWithCapacity(def.getRequiredPrimaryTypes().length);\n        for (org.apache.jackrabbit.spi.Name type : def.getRequiredPrimaryTypes()) {\n            names.add(getOakName(type));\n        }\n        tmpl.setRequiredPrimaryTypeNames(names.toArray(new java.lang.String[names.size()]));\n        org.apache.jackrabbit.spi.Name type = def.getDefaultPrimaryType();\n        if (type != null) {\n            tmpl.setDefaultPrimaryTypeName(getOakName(type));\n        }\n        return tmpl;\n    }\n\n    private javax.jcr.nodetype.PropertyDefinitionTemplate createPropertyDefinitionTemplate(javax.jcr.ValueFactory valueFactory, javax.jcr.nodetype.NodeTypeManager ntMgr, org.apache.jackrabbit.spi.QPropertyDefinition def) throws javax.jcr.RepositoryException {\n        javax.jcr.nodetype.PropertyDefinitionTemplate tmpl = ntMgr.createPropertyDefinitionTemplate();\n        org.apache.jackrabbit.spi.Name name = def.getName();\n        if (name != null) {\n            tmpl.setName(getOakName(name));\n        }\n        tmpl.setAutoCreated(def.isAutoCreated());\n        tmpl.setMandatory(def.isMandatory());\n        tmpl.setOnParentVersion(def.getOnParentVersion());\n        tmpl.setProtected(def.isProtected());\n        tmpl.setRequiredType(def.getRequiredType());\n        tmpl.setMultiple(def.isMultiple());\n        tmpl.setAvailableQueryOperators(def.getAvailableQueryOperators());\n        tmpl.setFullTextSearchable(def.isFullTextSearchable());\n        tmpl.setQueryOrderable(def.isQueryOrderable());\n        org.apache.jackrabbit.spi.QValueConstraint[] qConstraints = def.getValueConstraints();\n        if ((qConstraints != null) && (qConstraints.length > 0)) {\n            java.lang.String[] constraints = new java.lang.String[qConstraints.length];\n            for (int i = 0; i < qConstraints.length; i++) {\n                constraints[i] = qConstraints[i].getString();\n            }\n            tmpl.setValueConstraints(constraints);\n        }\n        org.apache.jackrabbit.spi.QValue[] qValues = def.getDefaultValues();\n        if (qValues != null) {\n            org.apache.jackrabbit.spi.commons.conversion.NamePathResolver npResolver = new org.apache.jackrabbit.spi.commons.conversion.DefaultNamePathResolver(source.getNamespaceRegistry());\n            javax.jcr.Value[] vs = new javax.jcr.Value[qValues.length];\n            for (int i = 0; i < qValues.length; i++) {\n                vs[i] = org.apache.jackrabbit.spi.commons.value.ValueFormat.getJCRValue(qValues[i], npResolver, valueFactory);\n            }\n            tmpl.setDefaultValues(vs);\n        }\n        return tmpl;\n    }\n\n    private java.lang.String copyWorkspace(org.apache.jackrabbit.oak.spi.state.NodeState sourceState, org.apache.jackrabbit.oak.spi.state.NodeBuilder builder, java.lang.String workspaceName) throws javax.jcr.RepositoryException {\n        final java.util.Set<java.lang.String> includes = org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.calculateEffectiveIncludePaths(includePaths, sourceState);\n        final java.util.Set<java.lang.String> excludes = com.google.common.collect.Sets.union(com.google.common.collect.ImmutableSet.copyOf(this.excludePaths), com.google.common.collect.ImmutableSet.of(\"/jcr:system/jcr:versionStorage\"));\n        final java.util.Set<java.lang.String> merges = com.google.common.collect.Sets.union(com.google.common.collect.ImmutableSet.copyOf(this.mergePaths), com.google.common.collect.ImmutableSet.of(\"/jcr:system\"));\n        org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Copying workspace {} [i: {}, e: {}, m: {}]\", workspaceName, includes, excludes, merges);\n        org.apache.jackrabbit.oak.upgrade.nodestate.NodeStateCopier.builder().include(includes).exclude(excludes).merge(merges).copy(sourceState, builder);\n        return workspaceName;\n    }\n\n    static java.util.Set<java.lang.String> calculateEffectiveIncludePaths(java.util.Set<java.lang.String> includePaths, org.apache.jackrabbit.oak.spi.state.NodeState state) {\n        if (!includePaths.contains(\"/\")) {\n            return com.google.common.collect.ImmutableSet.copyOf(includePaths);\n        }\n        final java.util.Set<java.lang.String> includes = com.google.common.collect.Sets.newHashSet();\n        for (java.lang.String childNodeName : state.getChildNodeNames()) {\n            includes.add(\"/\" + childNodeName);\n        }\n        return includes;\n    }\n\n    static class LoggingCompositeHook implements org.apache.jackrabbit.oak.spi.commit.CommitHook {\n        private final java.util.Collection<org.apache.jackrabbit.oak.spi.commit.CommitHook> hooks;\n\n        private boolean started = false;\n\n        private final boolean earlyShutdown;\n\n        private final org.apache.jackrabbit.core.RepositoryContext source;\n\n        public LoggingCompositeHook(java.util.Collection<org.apache.jackrabbit.oak.spi.commit.CommitHook> hooks) {\n            this(hooks, null, false);\n        }\n\n        public LoggingCompositeHook(java.util.Collection<org.apache.jackrabbit.oak.spi.commit.CommitHook> hooks, org.apache.jackrabbit.core.RepositoryContext source, boolean earlyShutdown) {\n            this.hooks = hooks;\n            this.earlyShutdown = earlyShutdown;\n            this.source = source;\n        }\n\n        @javax.annotation.Nonnull\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.spi.state.NodeState processCommit(org.apache.jackrabbit.oak.spi.state.NodeState before, org.apache.jackrabbit.oak.spi.state.NodeState after, org.apache.jackrabbit.oak.spi.commit.CommitInfo info) throws org.apache.jackrabbit.oak.api.CommitFailedException {\n            org.apache.jackrabbit.oak.spi.state.NodeState newState = after;\n            com.google.common.base.Stopwatch watch = com.google.common.base.Stopwatch.createStarted();\n            if ((earlyShutdown && (source != null)) && (!started)) {\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Shutting down source repository.\");\n                source.getRepository().shutdown();\n                started = true;\n            }\n            for (org.apache.jackrabbit.oak.spi.commit.CommitHook hook : hooks) {\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Processing commit via {}\", hook);\n                newState = hook.processCommit(before, newState, info);\n                org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.logger.info(\"Commit hook {} processed commit in {}\", hook, watch);\n                watch.reset().start();\n            }\n            return newState;\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "ForEach",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Try",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "overrideEarlyShutdown()",
            "src_parent": "new org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.LoggingCompositeHook(hooks, source, overrideEarlyShutdown())",
            "src_parent_type": "ConstructorCall",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "ForEach",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Try",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "earlyShutdown",
            "dst_parent": "earlyShutdown == false",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "FieldRead",
            "operator": "MOV",
            "src": "earlyShutdown",
            "src_parent": "new org.apache.jackrabbit.oak.upgrade.RepositoryUpgrade.LoggingCompositeHook(hooks, source, earlyShutdown)",
            "src_parent_type": "ConstructorCall",
            "src_type": "FieldRead"
          }
        }
      ],
      "file_name": "RepositoryUpgrade"
    }
  ],
  "id": "jackrabbit-oak_64712735"
}