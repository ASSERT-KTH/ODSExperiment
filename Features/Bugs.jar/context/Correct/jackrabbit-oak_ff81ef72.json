{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "local",
            "dst_parent": "isMostRecentCommitted(nodeStore, local, value.revision)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "UPD",
            "src": "newest",
            "src_parent": "isRevisionNewer(nodeStore, newest, value.revision)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "org.apache.jackrabbit.oak.plugins.document.Revision newest = local.firstKey()",
            "src_parent": "{\n    org.apache.jackrabbit.oak.plugins.document.Revision newest = local.firstKey();\n    if (isRevisionNewer(nodeStore, newest, value.revision)) {\n        org.apache.jackrabbit.oak.plugins.document.Revision newestPrev = getPreviousRanges().firstKey();\n        if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n            value = null;\n        }\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "isRevisionNewer(nodeStore, newest, value.revision)",
            "src_parent": "if (isRevisionNewer(nodeStore, newest, value.revision)) {\n    org.apache.jackrabbit.oak.plugins.document.Revision newestPrev = getPreviousRanges().firstKey();\n    if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n        value = null;\n    }\n}",
            "src_parent_type": "If",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean isMostRecentCommitted(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n    if (valueMap.isEmpty()) {\n        return true;\n    }\n    org.apache.jackrabbit.oak.plugins.document.Revision first = valueMap.firstKey();\n    if (!isRevisionNewer(context, first, revision)) {\n        return true;\n    }\n    for (org.apache.jackrabbit.oak.plugins.document.Revision r : valueMap.keySet()) {\n        org.apache.jackrabbit.oak.plugins.document.Revision c = getCommitRevision(r);\n        if (c != null) {\n            return !isRevisionNewer(context, c, revision);\n        }\n    }\n    return true;\n}",
            "src_parent": "public final class NodeDocument extends org.apache.jackrabbit.oak.plugins.document.Document implements org.apache.jackrabbit.oak.plugins.document.CachedNodeDocument {\n    public static final org.apache.jackrabbit.oak.plugins.document.NodeDocument NULL = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(new org.apache.jackrabbit.oak.plugins.document.memory.MemoryDocumentStore());\n\n    static {\n        NULL.seal();\n    }\n\n    static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(org.apache.jackrabbit.oak.plugins.document.NodeDocument.class);\n\n    public static final java.lang.String MIN_ID_VALUE = \"0000000\";\n\n    public static final java.lang.String MAX_ID_VALUE = \";\";\n\n    static final int SPLIT_CANDIDATE_THRESHOLD = 8 * 1024;\n\n    static final int DOC_SIZE_THRESHOLD = 256 * 1024;\n\n    static final int NUM_REVS_THRESHOLD = 100;\n\n    static final float SPLIT_RATIO = 0.3F;\n\n    static final int PREV_SPLIT_FACTOR = 10;\n\n    public static final java.lang.String COLLISIONS = \"_collisions\";\n\n    public static final java.lang.String MODIFIED_IN_SECS = \"_modified\";\n\n    static final int MODIFIED_IN_SECS_RESOLUTION = 5;\n\n    private static final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> EMPTY_RANGE_MAP = com.google.common.collect.Maps.unmodifiableNavigableMap(new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>());\n\n    static final java.lang.String COMMIT_ROOT = \"_commitRoot\";\n\n    private static final java.lang.String PREVIOUS = \"_prev\";\n\n    private static final java.lang.String DELETED = \"_deleted\";\n\n    public static final java.lang.String DELETED_ONCE = \"_deletedOnce\";\n\n    static final java.lang.String REVISIONS = \"_revisions\";\n\n    private static final java.lang.String LAST_REV = \"_lastRev\";\n\n    private static final java.lang.String CHILDREN_FLAG = \"_children\";\n\n    public static final java.lang.String PATH = \"_path\";\n\n    public static final java.lang.String HAS_BINARY_FLAG = \"_bin\";\n\n    private static final java.lang.String STALE_PREV = \"_stalePrev\";\n\n    public static final java.lang.String SD_TYPE = \"_sdType\";\n\n    public static final java.lang.String SD_MAX_REV_TIME_IN_SECS = \"_sdMaxRevTime\";\n\n    public static long getModifiedInSecs(long timestamp) {\n        long timeInSec = java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(timestamp);\n        return timeInSec - (timeInSec % org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS_RESOLUTION);\n    }\n\n    public enum SplitDocType {\n\n        NONE(-1),\n        DEFAULT(10),\n        @java.lang.Deprecated\n        DEFAULT_NO_CHILD(20),\n        @java.lang.Deprecated\n        PROP_COMMIT_ONLY(30),\n        INTERMEDIATE(40),\n        DEFAULT_LEAF(50),\n        COMMIT_ROOT_ONLY(60);\n        final int type;\n\n        private SplitDocType(int type) {\n            this.type = type;\n        }\n\n        public int typeCode() {\n            return type;\n        }\n\n        static org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType valueOf(java.lang.Integer type) {\n            if (type == null) {\n                return org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.NONE;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType docType : org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.values()) {\n                if (docType.type == type) {\n                    return docType;\n                }\n            }\n            throw new java.lang.IllegalArgumentException(\"Not a valid SplitDocType :\" + type);\n        }\n    }\n\n    public static final long HAS_BINARY_VAL = 1;\n\n    final org.apache.jackrabbit.oak.plugins.document.DocumentStore store;\n\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> previous;\n\n    private final java.util.concurrent.atomic.AtomicLong lastCheckTime = new java.util.concurrent.atomic.AtomicLong(java.lang.System.currentTimeMillis());\n\n    private final long creationTime;\n\n    NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store) {\n        this(store, java.lang.System.currentTimeMillis());\n    }\n\n    public NodeDocument(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentStore store, long creationTime) {\n        this.store = com.google.common.base.Preconditions.checkNotNull(store);\n        this.creationTime = creationTime;\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getValueMap(@javax.annotation.Nonnull\n    java.lang.String key) {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, key);\n    }\n\n    @java.lang.Override\n    public long getCreated() {\n        return creationTime;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.Long getModified() {\n        return ((java.lang.Long) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS)));\n    }\n\n    public boolean hasChildren() {\n        java.lang.Boolean childrenFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG)));\n        return (childrenFlag != null) && childrenFlag;\n    }\n\n    public boolean wasDeletedOnce() {\n        java.lang.Boolean deletedOnceFlag = ((java.lang.Boolean) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE)));\n        return (deletedOnceFlag != null) && deletedOnceFlag;\n    }\n\n    public boolean hasBeenModifiedSince(long lastModifiedTime) {\n        java.lang.Long modified = ((java.lang.Long) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS)));\n        return (modified != null) && (modified > java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(lastModifiedTime));\n    }\n\n    public boolean hasAllRevisionLessThan(long maxRevisionTime) {\n        java.lang.Long maxRevTimeStamp = ((java.lang.Long) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_MAX_REV_TIME_IN_SECS)));\n        return (maxRevTimeStamp != null) && (maxRevTimeStamp < java.util.concurrent.TimeUnit.MILLISECONDS.toSeconds(maxRevisionTime));\n    }\n\n    public boolean isSplitDocument() {\n        return getSplitDocType() != org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.NONE;\n    }\n\n    public org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType getSplitDocType() {\n        java.lang.Object t = get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.SD_TYPE);\n        return t == null ? org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.valueOf(((java.lang.Integer) (null))) : org.apache.jackrabbit.oak.plugins.document.NodeDocument.SplitDocType.valueOf(((java.lang.Number) (t)).intValue());\n    }\n\n    @java.lang.Override\n    public void markUpToDate(long checkTime) {\n        lastCheckTime.set(checkTime);\n    }\n\n    @java.lang.Override\n    public boolean isUpToDate(long lastCheckTime) {\n        return lastCheckTime <= this.lastCheckTime.get();\n    }\n\n    @java.lang.Override\n    public long getLastCheckTime() {\n        return lastCheckTime.get();\n    }\n\n    public boolean hasBinary() {\n        java.lang.Number flag = ((java.lang.Number) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG)));\n        return (flag != null) && (flag.intValue() == org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_VAL);\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.String getMainPath() {\n        java.lang.String p = getPath();\n        if (p.startsWith(\"p\")) {\n            p = org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, 2);\n            if (p.length() == 1) {\n                return \"/\";\n            } else {\n                return p.substring(1);\n            }\n        } else {\n            return p;\n        }\n    }\n\n    @javax.annotation.Nonnull\n    public java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> getLastRev() {\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> map = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> e : valueMap.entrySet()) {\n            int clusterId = e.getKey().getClusterId();\n            org.apache.jackrabbit.oak.plugins.document.Revision rev = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(e.getValue());\n            map.put(clusterId, rev);\n        }\n        return map;\n    }\n\n    public boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRootDoc = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRootDoc == null) {\n            return false;\n        }\n        java.lang.String value = commitRootDoc.getLocalRevisions().get(revision);\n        if (value != null) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : commitRootDoc.getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return prev.isCommitted(revision);\n            }\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getCommitRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(com.google.common.base.Preconditions.checkNotNull(revision));\n        if (commitRoot == null) {\n            return null;\n        }\n        java.lang.String value = commitRoot.getCommitValue(revision);\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(value)) {\n            return org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision(revision, value);\n        }\n        return null;\n    }\n\n    public boolean containsRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getLocalRevisions().containsKey(revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n            if (prev.containsRevision(revision)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int purgeUncommittedRevisions(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalRevisions();\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false);\n        int purgeCount = 0;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commit.getValue())) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n                if (r.getClusterId() == context.getClusterId()) {\n                    purgeCount++;\n                    op.removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, r);\n                }\n            }\n        }\n        if (op.hasChanges()) {\n            store.findAndUpdate(Collection.NODES, op);\n        }\n        return purgeCount;\n    }\n\n    int purgeCollisionMarkers(org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS);\n        org.apache.jackrabbit.oak.plugins.document.UpdateOp op = new org.apache.jackrabbit.oak.plugins.document.UpdateOp(getId(), false);\n        int purgeCount = 0;\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> commit : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision r = commit.getKey();\n            if (r.getClusterId() == context.getClusterId()) {\n                purgeCount++;\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.removeCollision(op, r);\n            }\n        }\n        if (op.hasChanges()) {\n            store.findAndUpdate(Collection.NODES, op);\n        }\n        return purgeCount;\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.Revision getMostRecentConflictFor(@javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.Revision> branchCommits, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context) {\n        com.google.common.base.Preconditions.checkNotNull(branchCommits);\n        com.google.common.base.Preconditions.checkNotNull(context);\n        java.util.Comparator<org.apache.jackrabbit.oak.plugins.document.Revision> comparator = context.getRevisionComparator();\n        org.apache.jackrabbit.oak.plugins.document.Revision conflict = null;\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> collisions = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS);\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : branchCommits) {\n            java.lang.String value = collisions.get(r.asTrunkRevision());\n            if (value == null) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.Revision c;\n            try {\n                c = org.apache.jackrabbit.oak.plugins.document.Revision.fromString(value);\n            } catch (java.lang.IllegalArgumentException e) {\n                continue;\n            }\n            if ((conflict == null) || (comparator.compare(conflict, c) < 0)) {\n                conflict = c;\n            }\n        }\n        return conflict;\n    }\n\n    @javax.annotation.CheckForNull\n    public java.lang.String getCommitRootPath(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String depth = getCommitRootDepth(revision);\n        if (depth != null) {\n            return getPathAtDepth(depth);\n        }\n        return null;\n    }\n\n    @javax.annotation.CheckForNull\n    org.apache.jackrabbit.oak.plugins.document.Revision getNewestRevision(final org.apache.jackrabbit.oak.plugins.document.RevisionContext context, final org.apache.jackrabbit.oak.plugins.document.Revision baseRev, final org.apache.jackrabbit.oak.plugins.document.Revision changeRev, final org.apache.jackrabbit.oak.plugins.document.Branch branch, final java.util.Set<org.apache.jackrabbit.oak.plugins.document.Revision> collisions) {\n        com.google.common.base.Preconditions.checkArgument((!baseRev.isBranch()) || (branch != null), \"Branch must be non-null if baseRev is a branch revision\");\n        org.apache.jackrabbit.oak.plugins.document.Revision head = context.getHeadRevision();\n        org.apache.jackrabbit.oak.plugins.document.Revision lower = (branch != null) ? branch.getBase() : baseRev;\n        java.util.Set<java.lang.Integer> clusterIds = java.util.Collections.emptySet();\n        if (!getPreviousRanges().isEmpty()) {\n            clusterIds = com.google.common.collect.Sets.newHashSet();\n            for (org.apache.jackrabbit.oak.plugins.document.Revision prevRev : getPreviousRanges().keySet()) {\n                if (!isRevisionNewer(context, lower, prevRev)) {\n                    clusterIds.add(prevRev.getClusterId());\n                }\n            }\n        }\n        boolean fullScan = true;\n        java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.Revision> changes;\n        if (clusterIds.isEmpty()) {\n            changes = com.google.common.collect.Iterables.mergeSorted(com.google.common.collect.ImmutableList.of(getLocalRevisions().keySet(), getLocalCommitRoot().keySet()), getLocalRevisions().comparator());\n        } else {\n            fullScan = false;\n            changes = getAllChanges();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.isDebugEnabled()) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" + \"_revisions {}, _commitRoot {}\", changeRev, getId(), getLocalRevisions(), getLocalCommitRoot());\n            }\n        }\n        java.util.Map<java.lang.Integer, org.apache.jackrabbit.oak.plugins.document.Revision> newestRevs = com.google.common.collect.Maps.newHashMap();\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions = com.google.common.collect.Maps.newHashMap();\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : changes) {\n            if (r.equals(changeRev)) {\n                continue;\n            }\n            if (!fullScan) {\n                if (clusterIds.contains(r.getClusterId())) {\n                    if (isRevisionNewer(context, lower, r)) {\n                        clusterIds.remove(r.getClusterId());\n                        if (clusterIds.isEmpty()) {\n                            break;\n                        }\n                    }\n                }\n            }\n            if (newestRevs.containsKey(r.getClusterId())) {\n                if ((branch != null) && (!branch.containsCommit(r))) {\n                    if (isRevisionNewer(context, r, branch.getBase())) {\n                        collisions.add(r);\n                    }\n                }\n            } else if (isValidRevision(context, r, null, baseRev, validRevisions)) {\n                newestRevs.put(r.getClusterId(), r);\n            } else {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(r);\n                org.apache.jackrabbit.oak.plugins.document.Revision commitRevision = null;\n                if (commitRoot != null) {\n                    commitRevision = commitRoot.getCommitRevision(r);\n                }\n                if ((commitRevision != null) && isRevisionNewer(context, commitRevision, head)) {\n                    collisions.add(r);\n                } else if (((commitRevision != null) && (branch == null)) && isRevisionNewer(context, r, baseRev)) {\n                    newestRevs.put(r.getClusterId(), r);\n                } else {\n                    collisions.add(r);\n                }\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision newestRev = null;\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : newestRevs.values()) {\n            newestRev = org.apache.jackrabbit.oak.plugins.document.util.Utils.max(newestRev, r, context.getRevisionComparator());\n        }\n        if (newestRev == null) {\n            return null;\n        }\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getLocalDeleted();\n        java.lang.String value = deleted.get(newestRev);\n        if ((value == null) && deleted.headMap(newestRev).isEmpty()) {\n            return newestRev;\n        }\n        if (value == null) {\n            value = getDeleted().get(newestRev);\n        }\n        if (\"true\".equals(value)) {\n            return null;\n        }\n        return newestRev;\n    }\n\n    boolean isValidRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions) {\n        if (validRevisions.containsKey(rev)) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = getCommitRoot(rev);\n        if (doc == null) {\n            return false;\n        }\n        if (doc.isCommitted(context, rev, commitValue, readRevision)) {\n            validRevisions.put(rev, commitValue);\n            return true;\n        }\n        return false;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.DocumentNodeState getNodeAtRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore nodeStore, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision lastModified) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions = com.google.common.collect.Maps.newHashMap();\n        org.apache.jackrabbit.oak.plugins.document.Branch branch = nodeStore.getBranches().getBranch(readRevision);\n        org.apache.jackrabbit.oak.plugins.document.LastRevs lastRevs = new org.apache.jackrabbit.oak.plugins.document.LastRevs(getLastRev(), readRevision, branch);\n        lastRevs.update(lastModified);\n        org.apache.jackrabbit.oak.plugins.document.Revision min = getLiveRevision(nodeStore, readRevision, validRevisions, lastRevs);\n        if (min == null) {\n            return null;\n        }\n        java.lang.String path = getPath();\n        org.apache.jackrabbit.oak.plugins.document.DocumentNodeState n = new org.apache.jackrabbit.oak.plugins.document.DocumentNodeState(nodeStore, path, readRevision, hasChildren());\n        org.apache.jackrabbit.oak.plugins.document.Revision lastRevision = min;\n        for (java.lang.String key : keySet()) {\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(key)) {\n                continue;\n            }\n            java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalMap(key);\n            if (local.isEmpty()) {\n                continue;\n            }\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(nodeStore, local, min, readRevision, validRevisions, lastRevs);\n            if (!getPreviousRanges().isEmpty()) {\n                if (!isMostRecentCommitted(nodeStore, local, value.revision)) {\n                    org.apache.jackrabbit.oak.plugins.document.Revision newestPrev = getPreviousRanges().firstKey();\n                    if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n                        value = null;\n                    }\n                }\n            }\n            if ((value == null) && (!getPreviousRanges().isEmpty())) {\n                value = getLatestValue(nodeStore, getValueMap(key), min, readRevision, validRevisions, lastRevs);\n            }\n            java.lang.String propertyName = org.apache.jackrabbit.oak.plugins.document.util.Utils.unescapePropertyName(key);\n            java.lang.String v = (value != null) ? value.value : null;\n            n.setProperty(propertyName, v);\n            if ((value != null) && isRevisionNewer(nodeStore, value.revision, lastRevision)) {\n                lastRevision = value.revision;\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision branchBase = null;\n        if (branch != null) {\n            branchBase = branch.getBase(readRevision);\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : lastRevs.get().values()) {\n            if (isRevisionNewer(nodeStore, r, readRevision)) {\n                lastRevision = readRevision;\n                continue;\n            } else if ((branchBase != null) && isRevisionNewer(nodeStore, r, branchBase)) {\n                r = branchBase;\n            }\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.revisionAreAmbiguous(nodeStore, r, lastRevision)) {\n                lastRevision = readRevision;\n            } else if (isRevisionNewer(nodeStore, r, lastRevision)) {\n                lastRevision = r;\n            }\n        }\n        if (branch != null) {\n            lastRevs.updateBranch(branch.getUnsavedLastRevision(path, readRevision));\n            org.apache.jackrabbit.oak.plugins.document.Revision r = lastRevs.getBranchRevision();\n            if (r != null) {\n                lastRevision = r;\n            }\n        }\n        n.setLastRevision(lastRevision);\n        return n;\n    }\n\n    @javax.annotation.CheckForNull\n    public org.apache.jackrabbit.oak.plugins.document.Revision getLiveRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision maxRev, java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions, org.apache.jackrabbit.oak.plugins.document.LastRevs lastRevs) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value value = getLatestValue(context, getLocalDeleted(), null, maxRev, validRevisions, lastRevs);\n        if ((value.value == null) && (!getPreviousRanges().isEmpty())) {\n            value = getLatestValue(context, getDeleted(), null, maxRev, validRevisions, lastRevs);\n        }\n        return \"false\".equals(value.value) ? value.revision : null;\n    }\n\n    boolean isConflicting(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision baseRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision commitRevision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, boolean enableConcurrentAddRemove) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> deleted = getLocalDeleted();\n        boolean allowConflictingDeleteChange = enableConcurrentAddRemove && allowConflictingDeleteChange(op);\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : deleted.entrySet()) {\n            if (entry.getKey().equals(commitRevision)) {\n                continue;\n            }\n            if (isRevisionNewer(context, entry.getKey(), baseRevision)) {\n                boolean newerDeleted = java.lang.Boolean.parseBoolean(entry.getValue());\n                if ((!allowConflictingDeleteChange) || (op.isDelete() != newerDeleted)) {\n                    return true;\n                }\n            }\n        }\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key, org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation> entry : op.getChanges().entrySet()) {\n            if (entry.getValue().type != Operation.Type.SET_MAP_ENTRY) {\n                continue;\n            }\n            java.lang.String name = entry.getKey().getName();\n            if (org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name) && (!allowConflictingDeleteChange)) {\n                return true;\n            }\n            if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                continue;\n            }\n            for (org.apache.jackrabbit.oak.plugins.document.Revision rev : getValueMap(name).keySet()) {\n                if (rev.equals(commitRevision)) {\n                    continue;\n                }\n                if (isRevisionNewer(context, rev, baseRevision)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean allowConflictingDeleteChange(org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        java.lang.String path = getPath();\n        if (!org.apache.jackrabbit.oak.plugins.document.util.Utils.isHiddenPath(path)) {\n            return false;\n        }\n        if ((!op.isNew()) && (!op.isDelete())) {\n            return false;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key opKey : op.getChanges().keySet()) {\n            java.lang.String name = opKey.getName();\n            if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(name)) {\n                return false;\n            }\n        }\n        for (java.lang.String dataKey : keySet()) {\n            if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isPropertyName(dataKey)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @javax.annotation.Nonnull\n    public java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.UpdateOp> split(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision head) {\n        return org.apache.jackrabbit.oak.plugins.document.SplitOperations.forDocument(this, context, head, org.apache.jackrabbit.oak.plugins.document.NodeDocument.NUM_REVS_THRESHOLD);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges() {\n        return getPreviousRanges(false);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> getPreviousRanges(boolean includeStale) {\n        if (includeStale) {\n            return createPreviousRanges(true);\n        } else {\n            if (previous == null) {\n                previous = createPreviousRanges(false);\n            }\n            return previous;\n        }\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> createPreviousRanges(boolean includeStale) {\n        java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> ranges;\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS);\n        if (map.isEmpty()) {\n            ranges = org.apache.jackrabbit.oak.plugins.document.NodeDocument.EMPTY_RANGE_MAP;\n        } else {\n            java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> stale = java.util.Collections.emptyMap();\n            if (!includeStale) {\n                stale = getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.STALE_PREV);\n            }\n            java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> transformed = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>(org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE);\n            for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : map.entrySet()) {\n                org.apache.jackrabbit.oak.plugins.document.Range r = org.apache.jackrabbit.oak.plugins.document.Range.fromEntry(entry.getKey(), entry.getValue());\n                if (java.lang.String.valueOf(r.height).equals(stale.get(r.high))) {\n                    continue;\n                }\n                transformed.put(r.high, r);\n            }\n            ranges = com.google.common.collect.Maps.unmodifiableNavigableMap(transformed);\n        }\n        return ranges;\n    }\n\n    @javax.annotation.Nonnull\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocs(@javax.annotation.Nonnull\n    final java.lang.String property, @javax.annotation.Nullable\n    final org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (getPreviousRanges().isEmpty()) {\n            return java.util.Collections.emptyList();\n        }\n        if (revision == null) {\n            return new org.apache.jackrabbit.oak.plugins.document.PropertyHistory(this, property);\n        } else {\n            final java.lang.String mainPath = getMainPath();\n            java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> entry = getPreviousRanges().floorEntry(revision);\n            if (entry != null) {\n                org.apache.jackrabbit.oak.plugins.document.Revision r = entry.getKey();\n                int h = entry.getValue().height;\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(mainPath, r, h);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDocument(prevId);\n                if (prev != null) {\n                    if (prev.getValueMap(property).containsKey(revision)) {\n                        return java.util.Collections.singleton(prev);\n                    }\n                } else {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n                }\n            }\n            return com.google.common.collect.Iterables.filter(com.google.common.collect.Iterables.transform(getPreviousRanges().headMap(revision).entrySet(), new com.google.common.base.Function<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>, org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public org.apache.jackrabbit.oak.plugins.document.NodeDocument apply(java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> input) {\n                    if (input.getValue().includes(revision)) {\n                        return getPreviousDoc(input.getKey(), input.getValue());\n                    }\n                    return null;\n                }\n            }), new com.google.common.base.Predicate<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n                @java.lang.Override\n                public boolean apply(@javax.annotation.Nullable\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument input) {\n                    return (input != null) && input.getValueMap(property).containsKey(revision);\n                }\n            });\n        }\n    }\n\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument getPreviousDocument(java.lang.String prevId) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.trace(\"get previous document {}\", prevId);\n        return store.find(Collection.NODES, prevId, java.lang.Integer.MAX_VALUE);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getAllPreviousDocs() {\n        if (getPreviousRanges().isEmpty()) {\n            return com.google.common.collect.Iterators.emptyIterator();\n        }\n        return new com.google.common.collect.AbstractIterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            private java.util.Queue<java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range>> previousRanges = com.google.common.collect.Queues.newArrayDeque(getPreviousRanges().entrySet());\n\n            @java.lang.Override\n            protected org.apache.jackrabbit.oak.plugins.document.NodeDocument computeNext() {\n                if (!previousRanges.isEmpty()) {\n                    java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> e = previousRanges.remove();\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDoc(e.getKey(), e.getValue());\n                    if (prev != null) {\n                        previousRanges.addAll(prev.getPreviousRanges().entrySet());\n                        return prev;\n                    }\n                }\n                return endOfData();\n            }\n        };\n    }\n\n    @javax.annotation.Nonnull\n    java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument> getPreviousDocLeaves() {\n        if (getPreviousRanges().isEmpty()) {\n            return com.google.common.collect.Iterators.emptyIterator();\n        }\n        final java.util.NavigableMap<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> ranges = com.google.common.collect.Maps.newTreeMap(getPreviousRanges());\n        return new com.google.common.collect.AbstractIterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument>() {\n            @java.lang.Override\n            protected org.apache.jackrabbit.oak.plugins.document.NodeDocument computeNext() {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument next;\n                for (; ;) {\n                    java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, org.apache.jackrabbit.oak.plugins.document.Range> topEntry = ranges.pollFirstEntry();\n                    if (topEntry == null) {\n                        next = endOfData();\n                        break;\n                    }\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDoc(topEntry.getKey(), topEntry.getValue());\n                    if (prev == null) {\n                        continue;\n                    }\n                    if (topEntry.getValue().getHeight() == 0) {\n                        next = prev;\n                        break;\n                    } else {\n                        ranges.putAll(prev.getPreviousRanges());\n                    }\n                }\n                return next;\n            }\n        };\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getPreviousDoc(org.apache.jackrabbit.oak.plugins.document.Revision rev, org.apache.jackrabbit.oak.plugins.document.Range range) {\n        int h = range.height;\n        java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getMainPath(), rev, h);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = getPreviousDocument(prevId);\n        if (prev != null) {\n            return prev;\n        } else {\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Document with previous revisions not found: \" + prevId);\n        }\n        return null;\n    }\n\n    @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.NodeDocument findPrevReferencingDoc(org.apache.jackrabbit.oak.plugins.document.Revision revision, int height) {\n        for (org.apache.jackrabbit.oak.plugins.document.Range range : getPreviousRanges().values()) {\n            if ((range.getHeight() == height) && range.high.equals(revision)) {\n                return this;\n            } else if (range.includes(revision)) {\n                java.lang.String prevId = org.apache.jackrabbit.oak.plugins.document.util.Utils.getPreviousIdFor(getMainPath(), range.high, range.height);\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument prev = store.find(org.apache.jackrabbit.oak.plugins.document.Collection.NODES, prevId);\n                if (prev == null) {\n                    org.apache.jackrabbit.oak.plugins.document.NodeDocument.LOG.warn(\"Split document {} does not exist anymore. Main document is {}\", prevId, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(getMainPath()));\n                    continue;\n                }\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = prev.findPrevReferencingDoc(revision, height);\n                if (doc != null) {\n                    return doc;\n                }\n            }\n        }\n        return null;\n    }\n\n    java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.Revision> getAllChanges() {\n        final java.util.SortedSet<org.apache.jackrabbit.oak.plugins.document.Revision> stack = com.google.common.collect.Sets.newTreeSet(org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE);\n        stack.addAll(getLocalCommitRoot().keySet());\n        stack.addAll(getLocalRevisions().keySet());\n        if (getPreviousRanges().isEmpty()) {\n            return stack;\n        }\n        return new java.lang.Iterable<org.apache.jackrabbit.oak.plugins.document.Revision>() {\n            @java.lang.Override\n            public java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> iterator() {\n                final java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.NodeDocument> previousDocs = getPreviousDocLeaves();\n                return new com.google.common.collect.AbstractIterator<org.apache.jackrabbit.oak.plugins.document.Revision>() {\n                    private org.apache.jackrabbit.oak.plugins.document.NodeDocument nextDoc;\n\n                    private org.apache.jackrabbit.oak.plugins.document.Revision nextRevision;\n\n                    @java.lang.Override\n                    protected org.apache.jackrabbit.oak.plugins.document.Revision computeNext() {\n                        if (stack.isEmpty()) {\n                            return endOfData();\n                        }\n                        org.apache.jackrabbit.oak.plugins.document.Revision next = stack.first();\n                        stack.remove(next);\n                        fillStackIfNeeded();\n                        return next;\n                    }\n\n                    private void fillStackIfNeeded() {\n                        for (; ;) {\n                            fetchNextDoc();\n                            if (nextDoc == null) {\n                                return;\n                            }\n                            if (!stack.isEmpty()) {\n                                org.apache.jackrabbit.oak.plugins.document.Revision top = stack.first();\n                                if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\n                                    return;\n                                }\n                            }\n                            com.google.common.collect.Iterables.addAll(stack, nextDoc.getAllChanges());\n                            nextDoc = null;\n                            nextRevision = null;\n                        }\n                    }\n\n                    private void fetchNextDoc() {\n                        for (; ;) {\n                            if (nextDoc != null) {\n                                break;\n                            }\n                            if (!previousDocs.hasNext()) {\n                                break;\n                            }\n                            nextDoc = previousDocs.next();\n                            java.util.Iterator<org.apache.jackrabbit.oak.plugins.document.Revision> changes = nextDoc.getAllChanges().iterator();\n                            if (changes.hasNext()) {\n                                nextRevision = changes.next();\n                                break;\n                            } else {\n                                nextDoc = null;\n                            }\n                        }\n                    }\n                };\n            }\n        };\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalMap(java.lang.String key) {\n        @java.lang.SuppressWarnings(\"unchecked\")\n        java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> map = ((java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String>) (data.get(key)));\n        if (map == null) {\n            map = ValueMap.EMPTY;\n        }\n        return map;\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalRevisions() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalCommitRoot() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getLocalDeleted() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    @javax.annotation.Nonnull\n    java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getStalePrev() {\n        return getLocalMap(org.apache.jackrabbit.oak.plugins.document.NodeDocument.STALE_PREV);\n    }\n\n    public static void setChildrenFlag(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, boolean hasChildNode) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.CHILDREN_FLAG, hasChildNode);\n    }\n\n    public static void setModified(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).max(org.apache.jackrabbit.oak.plugins.document.NodeDocument.MODIFIED_IN_SECS, org.apache.jackrabbit.oak.plugins.document.NodeDocument.getModifiedInSecs(com.google.common.base.Preconditions.checkNotNull(revision).getTimestamp()));\n    }\n\n    public static void setRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    java.lang.String commitValue) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision), com.google.common.base.Preconditions.checkNotNull(commitValue));\n    }\n\n    public static void unsetRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).unsetMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static boolean isRevisionsEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS.equals(name);\n    }\n\n    public static boolean isCommitRootEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT.equals(name);\n    }\n\n    public static boolean isDeletedEntry(java.lang.String name) {\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED.equals(name);\n    }\n\n    public static void removeRevision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void addCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision other) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision), other.toString());\n    }\n\n    public static void removeCollision(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COLLISIONS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setLastRev(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.LAST_REV, new org.apache.jackrabbit.oak.plugins.document.Revision(0, 0, revision.getClusterId()), revision.toString());\n    }\n\n    public static void setCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int commitRootDepth) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(commitRootDepth));\n    }\n\n    public static void removeCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision);\n    }\n\n    public static void setDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, boolean deleted) {\n        if (deleted) {\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.setDeletedOnce(op);\n        }\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(deleted));\n    }\n\n    public static void setDeletedOnce(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED_ONCE, java.lang.Boolean.TRUE);\n    }\n\n    public static void removeDeleted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED, revision);\n    }\n\n    public static void setPrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Range range) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(range).high, range.getLowValue());\n    }\n\n    public static void removePrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Range range) {\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.removePrevious(op, com.google.common.base.Preconditions.checkNotNull(range).high);\n    }\n\n    public static void removePrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PREVIOUS, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setStalePrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, int height) {\n        com.google.common.base.Preconditions.checkNotNull(op).setMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.STALE_PREV, com.google.common.base.Preconditions.checkNotNull(revision), java.lang.String.valueOf(height));\n    }\n\n    public static void removeStalePrevious(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        com.google.common.base.Preconditions.checkNotNull(op).removeMapEntry(org.apache.jackrabbit.oak.plugins.document.NodeDocument.STALE_PREV, com.google.common.base.Preconditions.checkNotNull(revision));\n    }\n\n    public static void setHasBinary(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.UpdateOp op) {\n        com.google.common.base.Preconditions.checkNotNull(op).set(org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_FLAG, org.apache.jackrabbit.oak.plugins.document.NodeDocument.HAS_BINARY_VAL);\n    }\n\n    private boolean isMostRecentCommitted(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, java.util.SortedMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        if (valueMap.isEmpty()) {\n            return true;\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision first = valueMap.firstKey();\n        if (!isRevisionNewer(context, first, revision)) {\n            return true;\n        }\n        for (org.apache.jackrabbit.oak.plugins.document.Revision r : valueMap.keySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision c = getCommitRevision(r);\n            if (c != null) {\n                return !isRevisionNewer(context, c, revision);\n            }\n        }\n        return true;\n    }\n\n    static boolean revisionAreAmbiguous(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision r1, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision r2) {\n        if (r1.getClusterId() == r2.getClusterId()) {\n            return false;\n        }\n        int c1 = context.getRevisionComparator().compare(r1, r2);\n        int c2 = r1.compareTo(r2);\n        if (c1 == 0) {\n            return c2 == 0;\n        } else if (c1 < 0) {\n            return c2 >= 0;\n        } else {\n            return c2 <= 0;\n        }\n    }\n\n    @javax.annotation.CheckForNull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument getCommitRoot(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision rev) {\n        if (getLocalRevisions().containsKey(rev)) {\n            return this;\n        }\n        java.lang.String commitRootPath;\n        java.lang.String depth = getLocalCommitRoot().get(rev);\n        if (depth != null) {\n            commitRootPath = getPathAtDepth(depth);\n        } else {\n            if (containsRevision(rev)) {\n                return this;\n            }\n            commitRootPath = getCommitRootPath(rev);\n            if (commitRootPath == null) {\n                return null;\n            }\n        }\n        return store.find(Collection.NODES, org.apache.jackrabbit.oak.plugins.document.util.Utils.getIdFromPath(commitRootPath));\n    }\n\n    @javax.annotation.Nonnull\n    private java.lang.String getPathAtDepth(@javax.annotation.Nonnull\n    java.lang.String depth) {\n        if (com.google.common.base.Preconditions.checkNotNull(depth).equals(\"0\")) {\n            return \"/\";\n        }\n        java.lang.String p = getPath();\n        return org.apache.jackrabbit.oak.commons.PathUtils.getAncestorPath(p, org.apache.jackrabbit.oak.commons.PathUtils.getDepth(p) - java.lang.Integer.parseInt(depth));\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitRootDepth(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> local = getLocalCommitRoot();\n        java.lang.String depth = local.get(revision);\n        if (depth == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.COMMIT_ROOT, revision)) {\n                depth = prev.getCommitRootDepth(revision);\n                if (depth != null) {\n                    break;\n                }\n            }\n        }\n        return depth;\n    }\n\n    private boolean isCommitted(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n    java.lang.String commitValue, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision) {\n        if (commitValue == null) {\n            commitValue = getCommitValue(revision);\n        }\n        if (commitValue == null) {\n            return false;\n        }\n        if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n            if ((context.getBranches().getBranch(readRevision) == null) && (!readRevision.isBranch())) {\n                revision = resolveCommitRevision(revision, commitValue);\n                return !isRevisionNewer(context, revision, readRevision);\n            } else if (commitValue.equals(getCommitValue(readRevision.asTrunkRevision()))) {\n                return !isRevisionNewer(context, revision, readRevision);\n            }\n        } else if (org.apache.jackrabbit.oak.plugins.document.Revision.fromString(commitValue).getClusterId() != context.getClusterId()) {\n            return false;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.NodeDocument.includeRevision(context, resolveCommitRevision(revision, commitValue), readRevision);\n    }\n\n    @javax.annotation.CheckForNull\n    private java.lang.String getCommitValue(org.apache.jackrabbit.oak.plugins.document.Revision revision) {\n        java.lang.String value = getLocalRevisions().get(revision);\n        if (value == null) {\n            for (org.apache.jackrabbit.oak.plugins.document.NodeDocument prev : getPreviousDocs(org.apache.jackrabbit.oak.plugins.document.NodeDocument.REVISIONS, revision)) {\n                value = prev.getCommitValue(revision);\n                if (value != null) {\n                    break;\n                }\n            }\n        }\n        return value;\n    }\n\n    private static boolean includeRevision(org.apache.jackrabbit.oak.plugins.document.RevisionContext context, org.apache.jackrabbit.oak.plugins.document.Revision x, org.apache.jackrabbit.oak.plugins.document.Revision requestRevision) {\n        org.apache.jackrabbit.oak.plugins.document.Branch b = context.getBranches().getBranch(x);\n        if (b != null) {\n            if (b.containsCommit(requestRevision)) {\n                return x.equalsIgnoreBranch(requestRevision) || isRevisionNewer(context, requestRevision, x);\n            }\n            return false;\n        }\n        b = context.getBranches().getBranch(requestRevision);\n        if (b != null) {\n            requestRevision = b.getBase(requestRevision);\n        }\n        return context.getRevisionComparator().compare(requestRevision, x) >= 0;\n    }\n\n    @javax.annotation.Nonnull\n    private org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value getLatestValue(@javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.RevisionContext context, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> valueMap, @javax.annotation.Nullable\n    org.apache.jackrabbit.oak.plugins.document.Revision min, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.Revision readRevision, @javax.annotation.Nonnull\n    java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> validRevisions, @javax.annotation.Nonnull\n    org.apache.jackrabbit.oak.plugins.document.LastRevs lastRevs) {\n        for (java.util.Map.Entry<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> entry : valueMap.entrySet()) {\n            org.apache.jackrabbit.oak.plugins.document.Revision propRev = entry.getKey();\n            java.lang.String commitValue = validRevisions.get(propRev);\n            if (commitValue == null) {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument commitRoot = getCommitRoot(propRev);\n                if (commitRoot == null) {\n                    continue;\n                }\n                commitValue = commitRoot.getCommitValue(propRev);\n                if (commitValue == null) {\n                    continue;\n                }\n            }\n            org.apache.jackrabbit.oak.plugins.document.Revision commitRev = resolveCommitRevision(propRev, commitValue);\n            if (org.apache.jackrabbit.oak.plugins.document.util.Utils.isCommitted(commitValue)) {\n                lastRevs.update(commitRev);\n            } else {\n                lastRevs.updateBranch(commitRev.asBranchRevision());\n            }\n            if ((min != null) && isRevisionNewer(context, min, commitRev)) {\n                continue;\n            }\n            if (isValidRevision(context, propRev, commitValue, readRevision, validRevisions)) {\n                return new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(commitRev, entry.getValue());\n            }\n        }\n        org.apache.jackrabbit.oak.plugins.document.Revision r = (min != null) ? min : readRevision;\n        return new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Value(r, null);\n    }\n\n    @java.lang.Override\n    public java.lang.String getPath() {\n        java.lang.String p = ((java.lang.String) (get(org.apache.jackrabbit.oak.plugins.document.NodeDocument.PATH)));\n        if (p != null) {\n            return p;\n        }\n        return org.apache.jackrabbit.oak.plugins.document.util.Utils.getPathFromId(getId());\n    }\n\n    @javax.annotation.Nonnull\n    private java.util.Map<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.String> getDeleted() {\n        return org.apache.jackrabbit.oak.plugins.document.ValueMap.create(this, org.apache.jackrabbit.oak.plugins.document.NodeDocument.DELETED);\n    }\n\n    public java.lang.String asString() {\n        org.apache.jackrabbit.oak.commons.json.JsopWriter json = new org.apache.jackrabbit.oak.commons.json.JsopBuilder();\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument.toJson(json, data);\n        return json.toString();\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    private static void toJson(org.apache.jackrabbit.oak.commons.json.JsopWriter json, java.util.Map<?, java.lang.Object> map) {\n        for (java.util.Map.Entry<?, java.lang.Object> e : map.entrySet()) {\n            json.key(e.getKey().toString());\n            java.lang.Object value = e.getValue();\n            if (value == null) {\n                json.value(null);\n            } else if (value instanceof java.lang.Boolean) {\n                json.value(((java.lang.Boolean) (value)));\n            } else if (value instanceof java.lang.Long) {\n                json.value(((java.lang.Long) (value)));\n            } else if (value instanceof java.lang.Integer) {\n                json.value(((java.lang.Integer) (value)));\n            } else if (value instanceof java.util.Map) {\n                json.object();\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.toJson(json, ((java.util.Map<java.lang.Object, java.lang.Object>) (value)));\n                json.endObject();\n            } else if (value instanceof org.apache.jackrabbit.oak.plugins.document.Revision) {\n                json.value(value.toString());\n            } else {\n                json.value(((java.lang.String) (value)));\n            }\n        }\n    }\n\n    public static org.apache.jackrabbit.oak.plugins.document.NodeDocument fromString(org.apache.jackrabbit.oak.plugins.document.DocumentStore store, java.lang.String s) {\n        org.apache.jackrabbit.oak.commons.json.JsopTokenizer json = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(s);\n        org.apache.jackrabbit.oak.plugins.document.NodeDocument doc = new org.apache.jackrabbit.oak.plugins.document.NodeDocument(store);\n        while (true) {\n            if (json.matches(JsopReader.END)) {\n                break;\n            }\n            java.lang.String k = json.readString();\n            json.read(':');\n            if (json.matches(JsopReader.END)) {\n                break;\n            }\n            doc.put(k, org.apache.jackrabbit.oak.plugins.document.NodeDocument.fromJson(json));\n            json.matches(',');\n        } \n        return doc;\n    }\n\n    private static java.lang.Object fromJson(org.apache.jackrabbit.oak.commons.json.JsopTokenizer json) {\n        switch (json.read()) {\n            case org.apache.jackrabbit.oak.commons.json.JsopReader.NULL :\n                return null;\n            case org.apache.jackrabbit.oak.commons.json.JsopReader.TRUE :\n                return true;\n            case org.apache.jackrabbit.oak.commons.json.JsopReader.FALSE :\n                return false;\n            case org.apache.jackrabbit.oak.commons.json.JsopReader.NUMBER :\n                return java.lang.Long.parseLong(json.getToken());\n            case org.apache.jackrabbit.oak.commons.json.JsopReader.STRING :\n                return json.getToken();\n            case '{' :\n                java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.Object> map = new java.util.TreeMap<org.apache.jackrabbit.oak.plugins.document.Revision, java.lang.Object>(org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE);\n                while (true) {\n                    if (json.matches('}')) {\n                        break;\n                    }\n                    java.lang.String k = json.readString();\n                    json.read(':');\n                    map.put(org.apache.jackrabbit.oak.plugins.document.Revision.fromString(k), org.apache.jackrabbit.oak.plugins.document.NodeDocument.fromJson(json));\n                    json.matches(',');\n                } \n                return map;\n        }\n        throw new java.lang.IllegalArgumentException(json.readRawValue());\n    }\n\n    public static final class Children implements java.lang.Cloneable , org.apache.jackrabbit.oak.cache.CacheValue {\n        java.util.ArrayList<java.lang.String> childNames = new java.util.ArrayList<java.lang.String>();\n\n        boolean isComplete;\n\n        @java.lang.Override\n        public int getMemory() {\n            int size = 114;\n            for (java.lang.String name : childNames) {\n                size += (name.length() * 2) + 56;\n            }\n            return size;\n        }\n\n        @java.lang.SuppressWarnings(\"unchecked\")\n        @java.lang.Override\n        public org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone() {\n            try {\n                org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children clone = ((org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children) (super.clone()));\n                clone.childNames = ((java.util.ArrayList<java.lang.String>) (childNames.clone()));\n                return clone;\n            } catch (java.lang.CloneNotSupportedException e) {\n                throw new java.lang.RuntimeException();\n            }\n        }\n\n        public java.lang.String asString() {\n            org.apache.jackrabbit.oak.commons.json.JsopWriter json = new org.apache.jackrabbit.oak.commons.json.JsopBuilder();\n            if (isComplete) {\n                json.key(\"isComplete\").value(true);\n            }\n            if (childNames.size() > 0) {\n                json.key(\"children\").array();\n                for (java.lang.String c : childNames) {\n                    json.value(c);\n                }\n                json.endArray();\n            }\n            return json.toString();\n        }\n\n        public static org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children fromString(java.lang.String s) {\n            org.apache.jackrabbit.oak.commons.json.JsopTokenizer json = new org.apache.jackrabbit.oak.commons.json.JsopTokenizer(s);\n            org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children children = new org.apache.jackrabbit.oak.plugins.document.NodeDocument.Children();\n            while (true) {\n                if (json.matches(JsopReader.END)) {\n                    break;\n                }\n                java.lang.String k = json.readString();\n                json.read(':');\n                if (\"isComplete\".equals(k)) {\n                    children.isComplete = json.read() == org.apache.jackrabbit.oak.commons.json.JsopReader.TRUE;\n                } else if (\"children\".equals(k)) {\n                    json.read('[');\n                    while (true) {\n                        if (json.matches(']')) {\n                            break;\n                        }\n                        java.lang.String value = json.readString();\n                        children.childNames.add(value);\n                        json.matches(',');\n                    } \n                }\n                if (json.matches(JsopReader.END)) {\n                    break;\n                }\n                json.read(',');\n            } \n            return children;\n        }\n    }\n\n    private static final class Value {\n        final org.apache.jackrabbit.oak.plugins.document.Revision revision;\n\n        final java.lang.String value;\n\n        Value(@javax.annotation.Nonnull\n        org.apache.jackrabbit.oak.plugins.document.Revision revision, @javax.annotation.Nullable\n        java.lang.String value) {\n            this.revision = com.google.common.base.Preconditions.checkNotNull(revision);\n            this.value = value;\n        }\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "!isMostRecentCommitted(nodeStore, local, value.revision)",
            "src_parent": "if (!isMostRecentCommitted(nodeStore, local, value.revision)) {\n    org.apache.jackrabbit.oak.plugins.document.Revision newestPrev = getPreviousRanges().firstKey();\n    if (isRevisionNewer(nodeStore, newestPrev, value.revision)) {\n        value = null;\n    }\n}",
            "src_parent_type": "If",
            "src_type": "UnaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "org.apache.jackrabbit.oak.plugins.document.NodeDocument",
            "dst_parent": "",
            "dst_parent_type": "ThisAccess",
            "dst_type": "TypeAccess",
            "operator": "MOV",
            "src": "org.apache.jackrabbit.oak.plugins.document.NodeDocument",
            "src_parent": "",
            "src_parent_type": "ThisAccess",
            "src_type": "TypeAccess"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "nodeStore",
            "dst_parent": "isMostRecentCommitted(nodeStore, local, value.revision)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "nodeStore",
            "src_parent": "isRevisionNewer(nodeStore, newest, value.revision)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "local",
            "dst_parent": "isMostRecentCommitted(nodeStore, local, value.revision)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "newest",
            "src_parent": "isRevisionNewer(nodeStore, newest, value.revision)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "value.revision",
            "dst_parent": "isMostRecentCommitted(nodeStore, local, value.revision)",
            "dst_parent_type": "Invocation",
            "dst_type": "FieldRead",
            "operator": "MOV",
            "src": "value.revision",
            "src_parent": "isRevisionNewer(nodeStore, newest, value.revision)",
            "src_parent_type": "Invocation",
            "src_type": "FieldRead"
          }
        }
      ],
      "file_name": "NodeDocument"
    }
  ],
  "id": "jackrabbit-oak_ff81ef72"
}