{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private java.util.Set<spoon.reflect.reference.CtTypeReference> exploredReferences = new java.util.HashSet<>();",
            "src_parent": "public class ImportScannerImpl extends spoon.reflect.visitor.CtScanner implements spoon.reflect.visitor.ImportScanner {\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang8 = java.util.Collections.singletonList(\"FunctionalInterface\");\n\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang9 = java.util.Arrays.asList(\"ProcessHandle\", \"StackWalker\", \"StackFramePermission\");\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtTypeReference<?>> classImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtFieldReference<?>> fieldImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtExecutableReference<?>> methodImports = new java.util.TreeMap<>();\n\n    protected spoon.reflect.reference.CtTypeReference<?> targetType;\n\n    private java.util.Map<java.lang.String, java.lang.Boolean> namesPresentInJavaLang = new java.util.HashMap<>();\n\n    private java.util.Set<java.lang.String> fieldAndMethodsNames = new java.util.HashSet<java.lang.String>();\n\n    private java.util.Set<spoon.reflect.reference.CtTypeReference> exploredReferences = new java.util.HashSet<>();\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        enter(fieldRead);\n        scan(fieldRead.getVariable());\n        scan(fieldRead.getAnnotations());\n        scan(fieldRead.getTypeCasts());\n        scan(fieldRead.getVariable());\n        scan(fieldRead.getTarget());\n        exit(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        enter(fieldWrite);\n        scan(fieldWrite.getVariable());\n        scan(fieldWrite.getAnnotations());\n        scan(fieldWrite.getTypeCasts());\n        scan(fieldWrite.getVariable());\n        scan(fieldWrite.getTarget());\n        exit(fieldWrite);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        enter(reference);\n        if (reference.isStatic()) {\n            if (!addFieldImport(reference)) {\n                scan(reference.getDeclaringType());\n            }\n        } else {\n            scan(reference.getDeclaringType());\n        }\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        enter(reference);\n        if (reference.isStatic()) {\n            addMethodImport(reference);\n        } else if (reference.isConstructor()) {\n            scan(reference.getDeclaringType());\n        }\n        scan(reference.getActualTypeArguments());\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enter(invocation);\n        scan(invocation.getAnnotations());\n        scan(invocation.getTypeCasts());\n        scan(invocation.getTarget());\n        scan(invocation.getExecutable());\n        scan(invocation.getArguments());\n        exit(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (!(reference instanceof spoon.reflect.reference.CtArrayTypeReference)) {\n            if (reference.getDeclaringType() == null) {\n                addClassImport(reference);\n            } else {\n                addClassImport(reference.getAccessType());\n            }\n        }\n        super.visitCtTypeReference(reference);\n    }\n\n    @java.lang.Override\n    public void scan(spoon.reflect.declaration.CtElement element) {\n        if ((element != null) && (!element.isImplicit())) {\n            element.accept(this);\n        }\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        addClassImport(annotationType.getReference());\n        super.visitCtAnnotationType(annotationType);\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        addClassImport(ctEnum.getReference());\n        super.visitCtEnum(ctEnum);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        addClassImport(intrface.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : intrface.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtInterface(intrface);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        addClassImport(ctClass.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : ctClass.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtClass(ctClass);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        for (spoon.reflect.reference.CtTypeReference<?> type : catchVariable.getMultiTypes()) {\n            addClassImport(type);\n        }\n        super.visitCtCatchVariable(catchVariable);\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeAllImports(spoon.reflect.declaration.CtType<?> simpleType) {\n        classImports.clear();\n        fieldImports.clear();\n        methodImports.clear();\n        targetType = simpleType.getReference().getTopLevelType();\n        addClassImport(simpleType.getReference());\n        scan(simpleType);\n        java.util.Collection<spoon.reflect.reference.CtReference> listallImports = new java.util.ArrayList<>();\n        listallImports.addAll(this.classImports.values());\n        listallImports.addAll(this.fieldImports.values());\n        listallImports.addAll(this.methodImports.values());\n        return listallImports;\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtTypeReference<?>> computeImports(spoon.reflect.declaration.CtElement element) {\n        classImports.clear();\n        fieldImports.clear();\n        methodImports.clear();\n        if (element instanceof spoon.reflect.declaration.CtType) {\n            spoon.reflect.declaration.CtType simpleType = ((spoon.reflect.declaration.CtType) (element));\n            targetType = simpleType.getReference().getTopLevelType();\n            addClassImport(simpleType.getReference());\n            scan(simpleType);\n        } else {\n            spoon.reflect.declaration.CtType<?> type = element.getParent(spoon.reflect.declaration.CtType.class);\n            targetType = (type == null) ? null : type.getReference().getTopLevelType();\n            scan(element);\n        }\n        return this.classImports.values();\n    }\n\n    @java.lang.Override\n    public boolean isImported(spoon.reflect.reference.CtReference ref) {\n        if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            return isImportedInFieldImports(((spoon.reflect.reference.CtFieldReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            return isImportedInMethodImports(((spoon.reflect.reference.CtExecutableReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            return isImportedInClassImports(((spoon.reflect.reference.CtTypeReference) (ref)));\n        } else {\n            return false;\n        }\n    }\n\n    private boolean isThereAnotherClassWithSameNameInAnotherPackage(spoon.reflect.reference.CtTypeReference<?> ref) {\n        for (spoon.reflect.reference.CtTypeReference typeref : this.exploredReferences) {\n            if (typeref.getSimpleName().equals(ref.getSimpleName()) && (!typeref.getQualifiedName().equals(ref.getQualifiedName()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean addClassImport(spoon.reflect.reference.CtTypeReference<?> ref) {\n        this.exploredReferences.add(ref);\n        if (ref == null) {\n            return false;\n        }\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return false;\n        }\n        if (classImports.containsKey(ref.getSimpleName())) {\n            return isImportedInClassImports(ref);\n        }\n        if ((ref.getPackage() == null) || ref.getPackage().isUnnamedPackage()) {\n            return false;\n        }\n        if (ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n            if (classNamePresentInJavaLang(ref)) {\n                return false;\n            }\n        }\n        if ((targetType != null) && (targetType.canAccess(ref) == false)) {\n            return false;\n        }\n        if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n            return false;\n        }\n        if (targetType != null) {\n            try {\n                spoon.reflect.declaration.CtElement parent = ref.getParent();\n                if (parent != null) {\n                    parent = parent.getParent();\n                    if (parent != null) {\n                        if (((parent instanceof spoon.reflect.code.CtFieldAccess) || (parent instanceof spoon.reflect.declaration.CtExecutable)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                            spoon.reflect.reference.CtTypeReference declaringType;\n                            spoon.reflect.reference.CtReference reference;\n                            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n                            if (parent instanceof spoon.reflect.code.CtFieldAccess) {\n                                spoon.reflect.code.CtFieldAccess field = ((spoon.reflect.code.CtFieldAccess) (parent));\n                                spoon.reflect.reference.CtFieldReference localReference = field.getVariable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.declaration.CtExecutable) {\n                                spoon.reflect.declaration.CtExecutable exec = ((spoon.reflect.declaration.CtExecutable) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = exec.getReference();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.code.CtInvocation) {\n                                spoon.reflect.code.CtInvocation invo = ((spoon.reflect.code.CtInvocation) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = invo.getExecutable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else {\n                                declaringType = null;\n                                reference = null;\n                            }\n                            if ((reference != null) && isImported(reference)) {\n                                if (declaringType != null) {\n                                    if ((declaringType.getPackage() != null) && (!declaringType.getPackage().isUnnamedPackage())) {\n                                        if (!declaringType.getPackage().getSimpleName().equals(\"java.lang\")) {\n                                            if (declaringType.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                                                classImports.put(ref.getSimpleName(), ref);\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            }\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if ((ref.getPackage() != null) && (!ref.getPackage().isUnnamedPackage())) {\n                if (!ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n                    if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                        return false;\n                    }\n                }\n            }\n        }\n        classImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    protected boolean isImportedInClassImports(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (targetType != null) {\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if ((ref.getPackage() != null) && (!ref.getPackage().isUnnamedPackage())) {\n                if (!ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n                    if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                        return true;\n                    }\n                }\n            }\n        }\n        if (ref.equals(targetType)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && classImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtTypeReference<?> exist = classImports.get(ref.getSimpleName());\n            if (exist.getQualifiedName().equals(ref.getQualifiedName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean declaringTypeIsLocalOrImported(spoon.reflect.reference.CtTypeReference declaringType) {\n        if (declaringType != null) {\n            if (isImportedInClassImports(declaringType) || classNamePresentInJavaLang(declaringType)) {\n                return true;\n            }\n            if ((!isTypeInCollision(declaringType, false)) && addClassImport(declaringType)) {\n                return true;\n            }\n            while (declaringType != null) {\n                if (declaringType.equals(targetType)) {\n                    return true;\n                }\n                declaringType = declaringType.getDeclaringType();\n            } \n        }\n        return false;\n    }\n\n    protected boolean addMethodImport(spoon.reflect.reference.CtExecutableReference ref) {\n        if (this.methodImports.containsKey(ref.getSimpleName())) {\n            return isImportedInMethodImports(ref);\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        methodImports.put(ref.getSimpleName(), ref);\n        if (ref.getDeclaringType() != null) {\n            if (ref.getDeclaringType().getPackage() != null) {\n                if (ref.getDeclaringType().getPackage().equals(this.targetType.getPackage())) {\n                    addClassImport(ref.getDeclaringType());\n                }\n            }\n        }\n        return true;\n    }\n\n    protected boolean isImportedInMethodImports(spoon.reflect.reference.CtExecutableReference<?> ref) {\n        if ((!ref.isImplicit()) && methodImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtExecutableReference<?> exist = methodImports.get(ref.getSimpleName());\n            if (exist.getSignature().equals(ref.getSignature())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean addFieldImport(spoon.reflect.reference.CtFieldReference ref) {\n        if (this.fieldImports.containsKey(ref.getSimpleName())) {\n            return isImportedInFieldImports(ref);\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        fieldImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    protected boolean isImportedInFieldImports(spoon.reflect.reference.CtFieldReference<?> ref) {\n        if ((!ref.isImplicit()) && fieldImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtFieldReference<?> exist = fieldImports.get(ref.getSimpleName());\n            try {\n                if ((exist.getFieldDeclaration() != null) && exist.getFieldDeclaration().equals(ref.getFieldDeclaration())) {\n                    return true;\n                }\n            } catch (spoon.support.SpoonClassNotFoundException notfound) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    protected boolean classNamePresentInJavaLang(spoon.reflect.reference.CtTypeReference<?> ref) {\n        java.lang.Boolean presentInJavaLang = namesPresentInJavaLang.get(ref.getSimpleName());\n        if (presentInJavaLang == null) {\n            if (spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang8.contains(ref.getSimpleName()) || spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang9.contains(ref.getSimpleName())) {\n                presentInJavaLang = true;\n            } else {\n                try {\n                    java.lang.Class.forName(\"java.lang.\" + ref.getSimpleName());\n                    presentInJavaLang = true;\n                } catch (java.lang.ClassNotFoundException e) {\n                    presentInJavaLang = false;\n                }\n            }\n            namesPresentInJavaLang.put(ref.getSimpleName(), presentInJavaLang);\n        }\n        return presentInJavaLang;\n    }\n\n    protected java.util.Set<java.lang.String> lookForLocalVariables(spoon.reflect.declaration.CtElement parent) {\n        java.util.Set<java.lang.String> result = new java.util.HashSet<>();\n        while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n            if (parent instanceof spoon.reflect.declaration.CtClass) {\n                return result;\n            }\n            parent = parent.getParent();\n        } \n        if (parent != null) {\n            spoon.reflect.code.CtBlock block = ((spoon.reflect.code.CtBlock) (parent));\n            boolean innerClass = false;\n            while ((parent != null) && (!(parent instanceof spoon.reflect.declaration.CtClass))) {\n                parent = parent.getParent();\n            } \n            if (parent != null) {\n                if (!(parent.getParent() instanceof spoon.reflect.declaration.CtPackage)) {\n                    while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n                        parent = parent.getParent();\n                    } \n                    if (parent != null) {\n                        block = ((spoon.reflect.code.CtBlock) (parent));\n                    }\n                }\n            }\n            spoon.reflect.visitor.AccessibleVariablesFinder avf = new spoon.reflect.visitor.AccessibleVariablesFinder(block);\n            java.util.List<spoon.reflect.declaration.CtVariable> variables = avf.find();\n            for (spoon.reflect.declaration.CtVariable variable : variables) {\n                result.add(variable.getSimpleName());\n            }\n        }\n        return result;\n    }\n\n    protected boolean isTypeInCollision(spoon.reflect.reference.CtReference ref, boolean fqnMode) {\n        if (targetType.getSimpleName().equals(ref.getSimpleName()) && (!targetType.equals(ref))) {\n            return true;\n        }\n        try {\n            spoon.reflect.declaration.CtElement parent;\n            if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                parent = ref.getParent();\n            } else {\n                parent = ref;\n            }\n            java.util.Set<java.lang.String> localVariablesOfBlock = new java.util.HashSet<>();\n            if (parent instanceof spoon.reflect.declaration.CtField) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtField) (parent)).getSimpleName());\n            } else if (parent instanceof spoon.reflect.declaration.CtMethod) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtMethod) (parent)).getSimpleName());\n            } else {\n                localVariablesOfBlock = this.lookForLocalVariables(parent);\n            }\n            while (!(parent instanceof spoon.reflect.declaration.CtPackage)) {\n                if ((parent instanceof spoon.reflect.reference.CtFieldReference) || (parent instanceof spoon.reflect.reference.CtExecutableReference)) {\n                    spoon.reflect.reference.CtReference parentType = ((spoon.reflect.reference.CtReference) (parent));\n                    java.util.LinkedList<java.lang.String> qualifiedNameTokens = new java.util.LinkedList<>();\n                    if (parentType != parent) {\n                        qualifiedNameTokens.add(parentType.getSimpleName());\n                    }\n                    spoon.reflect.reference.CtTypeReference typeReference;\n                    if (parent instanceof spoon.reflect.reference.CtFieldReference) {\n                        typeReference = ((spoon.reflect.reference.CtFieldReference) (parent)).getDeclaringType();\n                    } else {\n                        typeReference = ((spoon.reflect.reference.CtExecutableReference) (parent)).getDeclaringType();\n                    }\n                    if (typeReference != null) {\n                        qualifiedNameTokens.add(typeReference.getSimpleName());\n                        if (typeReference.getPackage() != null) {\n                            spoon.reflect.declaration.CtPackage ctPackage = typeReference.getPackage().getDeclaration();\n                            while (ctPackage != null) {\n                                qualifiedNameTokens.add(ctPackage.getSimpleName());\n                                spoon.reflect.declaration.CtElement packParent = ctPackage.getParent();\n                                if ((packParent.getParent() != null) && (!((spoon.reflect.declaration.CtPackage) (packParent)).getSimpleName().equals(spoon.reflect.declaration.CtPackage.TOP_LEVEL_PACKAGE_NAME))) {\n                                    ctPackage = ((spoon.reflect.declaration.CtPackage) (packParent));\n                                } else {\n                                    ctPackage = null;\n                                }\n                            } \n                        }\n                    }\n                    if (!qualifiedNameTokens.isEmpty()) {\n                        if (fieldAndMethodsNames.contains(qualifiedNameTokens.getLast()) || localVariablesOfBlock.contains(qualifiedNameTokens.getLast())) {\n                            qualifiedNameTokens.removeLast();\n                            if (fqnMode) {\n                                return true;\n                            } else {\n                                for (int i = qualifiedNameTokens.size() - 1; i > 0; i--) {\n                                    java.lang.String testedToken = qualifiedNameTokens.get(i);\n                                    if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                        }\n                    }\n                }\n                parent = parent.getParent();\n            } \n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean isThereAnotherClassWithSameNameInAnotherPackage(spoon.reflect.reference.CtTypeReference<?> ref) {\n    for (spoon.reflect.reference.CtTypeReference typeref : this.exploredReferences) {\n        if (typeref.getSimpleName().equals(ref.getSimpleName()) && (!typeref.getQualifiedName().equals(ref.getQualifiedName()))) {\n            return true;\n        }\n    }\n    return false;\n}",
            "src_parent": "public class ImportScannerImpl extends spoon.reflect.visitor.CtScanner implements spoon.reflect.visitor.ImportScanner {\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang8 = java.util.Collections.singletonList(\"FunctionalInterface\");\n\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang9 = java.util.Arrays.asList(\"ProcessHandle\", \"StackWalker\", \"StackFramePermission\");\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtTypeReference<?>> classImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtFieldReference<?>> fieldImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtExecutableReference<?>> methodImports = new java.util.TreeMap<>();\n\n    protected spoon.reflect.reference.CtTypeReference<?> targetType;\n\n    private java.util.Map<java.lang.String, java.lang.Boolean> namesPresentInJavaLang = new java.util.HashMap<>();\n\n    private java.util.Set<java.lang.String> fieldAndMethodsNames = new java.util.HashSet<java.lang.String>();\n\n    private java.util.Set<spoon.reflect.reference.CtTypeReference> exploredReferences = new java.util.HashSet<>();\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        enter(fieldRead);\n        scan(fieldRead.getVariable());\n        scan(fieldRead.getAnnotations());\n        scan(fieldRead.getTypeCasts());\n        scan(fieldRead.getVariable());\n        scan(fieldRead.getTarget());\n        exit(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        enter(fieldWrite);\n        scan(fieldWrite.getVariable());\n        scan(fieldWrite.getAnnotations());\n        scan(fieldWrite.getTypeCasts());\n        scan(fieldWrite.getVariable());\n        scan(fieldWrite.getTarget());\n        exit(fieldWrite);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        enter(reference);\n        if (reference.isStatic()) {\n            if (!addFieldImport(reference)) {\n                scan(reference.getDeclaringType());\n            }\n        } else {\n            scan(reference.getDeclaringType());\n        }\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        enter(reference);\n        if (reference.isStatic()) {\n            addMethodImport(reference);\n        } else if (reference.isConstructor()) {\n            scan(reference.getDeclaringType());\n        }\n        scan(reference.getActualTypeArguments());\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enter(invocation);\n        scan(invocation.getAnnotations());\n        scan(invocation.getTypeCasts());\n        scan(invocation.getTarget());\n        scan(invocation.getExecutable());\n        scan(invocation.getArguments());\n        exit(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (!(reference instanceof spoon.reflect.reference.CtArrayTypeReference)) {\n            if (reference.getDeclaringType() == null) {\n                addClassImport(reference);\n            } else {\n                addClassImport(reference.getAccessType());\n            }\n        }\n        super.visitCtTypeReference(reference);\n    }\n\n    @java.lang.Override\n    public void scan(spoon.reflect.declaration.CtElement element) {\n        if ((element != null) && (!element.isImplicit())) {\n            element.accept(this);\n        }\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        addClassImport(annotationType.getReference());\n        super.visitCtAnnotationType(annotationType);\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        addClassImport(ctEnum.getReference());\n        super.visitCtEnum(ctEnum);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        addClassImport(intrface.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : intrface.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtInterface(intrface);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        addClassImport(ctClass.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : ctClass.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtClass(ctClass);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        for (spoon.reflect.reference.CtTypeReference<?> type : catchVariable.getMultiTypes()) {\n            addClassImport(type);\n        }\n        super.visitCtCatchVariable(catchVariable);\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeAllImports(spoon.reflect.declaration.CtType<?> simpleType) {\n        classImports.clear();\n        fieldImports.clear();\n        methodImports.clear();\n        targetType = simpleType.getReference().getTopLevelType();\n        addClassImport(simpleType.getReference());\n        scan(simpleType);\n        java.util.Collection<spoon.reflect.reference.CtReference> listallImports = new java.util.ArrayList<>();\n        listallImports.addAll(this.classImports.values());\n        listallImports.addAll(this.fieldImports.values());\n        listallImports.addAll(this.methodImports.values());\n        return listallImports;\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtTypeReference<?>> computeImports(spoon.reflect.declaration.CtElement element) {\n        classImports.clear();\n        fieldImports.clear();\n        methodImports.clear();\n        if (element instanceof spoon.reflect.declaration.CtType) {\n            spoon.reflect.declaration.CtType simpleType = ((spoon.reflect.declaration.CtType) (element));\n            targetType = simpleType.getReference().getTopLevelType();\n            addClassImport(simpleType.getReference());\n            scan(simpleType);\n        } else {\n            spoon.reflect.declaration.CtType<?> type = element.getParent(spoon.reflect.declaration.CtType.class);\n            targetType = (type == null) ? null : type.getReference().getTopLevelType();\n            scan(element);\n        }\n        return this.classImports.values();\n    }\n\n    @java.lang.Override\n    public boolean isImported(spoon.reflect.reference.CtReference ref) {\n        if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            return isImportedInFieldImports(((spoon.reflect.reference.CtFieldReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            return isImportedInMethodImports(((spoon.reflect.reference.CtExecutableReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            return isImportedInClassImports(((spoon.reflect.reference.CtTypeReference) (ref)));\n        } else {\n            return false;\n        }\n    }\n\n    private boolean isThereAnotherClassWithSameNameInAnotherPackage(spoon.reflect.reference.CtTypeReference<?> ref) {\n        for (spoon.reflect.reference.CtTypeReference typeref : this.exploredReferences) {\n            if (typeref.getSimpleName().equals(ref.getSimpleName()) && (!typeref.getQualifiedName().equals(ref.getQualifiedName()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean addClassImport(spoon.reflect.reference.CtTypeReference<?> ref) {\n        this.exploredReferences.add(ref);\n        if (ref == null) {\n            return false;\n        }\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return false;\n        }\n        if (classImports.containsKey(ref.getSimpleName())) {\n            return isImportedInClassImports(ref);\n        }\n        if ((ref.getPackage() == null) || ref.getPackage().isUnnamedPackage()) {\n            return false;\n        }\n        if (ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n            if (classNamePresentInJavaLang(ref)) {\n                return false;\n            }\n        }\n        if ((targetType != null) && (targetType.canAccess(ref) == false)) {\n            return false;\n        }\n        if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n            return false;\n        }\n        if (targetType != null) {\n            try {\n                spoon.reflect.declaration.CtElement parent = ref.getParent();\n                if (parent != null) {\n                    parent = parent.getParent();\n                    if (parent != null) {\n                        if (((parent instanceof spoon.reflect.code.CtFieldAccess) || (parent instanceof spoon.reflect.declaration.CtExecutable)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                            spoon.reflect.reference.CtTypeReference declaringType;\n                            spoon.reflect.reference.CtReference reference;\n                            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n                            if (parent instanceof spoon.reflect.code.CtFieldAccess) {\n                                spoon.reflect.code.CtFieldAccess field = ((spoon.reflect.code.CtFieldAccess) (parent));\n                                spoon.reflect.reference.CtFieldReference localReference = field.getVariable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.declaration.CtExecutable) {\n                                spoon.reflect.declaration.CtExecutable exec = ((spoon.reflect.declaration.CtExecutable) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = exec.getReference();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.code.CtInvocation) {\n                                spoon.reflect.code.CtInvocation invo = ((spoon.reflect.code.CtInvocation) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = invo.getExecutable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else {\n                                declaringType = null;\n                                reference = null;\n                            }\n                            if ((reference != null) && isImported(reference)) {\n                                if (declaringType != null) {\n                                    if ((declaringType.getPackage() != null) && (!declaringType.getPackage().isUnnamedPackage())) {\n                                        if (!declaringType.getPackage().getSimpleName().equals(\"java.lang\")) {\n                                            if (declaringType.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                                                classImports.put(ref.getSimpleName(), ref);\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            }\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if ((ref.getPackage() != null) && (!ref.getPackage().isUnnamedPackage())) {\n                if (!ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n                    if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                        return false;\n                    }\n                }\n            }\n        }\n        classImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    protected boolean isImportedInClassImports(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (targetType != null) {\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if ((ref.getPackage() != null) && (!ref.getPackage().isUnnamedPackage())) {\n                if (!ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n                    if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                        return true;\n                    }\n                }\n            }\n        }\n        if (ref.equals(targetType)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && classImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtTypeReference<?> exist = classImports.get(ref.getSimpleName());\n            if (exist.getQualifiedName().equals(ref.getQualifiedName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean declaringTypeIsLocalOrImported(spoon.reflect.reference.CtTypeReference declaringType) {\n        if (declaringType != null) {\n            if (isImportedInClassImports(declaringType) || classNamePresentInJavaLang(declaringType)) {\n                return true;\n            }\n            if ((!isTypeInCollision(declaringType, false)) && addClassImport(declaringType)) {\n                return true;\n            }\n            while (declaringType != null) {\n                if (declaringType.equals(targetType)) {\n                    return true;\n                }\n                declaringType = declaringType.getDeclaringType();\n            } \n        }\n        return false;\n    }\n\n    protected boolean addMethodImport(spoon.reflect.reference.CtExecutableReference ref) {\n        if (this.methodImports.containsKey(ref.getSimpleName())) {\n            return isImportedInMethodImports(ref);\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        methodImports.put(ref.getSimpleName(), ref);\n        if (ref.getDeclaringType() != null) {\n            if (ref.getDeclaringType().getPackage() != null) {\n                if (ref.getDeclaringType().getPackage().equals(this.targetType.getPackage())) {\n                    addClassImport(ref.getDeclaringType());\n                }\n            }\n        }\n        return true;\n    }\n\n    protected boolean isImportedInMethodImports(spoon.reflect.reference.CtExecutableReference<?> ref) {\n        if ((!ref.isImplicit()) && methodImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtExecutableReference<?> exist = methodImports.get(ref.getSimpleName());\n            if (exist.getSignature().equals(ref.getSignature())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean addFieldImport(spoon.reflect.reference.CtFieldReference ref) {\n        if (this.fieldImports.containsKey(ref.getSimpleName())) {\n            return isImportedInFieldImports(ref);\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        fieldImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    protected boolean isImportedInFieldImports(spoon.reflect.reference.CtFieldReference<?> ref) {\n        if ((!ref.isImplicit()) && fieldImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtFieldReference<?> exist = fieldImports.get(ref.getSimpleName());\n            try {\n                if ((exist.getFieldDeclaration() != null) && exist.getFieldDeclaration().equals(ref.getFieldDeclaration())) {\n                    return true;\n                }\n            } catch (spoon.support.SpoonClassNotFoundException notfound) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    protected boolean classNamePresentInJavaLang(spoon.reflect.reference.CtTypeReference<?> ref) {\n        java.lang.Boolean presentInJavaLang = namesPresentInJavaLang.get(ref.getSimpleName());\n        if (presentInJavaLang == null) {\n            if (spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang8.contains(ref.getSimpleName()) || spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang9.contains(ref.getSimpleName())) {\n                presentInJavaLang = true;\n            } else {\n                try {\n                    java.lang.Class.forName(\"java.lang.\" + ref.getSimpleName());\n                    presentInJavaLang = true;\n                } catch (java.lang.ClassNotFoundException e) {\n                    presentInJavaLang = false;\n                }\n            }\n            namesPresentInJavaLang.put(ref.getSimpleName(), presentInJavaLang);\n        }\n        return presentInJavaLang;\n    }\n\n    protected java.util.Set<java.lang.String> lookForLocalVariables(spoon.reflect.declaration.CtElement parent) {\n        java.util.Set<java.lang.String> result = new java.util.HashSet<>();\n        while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n            if (parent instanceof spoon.reflect.declaration.CtClass) {\n                return result;\n            }\n            parent = parent.getParent();\n        } \n        if (parent != null) {\n            spoon.reflect.code.CtBlock block = ((spoon.reflect.code.CtBlock) (parent));\n            boolean innerClass = false;\n            while ((parent != null) && (!(parent instanceof spoon.reflect.declaration.CtClass))) {\n                parent = parent.getParent();\n            } \n            if (parent != null) {\n                if (!(parent.getParent() instanceof spoon.reflect.declaration.CtPackage)) {\n                    while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n                        parent = parent.getParent();\n                    } \n                    if (parent != null) {\n                        block = ((spoon.reflect.code.CtBlock) (parent));\n                    }\n                }\n            }\n            spoon.reflect.visitor.AccessibleVariablesFinder avf = new spoon.reflect.visitor.AccessibleVariablesFinder(block);\n            java.util.List<spoon.reflect.declaration.CtVariable> variables = avf.find();\n            for (spoon.reflect.declaration.CtVariable variable : variables) {\n                result.add(variable.getSimpleName());\n            }\n        }\n        return result;\n    }\n\n    protected boolean isTypeInCollision(spoon.reflect.reference.CtReference ref, boolean fqnMode) {\n        if (targetType.getSimpleName().equals(ref.getSimpleName()) && (!targetType.equals(ref))) {\n            return true;\n        }\n        try {\n            spoon.reflect.declaration.CtElement parent;\n            if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                parent = ref.getParent();\n            } else {\n                parent = ref;\n            }\n            java.util.Set<java.lang.String> localVariablesOfBlock = new java.util.HashSet<>();\n            if (parent instanceof spoon.reflect.declaration.CtField) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtField) (parent)).getSimpleName());\n            } else if (parent instanceof spoon.reflect.declaration.CtMethod) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtMethod) (parent)).getSimpleName());\n            } else {\n                localVariablesOfBlock = this.lookForLocalVariables(parent);\n            }\n            while (!(parent instanceof spoon.reflect.declaration.CtPackage)) {\n                if ((parent instanceof spoon.reflect.reference.CtFieldReference) || (parent instanceof spoon.reflect.reference.CtExecutableReference)) {\n                    spoon.reflect.reference.CtReference parentType = ((spoon.reflect.reference.CtReference) (parent));\n                    java.util.LinkedList<java.lang.String> qualifiedNameTokens = new java.util.LinkedList<>();\n                    if (parentType != parent) {\n                        qualifiedNameTokens.add(parentType.getSimpleName());\n                    }\n                    spoon.reflect.reference.CtTypeReference typeReference;\n                    if (parent instanceof spoon.reflect.reference.CtFieldReference) {\n                        typeReference = ((spoon.reflect.reference.CtFieldReference) (parent)).getDeclaringType();\n                    } else {\n                        typeReference = ((spoon.reflect.reference.CtExecutableReference) (parent)).getDeclaringType();\n                    }\n                    if (typeReference != null) {\n                        qualifiedNameTokens.add(typeReference.getSimpleName());\n                        if (typeReference.getPackage() != null) {\n                            spoon.reflect.declaration.CtPackage ctPackage = typeReference.getPackage().getDeclaration();\n                            while (ctPackage != null) {\n                                qualifiedNameTokens.add(ctPackage.getSimpleName());\n                                spoon.reflect.declaration.CtElement packParent = ctPackage.getParent();\n                                if ((packParent.getParent() != null) && (!((spoon.reflect.declaration.CtPackage) (packParent)).getSimpleName().equals(spoon.reflect.declaration.CtPackage.TOP_LEVEL_PACKAGE_NAME))) {\n                                    ctPackage = ((spoon.reflect.declaration.CtPackage) (packParent));\n                                } else {\n                                    ctPackage = null;\n                                }\n                            } \n                        }\n                    }\n                    if (!qualifiedNameTokens.isEmpty()) {\n                        if (fieldAndMethodsNames.contains(qualifiedNameTokens.getLast()) || localVariablesOfBlock.contains(qualifiedNameTokens.getLast())) {\n                            qualifiedNameTokens.removeLast();\n                            if (fqnMode) {\n                                return true;\n                            } else {\n                                for (int i = qualifiedNameTokens.size() - 1; i > 0; i--) {\n                                    java.lang.String testedToken = qualifiedNameTokens.get(i);\n                                    if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                        }\n                    }\n                }\n                parent = parent.getParent();\n            } \n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "this.exploredReferences.add(ref)",
            "src_parent": "{\n    this.exploredReferences.add(ref);\n    if (ref == null) {\n        return false;\n    }\n    if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n        return false;\n    }\n    if (classImports.containsKey(ref.getSimpleName())) {\n        return isImportedInClassImports(ref);\n    }\n    if ((ref.getPackage() == null) || ref.getPackage().isUnnamedPackage()) {\n        return false;\n    }\n    if (ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n        if (classNamePresentInJavaLang(ref)) {\n            return false;\n        }\n    }\n    if ((targetType != null) && (targetType.canAccess(ref) == false)) {\n        return false;\n    }\n    if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n        return false;\n    }\n    if (targetType != null) {\n        try {\n            spoon.reflect.declaration.CtElement parent = ref.getParent();\n            if (parent != null) {\n                parent = parent.getParent();\n                if (parent != null) {\n                    if (((parent instanceof spoon.reflect.code.CtFieldAccess) || (parent instanceof spoon.reflect.declaration.CtExecutable)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                        spoon.reflect.reference.CtTypeReference declaringType;\n                        spoon.reflect.reference.CtReference reference;\n                        spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n                        if (parent instanceof spoon.reflect.code.CtFieldAccess) {\n                            spoon.reflect.code.CtFieldAccess field = ((spoon.reflect.code.CtFieldAccess) (parent));\n                            spoon.reflect.reference.CtFieldReference localReference = field.getVariable();\n                            declaringType = localReference.getDeclaringType();\n                            reference = localReference;\n                        } else if (parent instanceof spoon.reflect.declaration.CtExecutable) {\n                            spoon.reflect.declaration.CtExecutable exec = ((spoon.reflect.declaration.CtExecutable) (parent));\n                            spoon.reflect.reference.CtExecutableReference localReference = exec.getReference();\n                            declaringType = localReference.getDeclaringType();\n                            reference = localReference;\n                        } else if (parent instanceof spoon.reflect.code.CtInvocation) {\n                            spoon.reflect.code.CtInvocation invo = ((spoon.reflect.code.CtInvocation) (parent));\n                            spoon.reflect.reference.CtExecutableReference localReference = invo.getExecutable();\n                            declaringType = localReference.getDeclaringType();\n                            reference = localReference;\n                        } else {\n                            declaringType = null;\n                            reference = null;\n                        }\n                        if ((reference != null) && isImported(reference)) {\n                            if (declaringType != null) {\n                                if ((declaringType.getPackage() != null) && (!declaringType.getPackage().isUnnamedPackage())) {\n                                    if (!declaringType.getPackage().getSimpleName().equals(\"java.lang\")) {\n                                        if (declaringType.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                                            classImports.put(ref.getSimpleName(), ref);\n                                            return true;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n        }\n        spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n        if ((ref.getPackage() != null) && (!ref.getPackage().isUnnamedPackage())) {\n            if (!ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n                if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                    return false;\n                }\n            }\n        }\n    }\n    classImports.put(ref.getSimpleName(), ref);\n    return true;\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n    return false;\n}",
            "src_parent": "{\n    this.exploredReferences.add(ref);\n    if (ref == null) {\n        return false;\n    }\n    if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n        return false;\n    }\n    if (classImports.containsKey(ref.getSimpleName())) {\n        return isImportedInClassImports(ref);\n    }\n    if ((ref.getPackage() == null) || ref.getPackage().isUnnamedPackage()) {\n        return false;\n    }\n    if (ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n        if (classNamePresentInJavaLang(ref)) {\n            return false;\n        }\n    }\n    if ((targetType != null) && (targetType.canAccess(ref) == false)) {\n        return false;\n    }\n    if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n        return false;\n    }\n    if (targetType != null) {\n        try {\n            spoon.reflect.declaration.CtElement parent = ref.getParent();\n            if (parent != null) {\n                parent = parent.getParent();\n                if (parent != null) {\n                    if (((parent instanceof spoon.reflect.code.CtFieldAccess) || (parent instanceof spoon.reflect.declaration.CtExecutable)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                        spoon.reflect.reference.CtTypeReference declaringType;\n                        spoon.reflect.reference.CtReference reference;\n                        spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n                        if (parent instanceof spoon.reflect.code.CtFieldAccess) {\n                            spoon.reflect.code.CtFieldAccess field = ((spoon.reflect.code.CtFieldAccess) (parent));\n                            spoon.reflect.reference.CtFieldReference localReference = field.getVariable();\n                            declaringType = localReference.getDeclaringType();\n                            reference = localReference;\n                        } else if (parent instanceof spoon.reflect.declaration.CtExecutable) {\n                            spoon.reflect.declaration.CtExecutable exec = ((spoon.reflect.declaration.CtExecutable) (parent));\n                            spoon.reflect.reference.CtExecutableReference localReference = exec.getReference();\n                            declaringType = localReference.getDeclaringType();\n                            reference = localReference;\n                        } else if (parent instanceof spoon.reflect.code.CtInvocation) {\n                            spoon.reflect.code.CtInvocation invo = ((spoon.reflect.code.CtInvocation) (parent));\n                            spoon.reflect.reference.CtExecutableReference localReference = invo.getExecutable();\n                            declaringType = localReference.getDeclaringType();\n                            reference = localReference;\n                        } else {\n                            declaringType = null;\n                            reference = null;\n                        }\n                        if ((reference != null) && isImported(reference)) {\n                            if (declaringType != null) {\n                                if ((declaringType.getPackage() != null) && (!declaringType.getPackage().isUnnamedPackage())) {\n                                    if (!declaringType.getPackage().getSimpleName().equals(\"java.lang\")) {\n                                        if (declaringType.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                                            classImports.put(ref.getSimpleName(), ref);\n                                            return true;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n        }\n        spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n        if ((ref.getPackage() != null) && (!ref.getPackage().isUnnamedPackage())) {\n            if (!ref.getPackage().getSimpleName().equals(\"java.lang\")) {\n                if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                    return false;\n                }\n            }\n        }\n    }\n    classImports.put(ref.getSimpleName(), ref);\n    return true;\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        }
      ],
      "file_name": "ImportScannerImpl"
    }
  ],
  "id": "bears_54"
}