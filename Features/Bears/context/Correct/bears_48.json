{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "getActualTypeArguments(typeDeclarer.getQualifiedName())",
            "dst_parent": "java.util.List<spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments = getActualTypeArguments(typeDeclarer.getQualifiedName())",
            "dst_parent_type": "LocalVariable",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "typeToArguments.get(typeDeclarer.getQualifiedName())",
            "src_parent": "java.util.List<spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments = typeToArguments.get(typeDeclarer.getQualifiedName())",
            "src_parent_type": "LocalVariable",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private java.util.List<spoon.reflect.reference.CtTypeReference<?>> getActualTypeArguments(java.lang.String qualifiedName) {\n    java.util.List<spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments = typeToArguments.get(qualifiedName);\n    if (actualTypeArguments != null) {\n        return actualTypeArguments;\n    }\n    if (enclosingClassTypingContext != null) {\n        return enclosingClassTypingContext.getActualTypeArguments(qualifiedName);\n    }\n    return null;\n}",
            "src_parent": "public class ClassTypingContext implements spoon.support.visitor.GenericTypeAdapter {\n    private spoon.support.visitor.ClassTypingContext enclosingClassTypingContext;\n\n    private java.util.Map<java.lang.String, java.util.List<spoon.reflect.reference.CtTypeReference<?>>> typeToArguments = new java.util.HashMap<>();\n\n    private spoon.reflect.declaration.CtTypeInformation lastResolvedSuperclass;\n\n    private java.util.Set<java.lang.String> visitedSet;\n\n    public ClassTypingContext(spoon.reflect.reference.CtTypeReference<?> typeReference) {\n        lastResolvedSuperclass = typeReference;\n        spoon.reflect.reference.CtTypeReference<?> enclosing = getEnclosingType(typeReference);\n        if (enclosing != null) {\n            enclosingClassTypingContext = createEnclosingHierarchy(enclosing);\n        }\n        typeToArguments.put(typeReference.getQualifiedName(), typeReference.getActualTypeArguments());\n    }\n\n    public ClassTypingContext(spoon.reflect.declaration.CtType<?> type) {\n        lastResolvedSuperclass = type;\n        spoon.reflect.declaration.CtType<?> enclosing = getEnclosingType(type);\n        if (enclosing != null) {\n            enclosingClassTypingContext = createEnclosingHierarchy(enclosing);\n        }\n        typeToArguments.put(type.getQualifiedName(), spoon.support.visitor.ClassTypingContext.getTypeReferences(type.getFormalCtTypeParameters()));\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> adaptType(spoon.reflect.declaration.CtTypeInformation type) {\n        if (type instanceof spoon.reflect.reference.CtTypeReference<?>) {\n            if (type instanceof spoon.reflect.reference.CtTypeParameterReference) {\n                return adaptTypeParameter(((spoon.reflect.reference.CtTypeParameterReference) (type)).getDeclaration());\n            }\n            return ((spoon.reflect.reference.CtTypeReference<?>) (type));\n        }\n        if (type instanceof spoon.reflect.declaration.CtTypeParameter) {\n            return adaptTypeParameter(((spoon.reflect.declaration.CtTypeParameter) (type)));\n        }\n        return ((spoon.reflect.declaration.CtType<?>) (type)).getReference();\n    }\n\n    public boolean isSubtypeOf(spoon.reflect.reference.CtTypeReference<?> superTypeRef) {\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> adaptedArgs = resolveActualTypeArgumentsOf(superTypeRef);\n        if (adaptedArgs == null) {\n            return false;\n        }\n        if (isSubTypeByActualTypeArguments(superTypeRef, adaptedArgs) == false) {\n            return false;\n        }\n        spoon.reflect.reference.CtTypeReference<?> enclosingTypeRef = getEnclosingType(superTypeRef);\n        if (enclosingTypeRef != null) {\n            if (enclosingClassTypingContext == null) {\n                return false;\n            }\n            return enclosingClassTypingContext.isSubtypeOf(enclosingTypeRef);\n        }\n        return true;\n    }\n\n    public java.util.List<spoon.reflect.reference.CtTypeReference<?>> resolveActualTypeArgumentsOf(spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        final java.lang.String typeQualifiedName = typeRef.getQualifiedName();\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> args = typeToArguments.get(typeQualifiedName);\n        if (args != null) {\n            return args;\n        }\n        spoon.reflect.reference.CtTypeReference<?> enclosingTypeRef = getEnclosingType(typeRef);\n        if (enclosingTypeRef != null) {\n            if (enclosingClassTypingContext == null) {\n                return null;\n            }\n            if (enclosingClassTypingContext.resolveActualTypeArgumentsOf(enclosingTypeRef) == null) {\n                return null;\n            }\n        }\n        if (lastResolvedSuperclass == null) {\n            return null;\n        }\n        final spoon.support.visitor.ClassTypingContext.HierarchyListener listener = new spoon.support.visitor.ClassTypingContext.HierarchyListener(getVisitedSet());\n        ((spoon.reflect.declaration.CtElement) (lastResolvedSuperclass)).map(new spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction().includingSelf(false).returnTypeReferences(true).setListener(listener)).forEach(new spoon.reflect.visitor.chain.CtConsumer<spoon.reflect.reference.CtTypeReference<?>>() {\n            @java.lang.Override\n            public void accept(spoon.reflect.reference.CtTypeReference<?> typeRef) {\n                java.lang.String superTypeQualifiedName = typeRef.getQualifiedName();\n                java.util.List<spoon.reflect.reference.CtTypeReference<?>> superTypeActualTypeArgumentsResolvedFromSubType = resolveTypeParameters(typeRef.getActualTypeArguments());\n                typeToArguments.put(superTypeQualifiedName, superTypeActualTypeArgumentsResolvedFromSubType);\n                if (typeQualifiedName.equals(superTypeQualifiedName)) {\n                    listener.foundArguments = superTypeActualTypeArgumentsResolvedFromSubType;\n                }\n            }\n        });\n        return listener.foundArguments;\n    }\n\n    @java.lang.Override\n    public spoon.support.visitor.ClassTypingContext getEnclosingGenericTypeAdapter() {\n        return enclosingClassTypingContext;\n    }\n\n    protected spoon.support.visitor.ClassTypingContext createEnclosingHierarchy(spoon.reflect.declaration.CtType<?> enclosingType) {\n        return new spoon.support.visitor.ClassTypingContext(enclosingType);\n    }\n\n    protected spoon.support.visitor.ClassTypingContext createEnclosingHierarchy(spoon.reflect.reference.CtTypeReference<?> enclosingTypeRef) {\n        return new spoon.support.visitor.ClassTypingContext(enclosingTypeRef);\n    }\n\n    static java.util.List<spoon.reflect.reference.CtTypeReference<?>> getTypeReferences(java.util.List<? extends spoon.reflect.declaration.CtType<?>> types) {\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> refs = new java.util.ArrayList<>(types.size());\n        for (spoon.reflect.declaration.CtType<?> type : types) {\n            refs.add(type.getReference());\n        }\n        return refs;\n    }\n\n    private spoon.reflect.declaration.CtType<?> getEnclosingType(spoon.reflect.declaration.CtType<?> type) {\n        if (type.hasModifier(spoon.reflect.declaration.ModifierKind.STATIC)) {\n            return null;\n        }\n        spoon.reflect.declaration.CtType<?> declType = type.getDeclaringType();\n        if (declType == null) {\n            return null;\n        }\n        if (declType.isInterface()) {\n            return null;\n        }\n        return declType;\n    }\n\n    private spoon.reflect.reference.CtTypeReference<?> getEnclosingType(spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        spoon.reflect.declaration.CtType<?> type = typeRef.getTypeDeclaration();\n        if (type.hasModifier(spoon.reflect.declaration.ModifierKind.STATIC)) {\n            return null;\n        }\n        spoon.reflect.declaration.CtType<?> declType = type.getDeclaringType();\n        if (declType == null) {\n            return null;\n        }\n        if (declType.isInterface()) {\n            return null;\n        }\n        return typeRef.getDeclaringType();\n    }\n\n    private spoon.reflect.reference.CtTypeReference<?> adaptTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParam) {\n        spoon.reflect.declaration.CtFormalTypeDeclarer declarer = typeParam.getTypeParameterDeclarer();\n        if ((declarer instanceof spoon.reflect.declaration.CtType<?>) == false) {\n            return null;\n        }\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments = resolveActualTypeArgumentsOf(((spoon.reflect.declaration.CtType<?>) (declarer)).getReference());\n        if (actualTypeArguments == null) {\n            if (enclosingClassTypingContext != null) {\n                return enclosingClassTypingContext.adaptType(typeParam);\n            }\n            return null;\n        }\n        return spoon.support.visitor.ClassTypingContext.getValue(actualTypeArguments, typeParam, declarer);\n    }\n\n    private java.util.Set<java.lang.String> getVisitedSet() {\n        if (visitedSet == null) {\n            visitedSet = new java.util.HashSet<>();\n        }\n        return visitedSet;\n    }\n\n    private class HierarchyListener extends spoon.reflect.visitor.filter.SuperInheritanceHierarchyFunction.DistinctTypeListener {\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> foundArguments;\n\n        HierarchyListener(java.util.Set<java.lang.String> visitedSet) {\n            super(visitedSet);\n        }\n\n        @java.lang.Override\n        public spoon.reflect.visitor.chain.ScanningMode enter(spoon.reflect.declaration.CtElement element) {\n            spoon.reflect.visitor.chain.ScanningMode mode = super.enter(element);\n            if (mode == spoon.reflect.visitor.chain.ScanningMode.SKIP_ALL) {\n                return mode;\n            }\n            spoon.reflect.declaration.CtType<?> type = ((spoon.reflect.reference.CtTypeReference<?>) (element)).getTypeDeclaration();\n            if (type instanceof spoon.reflect.declaration.CtClass) {\n                if (foundArguments != null) {\n                    return spoon.reflect.visitor.chain.ScanningMode.SKIP_ALL;\n                }\n                lastResolvedSuperclass = type;\n            }\n            return spoon.reflect.visitor.chain.ScanningMode.NORMAL;\n        }\n    }\n\n    private java.util.List<spoon.reflect.reference.CtTypeReference<?>> resolveTypeParameters(java.util.List<spoon.reflect.reference.CtTypeReference<?>> typeRefs) {\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> result = new java.util.ArrayList<>(typeRefs.size());\n        for (spoon.reflect.reference.CtTypeReference<?> typeRef : typeRefs) {\n            if (typeRef instanceof spoon.reflect.reference.CtTypeParameterReference) {\n                spoon.reflect.reference.CtTypeParameterReference typeParamRef = ((spoon.reflect.reference.CtTypeParameterReference) (typeRef));\n                spoon.reflect.declaration.CtTypeParameter typeParam = typeParamRef.getDeclaration();\n                spoon.reflect.declaration.CtFormalTypeDeclarer declarer = typeParam.getTypeParameterDeclarer();\n                if ((declarer instanceof spoon.reflect.declaration.CtType<?>) == false) {\n                    throw new spoon.SpoonException(\"Cannot adapt type parameters of non type scope\");\n                }\n                spoon.reflect.declaration.CtType<?> typeDeclarer = ((spoon.reflect.declaration.CtType<?>) (declarer));\n                java.util.List<spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments = getActualTypeArguments(typeDeclarer.getQualifiedName());\n                if (actualTypeArguments == null) {\n                    throw new spoon.SpoonException(((((\"Cannot resolve \" + (result.size() + 1)) + \") type parameter <\") + typeParamRef.getSimpleName()) + \">  of declarer \") + declarer);\n                }\n                if (actualTypeArguments.size() != typeDeclarer.getFormalCtTypeParameters().size()) {\n                    if (actualTypeArguments.isEmpty() == false) {\n                        throw new spoon.SpoonException(((\"Unexpected actual type arguments \" + actualTypeArguments) + \" on \") + typeDeclarer);\n                    }\n                    actualTypeArguments = spoon.support.visitor.ClassTypingContext.getTypeReferences(typeDeclarer.getFormalCtTypeParameters());\n                    typeToArguments.put(typeDeclarer.getQualifiedName(), actualTypeArguments);\n                }\n                typeRef = spoon.support.visitor.ClassTypingContext.getValue(actualTypeArguments, typeParam, declarer);\n            }\n            result.add(typeRef);\n        }\n        return result;\n    }\n\n    private java.util.List<spoon.reflect.reference.CtTypeReference<?>> getActualTypeArguments(java.lang.String qualifiedName) {\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments = typeToArguments.get(qualifiedName);\n        if (actualTypeArguments != null) {\n            return actualTypeArguments;\n        }\n        if (enclosingClassTypingContext != null) {\n            return enclosingClassTypingContext.getActualTypeArguments(qualifiedName);\n        }\n        return null;\n    }\n\n    private static spoon.reflect.reference.CtTypeReference<?> getValue(java.util.List<spoon.reflect.reference.CtTypeReference<?>> arguments, spoon.reflect.declaration.CtTypeParameter typeParam, spoon.reflect.declaration.CtFormalTypeDeclarer declarer) {\n        if (declarer.getFormalCtTypeParameters().size() != arguments.size()) {\n            throw new spoon.SpoonException(\"Unexpected count of actual type arguments\");\n        }\n        int typeParamIdx = declarer.getFormalCtTypeParameters().indexOf(typeParam);\n        return arguments.get(typeParamIdx);\n    }\n\n    static <T, U extends java.util.List<T>> T substituteBy(spoon.reflect.declaration.CtTypeParameter typeParameter, spoon.reflect.declaration.CtFormalTypeDeclarer declarer, U values) {\n        java.util.List<spoon.reflect.declaration.CtTypeParameter> typeParams = declarer.getFormalCtTypeParameters();\n        int position = typeParams.indexOf(typeParameter);\n        if (position == (-1)) {\n            throw new spoon.SpoonException(((\"Type parameter <\" + typeParameter.getSimpleName()) + \" not found in scope \") + declarer.getShortRepresentation());\n        }\n        if (values.size() != typeParams.size()) {\n            throw new spoon.SpoonException(\"Unexpected count of parameters\");\n        }\n        return values.get(position);\n    }\n\n    private boolean isSubTypeByActualTypeArguments(spoon.reflect.reference.CtTypeReference<?> superTypeRef, java.util.List<spoon.reflect.reference.CtTypeReference<?>> expectedSuperTypeArguments) {\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> superTypeArgs = superTypeRef.getActualTypeArguments();\n        if (superTypeArgs.isEmpty()) {\n            return true;\n        }\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> subTypeArgs = expectedSuperTypeArguments;\n        if (subTypeArgs.isEmpty()) {\n            return true;\n        }\n        if (subTypeArgs.size() != superTypeArgs.size()) {\n            return false;\n        }\n        for (int i = 0; i < subTypeArgs.size(); i++) {\n            spoon.reflect.reference.CtTypeReference<?> superArg = superTypeArgs.get(i);\n            spoon.reflect.reference.CtTypeReference<?> subArg = subTypeArgs.get(i);\n            if (isSubTypeArg(subArg, superArg) == false) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isSubTypeArg(spoon.reflect.reference.CtTypeReference<?> subArg, spoon.reflect.reference.CtTypeReference<?> superArg) {\n        if (superArg instanceof spoon.reflect.reference.CtWildcardReference) {\n            spoon.reflect.reference.CtWildcardReference wr = ((spoon.reflect.reference.CtWildcardReference) (superArg));\n            spoon.reflect.reference.CtTypeReference<?> superBound = wr.getBoundingType();\n            if (superBound == null) {\n                return wr.isUpper();\n            }\n            if (subArg instanceof spoon.reflect.reference.CtWildcardReference) {\n                spoon.reflect.reference.CtWildcardReference subWr = ((spoon.reflect.reference.CtWildcardReference) (subArg));\n                spoon.reflect.reference.CtTypeReference<?> subBound = subWr.getBoundingType();\n                if (subBound == null) {\n                    return false;\n                }\n                if (wr.isUpper() != subWr.isUpper()) {\n                    return false;\n                }\n                if (wr.isUpper()) {\n                    return subBound.isSubtypeOf(superBound);\n                }\n                return superBound.isSubtypeOf(subBound);\n            }\n            if (wr.isUpper()) {\n                return subArg.isSubtypeOf(superBound);\n            } else {\n                return superBound.isSubtypeOf(subArg);\n            }\n        }\n        return subArg.equals(superArg);\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Assignment",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "LocalVariable",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "LocalVariable",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "typeToArguments",
            "dst_parent": "typeToArguments.get(qualifiedName)",
            "dst_parent_type": "Invocation",
            "dst_type": "FieldRead",
            "operator": "MOV",
            "src": "typeToArguments",
            "src_parent": "typeToArguments.get(typeDeclarer.getQualifiedName())",
            "src_parent_type": "Invocation",
            "src_type": "FieldRead"
          }
        }
      ],
      "file_name": "ClassTypingContext"
    }
  ],
  "id": "bears_48"
}