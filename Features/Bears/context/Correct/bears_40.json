{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "isImplementationOf(declaringType)",
            "dst_parent": "if (isImplementationOf(declaringType)) {\n    return true;\n}",
            "dst_parent_type": "If",
            "dst_type": "Invocation",
            "operator": "UPD",
            "src": "isSubtypeOf(type)",
            "src_parent": "if (isSubtypeOf(type)) {\n    return true;\n}",
            "src_parent_type": "If",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "declaringType",
            "dst_parent": "isImplementationOf(declaringType)",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "UPD",
            "src": "type",
            "src_parent": "isSubtypeOf(type)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Throw",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "\"The declaring type is expected, but \"",
            "dst_parent": "(\"The declaring type is expected, but \" + getQualifiedName())",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "Literal",
            "operator": "UPD",
            "src": "\"The nestedType is expected, but it is: \"",
            "src_parent": "\"The nestedType is expected, but it is: \" + getQualifiedName()",
            "src_parent_type": "BinaryOperator",
            "src_type": "Literal"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean isImplementationOf(spoon.reflect.reference.CtTypeReference<?> type) {\n    spoon.reflect.reference.CtTypeReference<?> impl = this;\n    while (impl != null) {\n        if (impl.isSubtypeOf(type)) {\n            return true;\n        }\n        impl = impl.getDeclaringType();\n    } \n    return false;\n}",
            "src_parent": "public class CtTypeReferenceImpl<T> extends spoon.support.reflect.reference.CtReferenceImpl implements spoon.reflect.reference.CtTypeReference<T> {\n    private static final long serialVersionUID = 1L;\n\n    java.util.List<spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments = spoon.support.reflect.declaration.CtElementImpl.emptyList();\n\n    spoon.reflect.reference.CtTypeReference<?> declaringType;\n\n    private spoon.reflect.reference.CtPackageReference pack;\n\n    public CtTypeReferenceImpl() {\n        super();\n    }\n\n    @java.lang.Override\n    public void accept(spoon.reflect.visitor.CtVisitor visitor) {\n        visitor.visitCtTypeReference(this);\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> box() {\n        if (!isPrimitive()) {\n            return this;\n        }\n        if (getSimpleName().equals(\"int\")) {\n            return getFactory().Type().createReference(java.lang.Integer.class);\n        }\n        if (getSimpleName().equals(\"float\")) {\n            return getFactory().Type().createReference(java.lang.Float.class);\n        }\n        if (getSimpleName().equals(\"long\")) {\n            return getFactory().Type().createReference(java.lang.Long.class);\n        }\n        if (getSimpleName().equals(\"char\")) {\n            return getFactory().Type().createReference(java.lang.Character.class);\n        }\n        if (getSimpleName().equals(\"double\")) {\n            return getFactory().Type().createReference(java.lang.Double.class);\n        }\n        if (getSimpleName().equals(\"boolean\")) {\n            return getFactory().Type().createReference(java.lang.Boolean.class);\n        }\n        if (getSimpleName().equals(\"short\")) {\n            return getFactory().Type().createReference(java.lang.Short.class);\n        }\n        if (getSimpleName().equals(\"byte\")) {\n            return getFactory().Type().createReference(java.lang.Byte.class);\n        }\n        if (getSimpleName().equals(\"void\")) {\n            return getFactory().Type().createReference(java.lang.Void.class);\n        }\n        return this;\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public java.lang.Class<T> getActualClass() {\n        if (isPrimitive()) {\n            java.lang.String simpleN = getSimpleName();\n            if (\"boolean\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (boolean.class));\n            } else if (\"byte\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (byte.class));\n            } else if (\"double\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (double.class));\n            } else if (\"int\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (int.class));\n            } else if (\"short\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (short.class));\n            } else if (\"char\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (char.class));\n            } else if (\"long\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (long.class));\n            } else if (\"float\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (float.class));\n            } else if (\"void\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (void.class));\n            }\n        }\n        return findClass();\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    protected java.lang.Class<T> findClass() {\n        try {\n            return ((java.lang.Class<T>) (getFactory().getEnvironment().getInputClassLoader().loadClass(getQualifiedName())));\n        } catch (java.lang.Throwable e) {\n            throw new spoon.support.SpoonClassNotFoundException(\"cannot load class: \" + getQualifiedName(), e);\n        }\n    }\n\n    @java.lang.Override\n    public java.util.List<spoon.reflect.reference.CtTypeReference<?>> getActualTypeArguments() {\n        return actualTypeArguments;\n    }\n\n    @java.lang.Override\n    protected java.lang.reflect.AnnotatedElement getActualAnnotatedElement() {\n        return getActualClass();\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public spoon.reflect.declaration.CtType<T> getDeclaration() {\n        return getFactory().Type().get(getQualifiedName());\n    }\n\n    @java.lang.Override\n    public spoon.reflect.declaration.CtType<T> getTypeDeclaration() {\n        spoon.reflect.declaration.CtType<T> t = getFactory().Type().get(getQualifiedName());\n        if (t != null) {\n            return t;\n        }\n        return getFactory().Type().get(getActualClass());\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> getDeclaringType() {\n        return declaringType;\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtPackageReference getPackage() {\n        return pack;\n    }\n\n    @java.lang.Override\n    public java.lang.String getQualifiedName() {\n        if (getDeclaringType() != null) {\n            return (getDeclaringType().getQualifiedName() + spoon.reflect.declaration.CtType.INNERTTYPE_SEPARATOR) + getSimpleName();\n        } else if ((getPackage() != null) && (!getPackage().isUnnamedPackage())) {\n            return (getPackage().getSimpleName() + spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR) + getSimpleName();\n        } else {\n            return getSimpleName();\n        }\n    }\n\n    @java.lang.Override\n    public boolean isPrimitive() {\n        return (((((((\"boolean\".equals(getSimpleName()) || \"byte\".equals(getSimpleName())) || \"double\".equals(getSimpleName())) || \"int\".equals(getSimpleName())) || \"short\".equals(getSimpleName())) || \"char\".equals(getSimpleName())) || \"long\".equals(getSimpleName())) || \"float\".equals(getSimpleName())) || \"void\".equals(getSimpleName());\n    }\n\n    @java.lang.Override\n    public boolean isSubtypeOf(spoon.reflect.reference.CtTypeReference<?> type) {\n        if (type instanceof spoon.reflect.reference.CtTypeParameterReference) {\n            return false;\n        }\n        if (spoon.reflect.reference.CtTypeReference.NULL_TYPE_NAME.equals(getSimpleName()) || spoon.reflect.reference.CtTypeReference.NULL_TYPE_NAME.equals(type.getSimpleName())) {\n            return false;\n        }\n        if (isPrimitive() || type.isPrimitive()) {\n            return equals(type);\n        }\n        spoon.reflect.declaration.CtType<?> superTypeDecl = type.getDeclaration();\n        spoon.reflect.declaration.CtType<?> subTypeDecl = getDeclaration();\n        if ((subTypeDecl == null) && (superTypeDecl == null)) {\n            try {\n                if ((this instanceof spoon.reflect.reference.CtArrayTypeReference) && (type instanceof spoon.reflect.reference.CtArrayTypeReference)) {\n                    return ((spoon.reflect.reference.CtArrayTypeReference<?>) (this)).getComponentType().isSubtypeOf(((spoon.reflect.reference.CtArrayTypeReference<?>) (type)).getComponentType());\n                }\n                java.lang.Class<?> actualSubType = getActualClass();\n                java.lang.Class<?> actualSuperType = type.getActualClass();\n                return actualSuperType.isAssignableFrom(actualSubType);\n            } catch (java.lang.Exception e) {\n                spoon.Launcher.LOGGER.error((((((((\"cannot determine runtime types for '\" + this) + \"' (\") + getQualifiedName()) + \") and '\") + type) + \"' (\") + type.getQualifiedName()) + \")\", e);\n                return false;\n            }\n        }\n        if (getQualifiedName().equals(type.getQualifiedName())) {\n            return true;\n        }\n        if (subTypeDecl != null) {\n            if (getFactory().Type().OBJECT.equals(type)) {\n                return true;\n            }\n            for (spoon.reflect.reference.CtTypeReference<?> ref : subTypeDecl.getSuperInterfaces()) {\n                if (ref.isSubtypeOf(type)) {\n                    return true;\n                }\n            }\n            if (subTypeDecl instanceof spoon.reflect.declaration.CtClass) {\n                if (((spoon.reflect.declaration.CtClass<?>) (subTypeDecl)).getSuperclass() != null) {\n                    if (((spoon.reflect.declaration.CtClass<?>) (subTypeDecl)).getSuperclass().equals(type)) {\n                        return true;\n                    }\n                    return ((spoon.reflect.declaration.CtClass<?>) (subTypeDecl)).getSuperclass().isSubtypeOf(type);\n                }\n            }\n            return false;\n        } else {\n            try {\n                java.lang.Class<?> actualSubType = getActualClass();\n                for (java.lang.Class<?> c : actualSubType.getInterfaces()) {\n                    if (getFactory().Type().createReference(c).isSubtypeOf(type)) {\n                        return true;\n                    }\n                }\n                spoon.reflect.reference.CtTypeReference<?> superType = getFactory().Type().createReference(actualSubType.getSuperclass());\n                return (superType != null) && (superType.equals(type) || superType.isSubtypeOf(type));\n            } catch (java.lang.Exception e) {\n                spoon.Launcher.LOGGER.error((((\"cannot determine runtime types for '\" + this) + \"' and '\") + type) + \"'\", e);\n                return false;\n            }\n        }\n    }\n\n    private boolean isImplementationOf(spoon.reflect.reference.CtTypeReference<?> type) {\n        spoon.reflect.reference.CtTypeReference<?> impl = this;\n        while (impl != null) {\n            if (impl.isSubtypeOf(type)) {\n                return true;\n            }\n            impl = impl.getDeclaringType();\n        } \n        return false;\n    }\n\n    @java.lang.Override\n    public <C extends spoon.reflect.reference.CtActualTypeContainer> C setActualTypeArguments(java.util.List<? extends spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments) {\n        if ((actualTypeArguments == null) || actualTypeArguments.isEmpty()) {\n            this.actualTypeArguments = spoon.support.reflect.declaration.CtElementImpl.emptyList();\n            return ((C) (this));\n        }\n        if (this.actualTypeArguments == spoon.support.reflect.declaration.CtElementImpl.<spoon.reflect.reference.CtTypeReference<?>>emptyList()) {\n            this.actualTypeArguments = new java.util.ArrayList<>(spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n        }\n        this.actualTypeArguments.clear();\n        for (spoon.reflect.reference.CtTypeReference<?> actualTypeArgument : actualTypeArguments) {\n            addActualTypeArgument(actualTypeArgument);\n        }\n        return ((C) (this));\n    }\n\n    @java.lang.Override\n    public <C extends spoon.reflect.reference.CtTypeReference<T>> C setDeclaringType(spoon.reflect.reference.CtTypeReference<?> declaringType) {\n        if (declaringType != null) {\n            declaringType.setParent(this);\n        }\n        this.declaringType = declaringType;\n        return ((C) (this));\n    }\n\n    @java.lang.Override\n    public <C extends spoon.reflect.reference.CtTypeReference<T>> C setPackage(spoon.reflect.reference.CtPackageReference pack) {\n        if (pack != null) {\n            pack.setParent(this);\n        }\n        this.pack = pack;\n        return ((C) (this));\n    }\n\n    @java.lang.Override\n    public void replace(spoon.reflect.reference.CtTypeReference<?> reference) {\n        super.replace(reference);\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtIntersectionTypeReference<T> asCtIntersectionTypeReference() {\n        return ((spoon.reflect.reference.CtIntersectionTypeReference<T>) (this));\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> unbox() {\n        if (isPrimitive()) {\n            return this;\n        }\n        java.lang.Class<T> actualClass;\n        try {\n            actualClass = getActualClass();\n        } catch (spoon.support.SpoonClassNotFoundException e) {\n            return this;\n        }\n        if (actualClass == java.lang.Integer.class) {\n            return getFactory().Type().createReference(int.class);\n        }\n        if (actualClass == java.lang.Float.class) {\n            return getFactory().Type().createReference(float.class);\n        }\n        if (actualClass == java.lang.Long.class) {\n            return getFactory().Type().createReference(long.class);\n        }\n        if (actualClass == java.lang.Character.class) {\n            return getFactory().Type().createReference(char.class);\n        }\n        if (actualClass == java.lang.Double.class) {\n            return getFactory().Type().createReference(double.class);\n        }\n        if (actualClass == java.lang.Boolean.class) {\n            return getFactory().Type().createReference(boolean.class);\n        }\n        if (actualClass == java.lang.Short.class) {\n            return getFactory().Type().createReference(short.class);\n        }\n        if (actualClass == java.lang.Byte.class) {\n            return getFactory().Type().createReference(byte.class);\n        }\n        if (actualClass == java.lang.Void.class) {\n            return getFactory().Type().createReference(void.class);\n        }\n        return this;\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> getDeclaredFields() {\n        spoon.reflect.declaration.CtType<?> t = getDeclaration();\n        if (t == null) {\n            try {\n                return getDeclaredFieldReferences();\n            } catch (spoon.support.SpoonClassNotFoundException cnfe) {\n                handleParentNotFound(cnfe);\n                return java.util.Collections.emptyList();\n            }\n        } else {\n            return t.getDeclaredFields();\n        }\n    }\n\n    private java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> getDeclaredFieldReferences() {\n        java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> references = new java.util.ArrayList<>();\n        for (java.lang.reflect.Field f : getDeclaredFields(getActualClass())) {\n            references.add(getFactory().Field().createReference(f));\n        }\n        if (getActualClass().isAnnotation()) {\n            for (java.lang.reflect.Method m : getActualClass().getDeclaredMethods()) {\n                spoon.reflect.reference.CtTypeReference<?> retRef = getFactory().Type().createReference(m.getReturnType());\n                spoon.reflect.reference.CtFieldReference<?> fr = getFactory().Field().createReference(this, retRef, m.getName());\n                references.add(fr);\n            }\n        }\n        return references;\n    }\n\n    private java.lang.reflect.Field[] getDeclaredFields(java.lang.Class<?> cls) {\n        try {\n            return cls.getDeclaredFields();\n        } catch (java.lang.Throwable e) {\n            throw new spoon.support.SpoonClassNotFoundException(\"cannot load fields of class: \" + getQualifiedName(), e);\n        }\n    }\n\n    private void handleParentNotFound(spoon.support.SpoonClassNotFoundException cnfe) {\n        java.lang.String msg = ((\"cannot load class: \" + getQualifiedName()) + \" with class loader \") + java.lang.Thread.currentThread().getContextClassLoader();\n        if (getFactory().getEnvironment().getNoClasspath()) {\n            spoon.Launcher.LOGGER.warn(msg);\n            return;\n        } else {\n            throw cnfe;\n        }\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtFieldReference<?> getDeclaredField(java.lang.String name) {\n        if (name == null) {\n            return null;\n        }\n        spoon.reflect.declaration.CtType<?> t = getDeclaration();\n        if (t == null) {\n            try {\n                java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> fields = getDeclaredFieldReferences();\n                for (spoon.reflect.reference.CtFieldReference<?> field : fields) {\n                    if (name.equals(field.getSimpleName())) {\n                        return field;\n                    }\n                }\n            } catch (spoon.support.SpoonClassNotFoundException cnfe) {\n                handleParentNotFound(cnfe);\n                return null;\n            }\n            return null;\n        } else {\n            return t.getDeclaredField(name);\n        }\n    }\n\n    public spoon.reflect.reference.CtFieldReference<?> getDeclaredOrInheritedField(java.lang.String fieldName) {\n        spoon.reflect.declaration.CtType<?> t = getDeclaration();\n        if (t == null) {\n            spoon.reflect.reference.CtFieldReference<?> field = getDeclaredField(fieldName);\n            if (field != null) {\n                return field;\n            }\n            spoon.reflect.reference.CtTypeReference<?> typeRef = getSuperclass();\n            if (typeRef != null) {\n                field = typeRef.getDeclaredOrInheritedField(fieldName);\n                if (field != null) {\n                    return field;\n                }\n            }\n            java.util.Set<spoon.reflect.reference.CtTypeReference<?>> ifaces = getSuperInterfaces();\n            for (spoon.reflect.reference.CtTypeReference<?> iface : ifaces) {\n                field = iface.getDeclaredOrInheritedField(fieldName);\n                if (field != null) {\n                    return field;\n                }\n            }\n            return field;\n        } else {\n            return t.getDeclaredOrInheritedField(fieldName);\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtExecutableReference<?>> getDeclaredExecutables() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t == null) {\n            try {\n                return spoon.support.util.RtHelper.getAllExecutables(getActualClass(), getFactory());\n            } catch (final spoon.support.SpoonClassNotFoundException e) {\n                if (getFactory().getEnvironment().getNoClasspath()) {\n                    return java.util.Collections.emptyList();\n                }\n                throw e;\n            }\n        } else {\n            return t.getDeclaredExecutables();\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> getAllFields() {\n        try {\n            spoon.reflect.declaration.CtType<?> t = getTypeDeclaration();\n            return t.getAllFields();\n        } catch (spoon.support.SpoonClassNotFoundException cnfe) {\n            handleParentNotFound(cnfe);\n            return java.util.Collections.emptyList();\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtExecutableReference<?>> getAllExecutables() {\n        java.util.Collection<spoon.reflect.reference.CtExecutableReference<?>> l = new java.util.ArrayList<>();\n        spoon.reflect.declaration.CtType<T> t = getTypeDeclaration();\n        if (t != null) {\n            l.addAll(t.getAllExecutables());\n        }\n        return l;\n    }\n\n    @java.lang.Override\n    public java.util.Set<spoon.reflect.declaration.ModifierKind> getModifiers() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t != null) {\n            return t.getModifiers();\n        }\n        java.lang.Class<T> c = getActualClass();\n        return spoon.support.util.RtHelper.getModifiers(c.getModifiers());\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> getSuperclass() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t != null) {\n            return t.getSuperclass();\n        } else {\n            try {\n                java.lang.Class<T> c = getActualClass();\n                java.lang.Class<?> sc = c.getSuperclass();\n                if (sc == null) {\n                    return null;\n                }\n                return getFactory().Type().createReference(sc);\n            } catch (final spoon.support.SpoonClassNotFoundException e) {\n                if (getFactory().getEnvironment().getNoClasspath()) {\n                    return null;\n                }\n                throw e;\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Set<spoon.reflect.reference.CtTypeReference<?>> getSuperInterfaces() {\n        spoon.reflect.declaration.CtType<?> t = getDeclaration();\n        if (t != null) {\n            return t.getSuperInterfaces();\n        } else {\n            java.lang.Class<?> c = getActualClass();\n            java.lang.Class<?>[] sis = c.getInterfaces();\n            if ((sis != null) && (sis.length > 0)) {\n                java.util.Set<spoon.reflect.reference.CtTypeReference<?>> set = new spoon.support.util.QualifiedNameBasedSortedSet<spoon.reflect.reference.CtTypeReference<?>>();\n                for (java.lang.Class<?> si : sis) {\n                    set.add(getFactory().Type().createReference(si));\n                }\n                return set;\n            }\n        }\n        return java.util.Collections.emptySet();\n    }\n\n    @java.lang.Override\n    public boolean isAnonymous() {\n        try {\n            java.lang.Integer.parseInt(getSimpleName());\n        } catch (java.lang.NumberFormatException e) {\n            return false;\n        }\n        return true;\n    }\n\n    @java.lang.Override\n    public boolean isLocalType() {\n        if (this.getDeclaration() != null) {\n            return this.getDeclaration().isLocalType();\n        }\n        final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(\"^([0-9]+)([a-zA-Z]+)$\");\n        final java.util.regex.Matcher m = pattern.matcher(getSimpleName());\n        return m.find();\n    }\n\n    @java.lang.Override\n    public <C extends spoon.reflect.reference.CtActualTypeContainer> C addActualTypeArgument(spoon.reflect.reference.CtTypeReference<?> actualTypeArgument) {\n        if (actualTypeArgument == null) {\n            return ((C) (this));\n        }\n        if (actualTypeArguments == spoon.support.reflect.declaration.CtElementImpl.<spoon.reflect.reference.CtTypeReference<?>>emptyList()) {\n            actualTypeArguments = new java.util.ArrayList<>(spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n        }\n        actualTypeArgument.setParent(this);\n        actualTypeArguments.add(actualTypeArgument);\n        return ((C) (this));\n    }\n\n    @java.lang.Override\n    public boolean removeActualTypeArgument(spoon.reflect.reference.CtTypeReference<?> actualTypeArgument) {\n        return (actualTypeArguments != spoon.support.reflect.declaration.CtElementImpl.<spoon.reflect.reference.CtTypeReference<?>>emptyList()) && actualTypeArguments.remove(actualTypeArgument);\n    }\n\n    @java.lang.Override\n    public boolean isInterface() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t == null) {\n            return getActualClass().isInterface();\n        } else {\n            return t.isInterface();\n        }\n    }\n\n    @java.lang.Override\n    public boolean isAnnotationType() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t == null) {\n            return getActualClass().isAnnotation();\n        } else {\n            return t.isAnnotationType();\n        }\n    }\n\n    @java.lang.Override\n    public boolean isGenerics() {\n        return false;\n    }\n\n    @java.lang.Override\n    public boolean canAccess(spoon.reflect.reference.CtTypeReference<?> type) {\n        try {\n            java.util.Set<spoon.reflect.declaration.ModifierKind> modifiers = type.getModifiers();\n            if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PUBLIC)) {\n                return true;\n            }\n            if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PROTECTED)) {\n                spoon.reflect.reference.CtTypeReference<?> declaringType = type.getDeclaringType();\n                if (declaringType == null) {\n                    throw new spoon.SpoonException((\"The protected class \" + type.getQualifiedName()) + \" has no declaring class.\");\n                }\n                if (isImplementationOf(declaringType)) {\n                    return true;\n                }\n                return isInSamePackage(type);\n            }\n            if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PRIVATE)) {\n                return type.getTopLevelType().getQualifiedName().equals(this.getTopLevelType().getQualifiedName());\n            }\n            spoon.reflect.reference.CtTypeReference<?> declaringTypeRef = type.getDeclaringType();\n            if ((declaringTypeRef != null) && declaringTypeRef.isInterface()) {\n                return true;\n            }\n            return isInSamePackage(type);\n        } catch (spoon.support.SpoonClassNotFoundException e) {\n            handleParentNotFound(e);\n            return true;\n        }\n    }\n\n    private boolean isInSamePackage(spoon.reflect.reference.CtTypeReference<?> type) {\n        return type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName());\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> getTopLevelType() {\n        spoon.reflect.reference.CtTypeReference<?> type = this;\n        while (true) {\n            spoon.reflect.reference.CtTypeReference<?> parentType = type.getDeclaringType();\n            if (parentType == null) {\n                return type;\n            }\n            type = parentType;\n        } \n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> getAccessType() {\n        spoon.reflect.reference.CtTypeReference<?> declType = this.getDeclaringType();\n        if (declType == null) {\n            throw new spoon.SpoonException((\"The declaring type is expected, but \" + getQualifiedName()) + \" is top level type\");\n        }\n        spoon.reflect.declaration.CtType<?> contextType = getParent(spoon.reflect.declaration.CtType.class);\n        if (contextType == null) {\n            return declType;\n        }\n        spoon.reflect.reference.CtTypeReference<?> contextTypeRef = contextType.getReference();\n        if ((contextType != null) && (contextTypeRef.canAccess(declType) == false)) {\n            spoon.reflect.reference.CtTypeReference<?> visibleDeclType = null;\n            spoon.reflect.reference.CtTypeReference<?> type = contextTypeRef;\n            while ((visibleDeclType == null) && (type != null)) {\n                visibleDeclType = spoon.support.reflect.reference.CtTypeReferenceImpl.getLastVisibleSuperClassExtendingFrom(type, declType);\n                if (visibleDeclType != null) {\n                    spoon.support.reflect.reference.CtTypeReferenceImpl.applyActualTypeArguments(visibleDeclType, declType);\n                    break;\n                }\n                type = type.getDeclaringType();\n            } \n            declType = visibleDeclType;\n        }\n        if (declType == null) {\n            throw new spoon.SpoonException(((\"Cannot compute access path to type: \" + this.getQualifiedName()) + \" in context of type: \") + contextType.getQualifiedName());\n        }\n        return declType;\n    }\n\n    private static void applyActualTypeArguments(spoon.reflect.reference.CtTypeReference<?> targetTypeRef, spoon.reflect.reference.CtTypeReference<?> sourceTypeRef) {\n        spoon.reflect.reference.CtTypeReference<?> targetDeclType = targetTypeRef.getDeclaringType();\n        spoon.reflect.reference.CtTypeReference<?> sourceDeclType = sourceTypeRef.getDeclaringType();\n        if (((targetDeclType != null) && (sourceDeclType != null)) && targetDeclType.isSubtypeOf(sourceDeclType)) {\n            spoon.support.reflect.reference.CtTypeReferenceImpl.applyActualTypeArguments(targetDeclType, sourceDeclType);\n        }\n        if (targetTypeRef.isSubtypeOf(sourceTypeRef) == false) {\n            throw new spoon.SpoonException(((\"Invalid arguments. targetTypeRef \" + targetTypeRef.getQualifiedName()) + \" must be a sub type of sourceTypeRef \") + sourceTypeRef.getQualifiedName());\n        }\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> newTypeArgs = new java.util.ArrayList<>();\n        for (spoon.reflect.reference.CtTypeReference<?> l_tr : sourceTypeRef.getActualTypeArguments()) {\n            newTypeArgs.add(l_tr.clone());\n        }\n        targetTypeRef.setActualTypeArguments(newTypeArgs);\n    }\n\n    private static spoon.reflect.reference.CtTypeReference<?> getLastVisibleSuperClassExtendingFrom(spoon.reflect.reference.CtTypeReference<?> sourceType, spoon.reflect.reference.CtTypeReference<?> targetType) {\n        java.lang.String targetQN = targetType.getQualifiedName();\n        spoon.reflect.reference.CtTypeReference<?> adept = sourceType;\n        spoon.reflect.reference.CtTypeReference<?> type = sourceType;\n        while (true) {\n            if (targetQN.equals(type.getQualifiedName())) {\n                return adept;\n            }\n            type = type.getSuperclass();\n            if (type == null) {\n                return null;\n            }\n            if (sourceType.canAccess(type)) {\n                adept = type;\n            }\n        } \n    }\n\n    boolean isShadow;\n\n    @java.lang.Override\n    public boolean isShadow() {\n        return isShadow;\n    }\n\n    @java.lang.Override\n    public <E extends spoon.reflect.declaration.CtShadowable> E setShadow(boolean isShadow) {\n        this.isShadow = isShadow;\n        return ((E) (this));\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<T> clone() {\n        return ((spoon.reflect.reference.CtTypeReference<T>) (super.clone()));\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean isInSamePackage(spoon.reflect.reference.CtTypeReference<?> type) {\n    return type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName());\n}",
            "src_parent": "public class CtTypeReferenceImpl<T> extends spoon.support.reflect.reference.CtReferenceImpl implements spoon.reflect.reference.CtTypeReference<T> {\n    private static final long serialVersionUID = 1L;\n\n    java.util.List<spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments = spoon.support.reflect.declaration.CtElementImpl.emptyList();\n\n    spoon.reflect.reference.CtTypeReference<?> declaringType;\n\n    private spoon.reflect.reference.CtPackageReference pack;\n\n    public CtTypeReferenceImpl() {\n        super();\n    }\n\n    @java.lang.Override\n    public void accept(spoon.reflect.visitor.CtVisitor visitor) {\n        visitor.visitCtTypeReference(this);\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> box() {\n        if (!isPrimitive()) {\n            return this;\n        }\n        if (getSimpleName().equals(\"int\")) {\n            return getFactory().Type().createReference(java.lang.Integer.class);\n        }\n        if (getSimpleName().equals(\"float\")) {\n            return getFactory().Type().createReference(java.lang.Float.class);\n        }\n        if (getSimpleName().equals(\"long\")) {\n            return getFactory().Type().createReference(java.lang.Long.class);\n        }\n        if (getSimpleName().equals(\"char\")) {\n            return getFactory().Type().createReference(java.lang.Character.class);\n        }\n        if (getSimpleName().equals(\"double\")) {\n            return getFactory().Type().createReference(java.lang.Double.class);\n        }\n        if (getSimpleName().equals(\"boolean\")) {\n            return getFactory().Type().createReference(java.lang.Boolean.class);\n        }\n        if (getSimpleName().equals(\"short\")) {\n            return getFactory().Type().createReference(java.lang.Short.class);\n        }\n        if (getSimpleName().equals(\"byte\")) {\n            return getFactory().Type().createReference(java.lang.Byte.class);\n        }\n        if (getSimpleName().equals(\"void\")) {\n            return getFactory().Type().createReference(java.lang.Void.class);\n        }\n        return this;\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public java.lang.Class<T> getActualClass() {\n        if (isPrimitive()) {\n            java.lang.String simpleN = getSimpleName();\n            if (\"boolean\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (boolean.class));\n            } else if (\"byte\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (byte.class));\n            } else if (\"double\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (double.class));\n            } else if (\"int\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (int.class));\n            } else if (\"short\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (short.class));\n            } else if (\"char\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (char.class));\n            } else if (\"long\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (long.class));\n            } else if (\"float\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (float.class));\n            } else if (\"void\".equals(simpleN)) {\n                return ((java.lang.Class<T>) (void.class));\n            }\n        }\n        return findClass();\n    }\n\n    @java.lang.SuppressWarnings(\"unchecked\")\n    protected java.lang.Class<T> findClass() {\n        try {\n            return ((java.lang.Class<T>) (getFactory().getEnvironment().getInputClassLoader().loadClass(getQualifiedName())));\n        } catch (java.lang.Throwable e) {\n            throw new spoon.support.SpoonClassNotFoundException(\"cannot load class: \" + getQualifiedName(), e);\n        }\n    }\n\n    @java.lang.Override\n    public java.util.List<spoon.reflect.reference.CtTypeReference<?>> getActualTypeArguments() {\n        return actualTypeArguments;\n    }\n\n    @java.lang.Override\n    protected java.lang.reflect.AnnotatedElement getActualAnnotatedElement() {\n        return getActualClass();\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"unchecked\")\n    public spoon.reflect.declaration.CtType<T> getDeclaration() {\n        return getFactory().Type().get(getQualifiedName());\n    }\n\n    @java.lang.Override\n    public spoon.reflect.declaration.CtType<T> getTypeDeclaration() {\n        spoon.reflect.declaration.CtType<T> t = getFactory().Type().get(getQualifiedName());\n        if (t != null) {\n            return t;\n        }\n        return getFactory().Type().get(getActualClass());\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> getDeclaringType() {\n        return declaringType;\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtPackageReference getPackage() {\n        return pack;\n    }\n\n    @java.lang.Override\n    public java.lang.String getQualifiedName() {\n        if (getDeclaringType() != null) {\n            return (getDeclaringType().getQualifiedName() + spoon.reflect.declaration.CtType.INNERTTYPE_SEPARATOR) + getSimpleName();\n        } else if ((getPackage() != null) && (!getPackage().isUnnamedPackage())) {\n            return (getPackage().getSimpleName() + spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR) + getSimpleName();\n        } else {\n            return getSimpleName();\n        }\n    }\n\n    @java.lang.Override\n    public boolean isPrimitive() {\n        return (((((((\"boolean\".equals(getSimpleName()) || \"byte\".equals(getSimpleName())) || \"double\".equals(getSimpleName())) || \"int\".equals(getSimpleName())) || \"short\".equals(getSimpleName())) || \"char\".equals(getSimpleName())) || \"long\".equals(getSimpleName())) || \"float\".equals(getSimpleName())) || \"void\".equals(getSimpleName());\n    }\n\n    @java.lang.Override\n    public boolean isSubtypeOf(spoon.reflect.reference.CtTypeReference<?> type) {\n        if (type instanceof spoon.reflect.reference.CtTypeParameterReference) {\n            return false;\n        }\n        if (spoon.reflect.reference.CtTypeReference.NULL_TYPE_NAME.equals(getSimpleName()) || spoon.reflect.reference.CtTypeReference.NULL_TYPE_NAME.equals(type.getSimpleName())) {\n            return false;\n        }\n        if (isPrimitive() || type.isPrimitive()) {\n            return equals(type);\n        }\n        spoon.reflect.declaration.CtType<?> superTypeDecl = type.getDeclaration();\n        spoon.reflect.declaration.CtType<?> subTypeDecl = getDeclaration();\n        if ((subTypeDecl == null) && (superTypeDecl == null)) {\n            try {\n                if ((this instanceof spoon.reflect.reference.CtArrayTypeReference) && (type instanceof spoon.reflect.reference.CtArrayTypeReference)) {\n                    return ((spoon.reflect.reference.CtArrayTypeReference<?>) (this)).getComponentType().isSubtypeOf(((spoon.reflect.reference.CtArrayTypeReference<?>) (type)).getComponentType());\n                }\n                java.lang.Class<?> actualSubType = getActualClass();\n                java.lang.Class<?> actualSuperType = type.getActualClass();\n                return actualSuperType.isAssignableFrom(actualSubType);\n            } catch (java.lang.Exception e) {\n                spoon.Launcher.LOGGER.error((((((((\"cannot determine runtime types for '\" + this) + \"' (\") + getQualifiedName()) + \") and '\") + type) + \"' (\") + type.getQualifiedName()) + \")\", e);\n                return false;\n            }\n        }\n        if (getQualifiedName().equals(type.getQualifiedName())) {\n            return true;\n        }\n        if (subTypeDecl != null) {\n            if (getFactory().Type().OBJECT.equals(type)) {\n                return true;\n            }\n            for (spoon.reflect.reference.CtTypeReference<?> ref : subTypeDecl.getSuperInterfaces()) {\n                if (ref.isSubtypeOf(type)) {\n                    return true;\n                }\n            }\n            if (subTypeDecl instanceof spoon.reflect.declaration.CtClass) {\n                if (((spoon.reflect.declaration.CtClass<?>) (subTypeDecl)).getSuperclass() != null) {\n                    if (((spoon.reflect.declaration.CtClass<?>) (subTypeDecl)).getSuperclass().equals(type)) {\n                        return true;\n                    }\n                    return ((spoon.reflect.declaration.CtClass<?>) (subTypeDecl)).getSuperclass().isSubtypeOf(type);\n                }\n            }\n            return false;\n        } else {\n            try {\n                java.lang.Class<?> actualSubType = getActualClass();\n                for (java.lang.Class<?> c : actualSubType.getInterfaces()) {\n                    if (getFactory().Type().createReference(c).isSubtypeOf(type)) {\n                        return true;\n                    }\n                }\n                spoon.reflect.reference.CtTypeReference<?> superType = getFactory().Type().createReference(actualSubType.getSuperclass());\n                return (superType != null) && (superType.equals(type) || superType.isSubtypeOf(type));\n            } catch (java.lang.Exception e) {\n                spoon.Launcher.LOGGER.error((((\"cannot determine runtime types for '\" + this) + \"' and '\") + type) + \"'\", e);\n                return false;\n            }\n        }\n    }\n\n    private boolean isImplementationOf(spoon.reflect.reference.CtTypeReference<?> type) {\n        spoon.reflect.reference.CtTypeReference<?> impl = this;\n        while (impl != null) {\n            if (impl.isSubtypeOf(type)) {\n                return true;\n            }\n            impl = impl.getDeclaringType();\n        } \n        return false;\n    }\n\n    @java.lang.Override\n    public <C extends spoon.reflect.reference.CtActualTypeContainer> C setActualTypeArguments(java.util.List<? extends spoon.reflect.reference.CtTypeReference<?>> actualTypeArguments) {\n        if ((actualTypeArguments == null) || actualTypeArguments.isEmpty()) {\n            this.actualTypeArguments = spoon.support.reflect.declaration.CtElementImpl.emptyList();\n            return ((C) (this));\n        }\n        if (this.actualTypeArguments == spoon.support.reflect.declaration.CtElementImpl.<spoon.reflect.reference.CtTypeReference<?>>emptyList()) {\n            this.actualTypeArguments = new java.util.ArrayList<>(spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n        }\n        this.actualTypeArguments.clear();\n        for (spoon.reflect.reference.CtTypeReference<?> actualTypeArgument : actualTypeArguments) {\n            addActualTypeArgument(actualTypeArgument);\n        }\n        return ((C) (this));\n    }\n\n    @java.lang.Override\n    public <C extends spoon.reflect.reference.CtTypeReference<T>> C setDeclaringType(spoon.reflect.reference.CtTypeReference<?> declaringType) {\n        if (declaringType != null) {\n            declaringType.setParent(this);\n        }\n        this.declaringType = declaringType;\n        return ((C) (this));\n    }\n\n    @java.lang.Override\n    public <C extends spoon.reflect.reference.CtTypeReference<T>> C setPackage(spoon.reflect.reference.CtPackageReference pack) {\n        if (pack != null) {\n            pack.setParent(this);\n        }\n        this.pack = pack;\n        return ((C) (this));\n    }\n\n    @java.lang.Override\n    public void replace(spoon.reflect.reference.CtTypeReference<?> reference) {\n        super.replace(reference);\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtIntersectionTypeReference<T> asCtIntersectionTypeReference() {\n        return ((spoon.reflect.reference.CtIntersectionTypeReference<T>) (this));\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> unbox() {\n        if (isPrimitive()) {\n            return this;\n        }\n        java.lang.Class<T> actualClass;\n        try {\n            actualClass = getActualClass();\n        } catch (spoon.support.SpoonClassNotFoundException e) {\n            return this;\n        }\n        if (actualClass == java.lang.Integer.class) {\n            return getFactory().Type().createReference(int.class);\n        }\n        if (actualClass == java.lang.Float.class) {\n            return getFactory().Type().createReference(float.class);\n        }\n        if (actualClass == java.lang.Long.class) {\n            return getFactory().Type().createReference(long.class);\n        }\n        if (actualClass == java.lang.Character.class) {\n            return getFactory().Type().createReference(char.class);\n        }\n        if (actualClass == java.lang.Double.class) {\n            return getFactory().Type().createReference(double.class);\n        }\n        if (actualClass == java.lang.Boolean.class) {\n            return getFactory().Type().createReference(boolean.class);\n        }\n        if (actualClass == java.lang.Short.class) {\n            return getFactory().Type().createReference(short.class);\n        }\n        if (actualClass == java.lang.Byte.class) {\n            return getFactory().Type().createReference(byte.class);\n        }\n        if (actualClass == java.lang.Void.class) {\n            return getFactory().Type().createReference(void.class);\n        }\n        return this;\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> getDeclaredFields() {\n        spoon.reflect.declaration.CtType<?> t = getDeclaration();\n        if (t == null) {\n            try {\n                return getDeclaredFieldReferences();\n            } catch (spoon.support.SpoonClassNotFoundException cnfe) {\n                handleParentNotFound(cnfe);\n                return java.util.Collections.emptyList();\n            }\n        } else {\n            return t.getDeclaredFields();\n        }\n    }\n\n    private java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> getDeclaredFieldReferences() {\n        java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> references = new java.util.ArrayList<>();\n        for (java.lang.reflect.Field f : getDeclaredFields(getActualClass())) {\n            references.add(getFactory().Field().createReference(f));\n        }\n        if (getActualClass().isAnnotation()) {\n            for (java.lang.reflect.Method m : getActualClass().getDeclaredMethods()) {\n                spoon.reflect.reference.CtTypeReference<?> retRef = getFactory().Type().createReference(m.getReturnType());\n                spoon.reflect.reference.CtFieldReference<?> fr = getFactory().Field().createReference(this, retRef, m.getName());\n                references.add(fr);\n            }\n        }\n        return references;\n    }\n\n    private java.lang.reflect.Field[] getDeclaredFields(java.lang.Class<?> cls) {\n        try {\n            return cls.getDeclaredFields();\n        } catch (java.lang.Throwable e) {\n            throw new spoon.support.SpoonClassNotFoundException(\"cannot load fields of class: \" + getQualifiedName(), e);\n        }\n    }\n\n    private void handleParentNotFound(spoon.support.SpoonClassNotFoundException cnfe) {\n        java.lang.String msg = ((\"cannot load class: \" + getQualifiedName()) + \" with class loader \") + java.lang.Thread.currentThread().getContextClassLoader();\n        if (getFactory().getEnvironment().getNoClasspath()) {\n            spoon.Launcher.LOGGER.warn(msg);\n            return;\n        } else {\n            throw cnfe;\n        }\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtFieldReference<?> getDeclaredField(java.lang.String name) {\n        if (name == null) {\n            return null;\n        }\n        spoon.reflect.declaration.CtType<?> t = getDeclaration();\n        if (t == null) {\n            try {\n                java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> fields = getDeclaredFieldReferences();\n                for (spoon.reflect.reference.CtFieldReference<?> field : fields) {\n                    if (name.equals(field.getSimpleName())) {\n                        return field;\n                    }\n                }\n            } catch (spoon.support.SpoonClassNotFoundException cnfe) {\n                handleParentNotFound(cnfe);\n                return null;\n            }\n            return null;\n        } else {\n            return t.getDeclaredField(name);\n        }\n    }\n\n    public spoon.reflect.reference.CtFieldReference<?> getDeclaredOrInheritedField(java.lang.String fieldName) {\n        spoon.reflect.declaration.CtType<?> t = getDeclaration();\n        if (t == null) {\n            spoon.reflect.reference.CtFieldReference<?> field = getDeclaredField(fieldName);\n            if (field != null) {\n                return field;\n            }\n            spoon.reflect.reference.CtTypeReference<?> typeRef = getSuperclass();\n            if (typeRef != null) {\n                field = typeRef.getDeclaredOrInheritedField(fieldName);\n                if (field != null) {\n                    return field;\n                }\n            }\n            java.util.Set<spoon.reflect.reference.CtTypeReference<?>> ifaces = getSuperInterfaces();\n            for (spoon.reflect.reference.CtTypeReference<?> iface : ifaces) {\n                field = iface.getDeclaredOrInheritedField(fieldName);\n                if (field != null) {\n                    return field;\n                }\n            }\n            return field;\n        } else {\n            return t.getDeclaredOrInheritedField(fieldName);\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtExecutableReference<?>> getDeclaredExecutables() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t == null) {\n            try {\n                return spoon.support.util.RtHelper.getAllExecutables(getActualClass(), getFactory());\n            } catch (final spoon.support.SpoonClassNotFoundException e) {\n                if (getFactory().getEnvironment().getNoClasspath()) {\n                    return java.util.Collections.emptyList();\n                }\n                throw e;\n            }\n        } else {\n            return t.getDeclaredExecutables();\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtFieldReference<?>> getAllFields() {\n        try {\n            spoon.reflect.declaration.CtType<?> t = getTypeDeclaration();\n            return t.getAllFields();\n        } catch (spoon.support.SpoonClassNotFoundException cnfe) {\n            handleParentNotFound(cnfe);\n            return java.util.Collections.emptyList();\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Collection<spoon.reflect.reference.CtExecutableReference<?>> getAllExecutables() {\n        java.util.Collection<spoon.reflect.reference.CtExecutableReference<?>> l = new java.util.ArrayList<>();\n        spoon.reflect.declaration.CtType<T> t = getTypeDeclaration();\n        if (t != null) {\n            l.addAll(t.getAllExecutables());\n        }\n        return l;\n    }\n\n    @java.lang.Override\n    public java.util.Set<spoon.reflect.declaration.ModifierKind> getModifiers() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t != null) {\n            return t.getModifiers();\n        }\n        java.lang.Class<T> c = getActualClass();\n        return spoon.support.util.RtHelper.getModifiers(c.getModifiers());\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> getSuperclass() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t != null) {\n            return t.getSuperclass();\n        } else {\n            try {\n                java.lang.Class<T> c = getActualClass();\n                java.lang.Class<?> sc = c.getSuperclass();\n                if (sc == null) {\n                    return null;\n                }\n                return getFactory().Type().createReference(sc);\n            } catch (final spoon.support.SpoonClassNotFoundException e) {\n                if (getFactory().getEnvironment().getNoClasspath()) {\n                    return null;\n                }\n                throw e;\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Set<spoon.reflect.reference.CtTypeReference<?>> getSuperInterfaces() {\n        spoon.reflect.declaration.CtType<?> t = getDeclaration();\n        if (t != null) {\n            return t.getSuperInterfaces();\n        } else {\n            java.lang.Class<?> c = getActualClass();\n            java.lang.Class<?>[] sis = c.getInterfaces();\n            if ((sis != null) && (sis.length > 0)) {\n                java.util.Set<spoon.reflect.reference.CtTypeReference<?>> set = new spoon.support.util.QualifiedNameBasedSortedSet<spoon.reflect.reference.CtTypeReference<?>>();\n                for (java.lang.Class<?> si : sis) {\n                    set.add(getFactory().Type().createReference(si));\n                }\n                return set;\n            }\n        }\n        return java.util.Collections.emptySet();\n    }\n\n    @java.lang.Override\n    public boolean isAnonymous() {\n        try {\n            java.lang.Integer.parseInt(getSimpleName());\n        } catch (java.lang.NumberFormatException e) {\n            return false;\n        }\n        return true;\n    }\n\n    @java.lang.Override\n    public boolean isLocalType() {\n        if (this.getDeclaration() != null) {\n            return this.getDeclaration().isLocalType();\n        }\n        final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(\"^([0-9]+)([a-zA-Z]+)$\");\n        final java.util.regex.Matcher m = pattern.matcher(getSimpleName());\n        return m.find();\n    }\n\n    @java.lang.Override\n    public <C extends spoon.reflect.reference.CtActualTypeContainer> C addActualTypeArgument(spoon.reflect.reference.CtTypeReference<?> actualTypeArgument) {\n        if (actualTypeArgument == null) {\n            return ((C) (this));\n        }\n        if (actualTypeArguments == spoon.support.reflect.declaration.CtElementImpl.<spoon.reflect.reference.CtTypeReference<?>>emptyList()) {\n            actualTypeArguments = new java.util.ArrayList<>(spoon.reflect.ModelElementContainerDefaultCapacities.TYPE_TYPE_PARAMETERS_CONTAINER_DEFAULT_CAPACITY);\n        }\n        actualTypeArgument.setParent(this);\n        actualTypeArguments.add(actualTypeArgument);\n        return ((C) (this));\n    }\n\n    @java.lang.Override\n    public boolean removeActualTypeArgument(spoon.reflect.reference.CtTypeReference<?> actualTypeArgument) {\n        return (actualTypeArguments != spoon.support.reflect.declaration.CtElementImpl.<spoon.reflect.reference.CtTypeReference<?>>emptyList()) && actualTypeArguments.remove(actualTypeArgument);\n    }\n\n    @java.lang.Override\n    public boolean isInterface() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t == null) {\n            return getActualClass().isInterface();\n        } else {\n            return t.isInterface();\n        }\n    }\n\n    @java.lang.Override\n    public boolean isAnnotationType() {\n        spoon.reflect.declaration.CtType<T> t = getDeclaration();\n        if (t == null) {\n            return getActualClass().isAnnotation();\n        } else {\n            return t.isAnnotationType();\n        }\n    }\n\n    @java.lang.Override\n    public boolean isGenerics() {\n        return false;\n    }\n\n    @java.lang.Override\n    public boolean canAccess(spoon.reflect.reference.CtTypeReference<?> type) {\n        try {\n            java.util.Set<spoon.reflect.declaration.ModifierKind> modifiers = type.getModifiers();\n            if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PUBLIC)) {\n                return true;\n            }\n            if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PROTECTED)) {\n                spoon.reflect.reference.CtTypeReference<?> declaringType = type.getDeclaringType();\n                if (declaringType == null) {\n                    throw new spoon.SpoonException((\"The protected class \" + type.getQualifiedName()) + \" has no declaring class.\");\n                }\n                if (isImplementationOf(declaringType)) {\n                    return true;\n                }\n                return isInSamePackage(type);\n            }\n            if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PRIVATE)) {\n                return type.getTopLevelType().getQualifiedName().equals(this.getTopLevelType().getQualifiedName());\n            }\n            spoon.reflect.reference.CtTypeReference<?> declaringTypeRef = type.getDeclaringType();\n            if ((declaringTypeRef != null) && declaringTypeRef.isInterface()) {\n                return true;\n            }\n            return isInSamePackage(type);\n        } catch (spoon.support.SpoonClassNotFoundException e) {\n            handleParentNotFound(e);\n            return true;\n        }\n    }\n\n    private boolean isInSamePackage(spoon.reflect.reference.CtTypeReference<?> type) {\n        return type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName());\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> getTopLevelType() {\n        spoon.reflect.reference.CtTypeReference<?> type = this;\n        while (true) {\n            spoon.reflect.reference.CtTypeReference<?> parentType = type.getDeclaringType();\n            if (parentType == null) {\n                return type;\n            }\n            type = parentType;\n        } \n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<?> getAccessType() {\n        spoon.reflect.reference.CtTypeReference<?> declType = this.getDeclaringType();\n        if (declType == null) {\n            throw new spoon.SpoonException((\"The declaring type is expected, but \" + getQualifiedName()) + \" is top level type\");\n        }\n        spoon.reflect.declaration.CtType<?> contextType = getParent(spoon.reflect.declaration.CtType.class);\n        if (contextType == null) {\n            return declType;\n        }\n        spoon.reflect.reference.CtTypeReference<?> contextTypeRef = contextType.getReference();\n        if ((contextType != null) && (contextTypeRef.canAccess(declType) == false)) {\n            spoon.reflect.reference.CtTypeReference<?> visibleDeclType = null;\n            spoon.reflect.reference.CtTypeReference<?> type = contextTypeRef;\n            while ((visibleDeclType == null) && (type != null)) {\n                visibleDeclType = spoon.support.reflect.reference.CtTypeReferenceImpl.getLastVisibleSuperClassExtendingFrom(type, declType);\n                if (visibleDeclType != null) {\n                    spoon.support.reflect.reference.CtTypeReferenceImpl.applyActualTypeArguments(visibleDeclType, declType);\n                    break;\n                }\n                type = type.getDeclaringType();\n            } \n            declType = visibleDeclType;\n        }\n        if (declType == null) {\n            throw new spoon.SpoonException(((\"Cannot compute access path to type: \" + this.getQualifiedName()) + \" in context of type: \") + contextType.getQualifiedName());\n        }\n        return declType;\n    }\n\n    private static void applyActualTypeArguments(spoon.reflect.reference.CtTypeReference<?> targetTypeRef, spoon.reflect.reference.CtTypeReference<?> sourceTypeRef) {\n        spoon.reflect.reference.CtTypeReference<?> targetDeclType = targetTypeRef.getDeclaringType();\n        spoon.reflect.reference.CtTypeReference<?> sourceDeclType = sourceTypeRef.getDeclaringType();\n        if (((targetDeclType != null) && (sourceDeclType != null)) && targetDeclType.isSubtypeOf(sourceDeclType)) {\n            spoon.support.reflect.reference.CtTypeReferenceImpl.applyActualTypeArguments(targetDeclType, sourceDeclType);\n        }\n        if (targetTypeRef.isSubtypeOf(sourceTypeRef) == false) {\n            throw new spoon.SpoonException(((\"Invalid arguments. targetTypeRef \" + targetTypeRef.getQualifiedName()) + \" must be a sub type of sourceTypeRef \") + sourceTypeRef.getQualifiedName());\n        }\n        java.util.List<spoon.reflect.reference.CtTypeReference<?>> newTypeArgs = new java.util.ArrayList<>();\n        for (spoon.reflect.reference.CtTypeReference<?> l_tr : sourceTypeRef.getActualTypeArguments()) {\n            newTypeArgs.add(l_tr.clone());\n        }\n        targetTypeRef.setActualTypeArguments(newTypeArgs);\n    }\n\n    private static spoon.reflect.reference.CtTypeReference<?> getLastVisibleSuperClassExtendingFrom(spoon.reflect.reference.CtTypeReference<?> sourceType, spoon.reflect.reference.CtTypeReference<?> targetType) {\n        java.lang.String targetQN = targetType.getQualifiedName();\n        spoon.reflect.reference.CtTypeReference<?> adept = sourceType;\n        spoon.reflect.reference.CtTypeReference<?> type = sourceType;\n        while (true) {\n            if (targetQN.equals(type.getQualifiedName())) {\n                return adept;\n            }\n            type = type.getSuperclass();\n            if (type == null) {\n                return null;\n            }\n            if (sourceType.canAccess(type)) {\n                adept = type;\n            }\n        } \n    }\n\n    boolean isShadow;\n\n    @java.lang.Override\n    public boolean isShadow() {\n        return isShadow;\n    }\n\n    @java.lang.Override\n    public <E extends spoon.reflect.declaration.CtShadowable> E setShadow(boolean isShadow) {\n        this.isShadow = isShadow;\n        return ((E) (this));\n    }\n\n    @java.lang.Override\n    public spoon.reflect.reference.CtTypeReference<T> clone() {\n        return ((spoon.reflect.reference.CtTypeReference<T>) (super.clone()));\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "spoon.reflect.reference.CtTypeReference<?> declaringTypeRef = type.getDeclaringType()",
            "src_parent": "{\n    java.util.Set<spoon.reflect.declaration.ModifierKind> modifiers = type.getModifiers();\n    if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PUBLIC)) {\n        return true;\n    }\n    if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PROTECTED)) {\n        spoon.reflect.reference.CtTypeReference<?> declaringType = type.getDeclaringType();\n        if (declaringType == null) {\n            throw new spoon.SpoonException((\"The protected class \" + type.getQualifiedName()) + \" has no declaring class.\");\n        }\n        if (isImplementationOf(declaringType)) {\n            return true;\n        }\n        return isInSamePackage(type);\n    }\n    if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PRIVATE)) {\n        return type.getTopLevelType().getQualifiedName().equals(this.getTopLevelType().getQualifiedName());\n    }\n    spoon.reflect.reference.CtTypeReference<?> declaringTypeRef = type.getDeclaringType();\n    if ((declaringTypeRef != null) && declaringTypeRef.isInterface()) {\n        return true;\n    }\n    return isInSamePackage(type);\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "return isInSamePackage(type)",
            "src_parent": "{\n    java.util.Set<spoon.reflect.declaration.ModifierKind> modifiers = type.getModifiers();\n    if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PUBLIC)) {\n        return true;\n    }\n    if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PROTECTED)) {\n        spoon.reflect.reference.CtTypeReference<?> declaringType = type.getDeclaringType();\n        if (declaringType == null) {\n            throw new spoon.SpoonException((\"The protected class \" + type.getQualifiedName()) + \" has no declaring class.\");\n        }\n        if (isImplementationOf(declaringType)) {\n            return true;\n        }\n        return isInSamePackage(type);\n    }\n    if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PRIVATE)) {\n        return type.getTopLevelType().getQualifiedName().equals(this.getTopLevelType().getQualifiedName());\n    }\n    spoon.reflect.reference.CtTypeReference<?> declaringTypeRef = type.getDeclaringType();\n    if ((declaringTypeRef != null) && declaringTypeRef.isInterface()) {\n        return true;\n    }\n    return isInSamePackage(type);\n}",
            "src_parent_type": "Block",
            "src_type": "Return"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "(declaringTypeRef != null) && declaringTypeRef.isInterface()",
            "src_parent": "if ((declaringTypeRef != null) && declaringTypeRef.isInterface()) {\n    return true;\n}",
            "src_parent_type": "If",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Try",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "spoon.reflect.reference.CtTypeReference<?> declaringType = type.getDeclaringType()",
            "src_parent": "{\n    spoon.reflect.reference.CtTypeReference<?> declaringType = type.getDeclaringType();\n    if (declaringType == null) {\n        throw new spoon.SpoonException((\"The protected class \" + type.getQualifiedName()) + \" has no declaring class.\");\n    }\n    if (isImplementationOf(declaringType)) {\n        return true;\n    }\n    return isInSamePackage(type);\n}",
            "src_parent_type": "Block",
            "src_type": "LocalVariable"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Try",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (declaringType == null) {\n    throw new spoon.SpoonException((\"The protected class \" + type.getQualifiedName()) + \" has no declaring class.\");\n}",
            "src_parent": "{\n    spoon.reflect.reference.CtTypeReference<?> declaringType = type.getDeclaringType();\n    if (declaringType == null) {\n        throw new spoon.SpoonException((\"The protected class \" + type.getQualifiedName()) + \" has no declaring class.\");\n    }\n    if (isImplementationOf(declaringType)) {\n        return true;\n    }\n    return isInSamePackage(type);\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Try",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "return isInSamePackage(type)",
            "src_parent": "{\n    spoon.reflect.reference.CtTypeReference<?> declaringType = type.getDeclaringType();\n    if (declaringType == null) {\n        throw new spoon.SpoonException((\"The protected class \" + type.getQualifiedName()) + \" has no declaring class.\");\n    }\n    if (isImplementationOf(declaringType)) {\n        return true;\n    }\n    return isInSamePackage(type);\n}",
            "src_parent_type": "Block",
            "src_type": "Return"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Throw",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "(\"The declaring type is expected, but \" + getQualifiedName()) + \" is top level type\"",
            "src_parent": "new spoon.SpoonException((\"The declaring type is expected, but \" + getQualifiedName()) + \" is top level type\")",
            "src_parent_type": "ConstructorCall",
            "src_type": "BinaryOperator"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Try",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "return false",
            "dst_parent": "{\n    spoon.reflect.reference.CtTypeReference<?> impl = this;\n    while (impl != null) {\n        if (impl.isSubtypeOf(type)) {\n            return true;\n        }\n        impl = impl.getDeclaringType();\n    } \n    return false;\n}",
            "dst_parent_type": "Block",
            "dst_type": "Return",
            "operator": "MOV",
            "src": "return false",
            "src_parent": "{\n    java.util.Set<spoon.reflect.declaration.ModifierKind> modifiers = type.getModifiers();\n    if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PUBLIC)) {\n        return true;\n    }\n    if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PROTECTED)) {\n        if (isSubtypeOf(type)) {\n            return true;\n        }\n    }\n    if (modifiers.contains(spoon.reflect.declaration.ModifierKind.PRIVATE)) {\n        return type.getTopLevelType().getQualifiedName().equals(this.getTopLevelType().getQualifiedName());\n    }\n    if (type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName())) {\n        return true;\n    }\n    return false;\n}",
            "src_parent_type": "Block",
            "src_type": "Return"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Try",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName())",
            "dst_parent": "return type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName())",
            "dst_parent_type": "Return",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName())",
            "src_parent": "if (type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName())) {\n    return true;\n}",
            "src_parent_type": "If",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    return true;\n}",
            "dst_parent": "if ((declaringTypeRef != null) && declaringTypeRef.isInterface()) {\n    return true;\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    return true;\n}",
            "src_parent": "if (isSubtypeOf(type)) {\n    return true;\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Return",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "If",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "If",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Try",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    return true;\n}",
            "dst_parent": "if (isImplementationOf(declaringType)) {\n    return true;\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    return true;\n}",
            "src_parent": "if (type.getTopLevelType().getPackage().getSimpleName().equals(this.getTopLevelType().getPackage().getSimpleName())) {\n    return true;\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "If",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Throw",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "(\"The declaring type is expected, but \" + getQualifiedName())",
            "dst_parent": "(\"The declaring type is expected, but \" + getQualifiedName()) + \" is top level type\"",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "BinaryOperator",
            "operator": "MOV",
            "src": "\"The nestedType is expected, but it is: \" + getQualifiedName()",
            "src_parent": "new spoon.SpoonException(\"The nestedType is expected, but it is: \" + getQualifiedName())",
            "src_parent_type": "ConstructorCall",
            "src_type": "BinaryOperator"
          }
        }
      ],
      "file_name": "CtTypeReferenceImpl"
    }
  ],
  "id": "bears_40"
}