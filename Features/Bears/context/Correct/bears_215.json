{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "stringBuilder.append(ctJavaDocTag.getContent())",
            "src_parent": "{\n    stringBuilder.append(ctJavaDocTag.getContent());\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Switch",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "if (javadoc.contains(ctImport.getReference().getSimpleName())) {\n    this.setImportUsed(ctImport);\n}",
            "src_parent": "case TYPE :\n    if (javadoc.contains(ctImport.getReference().getSimpleName())) {\n        this.setImportUsed(ctImport);\n    }\n    break;",
            "src_parent_type": "Case",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static java.util.Set<java.lang.String> mainTags = new java.util.HashSet<>(java.util.Arrays.asList(\"see\", \"throws\", \"exception\"));",
            "src_parent": "public class ImportScannerImpl extends spoon.reflect.visitor.CtScanner implements spoon.reflect.visitor.ImportScanner {\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang8 = java.util.Collections.singletonList(\"FunctionalInterface\");\n\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang9 = java.util.Arrays.asList(\"ProcessHandle\", \"StackWalker\", \"StackFramePermission\");\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtTypeReference<?>> classImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtFieldReference<?>> fieldImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtExecutableReference<?>> methodImports = new java.util.TreeMap<>();\n\n    protected spoon.reflect.reference.CtTypeReference<?> targetType;\n\n    private java.util.Map<java.lang.String, java.lang.Boolean> namesPresentInJavaLang = new java.util.HashMap<>();\n\n    private java.util.Set<java.lang.String> fieldAndMethodsNames = new java.util.HashSet<>();\n\n    private java.util.Set<spoon.reflect.reference.CtTypeReference> exploredReferences = new java.util.HashSet<>();\n\n    private java.util.Map<spoon.reflect.declaration.CtImport, java.lang.Boolean> usedImport = new java.util.HashMap<>();\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        enter(fieldRead);\n        scan(fieldRead.getAnnotations());\n        scan(fieldRead.getTypeCasts());\n        scan(fieldRead.getVariable());\n        scan(fieldRead.getTarget());\n        exit(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        enter(reference);\n        scan(reference.getDeclaringType());\n        if (reference.isStatic()) {\n            addFieldImport(reference);\n        } else {\n            scan(reference.getDeclaringType());\n        }\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        enter(reference);\n        if (reference.isStatic()) {\n            addMethodImport(reference);\n        } else if (reference.isConstructor()) {\n            scan(reference.getDeclaringType());\n        }\n        scan(reference.getActualTypeArguments());\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (!(reference instanceof spoon.reflect.reference.CtArrayTypeReference)) {\n            spoon.reflect.reference.CtTypeReference typeReference;\n            if (reference.getDeclaringType() == null) {\n                typeReference = reference;\n            } else {\n                typeReference = reference.getAccessType();\n            }\n            if (!typeReference.equals(reference)) {\n                if (this.isAlreadyInUsedImport(reference)) {\n                    super.visitCtTypeReference(reference);\n                    return;\n                }\n            }\n            if (!this.isTypeInCollision(typeReference, false)) {\n                this.addClassImport(typeReference);\n            }\n        }\n        super.visitCtTypeReference(reference);\n    }\n\n    @java.lang.Override\n    public void scan(spoon.reflect.declaration.CtElement element) {\n        if (element != null) {\n            element.accept(this);\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc ctJavaDoc) {\n        java.lang.StringBuilder stringBuilder = new java.lang.StringBuilder();\n        stringBuilder.append(ctJavaDoc.getContent());\n        for (spoon.reflect.code.CtJavaDocTag ctJavaDocTag : ctJavaDoc.getTags()) {\n            stringBuilder.append(\"\\n\").append(ctJavaDocTag.getType()).append(\" \").append(ctJavaDocTag.getContent());\n        }\n        java.lang.String javadoc = stringBuilder.toString();\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case TYPE :\n                    if (javadoc.contains(ctImport.getReference().getSimpleName()) && (ctImport.getReference() instanceof spoon.reflect.reference.CtTypeReference)) {\n                        if (matchesTypeName(javadoc, ((spoon.reflect.reference.CtTypeReference<?>) (ctImport.getReference())))) {\n                            this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n    private static java.util.Set<java.lang.String> mainTags = new java.util.HashSet<>(java.util.Arrays.asList(\"see\", \"throws\", \"exception\"));\n\n    private static java.util.Set<java.lang.String> inlineTags = new java.util.HashSet<>(java.util.Arrays.asList(\"link\", \"linkplain\", \"value\"));\n\n    private static java.util.regex.Pattern tagRE = java.util.regex.Pattern.compile(\"(\\\\{)?@(\\\\w+)\\\\s+([\\\\w\\\\.\\\\$]+)(?:#(\\\\w+)(?:\\\\(([^\\\\)]*)\\\\)))?\");\n\n    private boolean matchesTypeName(java.lang.String javadoc, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        java.util.regex.Matcher m = spoon.reflect.visitor.ImportScannerImpl.tagRE.matcher(javadoc);\n        while (m.find()) {\n            java.lang.String bracket = m.group(1);\n            java.lang.String tag = m.group(2);\n            if (\"{\".equals(bracket)) {\n                if (spoon.reflect.visitor.ImportScannerImpl.inlineTags.contains(tag) == false) {\n                    continue;\n                }\n            } else if (spoon.reflect.visitor.ImportScannerImpl.mainTags.contains(tag) == false) {\n                continue;\n            }\n            java.lang.String type = m.group(3);\n            java.lang.String params = m.group(5);\n            if (isTypeMatching(type, typeRef)) {\n                return true;\n            }\n            if (params != null) {\n                java.lang.String[] paramTypes = params.split(\"\\\\s*,\\\\s*\");\n                for (java.lang.String paramType : paramTypes) {\n                    if (isTypeMatching(paramType, typeRef)) {\n                        return true;\n                    }\n                }\n            }\n        } \n        return false;\n    }\n\n    private boolean isTypeMatching(java.lang.String typeName, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        if (typeName != null) {\n            if (typeName.equals(typeRef.getQualifiedName())) {\n                return true;\n            }\n            if (typeName.equals(typeRef.getSimpleName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        addClassImport(annotationType.getReference());\n        super.visitCtAnnotationType(annotationType);\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        addClassImport(ctEnum.getReference());\n        super.visitCtEnum(ctEnum);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        addClassImport(intrface.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : intrface.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtInterface(intrface);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        addClassImport(ctClass.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : ctClass.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtClass(ctClass);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        for (spoon.reflect.reference.CtTypeReference<?> type : catchVariable.getMultiTypes()) {\n            addClassImport(type);\n        }\n        super.visitCtCatchVariable(catchVariable);\n    }\n\n    @java.lang.Override\n    public void visitCtInvocation(spoon.reflect.code.CtInvocation invocation) {\n        this.scan(invocation.getTypeCasts());\n        this.scan(invocation.getExecutable());\n        if (!this.isImportedInMethodImports(invocation.getExecutable())) {\n            this.scan(invocation.getTarget());\n        }\n        this.scan(invocation.getArguments());\n    }\n\n    @java.lang.Override\n    public java.util.Set<spoon.reflect.declaration.CtImport> getAllImports() {\n        java.util.Set<spoon.reflect.declaration.CtImport> listallImports = new java.util.HashSet<>();\n        for (java.util.Map.Entry<spoon.reflect.declaration.CtImport, java.lang.Boolean> entry : this.usedImport.entrySet()) {\n            if (entry.getValue()) {\n                listallImports.add(entry.getKey());\n            }\n        }\n        for (spoon.reflect.reference.CtReference reference : this.classImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.fieldImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.methodImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        return listallImports;\n    }\n\n    @java.lang.Override\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (element instanceof spoon.reflect.declaration.CtType) {\n            spoon.reflect.declaration.CtType simpleType = ((spoon.reflect.declaration.CtType) (element));\n            targetType = simpleType.getReference().getTopLevelType();\n            addClassImport(simpleType.getReference());\n            scan(simpleType);\n        } else {\n            spoon.reflect.declaration.CtType<?> type = element.getParent(spoon.reflect.declaration.CtType.class);\n            targetType = (type == null) ? null : type.getReference().getTopLevelType();\n            scan(element);\n        }\n    }\n\n    @java.lang.Override\n    public boolean isImported(spoon.reflect.reference.CtReference ref) {\n        if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            return isImportedInFieldImports(((spoon.reflect.reference.CtFieldReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            return isImportedInMethodImports(((spoon.reflect.reference.CtExecutableReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            return isImportedInClassImports(((spoon.reflect.reference.CtTypeReference) (ref)));\n        } else {\n            return false;\n        }\n    }\n\n    @java.lang.Override\n    public void initWithImports(java.util.Set<spoon.reflect.declaration.CtImport> importCollection) {\n        for (spoon.reflect.declaration.CtImport ctImport : importCollection) {\n            this.usedImport.put(ctImport, java.lang.Boolean.FALSE);\n        }\n    }\n\n    private boolean isThereAnotherClassWithSameNameInAnotherPackage(spoon.reflect.reference.CtTypeReference<?> ref) {\n        for (spoon.reflect.reference.CtTypeReference typeref : this.exploredReferences) {\n            if (typeref.getSimpleName().equals(ref.getSimpleName()) && (!typeref.getQualifiedName().equals(ref.getQualifiedName()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean addClassImport(spoon.reflect.reference.CtTypeReference<?> ref) {\n        this.exploredReferences.add(ref);\n        if (ref == null) {\n            return false;\n        }\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return false;\n        }\n        if (classImports.containsKey(ref.getSimpleName())) {\n            return isImportedInClassImports(ref);\n        }\n        if ((ref.getPackage() == null) || ref.getPackage().isUnnamedPackage()) {\n            return false;\n        }\n        if ((targetType != null) && (targetType.canAccess(ref) == false)) {\n            return false;\n        }\n        if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n            return false;\n        }\n        if (targetType != null) {\n            try {\n                spoon.reflect.declaration.CtElement parent = ref.getParent();\n                if (parent != null) {\n                    parent = parent.getParent();\n                    if (parent != null) {\n                        if (((parent instanceof spoon.reflect.code.CtFieldAccess) || (parent instanceof spoon.reflect.declaration.CtExecutable)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                            spoon.reflect.reference.CtTypeReference declaringType;\n                            spoon.reflect.reference.CtReference reference;\n                            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n                            if (parent instanceof spoon.reflect.code.CtFieldAccess) {\n                                spoon.reflect.code.CtFieldAccess field = ((spoon.reflect.code.CtFieldAccess) (parent));\n                                spoon.reflect.reference.CtFieldReference localReference = field.getVariable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.declaration.CtExecutable) {\n                                spoon.reflect.declaration.CtExecutable exec = ((spoon.reflect.declaration.CtExecutable) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = exec.getReference();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.code.CtInvocation) {\n                                spoon.reflect.code.CtInvocation invo = ((spoon.reflect.code.CtInvocation) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = invo.getExecutable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else {\n                                declaringType = null;\n                                reference = null;\n                            }\n                            if ((reference != null) && isImported(reference)) {\n                                if (declaringType != null) {\n                                    if ((declaringType.getPackage() != null) && (!declaringType.getPackage().isUnnamedPackage())) {\n                                        if (!\"java.lang\".equals(declaringType.getPackage().getSimpleName())) {\n                                            if (declaringType.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                                                classImports.put(ref.getSimpleName(), ref);\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            }\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    return false;\n                } else if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                    return false;\n                }\n            }\n        }\n        classImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    private boolean setImportUsed(spoon.reflect.declaration.CtImport ctImport) {\n        this.usedImport.put(ctImport, true);\n        return true;\n    }\n\n    private boolean isAlreadyInUsedImport(spoon.reflect.reference.CtReference ref) {\n        java.lang.String refQualifiedName = \"\";\n        spoon.reflect.reference.CtTypeReference refDeclaringType = null;\n        boolean isTypeRef = false;\n        boolean isExecRef = false;\n        boolean isFieldRef = false;\n        if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            refQualifiedName = ((spoon.reflect.reference.CtTypeReference) (ref)).getQualifiedName();\n            isTypeRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtExecutableReference) (ref)).getDeclaringType();\n            isExecRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtFieldReference) (ref)).getDeclaringType();\n            refQualifiedName = ((spoon.reflect.reference.CtFieldReference) (ref)).getQualifiedName();\n            isFieldRef = true;\n        }\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case METHOD :\n                    if (isExecRef) {\n                        spoon.reflect.reference.CtExecutableReference execRef = ((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference()));\n                        spoon.reflect.reference.CtTypeReference declaringType = execRef.getDeclaringType();\n                        if ((execRef.getSimpleName().equals(ref.getSimpleName()) && (declaringType != null)) && declaringType.equals(refDeclaringType)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case FIELD :\n                    if (isFieldRef) {\n                        spoon.reflect.reference.CtFieldReference importFieldRef = ((spoon.reflect.reference.CtFieldReference) (ctImport.getReference()));\n                        if (importFieldRef.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_STATIC_MEMBERS :\n                    if ((isExecRef || isFieldRef) && (refDeclaringType != null)) {\n                        java.lang.String qualifiedName = refDeclaringType.getQualifiedName();\n                        spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl importRef = ((spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl) (ctImport.getReference()));\n                        java.lang.String importRefStr = importRef.getQualifiedName();\n                        importRefStr = importRefStr.substring(0, importRefStr.lastIndexOf('.'));\n                        if (qualifiedName.equals(importRefStr)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case TYPE :\n                    if (isTypeRef) {\n                        spoon.reflect.reference.CtTypeReference typeReference = ((spoon.reflect.reference.CtTypeReference) (ctImport.getReference()));\n                        if (typeReference.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_TYPES :\n                    if (isTypeRef) {\n                        java.lang.String typeImportQualifiedName = ctImport.getReference().getSimpleName();\n                        if (refQualifiedName.equals(typeImportQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n        return false;\n    }\n\n    protected boolean isImportedInClassImports(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if (targetType != null) {\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (!\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                        return true;\n                    }\n                }\n            }\n        }\n        if (ref.equals(targetType)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && classImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtTypeReference<?> exist = classImports.get(ref.getSimpleName());\n            return exist.getQualifiedName().equals(ref.getQualifiedName());\n        }\n        return false;\n    }\n\n    private boolean declaringTypeIsLocalOrImported(spoon.reflect.reference.CtTypeReference declaringType) {\n        if (declaringType != null) {\n            boolean isInCollision = isTypeInCollision(declaringType, false);\n            if (!isInCollision) {\n                boolean importSuccess = addClassImport(declaringType);\n                if (importSuccess) {\n                    return true;\n                }\n            }\n            boolean importedInClassImports = isImportedInClassImports(declaringType);\n            boolean inJavaLang = classNamePresentInJavaLang(declaringType);\n            if (importedInClassImports || inJavaLang) {\n                return true;\n            }\n            while (declaringType != null) {\n                if (declaringType.equals(targetType)) {\n                    return true;\n                }\n                declaringType = declaringType.getDeclaringType();\n            } \n        }\n        return false;\n    }\n\n    private boolean isInCollisionWithLocalMethod(spoon.reflect.reference.CtExecutableReference ref) {\n        spoon.reflect.declaration.CtType<?> typeDecl = ref.getParent(spoon.reflect.declaration.CtType.class);\n        if (typeDecl != null) {\n            java.lang.String methodName = ref.getSimpleName();\n            for (spoon.reflect.declaration.CtMethod<?> method : typeDecl.getAllMethods()) {\n                if (method.getSimpleName().equals(methodName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    protected boolean addMethodImport(spoon.reflect.reference.CtExecutableReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.isImportedInMethodImports(ref)) {\n            return true;\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        if (this.isInCollisionWithLocalMethod(ref)) {\n            return false;\n        }\n        methodImports.put(ref.getSimpleName(), ref);\n        if (ref.getDeclaringType() != null) {\n            if (ref.getDeclaringType().getPackage() != null) {\n                if (ref.getDeclaringType().getPackage().equals(this.targetType.getPackage())) {\n                    addClassImport(ref.getDeclaringType());\n                }\n            }\n        }\n        return true;\n    }\n\n    protected boolean isImportedInMethodImports(spoon.reflect.reference.CtExecutableReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && methodImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtExecutableReference<?> exist = methodImports.get(ref.getSimpleName());\n            return getSignature(exist).equals(getSignature(ref));\n        }\n        return false;\n    }\n\n    private java.lang.String getSignature(spoon.reflect.reference.CtExecutableReference<?> exist) {\n        return ((exist.getDeclaringType() != null ? exist.getDeclaringType().getQualifiedName() : \"\") + \".\") + exist.getSignature();\n    }\n\n    protected boolean addFieldImport(spoon.reflect.reference.CtFieldReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.fieldImports.containsKey(ref.getSimpleName())) {\n            return isImportedInFieldImports(ref);\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        fieldImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    protected boolean isImportedInFieldImports(spoon.reflect.reference.CtFieldReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && fieldImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtFieldReference<?> exist = fieldImports.get(ref.getSimpleName());\n            try {\n                if ((exist.getFieldDeclaration() != null) && exist.getFieldDeclaration().equals(ref.getFieldDeclaration())) {\n                    return true;\n                }\n            } catch (spoon.support.SpoonClassNotFoundException notfound) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    protected boolean classNamePresentInJavaLang(spoon.reflect.reference.CtTypeReference<?> ref) {\n        java.lang.Boolean presentInJavaLang = namesPresentInJavaLang.get(ref.getSimpleName());\n        if (presentInJavaLang == null) {\n            if (spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang8.contains(ref.getSimpleName()) || spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang9.contains(ref.getSimpleName())) {\n                presentInJavaLang = true;\n            } else {\n                try {\n                    java.lang.Class.forName(\"java.lang.\" + ref.getSimpleName());\n                    presentInJavaLang = true;\n                } catch (java.lang.NoClassDefFoundError | java.lang.ClassNotFoundException e) {\n                    presentInJavaLang = false;\n                }\n            }\n            namesPresentInJavaLang.put(ref.getSimpleName(), presentInJavaLang);\n        }\n        return presentInJavaLang;\n    }\n\n    protected java.util.Set<java.lang.String> lookForLocalVariables(spoon.reflect.declaration.CtElement parent) {\n        java.util.Set<java.lang.String> result = new java.util.HashSet<>();\n        while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n            if (parent instanceof spoon.reflect.declaration.CtClass) {\n                return result;\n            }\n            parent = parent.getParent();\n        } \n        if (parent != null) {\n            spoon.reflect.code.CtBlock block = ((spoon.reflect.code.CtBlock) (parent));\n            boolean innerClass = false;\n            while ((parent != null) && (!(parent instanceof spoon.reflect.declaration.CtClass))) {\n                parent = parent.getParent();\n            } \n            if (parent != null) {\n                if (!(parent.getParent() instanceof spoon.reflect.declaration.CtPackage)) {\n                    while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n                        parent = parent.getParent();\n                    } \n                    if (parent != null) {\n                        block = ((spoon.reflect.code.CtBlock) (parent));\n                    }\n                }\n            }\n            spoon.reflect.visitor.AccessibleVariablesFinder avf = new spoon.reflect.visitor.AccessibleVariablesFinder(block);\n            java.util.List<spoon.reflect.declaration.CtVariable> variables = avf.find();\n            for (spoon.reflect.declaration.CtVariable variable : variables) {\n                result.add(variable.getSimpleName());\n            }\n        }\n        return result;\n    }\n\n    protected boolean isTypeInCollision(spoon.reflect.reference.CtReference ref, boolean fqnMode) {\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return true;\n        }\n        try {\n            spoon.reflect.declaration.CtElement parent;\n            if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                parent = ref.getParent();\n            } else {\n                parent = ref;\n            }\n            if (parent instanceof spoon.reflect.code.CtLiteral) {\n                return false;\n            }\n            java.util.Set<java.lang.String> localVariablesOfBlock = new java.util.HashSet<>();\n            if (parent instanceof spoon.reflect.declaration.CtField) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtField) (parent)).getSimpleName());\n            } else if (parent instanceof spoon.reflect.declaration.CtMethod) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtMethod) (parent)).getSimpleName());\n            } else {\n                localVariablesOfBlock = this.lookForLocalVariables(parent);\n            }\n            while (!(parent instanceof spoon.reflect.declaration.CtPackage)) {\n                if (((parent instanceof spoon.reflect.reference.CtFieldReference) || (parent instanceof spoon.reflect.reference.CtExecutableReference)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                    spoon.reflect.reference.CtReference parentType;\n                    if (parent instanceof spoon.reflect.code.CtInvocation) {\n                        parentType = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable();\n                    } else {\n                        parentType = ((spoon.reflect.reference.CtReference) (parent));\n                    }\n                    java.util.LinkedList<java.lang.String> qualifiedNameTokens = new java.util.LinkedList<>();\n                    if (parentType != parent) {\n                        qualifiedNameTokens.add(parentType.getSimpleName());\n                    }\n                    spoon.reflect.reference.CtTypeReference typeReference;\n                    if (parent instanceof spoon.reflect.reference.CtFieldReference) {\n                        typeReference = ((spoon.reflect.reference.CtFieldReference) (parent)).getDeclaringType();\n                    } else if (parent instanceof spoon.reflect.reference.CtExecutableReference) {\n                        typeReference = ((spoon.reflect.reference.CtExecutableReference) (parent)).getDeclaringType();\n                    } else {\n                        typeReference = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable().getDeclaringType();\n                    }\n                    if (typeReference != null) {\n                        qualifiedNameTokens.addFirst(typeReference.getSimpleName());\n                        if (typeReference.getPackage() != null) {\n                            java.util.StringTokenizer token = new java.util.StringTokenizer(typeReference.getPackage().getSimpleName(), spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                            int index = 0;\n                            while (token.hasMoreElements()) {\n                                qualifiedNameTokens.add(index, token.nextToken());\n                                index++;\n                            } \n                        }\n                    }\n                    if (!qualifiedNameTokens.isEmpty()) {\n                        if (fieldAndMethodsNames.contains(qualifiedNameTokens.getFirst()) || localVariablesOfBlock.contains(qualifiedNameTokens.getFirst())) {\n                            qualifiedNameTokens.removeFirst();\n                            if (fqnMode) {\n                                if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                                    if (qualifiedNameTokens.isEmpty()) {\n                                        return true;\n                                    }\n                                    for (java.lang.String testedToken : qualifiedNameTokens) {\n                                        if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                            return true;\n                                        }\n                                    }\n                                    return false;\n                                } else {\n                                    return true;\n                                }\n                            } else {\n                                for (java.lang.String testedToken : qualifiedNameTokens) {\n                                    if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                        }\n                    }\n                }\n                parent = parent.getParent();\n            } \n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static java.util.Set<java.lang.String> inlineTags = new java.util.HashSet<>(java.util.Arrays.asList(\"link\", \"linkplain\", \"value\"));",
            "src_parent": "public class ImportScannerImpl extends spoon.reflect.visitor.CtScanner implements spoon.reflect.visitor.ImportScanner {\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang8 = java.util.Collections.singletonList(\"FunctionalInterface\");\n\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang9 = java.util.Arrays.asList(\"ProcessHandle\", \"StackWalker\", \"StackFramePermission\");\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtTypeReference<?>> classImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtFieldReference<?>> fieldImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtExecutableReference<?>> methodImports = new java.util.TreeMap<>();\n\n    protected spoon.reflect.reference.CtTypeReference<?> targetType;\n\n    private java.util.Map<java.lang.String, java.lang.Boolean> namesPresentInJavaLang = new java.util.HashMap<>();\n\n    private java.util.Set<java.lang.String> fieldAndMethodsNames = new java.util.HashSet<>();\n\n    private java.util.Set<spoon.reflect.reference.CtTypeReference> exploredReferences = new java.util.HashSet<>();\n\n    private java.util.Map<spoon.reflect.declaration.CtImport, java.lang.Boolean> usedImport = new java.util.HashMap<>();\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        enter(fieldRead);\n        scan(fieldRead.getAnnotations());\n        scan(fieldRead.getTypeCasts());\n        scan(fieldRead.getVariable());\n        scan(fieldRead.getTarget());\n        exit(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        enter(reference);\n        scan(reference.getDeclaringType());\n        if (reference.isStatic()) {\n            addFieldImport(reference);\n        } else {\n            scan(reference.getDeclaringType());\n        }\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        enter(reference);\n        if (reference.isStatic()) {\n            addMethodImport(reference);\n        } else if (reference.isConstructor()) {\n            scan(reference.getDeclaringType());\n        }\n        scan(reference.getActualTypeArguments());\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (!(reference instanceof spoon.reflect.reference.CtArrayTypeReference)) {\n            spoon.reflect.reference.CtTypeReference typeReference;\n            if (reference.getDeclaringType() == null) {\n                typeReference = reference;\n            } else {\n                typeReference = reference.getAccessType();\n            }\n            if (!typeReference.equals(reference)) {\n                if (this.isAlreadyInUsedImport(reference)) {\n                    super.visitCtTypeReference(reference);\n                    return;\n                }\n            }\n            if (!this.isTypeInCollision(typeReference, false)) {\n                this.addClassImport(typeReference);\n            }\n        }\n        super.visitCtTypeReference(reference);\n    }\n\n    @java.lang.Override\n    public void scan(spoon.reflect.declaration.CtElement element) {\n        if (element != null) {\n            element.accept(this);\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc ctJavaDoc) {\n        java.lang.StringBuilder stringBuilder = new java.lang.StringBuilder();\n        stringBuilder.append(ctJavaDoc.getContent());\n        for (spoon.reflect.code.CtJavaDocTag ctJavaDocTag : ctJavaDoc.getTags()) {\n            stringBuilder.append(\"\\n\").append(ctJavaDocTag.getType()).append(\" \").append(ctJavaDocTag.getContent());\n        }\n        java.lang.String javadoc = stringBuilder.toString();\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case TYPE :\n                    if (javadoc.contains(ctImport.getReference().getSimpleName()) && (ctImport.getReference() instanceof spoon.reflect.reference.CtTypeReference)) {\n                        if (matchesTypeName(javadoc, ((spoon.reflect.reference.CtTypeReference<?>) (ctImport.getReference())))) {\n                            this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n    private static java.util.Set<java.lang.String> mainTags = new java.util.HashSet<>(java.util.Arrays.asList(\"see\", \"throws\", \"exception\"));\n\n    private static java.util.Set<java.lang.String> inlineTags = new java.util.HashSet<>(java.util.Arrays.asList(\"link\", \"linkplain\", \"value\"));\n\n    private static java.util.regex.Pattern tagRE = java.util.regex.Pattern.compile(\"(\\\\{)?@(\\\\w+)\\\\s+([\\\\w\\\\.\\\\$]+)(?:#(\\\\w+)(?:\\\\(([^\\\\)]*)\\\\)))?\");\n\n    private boolean matchesTypeName(java.lang.String javadoc, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        java.util.regex.Matcher m = spoon.reflect.visitor.ImportScannerImpl.tagRE.matcher(javadoc);\n        while (m.find()) {\n            java.lang.String bracket = m.group(1);\n            java.lang.String tag = m.group(2);\n            if (\"{\".equals(bracket)) {\n                if (spoon.reflect.visitor.ImportScannerImpl.inlineTags.contains(tag) == false) {\n                    continue;\n                }\n            } else if (spoon.reflect.visitor.ImportScannerImpl.mainTags.contains(tag) == false) {\n                continue;\n            }\n            java.lang.String type = m.group(3);\n            java.lang.String params = m.group(5);\n            if (isTypeMatching(type, typeRef)) {\n                return true;\n            }\n            if (params != null) {\n                java.lang.String[] paramTypes = params.split(\"\\\\s*,\\\\s*\");\n                for (java.lang.String paramType : paramTypes) {\n                    if (isTypeMatching(paramType, typeRef)) {\n                        return true;\n                    }\n                }\n            }\n        } \n        return false;\n    }\n\n    private boolean isTypeMatching(java.lang.String typeName, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        if (typeName != null) {\n            if (typeName.equals(typeRef.getQualifiedName())) {\n                return true;\n            }\n            if (typeName.equals(typeRef.getSimpleName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        addClassImport(annotationType.getReference());\n        super.visitCtAnnotationType(annotationType);\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        addClassImport(ctEnum.getReference());\n        super.visitCtEnum(ctEnum);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        addClassImport(intrface.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : intrface.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtInterface(intrface);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        addClassImport(ctClass.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : ctClass.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtClass(ctClass);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        for (spoon.reflect.reference.CtTypeReference<?> type : catchVariable.getMultiTypes()) {\n            addClassImport(type);\n        }\n        super.visitCtCatchVariable(catchVariable);\n    }\n\n    @java.lang.Override\n    public void visitCtInvocation(spoon.reflect.code.CtInvocation invocation) {\n        this.scan(invocation.getTypeCasts());\n        this.scan(invocation.getExecutable());\n        if (!this.isImportedInMethodImports(invocation.getExecutable())) {\n            this.scan(invocation.getTarget());\n        }\n        this.scan(invocation.getArguments());\n    }\n\n    @java.lang.Override\n    public java.util.Set<spoon.reflect.declaration.CtImport> getAllImports() {\n        java.util.Set<spoon.reflect.declaration.CtImport> listallImports = new java.util.HashSet<>();\n        for (java.util.Map.Entry<spoon.reflect.declaration.CtImport, java.lang.Boolean> entry : this.usedImport.entrySet()) {\n            if (entry.getValue()) {\n                listallImports.add(entry.getKey());\n            }\n        }\n        for (spoon.reflect.reference.CtReference reference : this.classImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.fieldImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.methodImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        return listallImports;\n    }\n\n    @java.lang.Override\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (element instanceof spoon.reflect.declaration.CtType) {\n            spoon.reflect.declaration.CtType simpleType = ((spoon.reflect.declaration.CtType) (element));\n            targetType = simpleType.getReference().getTopLevelType();\n            addClassImport(simpleType.getReference());\n            scan(simpleType);\n        } else {\n            spoon.reflect.declaration.CtType<?> type = element.getParent(spoon.reflect.declaration.CtType.class);\n            targetType = (type == null) ? null : type.getReference().getTopLevelType();\n            scan(element);\n        }\n    }\n\n    @java.lang.Override\n    public boolean isImported(spoon.reflect.reference.CtReference ref) {\n        if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            return isImportedInFieldImports(((spoon.reflect.reference.CtFieldReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            return isImportedInMethodImports(((spoon.reflect.reference.CtExecutableReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            return isImportedInClassImports(((spoon.reflect.reference.CtTypeReference) (ref)));\n        } else {\n            return false;\n        }\n    }\n\n    @java.lang.Override\n    public void initWithImports(java.util.Set<spoon.reflect.declaration.CtImport> importCollection) {\n        for (spoon.reflect.declaration.CtImport ctImport : importCollection) {\n            this.usedImport.put(ctImport, java.lang.Boolean.FALSE);\n        }\n    }\n\n    private boolean isThereAnotherClassWithSameNameInAnotherPackage(spoon.reflect.reference.CtTypeReference<?> ref) {\n        for (spoon.reflect.reference.CtTypeReference typeref : this.exploredReferences) {\n            if (typeref.getSimpleName().equals(ref.getSimpleName()) && (!typeref.getQualifiedName().equals(ref.getQualifiedName()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean addClassImport(spoon.reflect.reference.CtTypeReference<?> ref) {\n        this.exploredReferences.add(ref);\n        if (ref == null) {\n            return false;\n        }\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return false;\n        }\n        if (classImports.containsKey(ref.getSimpleName())) {\n            return isImportedInClassImports(ref);\n        }\n        if ((ref.getPackage() == null) || ref.getPackage().isUnnamedPackage()) {\n            return false;\n        }\n        if ((targetType != null) && (targetType.canAccess(ref) == false)) {\n            return false;\n        }\n        if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n            return false;\n        }\n        if (targetType != null) {\n            try {\n                spoon.reflect.declaration.CtElement parent = ref.getParent();\n                if (parent != null) {\n                    parent = parent.getParent();\n                    if (parent != null) {\n                        if (((parent instanceof spoon.reflect.code.CtFieldAccess) || (parent instanceof spoon.reflect.declaration.CtExecutable)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                            spoon.reflect.reference.CtTypeReference declaringType;\n                            spoon.reflect.reference.CtReference reference;\n                            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n                            if (parent instanceof spoon.reflect.code.CtFieldAccess) {\n                                spoon.reflect.code.CtFieldAccess field = ((spoon.reflect.code.CtFieldAccess) (parent));\n                                spoon.reflect.reference.CtFieldReference localReference = field.getVariable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.declaration.CtExecutable) {\n                                spoon.reflect.declaration.CtExecutable exec = ((spoon.reflect.declaration.CtExecutable) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = exec.getReference();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.code.CtInvocation) {\n                                spoon.reflect.code.CtInvocation invo = ((spoon.reflect.code.CtInvocation) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = invo.getExecutable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else {\n                                declaringType = null;\n                                reference = null;\n                            }\n                            if ((reference != null) && isImported(reference)) {\n                                if (declaringType != null) {\n                                    if ((declaringType.getPackage() != null) && (!declaringType.getPackage().isUnnamedPackage())) {\n                                        if (!\"java.lang\".equals(declaringType.getPackage().getSimpleName())) {\n                                            if (declaringType.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                                                classImports.put(ref.getSimpleName(), ref);\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            }\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    return false;\n                } else if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                    return false;\n                }\n            }\n        }\n        classImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    private boolean setImportUsed(spoon.reflect.declaration.CtImport ctImport) {\n        this.usedImport.put(ctImport, true);\n        return true;\n    }\n\n    private boolean isAlreadyInUsedImport(spoon.reflect.reference.CtReference ref) {\n        java.lang.String refQualifiedName = \"\";\n        spoon.reflect.reference.CtTypeReference refDeclaringType = null;\n        boolean isTypeRef = false;\n        boolean isExecRef = false;\n        boolean isFieldRef = false;\n        if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            refQualifiedName = ((spoon.reflect.reference.CtTypeReference) (ref)).getQualifiedName();\n            isTypeRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtExecutableReference) (ref)).getDeclaringType();\n            isExecRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtFieldReference) (ref)).getDeclaringType();\n            refQualifiedName = ((spoon.reflect.reference.CtFieldReference) (ref)).getQualifiedName();\n            isFieldRef = true;\n        }\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case METHOD :\n                    if (isExecRef) {\n                        spoon.reflect.reference.CtExecutableReference execRef = ((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference()));\n                        spoon.reflect.reference.CtTypeReference declaringType = execRef.getDeclaringType();\n                        if ((execRef.getSimpleName().equals(ref.getSimpleName()) && (declaringType != null)) && declaringType.equals(refDeclaringType)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case FIELD :\n                    if (isFieldRef) {\n                        spoon.reflect.reference.CtFieldReference importFieldRef = ((spoon.reflect.reference.CtFieldReference) (ctImport.getReference()));\n                        if (importFieldRef.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_STATIC_MEMBERS :\n                    if ((isExecRef || isFieldRef) && (refDeclaringType != null)) {\n                        java.lang.String qualifiedName = refDeclaringType.getQualifiedName();\n                        spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl importRef = ((spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl) (ctImport.getReference()));\n                        java.lang.String importRefStr = importRef.getQualifiedName();\n                        importRefStr = importRefStr.substring(0, importRefStr.lastIndexOf('.'));\n                        if (qualifiedName.equals(importRefStr)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case TYPE :\n                    if (isTypeRef) {\n                        spoon.reflect.reference.CtTypeReference typeReference = ((spoon.reflect.reference.CtTypeReference) (ctImport.getReference()));\n                        if (typeReference.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_TYPES :\n                    if (isTypeRef) {\n                        java.lang.String typeImportQualifiedName = ctImport.getReference().getSimpleName();\n                        if (refQualifiedName.equals(typeImportQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n        return false;\n    }\n\n    protected boolean isImportedInClassImports(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if (targetType != null) {\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (!\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                        return true;\n                    }\n                }\n            }\n        }\n        if (ref.equals(targetType)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && classImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtTypeReference<?> exist = classImports.get(ref.getSimpleName());\n            return exist.getQualifiedName().equals(ref.getQualifiedName());\n        }\n        return false;\n    }\n\n    private boolean declaringTypeIsLocalOrImported(spoon.reflect.reference.CtTypeReference declaringType) {\n        if (declaringType != null) {\n            boolean isInCollision = isTypeInCollision(declaringType, false);\n            if (!isInCollision) {\n                boolean importSuccess = addClassImport(declaringType);\n                if (importSuccess) {\n                    return true;\n                }\n            }\n            boolean importedInClassImports = isImportedInClassImports(declaringType);\n            boolean inJavaLang = classNamePresentInJavaLang(declaringType);\n            if (importedInClassImports || inJavaLang) {\n                return true;\n            }\n            while (declaringType != null) {\n                if (declaringType.equals(targetType)) {\n                    return true;\n                }\n                declaringType = declaringType.getDeclaringType();\n            } \n        }\n        return false;\n    }\n\n    private boolean isInCollisionWithLocalMethod(spoon.reflect.reference.CtExecutableReference ref) {\n        spoon.reflect.declaration.CtType<?> typeDecl = ref.getParent(spoon.reflect.declaration.CtType.class);\n        if (typeDecl != null) {\n            java.lang.String methodName = ref.getSimpleName();\n            for (spoon.reflect.declaration.CtMethod<?> method : typeDecl.getAllMethods()) {\n                if (method.getSimpleName().equals(methodName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    protected boolean addMethodImport(spoon.reflect.reference.CtExecutableReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.isImportedInMethodImports(ref)) {\n            return true;\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        if (this.isInCollisionWithLocalMethod(ref)) {\n            return false;\n        }\n        methodImports.put(ref.getSimpleName(), ref);\n        if (ref.getDeclaringType() != null) {\n            if (ref.getDeclaringType().getPackage() != null) {\n                if (ref.getDeclaringType().getPackage().equals(this.targetType.getPackage())) {\n                    addClassImport(ref.getDeclaringType());\n                }\n            }\n        }\n        return true;\n    }\n\n    protected boolean isImportedInMethodImports(spoon.reflect.reference.CtExecutableReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && methodImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtExecutableReference<?> exist = methodImports.get(ref.getSimpleName());\n            return getSignature(exist).equals(getSignature(ref));\n        }\n        return false;\n    }\n\n    private java.lang.String getSignature(spoon.reflect.reference.CtExecutableReference<?> exist) {\n        return ((exist.getDeclaringType() != null ? exist.getDeclaringType().getQualifiedName() : \"\") + \".\") + exist.getSignature();\n    }\n\n    protected boolean addFieldImport(spoon.reflect.reference.CtFieldReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.fieldImports.containsKey(ref.getSimpleName())) {\n            return isImportedInFieldImports(ref);\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        fieldImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    protected boolean isImportedInFieldImports(spoon.reflect.reference.CtFieldReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && fieldImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtFieldReference<?> exist = fieldImports.get(ref.getSimpleName());\n            try {\n                if ((exist.getFieldDeclaration() != null) && exist.getFieldDeclaration().equals(ref.getFieldDeclaration())) {\n                    return true;\n                }\n            } catch (spoon.support.SpoonClassNotFoundException notfound) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    protected boolean classNamePresentInJavaLang(spoon.reflect.reference.CtTypeReference<?> ref) {\n        java.lang.Boolean presentInJavaLang = namesPresentInJavaLang.get(ref.getSimpleName());\n        if (presentInJavaLang == null) {\n            if (spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang8.contains(ref.getSimpleName()) || spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang9.contains(ref.getSimpleName())) {\n                presentInJavaLang = true;\n            } else {\n                try {\n                    java.lang.Class.forName(\"java.lang.\" + ref.getSimpleName());\n                    presentInJavaLang = true;\n                } catch (java.lang.NoClassDefFoundError | java.lang.ClassNotFoundException e) {\n                    presentInJavaLang = false;\n                }\n            }\n            namesPresentInJavaLang.put(ref.getSimpleName(), presentInJavaLang);\n        }\n        return presentInJavaLang;\n    }\n\n    protected java.util.Set<java.lang.String> lookForLocalVariables(spoon.reflect.declaration.CtElement parent) {\n        java.util.Set<java.lang.String> result = new java.util.HashSet<>();\n        while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n            if (parent instanceof spoon.reflect.declaration.CtClass) {\n                return result;\n            }\n            parent = parent.getParent();\n        } \n        if (parent != null) {\n            spoon.reflect.code.CtBlock block = ((spoon.reflect.code.CtBlock) (parent));\n            boolean innerClass = false;\n            while ((parent != null) && (!(parent instanceof spoon.reflect.declaration.CtClass))) {\n                parent = parent.getParent();\n            } \n            if (parent != null) {\n                if (!(parent.getParent() instanceof spoon.reflect.declaration.CtPackage)) {\n                    while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n                        parent = parent.getParent();\n                    } \n                    if (parent != null) {\n                        block = ((spoon.reflect.code.CtBlock) (parent));\n                    }\n                }\n            }\n            spoon.reflect.visitor.AccessibleVariablesFinder avf = new spoon.reflect.visitor.AccessibleVariablesFinder(block);\n            java.util.List<spoon.reflect.declaration.CtVariable> variables = avf.find();\n            for (spoon.reflect.declaration.CtVariable variable : variables) {\n                result.add(variable.getSimpleName());\n            }\n        }\n        return result;\n    }\n\n    protected boolean isTypeInCollision(spoon.reflect.reference.CtReference ref, boolean fqnMode) {\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return true;\n        }\n        try {\n            spoon.reflect.declaration.CtElement parent;\n            if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                parent = ref.getParent();\n            } else {\n                parent = ref;\n            }\n            if (parent instanceof spoon.reflect.code.CtLiteral) {\n                return false;\n            }\n            java.util.Set<java.lang.String> localVariablesOfBlock = new java.util.HashSet<>();\n            if (parent instanceof spoon.reflect.declaration.CtField) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtField) (parent)).getSimpleName());\n            } else if (parent instanceof spoon.reflect.declaration.CtMethod) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtMethod) (parent)).getSimpleName());\n            } else {\n                localVariablesOfBlock = this.lookForLocalVariables(parent);\n            }\n            while (!(parent instanceof spoon.reflect.declaration.CtPackage)) {\n                if (((parent instanceof spoon.reflect.reference.CtFieldReference) || (parent instanceof spoon.reflect.reference.CtExecutableReference)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                    spoon.reflect.reference.CtReference parentType;\n                    if (parent instanceof spoon.reflect.code.CtInvocation) {\n                        parentType = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable();\n                    } else {\n                        parentType = ((spoon.reflect.reference.CtReference) (parent));\n                    }\n                    java.util.LinkedList<java.lang.String> qualifiedNameTokens = new java.util.LinkedList<>();\n                    if (parentType != parent) {\n                        qualifiedNameTokens.add(parentType.getSimpleName());\n                    }\n                    spoon.reflect.reference.CtTypeReference typeReference;\n                    if (parent instanceof spoon.reflect.reference.CtFieldReference) {\n                        typeReference = ((spoon.reflect.reference.CtFieldReference) (parent)).getDeclaringType();\n                    } else if (parent instanceof spoon.reflect.reference.CtExecutableReference) {\n                        typeReference = ((spoon.reflect.reference.CtExecutableReference) (parent)).getDeclaringType();\n                    } else {\n                        typeReference = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable().getDeclaringType();\n                    }\n                    if (typeReference != null) {\n                        qualifiedNameTokens.addFirst(typeReference.getSimpleName());\n                        if (typeReference.getPackage() != null) {\n                            java.util.StringTokenizer token = new java.util.StringTokenizer(typeReference.getPackage().getSimpleName(), spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                            int index = 0;\n                            while (token.hasMoreElements()) {\n                                qualifiedNameTokens.add(index, token.nextToken());\n                                index++;\n                            } \n                        }\n                    }\n                    if (!qualifiedNameTokens.isEmpty()) {\n                        if (fieldAndMethodsNames.contains(qualifiedNameTokens.getFirst()) || localVariablesOfBlock.contains(qualifiedNameTokens.getFirst())) {\n                            qualifiedNameTokens.removeFirst();\n                            if (fqnMode) {\n                                if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                                    if (qualifiedNameTokens.isEmpty()) {\n                                        return true;\n                                    }\n                                    for (java.lang.String testedToken : qualifiedNameTokens) {\n                                        if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                            return true;\n                                        }\n                                    }\n                                    return false;\n                                } else {\n                                    return true;\n                                }\n                            } else {\n                                for (java.lang.String testedToken : qualifiedNameTokens) {\n                                    if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                        }\n                    }\n                }\n                parent = parent.getParent();\n            } \n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private static java.util.regex.Pattern tagRE = java.util.regex.Pattern.compile(\"(\\\\{)?@(\\\\w+)\\\\s+([\\\\w\\\\.\\\\$]+)(?:#(\\\\w+)(?:\\\\(([^\\\\)]*)\\\\)))?\");",
            "src_parent": "public class ImportScannerImpl extends spoon.reflect.visitor.CtScanner implements spoon.reflect.visitor.ImportScanner {\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang8 = java.util.Collections.singletonList(\"FunctionalInterface\");\n\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang9 = java.util.Arrays.asList(\"ProcessHandle\", \"StackWalker\", \"StackFramePermission\");\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtTypeReference<?>> classImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtFieldReference<?>> fieldImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtExecutableReference<?>> methodImports = new java.util.TreeMap<>();\n\n    protected spoon.reflect.reference.CtTypeReference<?> targetType;\n\n    private java.util.Map<java.lang.String, java.lang.Boolean> namesPresentInJavaLang = new java.util.HashMap<>();\n\n    private java.util.Set<java.lang.String> fieldAndMethodsNames = new java.util.HashSet<>();\n\n    private java.util.Set<spoon.reflect.reference.CtTypeReference> exploredReferences = new java.util.HashSet<>();\n\n    private java.util.Map<spoon.reflect.declaration.CtImport, java.lang.Boolean> usedImport = new java.util.HashMap<>();\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        enter(fieldRead);\n        scan(fieldRead.getAnnotations());\n        scan(fieldRead.getTypeCasts());\n        scan(fieldRead.getVariable());\n        scan(fieldRead.getTarget());\n        exit(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        enter(reference);\n        scan(reference.getDeclaringType());\n        if (reference.isStatic()) {\n            addFieldImport(reference);\n        } else {\n            scan(reference.getDeclaringType());\n        }\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        enter(reference);\n        if (reference.isStatic()) {\n            addMethodImport(reference);\n        } else if (reference.isConstructor()) {\n            scan(reference.getDeclaringType());\n        }\n        scan(reference.getActualTypeArguments());\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (!(reference instanceof spoon.reflect.reference.CtArrayTypeReference)) {\n            spoon.reflect.reference.CtTypeReference typeReference;\n            if (reference.getDeclaringType() == null) {\n                typeReference = reference;\n            } else {\n                typeReference = reference.getAccessType();\n            }\n            if (!typeReference.equals(reference)) {\n                if (this.isAlreadyInUsedImport(reference)) {\n                    super.visitCtTypeReference(reference);\n                    return;\n                }\n            }\n            if (!this.isTypeInCollision(typeReference, false)) {\n                this.addClassImport(typeReference);\n            }\n        }\n        super.visitCtTypeReference(reference);\n    }\n\n    @java.lang.Override\n    public void scan(spoon.reflect.declaration.CtElement element) {\n        if (element != null) {\n            element.accept(this);\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc ctJavaDoc) {\n        java.lang.StringBuilder stringBuilder = new java.lang.StringBuilder();\n        stringBuilder.append(ctJavaDoc.getContent());\n        for (spoon.reflect.code.CtJavaDocTag ctJavaDocTag : ctJavaDoc.getTags()) {\n            stringBuilder.append(\"\\n\").append(ctJavaDocTag.getType()).append(\" \").append(ctJavaDocTag.getContent());\n        }\n        java.lang.String javadoc = stringBuilder.toString();\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case TYPE :\n                    if (javadoc.contains(ctImport.getReference().getSimpleName()) && (ctImport.getReference() instanceof spoon.reflect.reference.CtTypeReference)) {\n                        if (matchesTypeName(javadoc, ((spoon.reflect.reference.CtTypeReference<?>) (ctImport.getReference())))) {\n                            this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n    private static java.util.Set<java.lang.String> mainTags = new java.util.HashSet<>(java.util.Arrays.asList(\"see\", \"throws\", \"exception\"));\n\n    private static java.util.Set<java.lang.String> inlineTags = new java.util.HashSet<>(java.util.Arrays.asList(\"link\", \"linkplain\", \"value\"));\n\n    private static java.util.regex.Pattern tagRE = java.util.regex.Pattern.compile(\"(\\\\{)?@(\\\\w+)\\\\s+([\\\\w\\\\.\\\\$]+)(?:#(\\\\w+)(?:\\\\(([^\\\\)]*)\\\\)))?\");\n\n    private boolean matchesTypeName(java.lang.String javadoc, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        java.util.regex.Matcher m = spoon.reflect.visitor.ImportScannerImpl.tagRE.matcher(javadoc);\n        while (m.find()) {\n            java.lang.String bracket = m.group(1);\n            java.lang.String tag = m.group(2);\n            if (\"{\".equals(bracket)) {\n                if (spoon.reflect.visitor.ImportScannerImpl.inlineTags.contains(tag) == false) {\n                    continue;\n                }\n            } else if (spoon.reflect.visitor.ImportScannerImpl.mainTags.contains(tag) == false) {\n                continue;\n            }\n            java.lang.String type = m.group(3);\n            java.lang.String params = m.group(5);\n            if (isTypeMatching(type, typeRef)) {\n                return true;\n            }\n            if (params != null) {\n                java.lang.String[] paramTypes = params.split(\"\\\\s*,\\\\s*\");\n                for (java.lang.String paramType : paramTypes) {\n                    if (isTypeMatching(paramType, typeRef)) {\n                        return true;\n                    }\n                }\n            }\n        } \n        return false;\n    }\n\n    private boolean isTypeMatching(java.lang.String typeName, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        if (typeName != null) {\n            if (typeName.equals(typeRef.getQualifiedName())) {\n                return true;\n            }\n            if (typeName.equals(typeRef.getSimpleName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        addClassImport(annotationType.getReference());\n        super.visitCtAnnotationType(annotationType);\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        addClassImport(ctEnum.getReference());\n        super.visitCtEnum(ctEnum);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        addClassImport(intrface.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : intrface.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtInterface(intrface);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        addClassImport(ctClass.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : ctClass.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtClass(ctClass);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        for (spoon.reflect.reference.CtTypeReference<?> type : catchVariable.getMultiTypes()) {\n            addClassImport(type);\n        }\n        super.visitCtCatchVariable(catchVariable);\n    }\n\n    @java.lang.Override\n    public void visitCtInvocation(spoon.reflect.code.CtInvocation invocation) {\n        this.scan(invocation.getTypeCasts());\n        this.scan(invocation.getExecutable());\n        if (!this.isImportedInMethodImports(invocation.getExecutable())) {\n            this.scan(invocation.getTarget());\n        }\n        this.scan(invocation.getArguments());\n    }\n\n    @java.lang.Override\n    public java.util.Set<spoon.reflect.declaration.CtImport> getAllImports() {\n        java.util.Set<spoon.reflect.declaration.CtImport> listallImports = new java.util.HashSet<>();\n        for (java.util.Map.Entry<spoon.reflect.declaration.CtImport, java.lang.Boolean> entry : this.usedImport.entrySet()) {\n            if (entry.getValue()) {\n                listallImports.add(entry.getKey());\n            }\n        }\n        for (spoon.reflect.reference.CtReference reference : this.classImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.fieldImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.methodImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        return listallImports;\n    }\n\n    @java.lang.Override\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (element instanceof spoon.reflect.declaration.CtType) {\n            spoon.reflect.declaration.CtType simpleType = ((spoon.reflect.declaration.CtType) (element));\n            targetType = simpleType.getReference().getTopLevelType();\n            addClassImport(simpleType.getReference());\n            scan(simpleType);\n        } else {\n            spoon.reflect.declaration.CtType<?> type = element.getParent(spoon.reflect.declaration.CtType.class);\n            targetType = (type == null) ? null : type.getReference().getTopLevelType();\n            scan(element);\n        }\n    }\n\n    @java.lang.Override\n    public boolean isImported(spoon.reflect.reference.CtReference ref) {\n        if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            return isImportedInFieldImports(((spoon.reflect.reference.CtFieldReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            return isImportedInMethodImports(((spoon.reflect.reference.CtExecutableReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            return isImportedInClassImports(((spoon.reflect.reference.CtTypeReference) (ref)));\n        } else {\n            return false;\n        }\n    }\n\n    @java.lang.Override\n    public void initWithImports(java.util.Set<spoon.reflect.declaration.CtImport> importCollection) {\n        for (spoon.reflect.declaration.CtImport ctImport : importCollection) {\n            this.usedImport.put(ctImport, java.lang.Boolean.FALSE);\n        }\n    }\n\n    private boolean isThereAnotherClassWithSameNameInAnotherPackage(spoon.reflect.reference.CtTypeReference<?> ref) {\n        for (spoon.reflect.reference.CtTypeReference typeref : this.exploredReferences) {\n            if (typeref.getSimpleName().equals(ref.getSimpleName()) && (!typeref.getQualifiedName().equals(ref.getQualifiedName()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean addClassImport(spoon.reflect.reference.CtTypeReference<?> ref) {\n        this.exploredReferences.add(ref);\n        if (ref == null) {\n            return false;\n        }\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return false;\n        }\n        if (classImports.containsKey(ref.getSimpleName())) {\n            return isImportedInClassImports(ref);\n        }\n        if ((ref.getPackage() == null) || ref.getPackage().isUnnamedPackage()) {\n            return false;\n        }\n        if ((targetType != null) && (targetType.canAccess(ref) == false)) {\n            return false;\n        }\n        if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n            return false;\n        }\n        if (targetType != null) {\n            try {\n                spoon.reflect.declaration.CtElement parent = ref.getParent();\n                if (parent != null) {\n                    parent = parent.getParent();\n                    if (parent != null) {\n                        if (((parent instanceof spoon.reflect.code.CtFieldAccess) || (parent instanceof spoon.reflect.declaration.CtExecutable)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                            spoon.reflect.reference.CtTypeReference declaringType;\n                            spoon.reflect.reference.CtReference reference;\n                            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n                            if (parent instanceof spoon.reflect.code.CtFieldAccess) {\n                                spoon.reflect.code.CtFieldAccess field = ((spoon.reflect.code.CtFieldAccess) (parent));\n                                spoon.reflect.reference.CtFieldReference localReference = field.getVariable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.declaration.CtExecutable) {\n                                spoon.reflect.declaration.CtExecutable exec = ((spoon.reflect.declaration.CtExecutable) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = exec.getReference();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.code.CtInvocation) {\n                                spoon.reflect.code.CtInvocation invo = ((spoon.reflect.code.CtInvocation) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = invo.getExecutable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else {\n                                declaringType = null;\n                                reference = null;\n                            }\n                            if ((reference != null) && isImported(reference)) {\n                                if (declaringType != null) {\n                                    if ((declaringType.getPackage() != null) && (!declaringType.getPackage().isUnnamedPackage())) {\n                                        if (!\"java.lang\".equals(declaringType.getPackage().getSimpleName())) {\n                                            if (declaringType.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                                                classImports.put(ref.getSimpleName(), ref);\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            }\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    return false;\n                } else if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                    return false;\n                }\n            }\n        }\n        classImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    private boolean setImportUsed(spoon.reflect.declaration.CtImport ctImport) {\n        this.usedImport.put(ctImport, true);\n        return true;\n    }\n\n    private boolean isAlreadyInUsedImport(spoon.reflect.reference.CtReference ref) {\n        java.lang.String refQualifiedName = \"\";\n        spoon.reflect.reference.CtTypeReference refDeclaringType = null;\n        boolean isTypeRef = false;\n        boolean isExecRef = false;\n        boolean isFieldRef = false;\n        if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            refQualifiedName = ((spoon.reflect.reference.CtTypeReference) (ref)).getQualifiedName();\n            isTypeRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtExecutableReference) (ref)).getDeclaringType();\n            isExecRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtFieldReference) (ref)).getDeclaringType();\n            refQualifiedName = ((spoon.reflect.reference.CtFieldReference) (ref)).getQualifiedName();\n            isFieldRef = true;\n        }\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case METHOD :\n                    if (isExecRef) {\n                        spoon.reflect.reference.CtExecutableReference execRef = ((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference()));\n                        spoon.reflect.reference.CtTypeReference declaringType = execRef.getDeclaringType();\n                        if ((execRef.getSimpleName().equals(ref.getSimpleName()) && (declaringType != null)) && declaringType.equals(refDeclaringType)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case FIELD :\n                    if (isFieldRef) {\n                        spoon.reflect.reference.CtFieldReference importFieldRef = ((spoon.reflect.reference.CtFieldReference) (ctImport.getReference()));\n                        if (importFieldRef.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_STATIC_MEMBERS :\n                    if ((isExecRef || isFieldRef) && (refDeclaringType != null)) {\n                        java.lang.String qualifiedName = refDeclaringType.getQualifiedName();\n                        spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl importRef = ((spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl) (ctImport.getReference()));\n                        java.lang.String importRefStr = importRef.getQualifiedName();\n                        importRefStr = importRefStr.substring(0, importRefStr.lastIndexOf('.'));\n                        if (qualifiedName.equals(importRefStr)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case TYPE :\n                    if (isTypeRef) {\n                        spoon.reflect.reference.CtTypeReference typeReference = ((spoon.reflect.reference.CtTypeReference) (ctImport.getReference()));\n                        if (typeReference.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_TYPES :\n                    if (isTypeRef) {\n                        java.lang.String typeImportQualifiedName = ctImport.getReference().getSimpleName();\n                        if (refQualifiedName.equals(typeImportQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n        return false;\n    }\n\n    protected boolean isImportedInClassImports(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if (targetType != null) {\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (!\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                        return true;\n                    }\n                }\n            }\n        }\n        if (ref.equals(targetType)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && classImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtTypeReference<?> exist = classImports.get(ref.getSimpleName());\n            return exist.getQualifiedName().equals(ref.getQualifiedName());\n        }\n        return false;\n    }\n\n    private boolean declaringTypeIsLocalOrImported(spoon.reflect.reference.CtTypeReference declaringType) {\n        if (declaringType != null) {\n            boolean isInCollision = isTypeInCollision(declaringType, false);\n            if (!isInCollision) {\n                boolean importSuccess = addClassImport(declaringType);\n                if (importSuccess) {\n                    return true;\n                }\n            }\n            boolean importedInClassImports = isImportedInClassImports(declaringType);\n            boolean inJavaLang = classNamePresentInJavaLang(declaringType);\n            if (importedInClassImports || inJavaLang) {\n                return true;\n            }\n            while (declaringType != null) {\n                if (declaringType.equals(targetType)) {\n                    return true;\n                }\n                declaringType = declaringType.getDeclaringType();\n            } \n        }\n        return false;\n    }\n\n    private boolean isInCollisionWithLocalMethod(spoon.reflect.reference.CtExecutableReference ref) {\n        spoon.reflect.declaration.CtType<?> typeDecl = ref.getParent(spoon.reflect.declaration.CtType.class);\n        if (typeDecl != null) {\n            java.lang.String methodName = ref.getSimpleName();\n            for (spoon.reflect.declaration.CtMethod<?> method : typeDecl.getAllMethods()) {\n                if (method.getSimpleName().equals(methodName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    protected boolean addMethodImport(spoon.reflect.reference.CtExecutableReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.isImportedInMethodImports(ref)) {\n            return true;\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        if (this.isInCollisionWithLocalMethod(ref)) {\n            return false;\n        }\n        methodImports.put(ref.getSimpleName(), ref);\n        if (ref.getDeclaringType() != null) {\n            if (ref.getDeclaringType().getPackage() != null) {\n                if (ref.getDeclaringType().getPackage().equals(this.targetType.getPackage())) {\n                    addClassImport(ref.getDeclaringType());\n                }\n            }\n        }\n        return true;\n    }\n\n    protected boolean isImportedInMethodImports(spoon.reflect.reference.CtExecutableReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && methodImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtExecutableReference<?> exist = methodImports.get(ref.getSimpleName());\n            return getSignature(exist).equals(getSignature(ref));\n        }\n        return false;\n    }\n\n    private java.lang.String getSignature(spoon.reflect.reference.CtExecutableReference<?> exist) {\n        return ((exist.getDeclaringType() != null ? exist.getDeclaringType().getQualifiedName() : \"\") + \".\") + exist.getSignature();\n    }\n\n    protected boolean addFieldImport(spoon.reflect.reference.CtFieldReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.fieldImports.containsKey(ref.getSimpleName())) {\n            return isImportedInFieldImports(ref);\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        fieldImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    protected boolean isImportedInFieldImports(spoon.reflect.reference.CtFieldReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && fieldImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtFieldReference<?> exist = fieldImports.get(ref.getSimpleName());\n            try {\n                if ((exist.getFieldDeclaration() != null) && exist.getFieldDeclaration().equals(ref.getFieldDeclaration())) {\n                    return true;\n                }\n            } catch (spoon.support.SpoonClassNotFoundException notfound) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    protected boolean classNamePresentInJavaLang(spoon.reflect.reference.CtTypeReference<?> ref) {\n        java.lang.Boolean presentInJavaLang = namesPresentInJavaLang.get(ref.getSimpleName());\n        if (presentInJavaLang == null) {\n            if (spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang8.contains(ref.getSimpleName()) || spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang9.contains(ref.getSimpleName())) {\n                presentInJavaLang = true;\n            } else {\n                try {\n                    java.lang.Class.forName(\"java.lang.\" + ref.getSimpleName());\n                    presentInJavaLang = true;\n                } catch (java.lang.NoClassDefFoundError | java.lang.ClassNotFoundException e) {\n                    presentInJavaLang = false;\n                }\n            }\n            namesPresentInJavaLang.put(ref.getSimpleName(), presentInJavaLang);\n        }\n        return presentInJavaLang;\n    }\n\n    protected java.util.Set<java.lang.String> lookForLocalVariables(spoon.reflect.declaration.CtElement parent) {\n        java.util.Set<java.lang.String> result = new java.util.HashSet<>();\n        while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n            if (parent instanceof spoon.reflect.declaration.CtClass) {\n                return result;\n            }\n            parent = parent.getParent();\n        } \n        if (parent != null) {\n            spoon.reflect.code.CtBlock block = ((spoon.reflect.code.CtBlock) (parent));\n            boolean innerClass = false;\n            while ((parent != null) && (!(parent instanceof spoon.reflect.declaration.CtClass))) {\n                parent = parent.getParent();\n            } \n            if (parent != null) {\n                if (!(parent.getParent() instanceof spoon.reflect.declaration.CtPackage)) {\n                    while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n                        parent = parent.getParent();\n                    } \n                    if (parent != null) {\n                        block = ((spoon.reflect.code.CtBlock) (parent));\n                    }\n                }\n            }\n            spoon.reflect.visitor.AccessibleVariablesFinder avf = new spoon.reflect.visitor.AccessibleVariablesFinder(block);\n            java.util.List<spoon.reflect.declaration.CtVariable> variables = avf.find();\n            for (spoon.reflect.declaration.CtVariable variable : variables) {\n                result.add(variable.getSimpleName());\n            }\n        }\n        return result;\n    }\n\n    protected boolean isTypeInCollision(spoon.reflect.reference.CtReference ref, boolean fqnMode) {\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return true;\n        }\n        try {\n            spoon.reflect.declaration.CtElement parent;\n            if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                parent = ref.getParent();\n            } else {\n                parent = ref;\n            }\n            if (parent instanceof spoon.reflect.code.CtLiteral) {\n                return false;\n            }\n            java.util.Set<java.lang.String> localVariablesOfBlock = new java.util.HashSet<>();\n            if (parent instanceof spoon.reflect.declaration.CtField) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtField) (parent)).getSimpleName());\n            } else if (parent instanceof spoon.reflect.declaration.CtMethod) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtMethod) (parent)).getSimpleName());\n            } else {\n                localVariablesOfBlock = this.lookForLocalVariables(parent);\n            }\n            while (!(parent instanceof spoon.reflect.declaration.CtPackage)) {\n                if (((parent instanceof spoon.reflect.reference.CtFieldReference) || (parent instanceof spoon.reflect.reference.CtExecutableReference)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                    spoon.reflect.reference.CtReference parentType;\n                    if (parent instanceof spoon.reflect.code.CtInvocation) {\n                        parentType = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable();\n                    } else {\n                        parentType = ((spoon.reflect.reference.CtReference) (parent));\n                    }\n                    java.util.LinkedList<java.lang.String> qualifiedNameTokens = new java.util.LinkedList<>();\n                    if (parentType != parent) {\n                        qualifiedNameTokens.add(parentType.getSimpleName());\n                    }\n                    spoon.reflect.reference.CtTypeReference typeReference;\n                    if (parent instanceof spoon.reflect.reference.CtFieldReference) {\n                        typeReference = ((spoon.reflect.reference.CtFieldReference) (parent)).getDeclaringType();\n                    } else if (parent instanceof spoon.reflect.reference.CtExecutableReference) {\n                        typeReference = ((spoon.reflect.reference.CtExecutableReference) (parent)).getDeclaringType();\n                    } else {\n                        typeReference = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable().getDeclaringType();\n                    }\n                    if (typeReference != null) {\n                        qualifiedNameTokens.addFirst(typeReference.getSimpleName());\n                        if (typeReference.getPackage() != null) {\n                            java.util.StringTokenizer token = new java.util.StringTokenizer(typeReference.getPackage().getSimpleName(), spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                            int index = 0;\n                            while (token.hasMoreElements()) {\n                                qualifiedNameTokens.add(index, token.nextToken());\n                                index++;\n                            } \n                        }\n                    }\n                    if (!qualifiedNameTokens.isEmpty()) {\n                        if (fieldAndMethodsNames.contains(qualifiedNameTokens.getFirst()) || localVariablesOfBlock.contains(qualifiedNameTokens.getFirst())) {\n                            qualifiedNameTokens.removeFirst();\n                            if (fqnMode) {\n                                if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                                    if (qualifiedNameTokens.isEmpty()) {\n                                        return true;\n                                    }\n                                    for (java.lang.String testedToken : qualifiedNameTokens) {\n                                        if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                            return true;\n                                        }\n                                    }\n                                    return false;\n                                } else {\n                                    return true;\n                                }\n                            } else {\n                                for (java.lang.String testedToken : qualifiedNameTokens) {\n                                    if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                        }\n                    }\n                }\n                parent = parent.getParent();\n            } \n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Field"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean matchesTypeName(java.lang.String javadoc, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n    java.util.regex.Matcher m = spoon.reflect.visitor.ImportScannerImpl.tagRE.matcher(javadoc);\n    while (m.find()) {\n        java.lang.String bracket = m.group(1);\n        java.lang.String tag = m.group(2);\n        if (\"{\".equals(bracket)) {\n            if (spoon.reflect.visitor.ImportScannerImpl.inlineTags.contains(tag) == false) {\n                continue;\n            }\n        } else if (spoon.reflect.visitor.ImportScannerImpl.mainTags.contains(tag) == false) {\n            continue;\n        }\n        java.lang.String type = m.group(3);\n        java.lang.String params = m.group(5);\n        if (isTypeMatching(type, typeRef)) {\n            return true;\n        }\n        if (params != null) {\n            java.lang.String[] paramTypes = params.split(\"\\\\s*,\\\\s*\");\n            for (java.lang.String paramType : paramTypes) {\n                if (isTypeMatching(paramType, typeRef)) {\n                    return true;\n                }\n            }\n        }\n    } \n    return false;\n}",
            "src_parent": "public class ImportScannerImpl extends spoon.reflect.visitor.CtScanner implements spoon.reflect.visitor.ImportScanner {\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang8 = java.util.Collections.singletonList(\"FunctionalInterface\");\n\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang9 = java.util.Arrays.asList(\"ProcessHandle\", \"StackWalker\", \"StackFramePermission\");\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtTypeReference<?>> classImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtFieldReference<?>> fieldImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtExecutableReference<?>> methodImports = new java.util.TreeMap<>();\n\n    protected spoon.reflect.reference.CtTypeReference<?> targetType;\n\n    private java.util.Map<java.lang.String, java.lang.Boolean> namesPresentInJavaLang = new java.util.HashMap<>();\n\n    private java.util.Set<java.lang.String> fieldAndMethodsNames = new java.util.HashSet<>();\n\n    private java.util.Set<spoon.reflect.reference.CtTypeReference> exploredReferences = new java.util.HashSet<>();\n\n    private java.util.Map<spoon.reflect.declaration.CtImport, java.lang.Boolean> usedImport = new java.util.HashMap<>();\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        enter(fieldRead);\n        scan(fieldRead.getAnnotations());\n        scan(fieldRead.getTypeCasts());\n        scan(fieldRead.getVariable());\n        scan(fieldRead.getTarget());\n        exit(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        enter(reference);\n        scan(reference.getDeclaringType());\n        if (reference.isStatic()) {\n            addFieldImport(reference);\n        } else {\n            scan(reference.getDeclaringType());\n        }\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        enter(reference);\n        if (reference.isStatic()) {\n            addMethodImport(reference);\n        } else if (reference.isConstructor()) {\n            scan(reference.getDeclaringType());\n        }\n        scan(reference.getActualTypeArguments());\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (!(reference instanceof spoon.reflect.reference.CtArrayTypeReference)) {\n            spoon.reflect.reference.CtTypeReference typeReference;\n            if (reference.getDeclaringType() == null) {\n                typeReference = reference;\n            } else {\n                typeReference = reference.getAccessType();\n            }\n            if (!typeReference.equals(reference)) {\n                if (this.isAlreadyInUsedImport(reference)) {\n                    super.visitCtTypeReference(reference);\n                    return;\n                }\n            }\n            if (!this.isTypeInCollision(typeReference, false)) {\n                this.addClassImport(typeReference);\n            }\n        }\n        super.visitCtTypeReference(reference);\n    }\n\n    @java.lang.Override\n    public void scan(spoon.reflect.declaration.CtElement element) {\n        if (element != null) {\n            element.accept(this);\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc ctJavaDoc) {\n        java.lang.StringBuilder stringBuilder = new java.lang.StringBuilder();\n        stringBuilder.append(ctJavaDoc.getContent());\n        for (spoon.reflect.code.CtJavaDocTag ctJavaDocTag : ctJavaDoc.getTags()) {\n            stringBuilder.append(\"\\n\").append(ctJavaDocTag.getType()).append(\" \").append(ctJavaDocTag.getContent());\n        }\n        java.lang.String javadoc = stringBuilder.toString();\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case TYPE :\n                    if (javadoc.contains(ctImport.getReference().getSimpleName()) && (ctImport.getReference() instanceof spoon.reflect.reference.CtTypeReference)) {\n                        if (matchesTypeName(javadoc, ((spoon.reflect.reference.CtTypeReference<?>) (ctImport.getReference())))) {\n                            this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n    private static java.util.Set<java.lang.String> mainTags = new java.util.HashSet<>(java.util.Arrays.asList(\"see\", \"throws\", \"exception\"));\n\n    private static java.util.Set<java.lang.String> inlineTags = new java.util.HashSet<>(java.util.Arrays.asList(\"link\", \"linkplain\", \"value\"));\n\n    private static java.util.regex.Pattern tagRE = java.util.regex.Pattern.compile(\"(\\\\{)?@(\\\\w+)\\\\s+([\\\\w\\\\.\\\\$]+)(?:#(\\\\w+)(?:\\\\(([^\\\\)]*)\\\\)))?\");\n\n    private boolean matchesTypeName(java.lang.String javadoc, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        java.util.regex.Matcher m = spoon.reflect.visitor.ImportScannerImpl.tagRE.matcher(javadoc);\n        while (m.find()) {\n            java.lang.String bracket = m.group(1);\n            java.lang.String tag = m.group(2);\n            if (\"{\".equals(bracket)) {\n                if (spoon.reflect.visitor.ImportScannerImpl.inlineTags.contains(tag) == false) {\n                    continue;\n                }\n            } else if (spoon.reflect.visitor.ImportScannerImpl.mainTags.contains(tag) == false) {\n                continue;\n            }\n            java.lang.String type = m.group(3);\n            java.lang.String params = m.group(5);\n            if (isTypeMatching(type, typeRef)) {\n                return true;\n            }\n            if (params != null) {\n                java.lang.String[] paramTypes = params.split(\"\\\\s*,\\\\s*\");\n                for (java.lang.String paramType : paramTypes) {\n                    if (isTypeMatching(paramType, typeRef)) {\n                        return true;\n                    }\n                }\n            }\n        } \n        return false;\n    }\n\n    private boolean isTypeMatching(java.lang.String typeName, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        if (typeName != null) {\n            if (typeName.equals(typeRef.getQualifiedName())) {\n                return true;\n            }\n            if (typeName.equals(typeRef.getSimpleName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        addClassImport(annotationType.getReference());\n        super.visitCtAnnotationType(annotationType);\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        addClassImport(ctEnum.getReference());\n        super.visitCtEnum(ctEnum);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        addClassImport(intrface.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : intrface.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtInterface(intrface);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        addClassImport(ctClass.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : ctClass.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtClass(ctClass);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        for (spoon.reflect.reference.CtTypeReference<?> type : catchVariable.getMultiTypes()) {\n            addClassImport(type);\n        }\n        super.visitCtCatchVariable(catchVariable);\n    }\n\n    @java.lang.Override\n    public void visitCtInvocation(spoon.reflect.code.CtInvocation invocation) {\n        this.scan(invocation.getTypeCasts());\n        this.scan(invocation.getExecutable());\n        if (!this.isImportedInMethodImports(invocation.getExecutable())) {\n            this.scan(invocation.getTarget());\n        }\n        this.scan(invocation.getArguments());\n    }\n\n    @java.lang.Override\n    public java.util.Set<spoon.reflect.declaration.CtImport> getAllImports() {\n        java.util.Set<spoon.reflect.declaration.CtImport> listallImports = new java.util.HashSet<>();\n        for (java.util.Map.Entry<spoon.reflect.declaration.CtImport, java.lang.Boolean> entry : this.usedImport.entrySet()) {\n            if (entry.getValue()) {\n                listallImports.add(entry.getKey());\n            }\n        }\n        for (spoon.reflect.reference.CtReference reference : this.classImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.fieldImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.methodImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        return listallImports;\n    }\n\n    @java.lang.Override\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (element instanceof spoon.reflect.declaration.CtType) {\n            spoon.reflect.declaration.CtType simpleType = ((spoon.reflect.declaration.CtType) (element));\n            targetType = simpleType.getReference().getTopLevelType();\n            addClassImport(simpleType.getReference());\n            scan(simpleType);\n        } else {\n            spoon.reflect.declaration.CtType<?> type = element.getParent(spoon.reflect.declaration.CtType.class);\n            targetType = (type == null) ? null : type.getReference().getTopLevelType();\n            scan(element);\n        }\n    }\n\n    @java.lang.Override\n    public boolean isImported(spoon.reflect.reference.CtReference ref) {\n        if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            return isImportedInFieldImports(((spoon.reflect.reference.CtFieldReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            return isImportedInMethodImports(((spoon.reflect.reference.CtExecutableReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            return isImportedInClassImports(((spoon.reflect.reference.CtTypeReference) (ref)));\n        } else {\n            return false;\n        }\n    }\n\n    @java.lang.Override\n    public void initWithImports(java.util.Set<spoon.reflect.declaration.CtImport> importCollection) {\n        for (spoon.reflect.declaration.CtImport ctImport : importCollection) {\n            this.usedImport.put(ctImport, java.lang.Boolean.FALSE);\n        }\n    }\n\n    private boolean isThereAnotherClassWithSameNameInAnotherPackage(spoon.reflect.reference.CtTypeReference<?> ref) {\n        for (spoon.reflect.reference.CtTypeReference typeref : this.exploredReferences) {\n            if (typeref.getSimpleName().equals(ref.getSimpleName()) && (!typeref.getQualifiedName().equals(ref.getQualifiedName()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean addClassImport(spoon.reflect.reference.CtTypeReference<?> ref) {\n        this.exploredReferences.add(ref);\n        if (ref == null) {\n            return false;\n        }\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return false;\n        }\n        if (classImports.containsKey(ref.getSimpleName())) {\n            return isImportedInClassImports(ref);\n        }\n        if ((ref.getPackage() == null) || ref.getPackage().isUnnamedPackage()) {\n            return false;\n        }\n        if ((targetType != null) && (targetType.canAccess(ref) == false)) {\n            return false;\n        }\n        if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n            return false;\n        }\n        if (targetType != null) {\n            try {\n                spoon.reflect.declaration.CtElement parent = ref.getParent();\n                if (parent != null) {\n                    parent = parent.getParent();\n                    if (parent != null) {\n                        if (((parent instanceof spoon.reflect.code.CtFieldAccess) || (parent instanceof spoon.reflect.declaration.CtExecutable)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                            spoon.reflect.reference.CtTypeReference declaringType;\n                            spoon.reflect.reference.CtReference reference;\n                            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n                            if (parent instanceof spoon.reflect.code.CtFieldAccess) {\n                                spoon.reflect.code.CtFieldAccess field = ((spoon.reflect.code.CtFieldAccess) (parent));\n                                spoon.reflect.reference.CtFieldReference localReference = field.getVariable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.declaration.CtExecutable) {\n                                spoon.reflect.declaration.CtExecutable exec = ((spoon.reflect.declaration.CtExecutable) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = exec.getReference();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.code.CtInvocation) {\n                                spoon.reflect.code.CtInvocation invo = ((spoon.reflect.code.CtInvocation) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = invo.getExecutable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else {\n                                declaringType = null;\n                                reference = null;\n                            }\n                            if ((reference != null) && isImported(reference)) {\n                                if (declaringType != null) {\n                                    if ((declaringType.getPackage() != null) && (!declaringType.getPackage().isUnnamedPackage())) {\n                                        if (!\"java.lang\".equals(declaringType.getPackage().getSimpleName())) {\n                                            if (declaringType.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                                                classImports.put(ref.getSimpleName(), ref);\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            }\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    return false;\n                } else if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                    return false;\n                }\n            }\n        }\n        classImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    private boolean setImportUsed(spoon.reflect.declaration.CtImport ctImport) {\n        this.usedImport.put(ctImport, true);\n        return true;\n    }\n\n    private boolean isAlreadyInUsedImport(spoon.reflect.reference.CtReference ref) {\n        java.lang.String refQualifiedName = \"\";\n        spoon.reflect.reference.CtTypeReference refDeclaringType = null;\n        boolean isTypeRef = false;\n        boolean isExecRef = false;\n        boolean isFieldRef = false;\n        if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            refQualifiedName = ((spoon.reflect.reference.CtTypeReference) (ref)).getQualifiedName();\n            isTypeRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtExecutableReference) (ref)).getDeclaringType();\n            isExecRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtFieldReference) (ref)).getDeclaringType();\n            refQualifiedName = ((spoon.reflect.reference.CtFieldReference) (ref)).getQualifiedName();\n            isFieldRef = true;\n        }\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case METHOD :\n                    if (isExecRef) {\n                        spoon.reflect.reference.CtExecutableReference execRef = ((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference()));\n                        spoon.reflect.reference.CtTypeReference declaringType = execRef.getDeclaringType();\n                        if ((execRef.getSimpleName().equals(ref.getSimpleName()) && (declaringType != null)) && declaringType.equals(refDeclaringType)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case FIELD :\n                    if (isFieldRef) {\n                        spoon.reflect.reference.CtFieldReference importFieldRef = ((spoon.reflect.reference.CtFieldReference) (ctImport.getReference()));\n                        if (importFieldRef.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_STATIC_MEMBERS :\n                    if ((isExecRef || isFieldRef) && (refDeclaringType != null)) {\n                        java.lang.String qualifiedName = refDeclaringType.getQualifiedName();\n                        spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl importRef = ((spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl) (ctImport.getReference()));\n                        java.lang.String importRefStr = importRef.getQualifiedName();\n                        importRefStr = importRefStr.substring(0, importRefStr.lastIndexOf('.'));\n                        if (qualifiedName.equals(importRefStr)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case TYPE :\n                    if (isTypeRef) {\n                        spoon.reflect.reference.CtTypeReference typeReference = ((spoon.reflect.reference.CtTypeReference) (ctImport.getReference()));\n                        if (typeReference.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_TYPES :\n                    if (isTypeRef) {\n                        java.lang.String typeImportQualifiedName = ctImport.getReference().getSimpleName();\n                        if (refQualifiedName.equals(typeImportQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n        return false;\n    }\n\n    protected boolean isImportedInClassImports(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if (targetType != null) {\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (!\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                        return true;\n                    }\n                }\n            }\n        }\n        if (ref.equals(targetType)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && classImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtTypeReference<?> exist = classImports.get(ref.getSimpleName());\n            return exist.getQualifiedName().equals(ref.getQualifiedName());\n        }\n        return false;\n    }\n\n    private boolean declaringTypeIsLocalOrImported(spoon.reflect.reference.CtTypeReference declaringType) {\n        if (declaringType != null) {\n            boolean isInCollision = isTypeInCollision(declaringType, false);\n            if (!isInCollision) {\n                boolean importSuccess = addClassImport(declaringType);\n                if (importSuccess) {\n                    return true;\n                }\n            }\n            boolean importedInClassImports = isImportedInClassImports(declaringType);\n            boolean inJavaLang = classNamePresentInJavaLang(declaringType);\n            if (importedInClassImports || inJavaLang) {\n                return true;\n            }\n            while (declaringType != null) {\n                if (declaringType.equals(targetType)) {\n                    return true;\n                }\n                declaringType = declaringType.getDeclaringType();\n            } \n        }\n        return false;\n    }\n\n    private boolean isInCollisionWithLocalMethod(spoon.reflect.reference.CtExecutableReference ref) {\n        spoon.reflect.declaration.CtType<?> typeDecl = ref.getParent(spoon.reflect.declaration.CtType.class);\n        if (typeDecl != null) {\n            java.lang.String methodName = ref.getSimpleName();\n            for (spoon.reflect.declaration.CtMethod<?> method : typeDecl.getAllMethods()) {\n                if (method.getSimpleName().equals(methodName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    protected boolean addMethodImport(spoon.reflect.reference.CtExecutableReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.isImportedInMethodImports(ref)) {\n            return true;\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        if (this.isInCollisionWithLocalMethod(ref)) {\n            return false;\n        }\n        methodImports.put(ref.getSimpleName(), ref);\n        if (ref.getDeclaringType() != null) {\n            if (ref.getDeclaringType().getPackage() != null) {\n                if (ref.getDeclaringType().getPackage().equals(this.targetType.getPackage())) {\n                    addClassImport(ref.getDeclaringType());\n                }\n            }\n        }\n        return true;\n    }\n\n    protected boolean isImportedInMethodImports(spoon.reflect.reference.CtExecutableReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && methodImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtExecutableReference<?> exist = methodImports.get(ref.getSimpleName());\n            return getSignature(exist).equals(getSignature(ref));\n        }\n        return false;\n    }\n\n    private java.lang.String getSignature(spoon.reflect.reference.CtExecutableReference<?> exist) {\n        return ((exist.getDeclaringType() != null ? exist.getDeclaringType().getQualifiedName() : \"\") + \".\") + exist.getSignature();\n    }\n\n    protected boolean addFieldImport(spoon.reflect.reference.CtFieldReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.fieldImports.containsKey(ref.getSimpleName())) {\n            return isImportedInFieldImports(ref);\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        fieldImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    protected boolean isImportedInFieldImports(spoon.reflect.reference.CtFieldReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && fieldImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtFieldReference<?> exist = fieldImports.get(ref.getSimpleName());\n            try {\n                if ((exist.getFieldDeclaration() != null) && exist.getFieldDeclaration().equals(ref.getFieldDeclaration())) {\n                    return true;\n                }\n            } catch (spoon.support.SpoonClassNotFoundException notfound) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    protected boolean classNamePresentInJavaLang(spoon.reflect.reference.CtTypeReference<?> ref) {\n        java.lang.Boolean presentInJavaLang = namesPresentInJavaLang.get(ref.getSimpleName());\n        if (presentInJavaLang == null) {\n            if (spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang8.contains(ref.getSimpleName()) || spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang9.contains(ref.getSimpleName())) {\n                presentInJavaLang = true;\n            } else {\n                try {\n                    java.lang.Class.forName(\"java.lang.\" + ref.getSimpleName());\n                    presentInJavaLang = true;\n                } catch (java.lang.NoClassDefFoundError | java.lang.ClassNotFoundException e) {\n                    presentInJavaLang = false;\n                }\n            }\n            namesPresentInJavaLang.put(ref.getSimpleName(), presentInJavaLang);\n        }\n        return presentInJavaLang;\n    }\n\n    protected java.util.Set<java.lang.String> lookForLocalVariables(spoon.reflect.declaration.CtElement parent) {\n        java.util.Set<java.lang.String> result = new java.util.HashSet<>();\n        while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n            if (parent instanceof spoon.reflect.declaration.CtClass) {\n                return result;\n            }\n            parent = parent.getParent();\n        } \n        if (parent != null) {\n            spoon.reflect.code.CtBlock block = ((spoon.reflect.code.CtBlock) (parent));\n            boolean innerClass = false;\n            while ((parent != null) && (!(parent instanceof spoon.reflect.declaration.CtClass))) {\n                parent = parent.getParent();\n            } \n            if (parent != null) {\n                if (!(parent.getParent() instanceof spoon.reflect.declaration.CtPackage)) {\n                    while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n                        parent = parent.getParent();\n                    } \n                    if (parent != null) {\n                        block = ((spoon.reflect.code.CtBlock) (parent));\n                    }\n                }\n            }\n            spoon.reflect.visitor.AccessibleVariablesFinder avf = new spoon.reflect.visitor.AccessibleVariablesFinder(block);\n            java.util.List<spoon.reflect.declaration.CtVariable> variables = avf.find();\n            for (spoon.reflect.declaration.CtVariable variable : variables) {\n                result.add(variable.getSimpleName());\n            }\n        }\n        return result;\n    }\n\n    protected boolean isTypeInCollision(spoon.reflect.reference.CtReference ref, boolean fqnMode) {\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return true;\n        }\n        try {\n            spoon.reflect.declaration.CtElement parent;\n            if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                parent = ref.getParent();\n            } else {\n                parent = ref;\n            }\n            if (parent instanceof spoon.reflect.code.CtLiteral) {\n                return false;\n            }\n            java.util.Set<java.lang.String> localVariablesOfBlock = new java.util.HashSet<>();\n            if (parent instanceof spoon.reflect.declaration.CtField) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtField) (parent)).getSimpleName());\n            } else if (parent instanceof spoon.reflect.declaration.CtMethod) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtMethod) (parent)).getSimpleName());\n            } else {\n                localVariablesOfBlock = this.lookForLocalVariables(parent);\n            }\n            while (!(parent instanceof spoon.reflect.declaration.CtPackage)) {\n                if (((parent instanceof spoon.reflect.reference.CtFieldReference) || (parent instanceof spoon.reflect.reference.CtExecutableReference)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                    spoon.reflect.reference.CtReference parentType;\n                    if (parent instanceof spoon.reflect.code.CtInvocation) {\n                        parentType = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable();\n                    } else {\n                        parentType = ((spoon.reflect.reference.CtReference) (parent));\n                    }\n                    java.util.LinkedList<java.lang.String> qualifiedNameTokens = new java.util.LinkedList<>();\n                    if (parentType != parent) {\n                        qualifiedNameTokens.add(parentType.getSimpleName());\n                    }\n                    spoon.reflect.reference.CtTypeReference typeReference;\n                    if (parent instanceof spoon.reflect.reference.CtFieldReference) {\n                        typeReference = ((spoon.reflect.reference.CtFieldReference) (parent)).getDeclaringType();\n                    } else if (parent instanceof spoon.reflect.reference.CtExecutableReference) {\n                        typeReference = ((spoon.reflect.reference.CtExecutableReference) (parent)).getDeclaringType();\n                    } else {\n                        typeReference = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable().getDeclaringType();\n                    }\n                    if (typeReference != null) {\n                        qualifiedNameTokens.addFirst(typeReference.getSimpleName());\n                        if (typeReference.getPackage() != null) {\n                            java.util.StringTokenizer token = new java.util.StringTokenizer(typeReference.getPackage().getSimpleName(), spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                            int index = 0;\n                            while (token.hasMoreElements()) {\n                                qualifiedNameTokens.add(index, token.nextToken());\n                                index++;\n                            } \n                        }\n                    }\n                    if (!qualifiedNameTokens.isEmpty()) {\n                        if (fieldAndMethodsNames.contains(qualifiedNameTokens.getFirst()) || localVariablesOfBlock.contains(qualifiedNameTokens.getFirst())) {\n                            qualifiedNameTokens.removeFirst();\n                            if (fqnMode) {\n                                if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                                    if (qualifiedNameTokens.isEmpty()) {\n                                        return true;\n                                    }\n                                    for (java.lang.String testedToken : qualifiedNameTokens) {\n                                        if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                            return true;\n                                        }\n                                    }\n                                    return false;\n                                } else {\n                                    return true;\n                                }\n                            } else {\n                                for (java.lang.String testedToken : qualifiedNameTokens) {\n                                    if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                        }\n                    }\n                }\n                parent = parent.getParent();\n            } \n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Package",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Class",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "private boolean isTypeMatching(java.lang.String typeName, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n    if (typeName != null) {\n        if (typeName.equals(typeRef.getQualifiedName())) {\n            return true;\n        }\n        if (typeName.equals(typeRef.getSimpleName())) {\n            return true;\n        }\n    }\n    return false;\n}",
            "src_parent": "public class ImportScannerImpl extends spoon.reflect.visitor.CtScanner implements spoon.reflect.visitor.ImportScanner {\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang8 = java.util.Collections.singletonList(\"FunctionalInterface\");\n\n    private static final java.util.Collection<java.lang.String> namesPresentInJavaLang9 = java.util.Arrays.asList(\"ProcessHandle\", \"StackWalker\", \"StackFramePermission\");\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtTypeReference<?>> classImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtFieldReference<?>> fieldImports = new java.util.TreeMap<>();\n\n    protected java.util.Map<java.lang.String, spoon.reflect.reference.CtExecutableReference<?>> methodImports = new java.util.TreeMap<>();\n\n    protected spoon.reflect.reference.CtTypeReference<?> targetType;\n\n    private java.util.Map<java.lang.String, java.lang.Boolean> namesPresentInJavaLang = new java.util.HashMap<>();\n\n    private java.util.Set<java.lang.String> fieldAndMethodsNames = new java.util.HashSet<>();\n\n    private java.util.Set<spoon.reflect.reference.CtTypeReference> exploredReferences = new java.util.HashSet<>();\n\n    private java.util.Map<spoon.reflect.declaration.CtImport, java.lang.Boolean> usedImport = new java.util.HashMap<>();\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        enter(fieldRead);\n        scan(fieldRead.getAnnotations());\n        scan(fieldRead.getTypeCasts());\n        scan(fieldRead.getVariable());\n        scan(fieldRead.getTarget());\n        exit(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        enter(reference);\n        scan(reference.getDeclaringType());\n        if (reference.isStatic()) {\n            addFieldImport(reference);\n        } else {\n            scan(reference.getDeclaringType());\n        }\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        enter(reference);\n        if (reference.isStatic()) {\n            addMethodImport(reference);\n        } else if (reference.isConstructor()) {\n            scan(reference.getDeclaringType());\n        }\n        scan(reference.getActualTypeArguments());\n        exit(reference);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (!(reference instanceof spoon.reflect.reference.CtArrayTypeReference)) {\n            spoon.reflect.reference.CtTypeReference typeReference;\n            if (reference.getDeclaringType() == null) {\n                typeReference = reference;\n            } else {\n                typeReference = reference.getAccessType();\n            }\n            if (!typeReference.equals(reference)) {\n                if (this.isAlreadyInUsedImport(reference)) {\n                    super.visitCtTypeReference(reference);\n                    return;\n                }\n            }\n            if (!this.isTypeInCollision(typeReference, false)) {\n                this.addClassImport(typeReference);\n            }\n        }\n        super.visitCtTypeReference(reference);\n    }\n\n    @java.lang.Override\n    public void scan(spoon.reflect.declaration.CtElement element) {\n        if (element != null) {\n            element.accept(this);\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc ctJavaDoc) {\n        java.lang.StringBuilder stringBuilder = new java.lang.StringBuilder();\n        stringBuilder.append(ctJavaDoc.getContent());\n        for (spoon.reflect.code.CtJavaDocTag ctJavaDocTag : ctJavaDoc.getTags()) {\n            stringBuilder.append(\"\\n\").append(ctJavaDocTag.getType()).append(\" \").append(ctJavaDocTag.getContent());\n        }\n        java.lang.String javadoc = stringBuilder.toString();\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case TYPE :\n                    if (javadoc.contains(ctImport.getReference().getSimpleName()) && (ctImport.getReference() instanceof spoon.reflect.reference.CtTypeReference)) {\n                        if (matchesTypeName(javadoc, ((spoon.reflect.reference.CtTypeReference<?>) (ctImport.getReference())))) {\n                            this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n    private static java.util.Set<java.lang.String> mainTags = new java.util.HashSet<>(java.util.Arrays.asList(\"see\", \"throws\", \"exception\"));\n\n    private static java.util.Set<java.lang.String> inlineTags = new java.util.HashSet<>(java.util.Arrays.asList(\"link\", \"linkplain\", \"value\"));\n\n    private static java.util.regex.Pattern tagRE = java.util.regex.Pattern.compile(\"(\\\\{)?@(\\\\w+)\\\\s+([\\\\w\\\\.\\\\$]+)(?:#(\\\\w+)(?:\\\\(([^\\\\)]*)\\\\)))?\");\n\n    private boolean matchesTypeName(java.lang.String javadoc, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        java.util.regex.Matcher m = spoon.reflect.visitor.ImportScannerImpl.tagRE.matcher(javadoc);\n        while (m.find()) {\n            java.lang.String bracket = m.group(1);\n            java.lang.String tag = m.group(2);\n            if (\"{\".equals(bracket)) {\n                if (spoon.reflect.visitor.ImportScannerImpl.inlineTags.contains(tag) == false) {\n                    continue;\n                }\n            } else if (spoon.reflect.visitor.ImportScannerImpl.mainTags.contains(tag) == false) {\n                continue;\n            }\n            java.lang.String type = m.group(3);\n            java.lang.String params = m.group(5);\n            if (isTypeMatching(type, typeRef)) {\n                return true;\n            }\n            if (params != null) {\n                java.lang.String[] paramTypes = params.split(\"\\\\s*,\\\\s*\");\n                for (java.lang.String paramType : paramTypes) {\n                    if (isTypeMatching(paramType, typeRef)) {\n                        return true;\n                    }\n                }\n            }\n        } \n        return false;\n    }\n\n    private boolean isTypeMatching(java.lang.String typeName, spoon.reflect.reference.CtTypeReference<?> typeRef) {\n        if (typeName != null) {\n            if (typeName.equals(typeRef.getQualifiedName())) {\n                return true;\n            }\n            if (typeName.equals(typeRef.getSimpleName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        addClassImport(annotationType.getReference());\n        super.visitCtAnnotationType(annotationType);\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        addClassImport(ctEnum.getReference());\n        super.visitCtEnum(ctEnum);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        addClassImport(intrface.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : intrface.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtInterface(intrface);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        addClassImport(ctClass.getReference());\n        for (spoon.reflect.declaration.CtTypeMember t : ctClass.getTypeMembers()) {\n            if (!(t instanceof spoon.reflect.declaration.CtType)) {\n                continue;\n            }\n            addClassImport(((spoon.reflect.declaration.CtType) (t)).getReference());\n        }\n        super.visitCtClass(ctClass);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        for (spoon.reflect.reference.CtTypeReference<?> type : catchVariable.getMultiTypes()) {\n            addClassImport(type);\n        }\n        super.visitCtCatchVariable(catchVariable);\n    }\n\n    @java.lang.Override\n    public void visitCtInvocation(spoon.reflect.code.CtInvocation invocation) {\n        this.scan(invocation.getTypeCasts());\n        this.scan(invocation.getExecutable());\n        if (!this.isImportedInMethodImports(invocation.getExecutable())) {\n            this.scan(invocation.getTarget());\n        }\n        this.scan(invocation.getArguments());\n    }\n\n    @java.lang.Override\n    public java.util.Set<spoon.reflect.declaration.CtImport> getAllImports() {\n        java.util.Set<spoon.reflect.declaration.CtImport> listallImports = new java.util.HashSet<>();\n        for (java.util.Map.Entry<spoon.reflect.declaration.CtImport, java.lang.Boolean> entry : this.usedImport.entrySet()) {\n            if (entry.getValue()) {\n                listallImports.add(entry.getKey());\n            }\n        }\n        for (spoon.reflect.reference.CtReference reference : this.classImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.fieldImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        for (spoon.reflect.reference.CtReference reference : this.methodImports.values()) {\n            listallImports.add(reference.getFactory().Type().createImport(reference));\n        }\n        return listallImports;\n    }\n\n    @java.lang.Override\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (element instanceof spoon.reflect.declaration.CtType) {\n            spoon.reflect.declaration.CtType simpleType = ((spoon.reflect.declaration.CtType) (element));\n            targetType = simpleType.getReference().getTopLevelType();\n            addClassImport(simpleType.getReference());\n            scan(simpleType);\n        } else {\n            spoon.reflect.declaration.CtType<?> type = element.getParent(spoon.reflect.declaration.CtType.class);\n            targetType = (type == null) ? null : type.getReference().getTopLevelType();\n            scan(element);\n        }\n    }\n\n    @java.lang.Override\n    public boolean isImported(spoon.reflect.reference.CtReference ref) {\n        if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            return isImportedInFieldImports(((spoon.reflect.reference.CtFieldReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            return isImportedInMethodImports(((spoon.reflect.reference.CtExecutableReference) (ref)));\n        } else if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            return isImportedInClassImports(((spoon.reflect.reference.CtTypeReference) (ref)));\n        } else {\n            return false;\n        }\n    }\n\n    @java.lang.Override\n    public void initWithImports(java.util.Set<spoon.reflect.declaration.CtImport> importCollection) {\n        for (spoon.reflect.declaration.CtImport ctImport : importCollection) {\n            this.usedImport.put(ctImport, java.lang.Boolean.FALSE);\n        }\n    }\n\n    private boolean isThereAnotherClassWithSameNameInAnotherPackage(spoon.reflect.reference.CtTypeReference<?> ref) {\n        for (spoon.reflect.reference.CtTypeReference typeref : this.exploredReferences) {\n            if (typeref.getSimpleName().equals(ref.getSimpleName()) && (!typeref.getQualifiedName().equals(ref.getQualifiedName()))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    protected boolean addClassImport(spoon.reflect.reference.CtTypeReference<?> ref) {\n        this.exploredReferences.add(ref);\n        if (ref == null) {\n            return false;\n        }\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return false;\n        }\n        if (classImports.containsKey(ref.getSimpleName())) {\n            return isImportedInClassImports(ref);\n        }\n        if ((ref.getPackage() == null) || ref.getPackage().isUnnamedPackage()) {\n            return false;\n        }\n        if ((targetType != null) && (targetType.canAccess(ref) == false)) {\n            return false;\n        }\n        if (this.isThereAnotherClassWithSameNameInAnotherPackage(ref)) {\n            return false;\n        }\n        if (targetType != null) {\n            try {\n                spoon.reflect.declaration.CtElement parent = ref.getParent();\n                if (parent != null) {\n                    parent = parent.getParent();\n                    if (parent != null) {\n                        if (((parent instanceof spoon.reflect.code.CtFieldAccess) || (parent instanceof spoon.reflect.declaration.CtExecutable)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                            spoon.reflect.reference.CtTypeReference declaringType;\n                            spoon.reflect.reference.CtReference reference;\n                            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n                            if (parent instanceof spoon.reflect.code.CtFieldAccess) {\n                                spoon.reflect.code.CtFieldAccess field = ((spoon.reflect.code.CtFieldAccess) (parent));\n                                spoon.reflect.reference.CtFieldReference localReference = field.getVariable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.declaration.CtExecutable) {\n                                spoon.reflect.declaration.CtExecutable exec = ((spoon.reflect.declaration.CtExecutable) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = exec.getReference();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else if (parent instanceof spoon.reflect.code.CtInvocation) {\n                                spoon.reflect.code.CtInvocation invo = ((spoon.reflect.code.CtInvocation) (parent));\n                                spoon.reflect.reference.CtExecutableReference localReference = invo.getExecutable();\n                                declaringType = localReference.getDeclaringType();\n                                reference = localReference;\n                            } else {\n                                declaringType = null;\n                                reference = null;\n                            }\n                            if ((reference != null) && isImported(reference)) {\n                                if (declaringType != null) {\n                                    if ((declaringType.getPackage() != null) && (!declaringType.getPackage().isUnnamedPackage())) {\n                                        if (!\"java.lang\".equals(declaringType.getPackage().getSimpleName())) {\n                                            if (declaringType.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                                                classImports.put(ref.getSimpleName(), ref);\n                                                return true;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            }\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    return false;\n                } else if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                    return false;\n                }\n            }\n        }\n        classImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    private boolean setImportUsed(spoon.reflect.declaration.CtImport ctImport) {\n        this.usedImport.put(ctImport, true);\n        return true;\n    }\n\n    private boolean isAlreadyInUsedImport(spoon.reflect.reference.CtReference ref) {\n        java.lang.String refQualifiedName = \"\";\n        spoon.reflect.reference.CtTypeReference refDeclaringType = null;\n        boolean isTypeRef = false;\n        boolean isExecRef = false;\n        boolean isFieldRef = false;\n        if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n            refQualifiedName = ((spoon.reflect.reference.CtTypeReference) (ref)).getQualifiedName();\n            isTypeRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtExecutableReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtExecutableReference) (ref)).getDeclaringType();\n            isExecRef = true;\n        } else if (ref instanceof spoon.reflect.reference.CtFieldReference) {\n            refDeclaringType = ((spoon.reflect.reference.CtFieldReference) (ref)).getDeclaringType();\n            refQualifiedName = ((spoon.reflect.reference.CtFieldReference) (ref)).getQualifiedName();\n            isFieldRef = true;\n        }\n        for (spoon.reflect.declaration.CtImport ctImport : this.usedImport.keySet()) {\n            switch (ctImport.getImportKind()) {\n                case METHOD :\n                    if (isExecRef) {\n                        spoon.reflect.reference.CtExecutableReference execRef = ((spoon.reflect.reference.CtExecutableReference) (ctImport.getReference()));\n                        spoon.reflect.reference.CtTypeReference declaringType = execRef.getDeclaringType();\n                        if ((execRef.getSimpleName().equals(ref.getSimpleName()) && (declaringType != null)) && declaringType.equals(refDeclaringType)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case FIELD :\n                    if (isFieldRef) {\n                        spoon.reflect.reference.CtFieldReference importFieldRef = ((spoon.reflect.reference.CtFieldReference) (ctImport.getReference()));\n                        if (importFieldRef.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_STATIC_MEMBERS :\n                    if ((isExecRef || isFieldRef) && (refDeclaringType != null)) {\n                        java.lang.String qualifiedName = refDeclaringType.getQualifiedName();\n                        spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl importRef = ((spoon.support.reflect.reference.CtWildcardStaticTypeMemberReferenceImpl) (ctImport.getReference()));\n                        java.lang.String importRefStr = importRef.getQualifiedName();\n                        importRefStr = importRefStr.substring(0, importRefStr.lastIndexOf('.'));\n                        if (qualifiedName.equals(importRefStr)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case TYPE :\n                    if (isTypeRef) {\n                        spoon.reflect.reference.CtTypeReference typeReference = ((spoon.reflect.reference.CtTypeReference) (ctImport.getReference()));\n                        if (typeReference.getQualifiedName().equals(refQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n                case ALL_TYPES :\n                    if (isTypeRef) {\n                        java.lang.String typeImportQualifiedName = ctImport.getReference().getSimpleName();\n                        if (refQualifiedName.equals(typeImportQualifiedName)) {\n                            return this.setImportUsed(ctImport);\n                        }\n                    }\n                    break;\n            }\n        }\n        return false;\n    }\n\n    protected boolean isImportedInClassImports(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if (targetType != null) {\n            spoon.reflect.reference.CtPackageReference pack = targetType.getPackage();\n            if (((pack != null) && (ref.getPackage() != null)) && (!ref.getPackage().isUnnamedPackage())) {\n                if (!\"java.lang\".equals(ref.getPackage().getSimpleName())) {\n                    if (ref.getPackage().getSimpleName().equals(pack.getSimpleName())) {\n                        return true;\n                    }\n                }\n            }\n        }\n        if (ref.equals(targetType)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && classImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtTypeReference<?> exist = classImports.get(ref.getSimpleName());\n            return exist.getQualifiedName().equals(ref.getQualifiedName());\n        }\n        return false;\n    }\n\n    private boolean declaringTypeIsLocalOrImported(spoon.reflect.reference.CtTypeReference declaringType) {\n        if (declaringType != null) {\n            boolean isInCollision = isTypeInCollision(declaringType, false);\n            if (!isInCollision) {\n                boolean importSuccess = addClassImport(declaringType);\n                if (importSuccess) {\n                    return true;\n                }\n            }\n            boolean importedInClassImports = isImportedInClassImports(declaringType);\n            boolean inJavaLang = classNamePresentInJavaLang(declaringType);\n            if (importedInClassImports || inJavaLang) {\n                return true;\n            }\n            while (declaringType != null) {\n                if (declaringType.equals(targetType)) {\n                    return true;\n                }\n                declaringType = declaringType.getDeclaringType();\n            } \n        }\n        return false;\n    }\n\n    private boolean isInCollisionWithLocalMethod(spoon.reflect.reference.CtExecutableReference ref) {\n        spoon.reflect.declaration.CtType<?> typeDecl = ref.getParent(spoon.reflect.declaration.CtType.class);\n        if (typeDecl != null) {\n            java.lang.String methodName = ref.getSimpleName();\n            for (spoon.reflect.declaration.CtMethod<?> method : typeDecl.getAllMethods()) {\n                if (method.getSimpleName().equals(methodName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    protected boolean addMethodImport(spoon.reflect.reference.CtExecutableReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.isImportedInMethodImports(ref)) {\n            return true;\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        if (this.isInCollisionWithLocalMethod(ref)) {\n            return false;\n        }\n        methodImports.put(ref.getSimpleName(), ref);\n        if (ref.getDeclaringType() != null) {\n            if (ref.getDeclaringType().getPackage() != null) {\n                if (ref.getDeclaringType().getPackage().equals(this.targetType.getPackage())) {\n                    addClassImport(ref.getDeclaringType());\n                }\n            }\n        }\n        return true;\n    }\n\n    protected boolean isImportedInMethodImports(spoon.reflect.reference.CtExecutableReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && methodImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtExecutableReference<?> exist = methodImports.get(ref.getSimpleName());\n            return getSignature(exist).equals(getSignature(ref));\n        }\n        return false;\n    }\n\n    private java.lang.String getSignature(spoon.reflect.reference.CtExecutableReference<?> exist) {\n        return ((exist.getDeclaringType() != null ? exist.getDeclaringType().getQualifiedName() : \"\") + \".\") + exist.getSignature();\n    }\n\n    protected boolean addFieldImport(spoon.reflect.reference.CtFieldReference ref) {\n        if (ref.getFactory().getEnvironment().getComplianceLevel() < 5) {\n            return false;\n        }\n        if (this.fieldImports.containsKey(ref.getSimpleName())) {\n            return isImportedInFieldImports(ref);\n        }\n        if (declaringTypeIsLocalOrImported(ref.getDeclaringType())) {\n            return false;\n        }\n        fieldImports.put(ref.getSimpleName(), ref);\n        return true;\n    }\n\n    protected boolean isImportedInFieldImports(spoon.reflect.reference.CtFieldReference<?> ref) {\n        if (this.isAlreadyInUsedImport(ref)) {\n            return true;\n        }\n        if ((!ref.isImplicit()) && fieldImports.containsKey(ref.getSimpleName())) {\n            spoon.reflect.reference.CtFieldReference<?> exist = fieldImports.get(ref.getSimpleName());\n            try {\n                if ((exist.getFieldDeclaration() != null) && exist.getFieldDeclaration().equals(ref.getFieldDeclaration())) {\n                    return true;\n                }\n            } catch (spoon.support.SpoonClassNotFoundException notfound) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    protected boolean classNamePresentInJavaLang(spoon.reflect.reference.CtTypeReference<?> ref) {\n        java.lang.Boolean presentInJavaLang = namesPresentInJavaLang.get(ref.getSimpleName());\n        if (presentInJavaLang == null) {\n            if (spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang8.contains(ref.getSimpleName()) || spoon.reflect.visitor.ImportScannerImpl.namesPresentInJavaLang9.contains(ref.getSimpleName())) {\n                presentInJavaLang = true;\n            } else {\n                try {\n                    java.lang.Class.forName(\"java.lang.\" + ref.getSimpleName());\n                    presentInJavaLang = true;\n                } catch (java.lang.NoClassDefFoundError | java.lang.ClassNotFoundException e) {\n                    presentInJavaLang = false;\n                }\n            }\n            namesPresentInJavaLang.put(ref.getSimpleName(), presentInJavaLang);\n        }\n        return presentInJavaLang;\n    }\n\n    protected java.util.Set<java.lang.String> lookForLocalVariables(spoon.reflect.declaration.CtElement parent) {\n        java.util.Set<java.lang.String> result = new java.util.HashSet<>();\n        while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n            if (parent instanceof spoon.reflect.declaration.CtClass) {\n                return result;\n            }\n            parent = parent.getParent();\n        } \n        if (parent != null) {\n            spoon.reflect.code.CtBlock block = ((spoon.reflect.code.CtBlock) (parent));\n            boolean innerClass = false;\n            while ((parent != null) && (!(parent instanceof spoon.reflect.declaration.CtClass))) {\n                parent = parent.getParent();\n            } \n            if (parent != null) {\n                if (!(parent.getParent() instanceof spoon.reflect.declaration.CtPackage)) {\n                    while ((parent != null) && (!(parent instanceof spoon.reflect.code.CtBlock))) {\n                        parent = parent.getParent();\n                    } \n                    if (parent != null) {\n                        block = ((spoon.reflect.code.CtBlock) (parent));\n                    }\n                }\n            }\n            spoon.reflect.visitor.AccessibleVariablesFinder avf = new spoon.reflect.visitor.AccessibleVariablesFinder(block);\n            java.util.List<spoon.reflect.declaration.CtVariable> variables = avf.find();\n            for (spoon.reflect.declaration.CtVariable variable : variables) {\n                result.add(variable.getSimpleName());\n            }\n        }\n        return result;\n    }\n\n    protected boolean isTypeInCollision(spoon.reflect.reference.CtReference ref, boolean fqnMode) {\n        if (((targetType != null) && targetType.getSimpleName().equals(ref.getSimpleName())) && (!targetType.equals(ref))) {\n            return true;\n        }\n        try {\n            spoon.reflect.declaration.CtElement parent;\n            if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                parent = ref.getParent();\n            } else {\n                parent = ref;\n            }\n            if (parent instanceof spoon.reflect.code.CtLiteral) {\n                return false;\n            }\n            java.util.Set<java.lang.String> localVariablesOfBlock = new java.util.HashSet<>();\n            if (parent instanceof spoon.reflect.declaration.CtField) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtField) (parent)).getSimpleName());\n            } else if (parent instanceof spoon.reflect.declaration.CtMethod) {\n                this.fieldAndMethodsNames.add(((spoon.reflect.declaration.CtMethod) (parent)).getSimpleName());\n            } else {\n                localVariablesOfBlock = this.lookForLocalVariables(parent);\n            }\n            while (!(parent instanceof spoon.reflect.declaration.CtPackage)) {\n                if (((parent instanceof spoon.reflect.reference.CtFieldReference) || (parent instanceof spoon.reflect.reference.CtExecutableReference)) || (parent instanceof spoon.reflect.code.CtInvocation)) {\n                    spoon.reflect.reference.CtReference parentType;\n                    if (parent instanceof spoon.reflect.code.CtInvocation) {\n                        parentType = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable();\n                    } else {\n                        parentType = ((spoon.reflect.reference.CtReference) (parent));\n                    }\n                    java.util.LinkedList<java.lang.String> qualifiedNameTokens = new java.util.LinkedList<>();\n                    if (parentType != parent) {\n                        qualifiedNameTokens.add(parentType.getSimpleName());\n                    }\n                    spoon.reflect.reference.CtTypeReference typeReference;\n                    if (parent instanceof spoon.reflect.reference.CtFieldReference) {\n                        typeReference = ((spoon.reflect.reference.CtFieldReference) (parent)).getDeclaringType();\n                    } else if (parent instanceof spoon.reflect.reference.CtExecutableReference) {\n                        typeReference = ((spoon.reflect.reference.CtExecutableReference) (parent)).getDeclaringType();\n                    } else {\n                        typeReference = ((spoon.reflect.code.CtInvocation) (parent)).getExecutable().getDeclaringType();\n                    }\n                    if (typeReference != null) {\n                        qualifiedNameTokens.addFirst(typeReference.getSimpleName());\n                        if (typeReference.getPackage() != null) {\n                            java.util.StringTokenizer token = new java.util.StringTokenizer(typeReference.getPackage().getSimpleName(), spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                            int index = 0;\n                            while (token.hasMoreElements()) {\n                                qualifiedNameTokens.add(index, token.nextToken());\n                                index++;\n                            } \n                        }\n                    }\n                    if (!qualifiedNameTokens.isEmpty()) {\n                        if (fieldAndMethodsNames.contains(qualifiedNameTokens.getFirst()) || localVariablesOfBlock.contains(qualifiedNameTokens.getFirst())) {\n                            qualifiedNameTokens.removeFirst();\n                            if (fqnMode) {\n                                if (ref instanceof spoon.reflect.reference.CtTypeReference) {\n                                    if (qualifiedNameTokens.isEmpty()) {\n                                        return true;\n                                    }\n                                    for (java.lang.String testedToken : qualifiedNameTokens) {\n                                        if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                            return true;\n                                        }\n                                    }\n                                    return false;\n                                } else {\n                                    return true;\n                                }\n                            } else {\n                                for (java.lang.String testedToken : qualifiedNameTokens) {\n                                    if ((!fieldAndMethodsNames.contains(testedToken)) && (!localVariablesOfBlock.contains(testedToken))) {\n                                        return false;\n                                    }\n                                }\n                                return true;\n                            }\n                        }\n                    }\n                }\n                parent = parent.getParent();\n            } \n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        return false;\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "ForEach",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "Invocation",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "LocalVariable",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "ForEach",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "stringBuilder.append(\"\\n\").append(ctJavaDocTag.getType()).append(\" \").append(ctJavaDocTag.getContent())",
            "src_parent": "{\n    stringBuilder.append(\"\\n\").append(ctJavaDocTag.getType()).append(\" \").append(ctJavaDocTag.getContent());\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Switch",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (javadoc.contains(ctImport.getReference().getSimpleName()) && (ctImport.getReference() instanceof spoon.reflect.reference.CtTypeReference)) {\n    if (matchesTypeName(javadoc, ((spoon.reflect.reference.CtTypeReference<?>) (ctImport.getReference())))) {\n        this.setImportUsed(ctImport);\n    }\n}",
            "src_parent": "case TYPE :\n    if (javadoc.contains(ctImport.getReference().getSimpleName()) && (ctImport.getReference() instanceof spoon.reflect.reference.CtTypeReference)) {\n        if (matchesTypeName(javadoc, ((spoon.reflect.reference.CtTypeReference<?>) (ctImport.getReference())))) {\n            this.setImportUsed(ctImport);\n        }\n    }\n    break;",
            "src_parent_type": "Case",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "ctJavaDocTag.getContent()",
            "dst_parent": "stringBuilder.append(\"\\n\").append(ctJavaDocTag.getType()).append(\" \").append(ctJavaDocTag.getContent())",
            "dst_parent_type": "Invocation",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "ctJavaDocTag.getContent()",
            "src_parent": "stringBuilder.append(ctJavaDocTag.getContent())",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "ForEach",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "stringBuilder",
            "dst_parent": "stringBuilder.append(\"\\n\")",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "stringBuilder",
            "src_parent": "stringBuilder.append(ctJavaDocTag.getContent())",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Break",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Case",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "javadoc.contains(ctImport.getReference().getSimpleName())",
            "dst_parent": "javadoc.contains(ctImport.getReference().getSimpleName()) && (ctImport.getReference() instanceof spoon.reflect.reference.CtTypeReference)",
            "dst_parent_type": "BinaryOperator",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "javadoc.contains(ctImport.getReference().getSimpleName())",
            "src_parent": "if (javadoc.contains(ctImport.getReference().getSimpleName())) {\n    this.setImportUsed(ctImport);\n}",
            "src_parent_type": "If",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "Break",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Case",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "If",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "{\n    this.setImportUsed(ctImport);\n}",
            "dst_parent": "if (matchesTypeName(javadoc, ((spoon.reflect.reference.CtTypeReference<?>) (ctImport.getReference())))) {\n    this.setImportUsed(ctImport);\n}",
            "dst_parent_type": "If",
            "dst_type": "Block",
            "operator": "MOV",
            "src": "{\n    this.setImportUsed(ctImport);\n}",
            "src_parent": "if (javadoc.contains(ctImport.getReference().getSimpleName())) {\n    this.setImportUsed(ctImport);\n}",
            "src_parent_type": "If",
            "src_type": "Block"
          }
        }
      ],
      "file_name": "ImportScannerImpl"
    }
  ],
  "id": "bears_215"
}