{
  "files": [
    {
      "features": [
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@java.lang.Override\npublic void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n    spoon.reflect.reference.CtTypeParameterReference ref = typeParameter.getReference();\n    if (ref.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(ref);\n    if (printQualified(ref)) {\n        printer.write(ref.getQualifiedName());\n    } else {\n        printer.write(ref.getSimpleName());\n    }\n    if (ref.getBoundingType() != null) {\n        if (ref.isUpper()) {\n            printer.write(\" extends \");\n        } else {\n            printer.write(\" super \");\n        }\n        scan(ref.getBoundingType());\n    }\n}",
            "dst_parent": "public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    public static final java.lang.String JAVA_FILE_EXTENSION = \".java\";\n\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION = \"package-info\" + spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION;\n\n    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty(\"line.separator\");\n\n    public static final java.lang.String COMMENT_STAR = \" * \";\n\n    public static final java.lang.String BLOCK_COMMENT_END = \" */\";\n\n    public static final java.lang.String JAVADOC_START = \"/**\";\n\n    public static final java.lang.String INLINE_COMMENT_START = \"// \";\n\n    public static final java.lang.String BLOCK_COMMENT_START = \"/* \";\n\n    public spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();\n\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    private spoon.compiler.Environment env;\n\n    private spoon.reflect.visitor.PrinterHelper printer;\n\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    private spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env = env;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        printer.mapLine(e, sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            context.parenthesedExpression.push(e);\n            printer.write(\"(\");\n        }\n        if (!e.getTypeCasts().isEmpty()) {\n            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {\n                printer.write(\"(\");\n                this.scan(r);\n                printer.write(\") \");\n                printer.write(\"(\");\n                context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(s, sourceCompilationUnit);\n        elementPrinterHelper.writeAnnotations(s);\n        if (s.getLabel() != null) {\n            printer.write(s.getLabel()).write(\" : \");\n        }\n    }\n\n    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        while ((context.parenthesedExpression.size() > 0) && (e == context.parenthesedExpression.peek())) {\n            context.parenthesedExpression.pop();\n            printer.write(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeImports(spoon.reflect.declaration.CtType<?> type) {\n        context.currentTopLevel = type;\n        return importsContext.computeAllImports(context.currentTopLevel);\n    }\n\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (env.isAutoImports()) {\n            importsContext.computeImports(element);\n        }\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e != null) {\n            context.elementStack.push(e);\n            if (env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    printer.adjustStartPosition(e);\n                }\n            }\n            e.accept(this);\n            context.elementStack.pop();\n        }\n        return this;\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.reference.CtReference ref) {\n        if (ref != null) {\n            ref.accept(this);\n        }\n        return this;\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {\n        if (e.getTypeCasts().size() != 0) {\n            return true;\n        }\n        try {\n            if ((e.getParent() instanceof spoon.reflect.code.CtBinaryOperator) || (e.getParent() instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if (e.getParent() instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {\n        elementPrinterHelper.writeAnnotations(annotation);\n        printer.write(\"@\");\n        scan(annotation.getAnnotationType());\n        if (annotation.getValues().size() > 0) {\n            printer.write(\"(\");\n            for (java.util.Map.Entry<java.lang.String, spoon.reflect.code.CtExpression> e : annotation.getValues().entrySet()) {\n                printer.write(e.getKey() + \" = \");\n                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\")\");\n        }\n        printer.writeln().writeTabs();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        visitCtType(annotationType);\n        printer.write((\"@interface \" + annotationType.getSimpleName()) + \" {\").incTab();\n        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        elementPrinterHelper.writeComment(impl);\n        elementPrinterHelper.writeAnnotations(impl);\n        elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        printer.write(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        printer.write(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!context.skipArray()) {\n            printer.write(\"[]\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {\n        enterCtStatement(asserted);\n        printer.write(\"assert \");\n        scan(asserted.getAssertExpression());\n        if (asserted.getExpression() != null) {\n            printer.write(\" : \");\n            scan(asserted.getExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        printer.write(\" = \");\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        printer.write(\" \").writeOperator(operator.getKind()).write(\" \");\n        scan(operator.getRightHandOperand());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {\n        enterCtStatement(block);\n        if (!block.isImplicit()) {\n            printer.write(\"{\");\n        }\n        printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!statement.isImplicit()) {\n                printer.writeln().writeTabs();\n                elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        printer.decTab();\n        printer.adjustEndPosition(block);\n        if (env.isPreserveLineNumbers()) {\n            if (!block.isImplicit()) {\n                printer.writeTabs().write(\"}\");\n            }\n        } else {\n            printer.writeln().writeTabs();\n            if (!block.isImplicit()) {\n                printer.write(\"}\");\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        printer.write(\"break\");\n        if (breakStatement.getTargetLabel() != null) {\n            printer.write(\" \" + breakStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {\n        enterCtStatement(caseStatement);\n        if (caseStatement.getCaseExpression() != null) {\n            printer.write(\"case \");\n            if (caseStatement.getCaseExpression() instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                if (((variable.getType() != null) && (variable.getDeclaringType() != null)) && variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName())) {\n                    printer.write(variable.getSimpleName());\n                } else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            } else {\n                scan(caseStatement.getCaseExpression());\n            }\n        } else {\n            printer.write(\"default\");\n        }\n        printer.write(\" :\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            printer.writeln().writeTabs();\n            elementPrinterHelper.writeStatement(statement);\n        }\n        printer.decTab();\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.write(\" catch (\");\n        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();\n        if (parameter.getMultiTypes().size() > 0) {\n            for (int i = 0; i < parameter.getMultiTypes().size(); i++) {\n                spoon.reflect.reference.CtTypeReference<?> type = parameter.getMultiTypes().get(i);\n                scan(type);\n                if (i < (parameter.getMultiTypes().size() - 1)) {\n                    printer.write(\" | \");\n                }\n            }\n            printer.write(\" \" + parameter.getSimpleName());\n        } else {\n            scan(parameter);\n        }\n        printer.write(\") \");\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        context.pushCurrentThis(ctClass);\n        if (((ctClass.getSimpleName() != null) && (!spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()))) && (!ctClass.isAnonymous())) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                printer.write(\"class \" + ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(\"class \" + ctClass.getSimpleName());\n            }\n            elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            elementPrinterHelper.writeExtendsClause(ctClass);\n            elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        printer.adjustEndPosition(ctClass).decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        spoon.reflect.reference.CtTypeParameterReference ref = typeParameter.getReference();\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n        if (ref.getBoundingType() != null) {\n            if (ref.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(ref.getBoundingType());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();\n        boolean parent;\n        try {\n            parent = (conditional.getParent() instanceof spoon.reflect.code.CtAssignment) || (conditional.getParent() instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            parent = false;\n        }\n        if (parent) {\n            printer.write(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            printer.write(\")\");\n        }\n        printer.write(\" ? \");\n        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();\n        scan(thenExpression);\n        printer.write(\" : \");\n        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();\n        boolean isAssign = false;\n        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            printer.write(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            printer.write(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {\n        elementPrinterHelper.writeComment(constructor);\n        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(constructor);\n        elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (constructor.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        if (constructor.getDeclaringType() != null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                printer.write(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        elementPrinterHelper.writeExecutableParameters(constructor);\n        elementPrinterHelper.writeThrowsClause(constructor);\n        printer.write(\" \");\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        printer.write(\"continue\");\n        if (continueStatement.getTargetLabel() != null) {\n            printer.write(\" \" + continueStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        printer.write(\"do\");\n        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        printer.write(\"while (\");\n        scan(doLoop.getLoopingExpression());\n        printer.write(\" )\");\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        visitCtType(ctEnum);\n        printer.write(\"enum \" + ctEnum.getSimpleName());\n        elementPrinterHelper.writeImplementsClause(ctEnum);\n        context.pushCurrentThis(ctEnum);\n        printer.write(\" {\").incTab().writeln();\n        if (ctEnum.getEnumValues().size() == 0) {\n            printer.writeTabs().write(\";\").writeln();\n        } else {\n            for (spoon.reflect.declaration.CtEnumValue<?> enumValue : ctEnum.getEnumValues()) {\n                scan(enumValue);\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\";\");\n        }\n        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        printer.write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {\n        elementPrinterHelper.writeComment(f);\n        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        printer.write(\" \");\n        printer.write(f.getSimpleName());\n        if (f.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(f.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n        printer.write(enumValue.getSimpleName());\n        if (enumValue.getDefaultExpression() != null) {\n            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));\n            if (constructorCall.getArguments().size() > 0) {\n                printer.write(\"(\");\n                boolean first = true;\n                for (spoon.reflect.code.CtExpression<?> ctexpr : constructorCall.getArguments()) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        printer.write(\",\");\n                    }\n                    scan(ctexpr);\n                }\n                printer.write(\")\");\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {\n        enterCtExpression(f);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (f.getVariable().isStatic() && (f.getTarget() instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression<?> target = f.getTarget();\n            if (target != null) {\n                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField = f.getVariable().isStatic();\n                boolean isImportedField = importsContext.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {\n                    if (target.isImplicit()) {\n                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();\n                        final java.lang.String fieldName = field.getSimpleName();\n                        spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                        if (var != field) {\n                            target.setImplicit(false);\n                        }\n                    }\n                    printer.snapshotLength();\n                    scan(target);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent = targetExp.getParent();\n            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        if ((((((parent instanceof spoon.reflect.code.CtFieldWrite) && targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget())) && (anonymousParent != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable() != null)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();\n            if (thisAccess.isImplicit()) {\n                return;\n            }\n            if ((targetType == null) || ((thisAccess.getParent(spoon.reflect.declaration.CtType.class) != null) && thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel())) {\n                printer.write(\"this\");\n                return;\n            }\n            if (targetType.isAnonymous()) {\n                printer.write(\"this\");\n                return;\n            }\n            if (!context.currentThis.isEmpty()) {\n                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();\n                if (!lastTypeQualifiedName.equals(targetTypeQualifiedName)) {\n                    printer.snapshotLength();\n                    visitCtTypeReferenceWithoutGenerics(targetType);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                    printer.write(\"this\");\n                    return;\n                }\n            }\n            printer.write(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {\n        enterCtExpression(f);\n        if (f.getTarget() != null) {\n            scan(f.getTarget());\n            printer.write(\".\");\n        }\n        printer.write(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n        printer.write(spoon.reflect.code.CtJavaDocTag.JAVADOC_TAG_PREFIX);\n        printer.write(docTag.getType().name().toLowerCase());\n        printer.write(\" \");\n        if (docTag.getType().hasParam()) {\n            printer.write(docTag.getParam()).writeln().writeTabs();\n        }\n        java.lang.String[] tagLines = docTag.getContent().split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n        for (int i = 0; i < tagLines.length; i++) {\n            java.lang.String com = tagLines[i];\n            if ((i > 0) || docTag.getType().hasParam()) {\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n            }\n            if (docTag.getType().hasParam()) {\n                printer.write(\"\\t\\t\");\n            }\n            printer.write(com.trim()).writeln().writeTabs();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!env.isCommentsEnabled()) && (context.elementStack.size() > 1)) {\n            return;\n        }\n        switch (comment.getCommentType()) {\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln().writeTabs();\n                break;\n            case INLINE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.INLINE_COMMENT_START);\n                break;\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_START);\n                break;\n        }\n        java.lang.String content = comment.getContent();\n        switch (comment.getCommentType()) {\n            case INLINE :\n                printer.write(content);\n                break;\n            default :\n                java.lang.String[] lines = content.split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n                for (int i = 0; i < lines.length; i++) {\n                    java.lang.String com = lines[i];\n                    if (comment.getCommentType() == spoon.reflect.code.CtComment.CommentType.BLOCK) {\n                        printer.write(com);\n                        if (lines.length > 1) {\n                            printer.writeln().writeTabs();\n                        }\n                    } else if (com.length() > 0) {\n                        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR + com).writeln().writeTabs();\n                    } else {\n                        printer.write(\" *\" + com).writeln().writeTabs();\n                    }\n                }\n                if (comment instanceof spoon.reflect.code.CtJavaDoc) {\n                    if (!((spoon.reflect.code.CtJavaDoc) (comment)).getTags().isEmpty()) {\n                        printer.write(\" *\").writeln().writeTabs();\n                    }\n                    for (spoon.reflect.code.CtJavaDocTag docTag : ((spoon.reflect.code.CtJavaDoc) (comment)).getTags()) {\n                        scan(docTag);\n                    }\n                }\n                break;\n        }\n        switch (comment.getCommentType()) {\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (annotationFieldAccess.getTarget() != null) {\n                scan(annotationFieldAccess.getTarget());\n                printer.write(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            printer.write(\"()\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        boolean isStatic = reference.getSimpleName().equals(\"class\") || ((!reference.getSimpleName().equals(\"super\")) && reference.isStatic());\n        boolean printType = true;\n        if (reference.isFinal() && reference.isStatic()) {\n            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                printType = false;\n            } else if (context.isInCurrentScope(declTypeRef)) {\n                printType = false;\n            }\n        }\n        if ((isStatic && printType) && (!context.ignoreStaticAccess())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            printer.write(\".\");\n        }\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        printer.write(\"for (\");\n        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();\n        if (st.size() > 0) {\n            scan(st.get(0));\n        }\n        if (st.size() > 1) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().noTypeDecl(true)) {\n                for (int i = 1; i < st.size(); i++) {\n                    printer.write(\", \");\n                    scan(st.get(i));\n                }\n            }\n        }\n        printer.write(\"; \");\n        scan(forLoop.getExpression());\n        printer.write(\";\");\n        if (!forLoop.getForUpdate().isEmpty()) {\n            printer.write(\" \");\n        }\n        for (spoon.reflect.code.CtStatement s : forLoop.getForUpdate()) {\n            scan(s);\n            printer.write(\" , \");\n        }\n        if (forLoop.getForUpdate().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        printer.write(\"for (\");\n        scan(foreach.getVariable());\n        printer.write(\" : \");\n        scan(foreach.getExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        printer.write(\"if (\");\n        scan(ifElement.getCondition());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if (ifElement.getElseStatement() != null) {\n            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition() == null) ? ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition() : ifElement.getThenStatement().getPosition();\n                if (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd()) {\n                    elementPrinterHelper.writeComment(comment);\n                }\n            }\n            printer.write(\"else\");\n            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        visitCtType(intrface);\n        printer.write(\"interface \" + intrface.getSimpleName());\n        if (intrface.getFormalCtTypeParameters() != null) {\n            elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (intrface.getSuperInterfaces().size() > 0) {\n            printer.write(\" extends \");\n            for (spoon.reflect.reference.CtTypeReference<?> ref : intrface.getSuperInterfaces()) {\n                scan(ref);\n                printer.write(\" , \");\n            }\n            printer.removeLastChar();\n        }\n        context.pushCurrentThis(intrface);\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType<?> parentType;\n            try {\n                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType = null;\n            }\n            if (((parentType != null) && (parentType.getQualifiedName() != null)) && parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName())) {\n                printer.write(\"this\");\n            } else {\n                printer.snapshotLength();\n                scan(invocation.getTarget());\n                if (printer.hasNewContent()) {\n                    printer.write(\".\");\n                }\n                printer.write(\"super\");\n            }\n        } else {\n            printer.snapshotLength();\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                if (invocation.getTarget() instanceof spoon.reflect.code.CtTypeAccess) {\n                    _context.ignoreGenerics(true);\n                }\n                scan(invocation.getTarget());\n            }\n            if (printer.hasNewContent()) {\n                printer.write(\".\");\n            }\n            elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (env.isPreserveLineNumbers()) {\n                printer.adjustStartPosition(invocation);\n            }\n            printer.write(invocation.getExecutable().getSimpleName());\n        }\n        printer.write(\"(\");\n        boolean remove = false;\n        for (spoon.reflect.code.CtExpression<?> e : invocation.getArguments()) {\n            scan(e);\n            printer.write(\", \");\n            remove = true;\n        }\n        if (remove) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        exitCtExpression(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {\n        enterCtExpression(literal);\n        if (literal.getValue() == null) {\n            printer.write(\"null\");\n        } else if (literal.getValue() instanceof java.lang.Long) {\n            printer.write(literal.getValue() + \"L\");\n        } else if (literal.getValue() instanceof java.lang.Float) {\n            printer.write(literal.getValue() + \"F\");\n        } else if (literal.getValue() instanceof java.lang.Character) {\n            printer.write(\"'\");\n            boolean mayContainsSpecialCharacter = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacter = stringLength != 1;\n            }\n            printer.writeStringLiteral(new java.lang.String(new char[]{ ((java.lang.Character) (literal.getValue())) }), mayContainsSpecialCharacter);\n            printer.write(\"'\");\n        } else if (literal.getValue() instanceof java.lang.String) {\n            printer.write('\\\"');\n            boolean mayContainsSpecialCharacters = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacters = ((java.lang.String) (literal.getValue())).length() != stringLength;\n            }\n            printer.writeStringLiteral(((java.lang.String) (literal.getValue())), mayContainsSpecialCharacters);\n            printer.write('\\\"');\n        } else if (literal.getValue() instanceof java.lang.Class) {\n            printer.write(((java.lang.Class<?>) (literal.getValue())).getName());\n        } else {\n            printer.write(literal.getValue().toString());\n        }\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {\n        if (!context.noTypeDecl()) {\n            enterCtStatement(localVariable);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(localVariable);\n        }\n        if (!context.noTypeDecl()) {\n            elementPrinterHelper.writeModifiers(localVariable);\n            scan(localVariable.getType());\n            printer.write(\" \");\n        }\n        printer.write(localVariable.getSimpleName());\n        if (localVariable.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(localVariable.getDefaultExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(catchVariable);\n        }\n        elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        printer.write(\" \");\n        printer.write(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {\n        elementPrinterHelper.writeComment(m);\n        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(m);\n        if (m.isDefaultMethod()) {\n            printer.write(\"default \");\n        }\n        elementPrinterHelper.writeFormalTypeParameters(m);\n        if (m.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        printer.write(\" \");\n        printer.write(m.getSimpleName());\n        elementPrinterHelper.writeExecutableParameters(m);\n        elementPrinterHelper.writeThrowsClause(m);\n        if (m.getBody() != null) {\n            printer.write(\" \");\n            scan(m.getBody());\n            if (m.getBody().getPosition() != null) {\n                if (m.getBody().getPosition().getCompilationUnit() == sourceCompilationUnit) {\n                    if (m.getBody().getStatements().isEmpty() || (!(m.getBody().getStatements().get(m.getBody().getStatements().size() - 1) instanceof spoon.reflect.code.CtReturn))) {\n                        printer.putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                } else {\n                    printer.undefineLine();\n                }\n            } else {\n                printer.undefineLine();\n            }\n        } else {\n            printer.write(\";\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n        elementPrinterHelper.writeComment(annotationMethod);\n        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        printer.write(\" \");\n        printer.write(annotationMethod.getSimpleName());\n        printer.write(\"()\");\n        if (annotationMethod.getDefaultExpression() != null) {\n            printer.write(\" default \");\n            scan(annotationMethod.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation = (newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class) == null) && (newArray.getParent(spoon.reflect.declaration.CtAnnotation.class) == null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation = true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();\n            if (ref != null) {\n                printer.write(\"new \");\n            }\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                printer.write(\"[\");\n                if (newArray.getDimensionExpressions().size() > i) {\n                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                printer.write(\"]\");\n                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().size() == 0) {\n            printer.write(\"{ \");\n            java.util.List<spoon.reflect.code.CtExpression<?>> l_elements = newArray.getElements();\n            for (int i = 0; i < l_elements.size(); i++) {\n                spoon.reflect.code.CtExpression e = l_elements.get(i);\n                scan(e);\n                printer.write(\" , \");\n                if ((i + 1) == l_elements.size()) {\n                    printer.removeLastChar();\n                    java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n                    if ((!comments.isEmpty()) && (comments.get(comments.size() - 1).getCommentType() == spoon.reflect.code.CtComment.CommentType.INLINE)) {\n                        printer.writeln();\n                    }\n                }\n            }\n            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            printer.write(\" }\");\n        }\n        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n    }\n\n    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (ctConstructorCall.getTarget() != null) {\n                scan(ctConstructorCall.getTarget());\n                printer.write(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            printer.write(\"new \");\n            if (ctConstructorCall.getActualTypeArguments().size() > 0) {\n                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        printer.write(\"(\");\n        for (spoon.reflect.code.CtCodeElement exp : ctConstructorCall.getArguments()) {\n            scan(exp);\n            printer.write(\", \");\n        }\n        if (ctConstructorCall.getArguments().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n    }\n\n    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (reference == null) {\n            return false;\n        }\n        if (reference.getDeclaringType() == null) {\n            return false;\n        }\n        if (reference.isLocalType()) {\n            return false;\n        }\n        if (reference.getDeclaringType().getActualTypeArguments().size() != 0) {\n            return true;\n        }\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {\n        enterCtExpression(lambda);\n        printer.write(\"(\");\n        if (lambda.getParameters().size() > 0) {\n            for (spoon.reflect.declaration.CtParameter<?> parameter : lambda.getParameters()) {\n                scan(parameter);\n                printer.write(\",\");\n            }\n            printer.removeLastChar();\n        }\n        printer.write(\") -> \");\n        if (lambda.getBody() != null) {\n            scan(lambda.getBody());\n        } else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n        enterCtExpression(expression);\n        scan(expression.getTarget());\n        printer.write(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            printer.write(\"new\");\n        } else {\n            printer.write(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        printer.write(\" \");\n        printer.writeOperator(assignment.getKind());\n        printer.write(\"= \");\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!ctPackage.isUnnamedPackage()) {\n            printer.write((\"package \" + ctPackage.getQualifiedName()) + \";\");\n        } else {\n            printer.write(\"// default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)\\n\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {\n        elementPrinterHelper.writeComment(parameter);\n        elementPrinterHelper.writeAnnotations(parameter);\n        elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());\n            printer.write(\"...\");\n        } else {\n            scan(parameter.getType());\n        }\n        printer.write(\" \");\n        printer.write(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {\n        enterCtStatement(returnStatement);\n        printer.write(\"return \");\n        scan(returnStatement.getReturnedExpression());\n    }\n\n    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {\n        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(type, sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            context.currentTopLevel = type;\n        }\n        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {\n        enterCtStatement(switchStatement);\n        printer.write(\"switch (\");\n        scan(switchStatement.getSelector());\n        printer.write(\") {\").incTab();\n        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {\n            printer.writeln().writeTabs();\n            scan(c);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.decTab().write(\"}\");\n        } else {\n            printer.decTab().writeln().writeTabs().write(\"}\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        printer.write(\"synchronized\");\n        if (synchro.getExpression() != null) {\n            printer.write(\"(\");\n            scan(synchro.getExpression());\n            printer.write(\") \");\n        }\n        scan(synchro.getBlock());\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        printer.write(\"throw \");\n        scan(throwStatement.getThrownExpression());\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        printer.write(\"try \");\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if (tryBlock.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryBlock.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        printer.write(\"try \");\n        if ((tryWithResource.getResources() != null) && (!tryWithResource.getResources().isEmpty())) {\n            printer.write(\"(\");\n            for (spoon.reflect.code.CtLocalVariable<?> r : tryWithResource.getResources()) {\n                scan(r);\n                printer.write(\";\");\n            }\n            printer.removeLastChar();\n            printer.write(\") \");\n        }\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if (tryWithResource.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryWithResource.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        if (wildcardReference.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(wildcardReference);\n        if (printQualified(wildcardReference)) {\n            printer.write(wildcardReference.getQualifiedName());\n        } else {\n            printer.write(wildcardReference.getSimpleName());\n        }\n        if (wildcardReference.getBoundingType() != null) {\n            if (wildcardReference.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(wildcardReference.getBoundingType());\n        }\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (importsContext.isImported(ref) || ((this.env.isAutoImports() && (ref.getPackage() != null)) && ref.getPackage().getSimpleName().equals(\"java.lang\"))) {\n            for (spoon.reflect.visitor.TypeContext typeContext : context.currentThis) {\n                if (typeContext.getSimpleName().equals(ref.getSimpleName()) && (!java.util.Objects.equals(typeContext.getPackage(), ref.getPackage()))) {\n                    return true;\n                }\n                if (typeContext.isNameConflict(ref.getSimpleName())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n        for (spoon.reflect.reference.CtTypeReference<?> bound : reference.getBounds()) {\n            scan(bound);\n            printer.write(\" & \");\n        }\n        printer.removeLastChar();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n            return;\n        }\n        boolean isInner = ref.getDeclaringType() != null;\n        if (isInner) {\n            if ((!context.ignoreEnclosingClass()) && (!ref.isLocalType())) {\n                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();\n                if (!accessType.isAnonymous()) {\n                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    printer.write(\".\");\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                printer.write(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(ref.getSimpleName());\n            }\n        } else {\n            if ((ref.getPackage() != null) && printQualified(ref)) {\n                if (!ref.getPackage().isUnnamedPackage()) {\n                    scan(ref.getPackage());\n                    printer.write(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n        }\n        if (withGenerics && (!context.ignoreGenerics())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {\n                elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        printer.preWriteUnaryOperator(operator.getKind());\n        scan(operator.getOperand());\n        printer.postWriteUnaryOperator(operator.getKind());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {\n        enterCtExpression(variableRead);\n        printer.write(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n        enterCtExpression(variableWrite);\n        printer.write(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        printer.write(\"while (\");\n        scan(whileLoop.getLoopingExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n        elementPrinterHelper.writeComment(expression);\n        printer.write(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        elementPrinterHelper.writeComment(statement);\n        printer.write(statement.getValue());\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return context;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String getPackageDeclaration() {\n        return printPackageInfo(context.currentTopLevel.getPackage());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        spoon.reflect.visitor.PrinterHelper bck = printer;\n        spoon.reflect.visitor.ElementPrinterHelper bck2 = elementPrinterHelper;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        elementPrinterHelper.writeComment(pack);\n        for (spoon.reflect.declaration.CtAnnotation<?> a : pack.getAnnotations()) {\n            a.accept(this);\n        }\n        if (!pack.isUnnamedPackage()) {\n            printer.write((\"package \" + pack.getQualifiedName()) + \";\");\n        }\n        java.lang.String ret = printer.toString();\n        elementPrinterHelper = bck2;\n        printer = bck;\n        return ret;\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public void reset() {\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper.setPrinter(printer);\n        context = new spoon.reflect.visitor.PrintingContext();\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {\n        this.sourceCompilationUnit = sourceCompilationUnit;\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n        java.util.Set<spoon.reflect.reference.CtReference> imports = new java.util.HashSet<>();\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            imports.addAll(computeImports(t));\n        }\n        elementPrinterHelper.writeHeader(types, imports);\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            scan(t);\n            if (!env.isPreserveLineNumbers()) {\n                printer.writeln().writeln().writeTabs();\n            } else {\n                printer.adjustEndPosition(t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {\n        return printer.getLineNumberMapping();\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "@java.lang.Override\npublic void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n    if (ref.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(ref);\n    if (printQualified(ref)) {\n        printer.write(ref.getQualifiedName());\n    } else {\n        printer.write(ref.getSimpleName());\n    }\n    if (ref.getBoundingType() != null) {\n        if (ref.isUpper()) {\n            printer.write(\" extends \");\n        } else {\n            printer.write(\" super \");\n        }\n        scan(ref.getBoundingType());\n    }\n}",
            "src_parent": "public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    public static final java.lang.String JAVA_FILE_EXTENSION = \".java\";\n\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION = \"package-info\" + spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION;\n\n    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty(\"line.separator\");\n\n    public static final java.lang.String COMMENT_STAR = \" * \";\n\n    public static final java.lang.String BLOCK_COMMENT_END = \" */\";\n\n    public static final java.lang.String JAVADOC_START = \"/**\";\n\n    public static final java.lang.String INLINE_COMMENT_START = \"// \";\n\n    public static final java.lang.String BLOCK_COMMENT_START = \"/* \";\n\n    public spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();\n\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    private spoon.compiler.Environment env;\n\n    private spoon.reflect.visitor.PrinterHelper printer;\n\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    private spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env = env;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        printer.mapLine(e, sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            context.parenthesedExpression.push(e);\n            printer.write(\"(\");\n        }\n        if (!e.getTypeCasts().isEmpty()) {\n            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {\n                printer.write(\"(\");\n                this.scan(r);\n                printer.write(\") \");\n                printer.write(\"(\");\n                context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(s, sourceCompilationUnit);\n        elementPrinterHelper.writeAnnotations(s);\n        if (s.getLabel() != null) {\n            printer.write(s.getLabel()).write(\" : \");\n        }\n    }\n\n    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        while ((context.parenthesedExpression.size() > 0) && (e == context.parenthesedExpression.peek())) {\n            context.parenthesedExpression.pop();\n            printer.write(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeImports(spoon.reflect.declaration.CtType<?> type) {\n        context.currentTopLevel = type;\n        return importsContext.computeAllImports(context.currentTopLevel);\n    }\n\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (env.isAutoImports()) {\n            importsContext.computeImports(element);\n        }\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e != null) {\n            context.elementStack.push(e);\n            if (env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    printer.adjustStartPosition(e);\n                }\n            }\n            e.accept(this);\n            context.elementStack.pop();\n        }\n        return this;\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.reference.CtReference ref) {\n        if (ref != null) {\n            ref.accept(this);\n        }\n        return this;\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {\n        if (e.getTypeCasts().size() != 0) {\n            return true;\n        }\n        try {\n            if ((e.getParent() instanceof spoon.reflect.code.CtBinaryOperator) || (e.getParent() instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if (e.getParent() instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {\n        elementPrinterHelper.writeAnnotations(annotation);\n        printer.write(\"@\");\n        scan(annotation.getAnnotationType());\n        if (annotation.getValues().size() > 0) {\n            printer.write(\"(\");\n            for (java.util.Map.Entry<java.lang.String, spoon.reflect.code.CtExpression> e : annotation.getValues().entrySet()) {\n                printer.write(e.getKey() + \" = \");\n                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\")\");\n        }\n        printer.writeln().writeTabs();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        visitCtType(annotationType);\n        printer.write((\"@interface \" + annotationType.getSimpleName()) + \" {\").incTab();\n        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        elementPrinterHelper.writeComment(impl);\n        elementPrinterHelper.writeAnnotations(impl);\n        elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        printer.write(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        printer.write(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!context.skipArray()) {\n            printer.write(\"[]\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {\n        enterCtStatement(asserted);\n        printer.write(\"assert \");\n        scan(asserted.getAssertExpression());\n        if (asserted.getExpression() != null) {\n            printer.write(\" : \");\n            scan(asserted.getExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        printer.write(\" = \");\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        printer.write(\" \").writeOperator(operator.getKind()).write(\" \");\n        scan(operator.getRightHandOperand());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {\n        enterCtStatement(block);\n        if (!block.isImplicit()) {\n            printer.write(\"{\");\n        }\n        printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!statement.isImplicit()) {\n                printer.writeln().writeTabs();\n                elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        printer.decTab();\n        printer.adjustEndPosition(block);\n        if (env.isPreserveLineNumbers()) {\n            if (!block.isImplicit()) {\n                printer.writeTabs().write(\"}\");\n            }\n        } else {\n            printer.writeln().writeTabs();\n            if (!block.isImplicit()) {\n                printer.write(\"}\");\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        printer.write(\"break\");\n        if (breakStatement.getTargetLabel() != null) {\n            printer.write(\" \" + breakStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {\n        enterCtStatement(caseStatement);\n        if (caseStatement.getCaseExpression() != null) {\n            printer.write(\"case \");\n            if (caseStatement.getCaseExpression() instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                if (((variable.getType() != null) && (variable.getDeclaringType() != null)) && variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName())) {\n                    printer.write(variable.getSimpleName());\n                } else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            } else {\n                scan(caseStatement.getCaseExpression());\n            }\n        } else {\n            printer.write(\"default\");\n        }\n        printer.write(\" :\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            printer.writeln().writeTabs();\n            elementPrinterHelper.writeStatement(statement);\n        }\n        printer.decTab();\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.write(\" catch (\");\n        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();\n        if (parameter.getMultiTypes().size() > 0) {\n            for (int i = 0; i < parameter.getMultiTypes().size(); i++) {\n                spoon.reflect.reference.CtTypeReference<?> type = parameter.getMultiTypes().get(i);\n                scan(type);\n                if (i < (parameter.getMultiTypes().size() - 1)) {\n                    printer.write(\" | \");\n                }\n            }\n            printer.write(\" \" + parameter.getSimpleName());\n        } else {\n            scan(parameter);\n        }\n        printer.write(\") \");\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        context.pushCurrentThis(ctClass);\n        if (((ctClass.getSimpleName() != null) && (!spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()))) && (!ctClass.isAnonymous())) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                printer.write(\"class \" + ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(\"class \" + ctClass.getSimpleName());\n            }\n            elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            elementPrinterHelper.writeExtendsClause(ctClass);\n            elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        printer.adjustEndPosition(ctClass).decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        visitCtTypeParameterReference(typeParameter.getReference());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();\n        boolean parent;\n        try {\n            parent = (conditional.getParent() instanceof spoon.reflect.code.CtAssignment) || (conditional.getParent() instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            parent = false;\n        }\n        if (parent) {\n            printer.write(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            printer.write(\")\");\n        }\n        printer.write(\" ? \");\n        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();\n        scan(thenExpression);\n        printer.write(\" : \");\n        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();\n        boolean isAssign = false;\n        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            printer.write(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            printer.write(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {\n        elementPrinterHelper.writeComment(constructor);\n        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(constructor);\n        elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (constructor.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        if (constructor.getDeclaringType() != null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                printer.write(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        elementPrinterHelper.writeExecutableParameters(constructor);\n        elementPrinterHelper.writeThrowsClause(constructor);\n        printer.write(\" \");\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        printer.write(\"continue\");\n        if (continueStatement.getTargetLabel() != null) {\n            printer.write(\" \" + continueStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        printer.write(\"do\");\n        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        printer.write(\"while (\");\n        scan(doLoop.getLoopingExpression());\n        printer.write(\" )\");\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        visitCtType(ctEnum);\n        printer.write(\"enum \" + ctEnum.getSimpleName());\n        elementPrinterHelper.writeImplementsClause(ctEnum);\n        context.pushCurrentThis(ctEnum);\n        printer.write(\" {\").incTab().writeln();\n        if (ctEnum.getEnumValues().size() == 0) {\n            printer.writeTabs().write(\";\").writeln();\n        } else {\n            for (spoon.reflect.declaration.CtEnumValue<?> enumValue : ctEnum.getEnumValues()) {\n                scan(enumValue);\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\";\");\n        }\n        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        printer.write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {\n        elementPrinterHelper.writeComment(f);\n        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        printer.write(\" \");\n        printer.write(f.getSimpleName());\n        if (f.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(f.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n        printer.write(enumValue.getSimpleName());\n        if (enumValue.getDefaultExpression() != null) {\n            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));\n            if (constructorCall.getArguments().size() > 0) {\n                printer.write(\"(\");\n                boolean first = true;\n                for (spoon.reflect.code.CtExpression<?> ctexpr : constructorCall.getArguments()) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        printer.write(\",\");\n                    }\n                    scan(ctexpr);\n                }\n                printer.write(\")\");\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {\n        enterCtExpression(f);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (f.getVariable().isStatic() && (f.getTarget() instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression<?> target = f.getTarget();\n            if (target != null) {\n                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField = f.getVariable().isStatic();\n                boolean isImportedField = importsContext.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {\n                    if (target.isImplicit()) {\n                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();\n                        final java.lang.String fieldName = field.getSimpleName();\n                        spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                        if (var != field) {\n                            target.setImplicit(false);\n                        }\n                    }\n                    printer.snapshotLength();\n                    scan(target);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent = targetExp.getParent();\n            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        if ((((((parent instanceof spoon.reflect.code.CtFieldWrite) && targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget())) && (anonymousParent != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable() != null)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();\n            if (thisAccess.isImplicit()) {\n                return;\n            }\n            if ((targetType == null) || ((thisAccess.getParent(spoon.reflect.declaration.CtType.class) != null) && thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel())) {\n                printer.write(\"this\");\n                return;\n            }\n            if (targetType.isAnonymous()) {\n                printer.write(\"this\");\n                return;\n            }\n            if (!context.currentThis.isEmpty()) {\n                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();\n                if (!lastTypeQualifiedName.equals(targetTypeQualifiedName)) {\n                    printer.snapshotLength();\n                    visitCtTypeReferenceWithoutGenerics(targetType);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                    printer.write(\"this\");\n                    return;\n                }\n            }\n            printer.write(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {\n        enterCtExpression(f);\n        if (f.getTarget() != null) {\n            scan(f.getTarget());\n            printer.write(\".\");\n        }\n        printer.write(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n        printer.write(spoon.reflect.code.CtJavaDocTag.JAVADOC_TAG_PREFIX);\n        printer.write(docTag.getType().name().toLowerCase());\n        printer.write(\" \");\n        if (docTag.getType().hasParam()) {\n            printer.write(docTag.getParam()).writeln().writeTabs();\n        }\n        java.lang.String[] tagLines = docTag.getContent().split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n        for (int i = 0; i < tagLines.length; i++) {\n            java.lang.String com = tagLines[i];\n            if ((i > 0) || docTag.getType().hasParam()) {\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n            }\n            if (docTag.getType().hasParam()) {\n                printer.write(\"\\t\\t\");\n            }\n            printer.write(com.trim()).writeln().writeTabs();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!env.isCommentsEnabled()) && (context.elementStack.size() > 1)) {\n            return;\n        }\n        switch (comment.getCommentType()) {\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln().writeTabs();\n                break;\n            case INLINE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.INLINE_COMMENT_START);\n                break;\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_START);\n                break;\n        }\n        java.lang.String content = comment.getContent();\n        switch (comment.getCommentType()) {\n            case INLINE :\n                printer.write(content);\n                break;\n            default :\n                java.lang.String[] lines = content.split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n                for (int i = 0; i < lines.length; i++) {\n                    java.lang.String com = lines[i];\n                    if (comment.getCommentType() == spoon.reflect.code.CtComment.CommentType.BLOCK) {\n                        printer.write(com);\n                        if (lines.length > 1) {\n                            printer.writeln().writeTabs();\n                        }\n                    } else if (com.length() > 0) {\n                        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR + com).writeln().writeTabs();\n                    } else {\n                        printer.write(\" *\" + com).writeln().writeTabs();\n                    }\n                }\n                if (comment instanceof spoon.reflect.code.CtJavaDoc) {\n                    if (!((spoon.reflect.code.CtJavaDoc) (comment)).getTags().isEmpty()) {\n                        printer.write(\" *\").writeln().writeTabs();\n                    }\n                    for (spoon.reflect.code.CtJavaDocTag docTag : ((spoon.reflect.code.CtJavaDoc) (comment)).getTags()) {\n                        scan(docTag);\n                    }\n                }\n                break;\n        }\n        switch (comment.getCommentType()) {\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (annotationFieldAccess.getTarget() != null) {\n                scan(annotationFieldAccess.getTarget());\n                printer.write(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            printer.write(\"()\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        boolean isStatic = reference.getSimpleName().equals(\"class\") || ((!reference.getSimpleName().equals(\"super\")) && reference.isStatic());\n        boolean printType = true;\n        if (reference.isFinal() && reference.isStatic()) {\n            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                printType = false;\n            } else if (context.isInCurrentScope(declTypeRef)) {\n                printType = false;\n            }\n        }\n        if ((isStatic && printType) && (!context.ignoreStaticAccess())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            printer.write(\".\");\n        }\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        printer.write(\"for (\");\n        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();\n        if (st.size() > 0) {\n            scan(st.get(0));\n        }\n        if (st.size() > 1) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().noTypeDecl(true)) {\n                for (int i = 1; i < st.size(); i++) {\n                    printer.write(\", \");\n                    scan(st.get(i));\n                }\n            }\n        }\n        printer.write(\"; \");\n        scan(forLoop.getExpression());\n        printer.write(\";\");\n        if (!forLoop.getForUpdate().isEmpty()) {\n            printer.write(\" \");\n        }\n        for (spoon.reflect.code.CtStatement s : forLoop.getForUpdate()) {\n            scan(s);\n            printer.write(\" , \");\n        }\n        if (forLoop.getForUpdate().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        printer.write(\"for (\");\n        scan(foreach.getVariable());\n        printer.write(\" : \");\n        scan(foreach.getExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        printer.write(\"if (\");\n        scan(ifElement.getCondition());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if (ifElement.getElseStatement() != null) {\n            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition() == null) ? ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition() : ifElement.getThenStatement().getPosition();\n                if (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd()) {\n                    elementPrinterHelper.writeComment(comment);\n                }\n            }\n            printer.write(\"else\");\n            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        visitCtType(intrface);\n        printer.write(\"interface \" + intrface.getSimpleName());\n        if (intrface.getFormalCtTypeParameters() != null) {\n            elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (intrface.getSuperInterfaces().size() > 0) {\n            printer.write(\" extends \");\n            for (spoon.reflect.reference.CtTypeReference<?> ref : intrface.getSuperInterfaces()) {\n                scan(ref);\n                printer.write(\" , \");\n            }\n            printer.removeLastChar();\n        }\n        context.pushCurrentThis(intrface);\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType<?> parentType;\n            try {\n                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType = null;\n            }\n            if (((parentType != null) && (parentType.getQualifiedName() != null)) && parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName())) {\n                printer.write(\"this\");\n            } else {\n                printer.snapshotLength();\n                scan(invocation.getTarget());\n                if (printer.hasNewContent()) {\n                    printer.write(\".\");\n                }\n                printer.write(\"super\");\n            }\n        } else {\n            printer.snapshotLength();\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                if (invocation.getTarget() instanceof spoon.reflect.code.CtTypeAccess) {\n                    _context.ignoreGenerics(true);\n                }\n                scan(invocation.getTarget());\n            }\n            if (printer.hasNewContent()) {\n                printer.write(\".\");\n            }\n            elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (env.isPreserveLineNumbers()) {\n                printer.adjustStartPosition(invocation);\n            }\n            printer.write(invocation.getExecutable().getSimpleName());\n        }\n        printer.write(\"(\");\n        boolean remove = false;\n        for (spoon.reflect.code.CtExpression<?> e : invocation.getArguments()) {\n            scan(e);\n            printer.write(\", \");\n            remove = true;\n        }\n        if (remove) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        exitCtExpression(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {\n        enterCtExpression(literal);\n        if (literal.getValue() == null) {\n            printer.write(\"null\");\n        } else if (literal.getValue() instanceof java.lang.Long) {\n            printer.write(literal.getValue() + \"L\");\n        } else if (literal.getValue() instanceof java.lang.Float) {\n            printer.write(literal.getValue() + \"F\");\n        } else if (literal.getValue() instanceof java.lang.Character) {\n            printer.write(\"'\");\n            boolean mayContainsSpecialCharacter = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacter = stringLength != 1;\n            }\n            printer.writeStringLiteral(new java.lang.String(new char[]{ ((java.lang.Character) (literal.getValue())) }), mayContainsSpecialCharacter);\n            printer.write(\"'\");\n        } else if (literal.getValue() instanceof java.lang.String) {\n            printer.write('\\\"');\n            boolean mayContainsSpecialCharacters = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacters = ((java.lang.String) (literal.getValue())).length() != stringLength;\n            }\n            printer.writeStringLiteral(((java.lang.String) (literal.getValue())), mayContainsSpecialCharacters);\n            printer.write('\\\"');\n        } else if (literal.getValue() instanceof java.lang.Class) {\n            printer.write(((java.lang.Class<?>) (literal.getValue())).getName());\n        } else {\n            printer.write(literal.getValue().toString());\n        }\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {\n        if (!context.noTypeDecl()) {\n            enterCtStatement(localVariable);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(localVariable);\n        }\n        if (!context.noTypeDecl()) {\n            elementPrinterHelper.writeModifiers(localVariable);\n            scan(localVariable.getType());\n            printer.write(\" \");\n        }\n        printer.write(localVariable.getSimpleName());\n        if (localVariable.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(localVariable.getDefaultExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(catchVariable);\n        }\n        elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        printer.write(\" \");\n        printer.write(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {\n        elementPrinterHelper.writeComment(m);\n        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(m);\n        if (m.isDefaultMethod()) {\n            printer.write(\"default \");\n        }\n        elementPrinterHelper.writeFormalTypeParameters(m);\n        if (m.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        printer.write(\" \");\n        printer.write(m.getSimpleName());\n        elementPrinterHelper.writeExecutableParameters(m);\n        elementPrinterHelper.writeThrowsClause(m);\n        if (m.getBody() != null) {\n            printer.write(\" \");\n            scan(m.getBody());\n            if (m.getBody().getPosition() != null) {\n                if (m.getBody().getPosition().getCompilationUnit() == sourceCompilationUnit) {\n                    if (m.getBody().getStatements().isEmpty() || (!(m.getBody().getStatements().get(m.getBody().getStatements().size() - 1) instanceof spoon.reflect.code.CtReturn))) {\n                        printer.putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                } else {\n                    printer.undefineLine();\n                }\n            } else {\n                printer.undefineLine();\n            }\n        } else {\n            printer.write(\";\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n        elementPrinterHelper.writeComment(annotationMethod);\n        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        printer.write(\" \");\n        printer.write(annotationMethod.getSimpleName());\n        printer.write(\"()\");\n        if (annotationMethod.getDefaultExpression() != null) {\n            printer.write(\" default \");\n            scan(annotationMethod.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation = (newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class) == null) && (newArray.getParent(spoon.reflect.declaration.CtAnnotation.class) == null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation = true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();\n            if (ref != null) {\n                printer.write(\"new \");\n            }\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                printer.write(\"[\");\n                if (newArray.getDimensionExpressions().size() > i) {\n                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                printer.write(\"]\");\n                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().size() == 0) {\n            printer.write(\"{ \");\n            java.util.List<spoon.reflect.code.CtExpression<?>> l_elements = newArray.getElements();\n            for (int i = 0; i < l_elements.size(); i++) {\n                spoon.reflect.code.CtExpression e = l_elements.get(i);\n                scan(e);\n                printer.write(\" , \");\n                if ((i + 1) == l_elements.size()) {\n                    printer.removeLastChar();\n                    java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n                    if ((!comments.isEmpty()) && (comments.get(comments.size() - 1).getCommentType() == spoon.reflect.code.CtComment.CommentType.INLINE)) {\n                        printer.writeln();\n                    }\n                }\n            }\n            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            printer.write(\" }\");\n        }\n        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n    }\n\n    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (ctConstructorCall.getTarget() != null) {\n                scan(ctConstructorCall.getTarget());\n                printer.write(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            printer.write(\"new \");\n            if (ctConstructorCall.getActualTypeArguments().size() > 0) {\n                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        printer.write(\"(\");\n        for (spoon.reflect.code.CtCodeElement exp : ctConstructorCall.getArguments()) {\n            scan(exp);\n            printer.write(\", \");\n        }\n        if (ctConstructorCall.getArguments().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n    }\n\n    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (reference == null) {\n            return false;\n        }\n        if (reference.getDeclaringType() == null) {\n            return false;\n        }\n        if (reference.isLocalType()) {\n            return false;\n        }\n        if (reference.getDeclaringType().getActualTypeArguments().size() != 0) {\n            return true;\n        }\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {\n        enterCtExpression(lambda);\n        printer.write(\"(\");\n        if (lambda.getParameters().size() > 0) {\n            for (spoon.reflect.declaration.CtParameter<?> parameter : lambda.getParameters()) {\n                scan(parameter);\n                printer.write(\",\");\n            }\n            printer.removeLastChar();\n        }\n        printer.write(\") -> \");\n        if (lambda.getBody() != null) {\n            scan(lambda.getBody());\n        } else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n        enterCtExpression(expression);\n        scan(expression.getTarget());\n        printer.write(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            printer.write(\"new\");\n        } else {\n            printer.write(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        printer.write(\" \");\n        printer.writeOperator(assignment.getKind());\n        printer.write(\"= \");\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!ctPackage.isUnnamedPackage()) {\n            printer.write((\"package \" + ctPackage.getQualifiedName()) + \";\");\n        } else {\n            printer.write(\"// default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)\\n\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {\n        elementPrinterHelper.writeComment(parameter);\n        elementPrinterHelper.writeAnnotations(parameter);\n        elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());\n            printer.write(\"...\");\n        } else {\n            scan(parameter.getType());\n        }\n        printer.write(\" \");\n        printer.write(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {\n        enterCtStatement(returnStatement);\n        printer.write(\"return \");\n        scan(returnStatement.getReturnedExpression());\n    }\n\n    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {\n        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(type, sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            context.currentTopLevel = type;\n        }\n        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {\n        enterCtStatement(switchStatement);\n        printer.write(\"switch (\");\n        scan(switchStatement.getSelector());\n        printer.write(\") {\").incTab();\n        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {\n            printer.writeln().writeTabs();\n            scan(c);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.decTab().write(\"}\");\n        } else {\n            printer.decTab().writeln().writeTabs().write(\"}\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        printer.write(\"synchronized\");\n        if (synchro.getExpression() != null) {\n            printer.write(\"(\");\n            scan(synchro.getExpression());\n            printer.write(\") \");\n        }\n        scan(synchro.getBlock());\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        printer.write(\"throw \");\n        scan(throwStatement.getThrownExpression());\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        printer.write(\"try \");\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if (tryBlock.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryBlock.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        printer.write(\"try \");\n        if ((tryWithResource.getResources() != null) && (!tryWithResource.getResources().isEmpty())) {\n            printer.write(\"(\");\n            for (spoon.reflect.code.CtLocalVariable<?> r : tryWithResource.getResources()) {\n                scan(r);\n                printer.write(\";\");\n            }\n            printer.removeLastChar();\n            printer.write(\") \");\n        }\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if (tryWithResource.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryWithResource.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n        if (ref.getBoundingType() != null) {\n            if (ref.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(ref.getBoundingType());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        visitCtTypeParameterReference(wildcardReference);\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (importsContext.isImported(ref) || ((this.env.isAutoImports() && (ref.getPackage() != null)) && ref.getPackage().getSimpleName().equals(\"java.lang\"))) {\n            for (spoon.reflect.visitor.TypeContext typeContext : context.currentThis) {\n                if (typeContext.getSimpleName().equals(ref.getSimpleName()) && (!java.util.Objects.equals(typeContext.getPackage(), ref.getPackage()))) {\n                    return true;\n                }\n                if (typeContext.isNameConflict(ref.getSimpleName())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n        for (spoon.reflect.reference.CtTypeReference<?> bound : reference.getBounds()) {\n            scan(bound);\n            printer.write(\" & \");\n        }\n        printer.removeLastChar();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n            return;\n        }\n        boolean isInner = ref.getDeclaringType() != null;\n        if (isInner) {\n            if ((!context.ignoreEnclosingClass()) && (!ref.isLocalType())) {\n                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();\n                if (!accessType.isAnonymous()) {\n                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    printer.write(\".\");\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                printer.write(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(ref.getSimpleName());\n            }\n        } else {\n            if ((ref.getPackage() != null) && printQualified(ref)) {\n                if (!ref.getPackage().isUnnamedPackage()) {\n                    scan(ref.getPackage());\n                    printer.write(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n        }\n        if (withGenerics && (!context.ignoreGenerics())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {\n                elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        printer.preWriteUnaryOperator(operator.getKind());\n        scan(operator.getOperand());\n        printer.postWriteUnaryOperator(operator.getKind());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {\n        enterCtExpression(variableRead);\n        printer.write(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n        enterCtExpression(variableWrite);\n        printer.write(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        printer.write(\"while (\");\n        scan(whileLoop.getLoopingExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n        elementPrinterHelper.writeComment(expression);\n        printer.write(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        elementPrinterHelper.writeComment(statement);\n        printer.write(statement.getValue());\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return context;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String getPackageDeclaration() {\n        return printPackageInfo(context.currentTopLevel.getPackage());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        spoon.reflect.visitor.PrinterHelper bck = printer;\n        spoon.reflect.visitor.ElementPrinterHelper bck2 = elementPrinterHelper;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        elementPrinterHelper.writeComment(pack);\n        for (spoon.reflect.declaration.CtAnnotation<?> a : pack.getAnnotations()) {\n            a.accept(this);\n        }\n        if (!pack.isUnnamedPackage()) {\n            printer.write((\"package \" + pack.getQualifiedName()) + \";\");\n        }\n        java.lang.String ret = printer.toString();\n        elementPrinterHelper = bck2;\n        printer = bck;\n        return ret;\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public void reset() {\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper.setPrinter(printer);\n        context = new spoon.reflect.visitor.PrintingContext();\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {\n        this.sourceCompilationUnit = sourceCompilationUnit;\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n        java.util.Set<spoon.reflect.reference.CtReference> imports = new java.util.HashSet<>();\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            imports.addAll(computeImports(t));\n        }\n        elementPrinterHelper.writeHeader(types, imports);\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            scan(t);\n            if (!env.isPreserveLineNumbers()) {\n                printer.writeln().writeln().writeTabs();\n            } else {\n                printer.adjustEndPosition(t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {\n        return printer.getLineNumberMapping();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@java.lang.Override\npublic void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n    if (ref.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(ref);\n    if (printQualified(ref)) {\n        printer.write(ref.getQualifiedName());\n    } else {\n        printer.write(ref.getSimpleName());\n    }\n}",
            "dst_parent": "public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    public static final java.lang.String JAVA_FILE_EXTENSION = \".java\";\n\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION = \"package-info\" + spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION;\n\n    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty(\"line.separator\");\n\n    public static final java.lang.String COMMENT_STAR = \" * \";\n\n    public static final java.lang.String BLOCK_COMMENT_END = \" */\";\n\n    public static final java.lang.String JAVADOC_START = \"/**\";\n\n    public static final java.lang.String INLINE_COMMENT_START = \"// \";\n\n    public static final java.lang.String BLOCK_COMMENT_START = \"/* \";\n\n    public spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();\n\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    private spoon.compiler.Environment env;\n\n    private spoon.reflect.visitor.PrinterHelper printer;\n\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    private spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env = env;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        printer.mapLine(e, sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            context.parenthesedExpression.push(e);\n            printer.write(\"(\");\n        }\n        if (!e.getTypeCasts().isEmpty()) {\n            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {\n                printer.write(\"(\");\n                this.scan(r);\n                printer.write(\") \");\n                printer.write(\"(\");\n                context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(s, sourceCompilationUnit);\n        elementPrinterHelper.writeAnnotations(s);\n        if (s.getLabel() != null) {\n            printer.write(s.getLabel()).write(\" : \");\n        }\n    }\n\n    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        while ((context.parenthesedExpression.size() > 0) && (e == context.parenthesedExpression.peek())) {\n            context.parenthesedExpression.pop();\n            printer.write(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeImports(spoon.reflect.declaration.CtType<?> type) {\n        context.currentTopLevel = type;\n        return importsContext.computeAllImports(context.currentTopLevel);\n    }\n\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (env.isAutoImports()) {\n            importsContext.computeImports(element);\n        }\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e != null) {\n            context.elementStack.push(e);\n            if (env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    printer.adjustStartPosition(e);\n                }\n            }\n            e.accept(this);\n            context.elementStack.pop();\n        }\n        return this;\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.reference.CtReference ref) {\n        if (ref != null) {\n            ref.accept(this);\n        }\n        return this;\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {\n        if (e.getTypeCasts().size() != 0) {\n            return true;\n        }\n        try {\n            if ((e.getParent() instanceof spoon.reflect.code.CtBinaryOperator) || (e.getParent() instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if (e.getParent() instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {\n        elementPrinterHelper.writeAnnotations(annotation);\n        printer.write(\"@\");\n        scan(annotation.getAnnotationType());\n        if (annotation.getValues().size() > 0) {\n            printer.write(\"(\");\n            for (java.util.Map.Entry<java.lang.String, spoon.reflect.code.CtExpression> e : annotation.getValues().entrySet()) {\n                printer.write(e.getKey() + \" = \");\n                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\")\");\n        }\n        printer.writeln().writeTabs();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        visitCtType(annotationType);\n        printer.write((\"@interface \" + annotationType.getSimpleName()) + \" {\").incTab();\n        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        elementPrinterHelper.writeComment(impl);\n        elementPrinterHelper.writeAnnotations(impl);\n        elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        printer.write(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        printer.write(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!context.skipArray()) {\n            printer.write(\"[]\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {\n        enterCtStatement(asserted);\n        printer.write(\"assert \");\n        scan(asserted.getAssertExpression());\n        if (asserted.getExpression() != null) {\n            printer.write(\" : \");\n            scan(asserted.getExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        printer.write(\" = \");\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        printer.write(\" \").writeOperator(operator.getKind()).write(\" \");\n        scan(operator.getRightHandOperand());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {\n        enterCtStatement(block);\n        if (!block.isImplicit()) {\n            printer.write(\"{\");\n        }\n        printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!statement.isImplicit()) {\n                printer.writeln().writeTabs();\n                elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        printer.decTab();\n        printer.adjustEndPosition(block);\n        if (env.isPreserveLineNumbers()) {\n            if (!block.isImplicit()) {\n                printer.writeTabs().write(\"}\");\n            }\n        } else {\n            printer.writeln().writeTabs();\n            if (!block.isImplicit()) {\n                printer.write(\"}\");\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        printer.write(\"break\");\n        if (breakStatement.getTargetLabel() != null) {\n            printer.write(\" \" + breakStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {\n        enterCtStatement(caseStatement);\n        if (caseStatement.getCaseExpression() != null) {\n            printer.write(\"case \");\n            if (caseStatement.getCaseExpression() instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                if (((variable.getType() != null) && (variable.getDeclaringType() != null)) && variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName())) {\n                    printer.write(variable.getSimpleName());\n                } else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            } else {\n                scan(caseStatement.getCaseExpression());\n            }\n        } else {\n            printer.write(\"default\");\n        }\n        printer.write(\" :\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            printer.writeln().writeTabs();\n            elementPrinterHelper.writeStatement(statement);\n        }\n        printer.decTab();\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.write(\" catch (\");\n        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();\n        if (parameter.getMultiTypes().size() > 0) {\n            for (int i = 0; i < parameter.getMultiTypes().size(); i++) {\n                spoon.reflect.reference.CtTypeReference<?> type = parameter.getMultiTypes().get(i);\n                scan(type);\n                if (i < (parameter.getMultiTypes().size() - 1)) {\n                    printer.write(\" | \");\n                }\n            }\n            printer.write(\" \" + parameter.getSimpleName());\n        } else {\n            scan(parameter);\n        }\n        printer.write(\") \");\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        context.pushCurrentThis(ctClass);\n        if (((ctClass.getSimpleName() != null) && (!spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()))) && (!ctClass.isAnonymous())) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                printer.write(\"class \" + ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(\"class \" + ctClass.getSimpleName());\n            }\n            elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            elementPrinterHelper.writeExtendsClause(ctClass);\n            elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        printer.adjustEndPosition(ctClass).decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        spoon.reflect.reference.CtTypeParameterReference ref = typeParameter.getReference();\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n        if (ref.getBoundingType() != null) {\n            if (ref.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(ref.getBoundingType());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();\n        boolean parent;\n        try {\n            parent = (conditional.getParent() instanceof spoon.reflect.code.CtAssignment) || (conditional.getParent() instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            parent = false;\n        }\n        if (parent) {\n            printer.write(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            printer.write(\")\");\n        }\n        printer.write(\" ? \");\n        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();\n        scan(thenExpression);\n        printer.write(\" : \");\n        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();\n        boolean isAssign = false;\n        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            printer.write(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            printer.write(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {\n        elementPrinterHelper.writeComment(constructor);\n        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(constructor);\n        elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (constructor.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        if (constructor.getDeclaringType() != null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                printer.write(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        elementPrinterHelper.writeExecutableParameters(constructor);\n        elementPrinterHelper.writeThrowsClause(constructor);\n        printer.write(\" \");\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        printer.write(\"continue\");\n        if (continueStatement.getTargetLabel() != null) {\n            printer.write(\" \" + continueStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        printer.write(\"do\");\n        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        printer.write(\"while (\");\n        scan(doLoop.getLoopingExpression());\n        printer.write(\" )\");\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        visitCtType(ctEnum);\n        printer.write(\"enum \" + ctEnum.getSimpleName());\n        elementPrinterHelper.writeImplementsClause(ctEnum);\n        context.pushCurrentThis(ctEnum);\n        printer.write(\" {\").incTab().writeln();\n        if (ctEnum.getEnumValues().size() == 0) {\n            printer.writeTabs().write(\";\").writeln();\n        } else {\n            for (spoon.reflect.declaration.CtEnumValue<?> enumValue : ctEnum.getEnumValues()) {\n                scan(enumValue);\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\";\");\n        }\n        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        printer.write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {\n        elementPrinterHelper.writeComment(f);\n        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        printer.write(\" \");\n        printer.write(f.getSimpleName());\n        if (f.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(f.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n        printer.write(enumValue.getSimpleName());\n        if (enumValue.getDefaultExpression() != null) {\n            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));\n            if (constructorCall.getArguments().size() > 0) {\n                printer.write(\"(\");\n                boolean first = true;\n                for (spoon.reflect.code.CtExpression<?> ctexpr : constructorCall.getArguments()) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        printer.write(\",\");\n                    }\n                    scan(ctexpr);\n                }\n                printer.write(\")\");\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {\n        enterCtExpression(f);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (f.getVariable().isStatic() && (f.getTarget() instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression<?> target = f.getTarget();\n            if (target != null) {\n                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField = f.getVariable().isStatic();\n                boolean isImportedField = importsContext.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {\n                    if (target.isImplicit()) {\n                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();\n                        final java.lang.String fieldName = field.getSimpleName();\n                        spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                        if (var != field) {\n                            target.setImplicit(false);\n                        }\n                    }\n                    printer.snapshotLength();\n                    scan(target);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent = targetExp.getParent();\n            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        if ((((((parent instanceof spoon.reflect.code.CtFieldWrite) && targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget())) && (anonymousParent != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable() != null)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();\n            if (thisAccess.isImplicit()) {\n                return;\n            }\n            if ((targetType == null) || ((thisAccess.getParent(spoon.reflect.declaration.CtType.class) != null) && thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel())) {\n                printer.write(\"this\");\n                return;\n            }\n            if (targetType.isAnonymous()) {\n                printer.write(\"this\");\n                return;\n            }\n            if (!context.currentThis.isEmpty()) {\n                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();\n                if (!lastTypeQualifiedName.equals(targetTypeQualifiedName)) {\n                    printer.snapshotLength();\n                    visitCtTypeReferenceWithoutGenerics(targetType);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                    printer.write(\"this\");\n                    return;\n                }\n            }\n            printer.write(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {\n        enterCtExpression(f);\n        if (f.getTarget() != null) {\n            scan(f.getTarget());\n            printer.write(\".\");\n        }\n        printer.write(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n        printer.write(spoon.reflect.code.CtJavaDocTag.JAVADOC_TAG_PREFIX);\n        printer.write(docTag.getType().name().toLowerCase());\n        printer.write(\" \");\n        if (docTag.getType().hasParam()) {\n            printer.write(docTag.getParam()).writeln().writeTabs();\n        }\n        java.lang.String[] tagLines = docTag.getContent().split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n        for (int i = 0; i < tagLines.length; i++) {\n            java.lang.String com = tagLines[i];\n            if ((i > 0) || docTag.getType().hasParam()) {\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n            }\n            if (docTag.getType().hasParam()) {\n                printer.write(\"\\t\\t\");\n            }\n            printer.write(com.trim()).writeln().writeTabs();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!env.isCommentsEnabled()) && (context.elementStack.size() > 1)) {\n            return;\n        }\n        switch (comment.getCommentType()) {\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln().writeTabs();\n                break;\n            case INLINE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.INLINE_COMMENT_START);\n                break;\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_START);\n                break;\n        }\n        java.lang.String content = comment.getContent();\n        switch (comment.getCommentType()) {\n            case INLINE :\n                printer.write(content);\n                break;\n            default :\n                java.lang.String[] lines = content.split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n                for (int i = 0; i < lines.length; i++) {\n                    java.lang.String com = lines[i];\n                    if (comment.getCommentType() == spoon.reflect.code.CtComment.CommentType.BLOCK) {\n                        printer.write(com);\n                        if (lines.length > 1) {\n                            printer.writeln().writeTabs();\n                        }\n                    } else if (com.length() > 0) {\n                        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR + com).writeln().writeTabs();\n                    } else {\n                        printer.write(\" *\" + com).writeln().writeTabs();\n                    }\n                }\n                if (comment instanceof spoon.reflect.code.CtJavaDoc) {\n                    if (!((spoon.reflect.code.CtJavaDoc) (comment)).getTags().isEmpty()) {\n                        printer.write(\" *\").writeln().writeTabs();\n                    }\n                    for (spoon.reflect.code.CtJavaDocTag docTag : ((spoon.reflect.code.CtJavaDoc) (comment)).getTags()) {\n                        scan(docTag);\n                    }\n                }\n                break;\n        }\n        switch (comment.getCommentType()) {\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (annotationFieldAccess.getTarget() != null) {\n                scan(annotationFieldAccess.getTarget());\n                printer.write(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            printer.write(\"()\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        boolean isStatic = reference.getSimpleName().equals(\"class\") || ((!reference.getSimpleName().equals(\"super\")) && reference.isStatic());\n        boolean printType = true;\n        if (reference.isFinal() && reference.isStatic()) {\n            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                printType = false;\n            } else if (context.isInCurrentScope(declTypeRef)) {\n                printType = false;\n            }\n        }\n        if ((isStatic && printType) && (!context.ignoreStaticAccess())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            printer.write(\".\");\n        }\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        printer.write(\"for (\");\n        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();\n        if (st.size() > 0) {\n            scan(st.get(0));\n        }\n        if (st.size() > 1) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().noTypeDecl(true)) {\n                for (int i = 1; i < st.size(); i++) {\n                    printer.write(\", \");\n                    scan(st.get(i));\n                }\n            }\n        }\n        printer.write(\"; \");\n        scan(forLoop.getExpression());\n        printer.write(\";\");\n        if (!forLoop.getForUpdate().isEmpty()) {\n            printer.write(\" \");\n        }\n        for (spoon.reflect.code.CtStatement s : forLoop.getForUpdate()) {\n            scan(s);\n            printer.write(\" , \");\n        }\n        if (forLoop.getForUpdate().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        printer.write(\"for (\");\n        scan(foreach.getVariable());\n        printer.write(\" : \");\n        scan(foreach.getExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        printer.write(\"if (\");\n        scan(ifElement.getCondition());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if (ifElement.getElseStatement() != null) {\n            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition() == null) ? ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition() : ifElement.getThenStatement().getPosition();\n                if (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd()) {\n                    elementPrinterHelper.writeComment(comment);\n                }\n            }\n            printer.write(\"else\");\n            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        visitCtType(intrface);\n        printer.write(\"interface \" + intrface.getSimpleName());\n        if (intrface.getFormalCtTypeParameters() != null) {\n            elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (intrface.getSuperInterfaces().size() > 0) {\n            printer.write(\" extends \");\n            for (spoon.reflect.reference.CtTypeReference<?> ref : intrface.getSuperInterfaces()) {\n                scan(ref);\n                printer.write(\" , \");\n            }\n            printer.removeLastChar();\n        }\n        context.pushCurrentThis(intrface);\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType<?> parentType;\n            try {\n                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType = null;\n            }\n            if (((parentType != null) && (parentType.getQualifiedName() != null)) && parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName())) {\n                printer.write(\"this\");\n            } else {\n                printer.snapshotLength();\n                scan(invocation.getTarget());\n                if (printer.hasNewContent()) {\n                    printer.write(\".\");\n                }\n                printer.write(\"super\");\n            }\n        } else {\n            printer.snapshotLength();\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                if (invocation.getTarget() instanceof spoon.reflect.code.CtTypeAccess) {\n                    _context.ignoreGenerics(true);\n                }\n                scan(invocation.getTarget());\n            }\n            if (printer.hasNewContent()) {\n                printer.write(\".\");\n            }\n            elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (env.isPreserveLineNumbers()) {\n                printer.adjustStartPosition(invocation);\n            }\n            printer.write(invocation.getExecutable().getSimpleName());\n        }\n        printer.write(\"(\");\n        boolean remove = false;\n        for (spoon.reflect.code.CtExpression<?> e : invocation.getArguments()) {\n            scan(e);\n            printer.write(\", \");\n            remove = true;\n        }\n        if (remove) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        exitCtExpression(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {\n        enterCtExpression(literal);\n        if (literal.getValue() == null) {\n            printer.write(\"null\");\n        } else if (literal.getValue() instanceof java.lang.Long) {\n            printer.write(literal.getValue() + \"L\");\n        } else if (literal.getValue() instanceof java.lang.Float) {\n            printer.write(literal.getValue() + \"F\");\n        } else if (literal.getValue() instanceof java.lang.Character) {\n            printer.write(\"'\");\n            boolean mayContainsSpecialCharacter = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacter = stringLength != 1;\n            }\n            printer.writeStringLiteral(new java.lang.String(new char[]{ ((java.lang.Character) (literal.getValue())) }), mayContainsSpecialCharacter);\n            printer.write(\"'\");\n        } else if (literal.getValue() instanceof java.lang.String) {\n            printer.write('\\\"');\n            boolean mayContainsSpecialCharacters = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacters = ((java.lang.String) (literal.getValue())).length() != stringLength;\n            }\n            printer.writeStringLiteral(((java.lang.String) (literal.getValue())), mayContainsSpecialCharacters);\n            printer.write('\\\"');\n        } else if (literal.getValue() instanceof java.lang.Class) {\n            printer.write(((java.lang.Class<?>) (literal.getValue())).getName());\n        } else {\n            printer.write(literal.getValue().toString());\n        }\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {\n        if (!context.noTypeDecl()) {\n            enterCtStatement(localVariable);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(localVariable);\n        }\n        if (!context.noTypeDecl()) {\n            elementPrinterHelper.writeModifiers(localVariable);\n            scan(localVariable.getType());\n            printer.write(\" \");\n        }\n        printer.write(localVariable.getSimpleName());\n        if (localVariable.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(localVariable.getDefaultExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(catchVariable);\n        }\n        elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        printer.write(\" \");\n        printer.write(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {\n        elementPrinterHelper.writeComment(m);\n        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(m);\n        if (m.isDefaultMethod()) {\n            printer.write(\"default \");\n        }\n        elementPrinterHelper.writeFormalTypeParameters(m);\n        if (m.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        printer.write(\" \");\n        printer.write(m.getSimpleName());\n        elementPrinterHelper.writeExecutableParameters(m);\n        elementPrinterHelper.writeThrowsClause(m);\n        if (m.getBody() != null) {\n            printer.write(\" \");\n            scan(m.getBody());\n            if (m.getBody().getPosition() != null) {\n                if (m.getBody().getPosition().getCompilationUnit() == sourceCompilationUnit) {\n                    if (m.getBody().getStatements().isEmpty() || (!(m.getBody().getStatements().get(m.getBody().getStatements().size() - 1) instanceof spoon.reflect.code.CtReturn))) {\n                        printer.putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                } else {\n                    printer.undefineLine();\n                }\n            } else {\n                printer.undefineLine();\n            }\n        } else {\n            printer.write(\";\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n        elementPrinterHelper.writeComment(annotationMethod);\n        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        printer.write(\" \");\n        printer.write(annotationMethod.getSimpleName());\n        printer.write(\"()\");\n        if (annotationMethod.getDefaultExpression() != null) {\n            printer.write(\" default \");\n            scan(annotationMethod.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation = (newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class) == null) && (newArray.getParent(spoon.reflect.declaration.CtAnnotation.class) == null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation = true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();\n            if (ref != null) {\n                printer.write(\"new \");\n            }\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                printer.write(\"[\");\n                if (newArray.getDimensionExpressions().size() > i) {\n                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                printer.write(\"]\");\n                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().size() == 0) {\n            printer.write(\"{ \");\n            java.util.List<spoon.reflect.code.CtExpression<?>> l_elements = newArray.getElements();\n            for (int i = 0; i < l_elements.size(); i++) {\n                spoon.reflect.code.CtExpression e = l_elements.get(i);\n                scan(e);\n                printer.write(\" , \");\n                if ((i + 1) == l_elements.size()) {\n                    printer.removeLastChar();\n                    java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n                    if ((!comments.isEmpty()) && (comments.get(comments.size() - 1).getCommentType() == spoon.reflect.code.CtComment.CommentType.INLINE)) {\n                        printer.writeln();\n                    }\n                }\n            }\n            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            printer.write(\" }\");\n        }\n        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n    }\n\n    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (ctConstructorCall.getTarget() != null) {\n                scan(ctConstructorCall.getTarget());\n                printer.write(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            printer.write(\"new \");\n            if (ctConstructorCall.getActualTypeArguments().size() > 0) {\n                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        printer.write(\"(\");\n        for (spoon.reflect.code.CtCodeElement exp : ctConstructorCall.getArguments()) {\n            scan(exp);\n            printer.write(\", \");\n        }\n        if (ctConstructorCall.getArguments().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n    }\n\n    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (reference == null) {\n            return false;\n        }\n        if (reference.getDeclaringType() == null) {\n            return false;\n        }\n        if (reference.isLocalType()) {\n            return false;\n        }\n        if (reference.getDeclaringType().getActualTypeArguments().size() != 0) {\n            return true;\n        }\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {\n        enterCtExpression(lambda);\n        printer.write(\"(\");\n        if (lambda.getParameters().size() > 0) {\n            for (spoon.reflect.declaration.CtParameter<?> parameter : lambda.getParameters()) {\n                scan(parameter);\n                printer.write(\",\");\n            }\n            printer.removeLastChar();\n        }\n        printer.write(\") -> \");\n        if (lambda.getBody() != null) {\n            scan(lambda.getBody());\n        } else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n        enterCtExpression(expression);\n        scan(expression.getTarget());\n        printer.write(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            printer.write(\"new\");\n        } else {\n            printer.write(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        printer.write(\" \");\n        printer.writeOperator(assignment.getKind());\n        printer.write(\"= \");\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!ctPackage.isUnnamedPackage()) {\n            printer.write((\"package \" + ctPackage.getQualifiedName()) + \";\");\n        } else {\n            printer.write(\"// default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)\\n\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {\n        elementPrinterHelper.writeComment(parameter);\n        elementPrinterHelper.writeAnnotations(parameter);\n        elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());\n            printer.write(\"...\");\n        } else {\n            scan(parameter.getType());\n        }\n        printer.write(\" \");\n        printer.write(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {\n        enterCtStatement(returnStatement);\n        printer.write(\"return \");\n        scan(returnStatement.getReturnedExpression());\n    }\n\n    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {\n        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(type, sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            context.currentTopLevel = type;\n        }\n        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {\n        enterCtStatement(switchStatement);\n        printer.write(\"switch (\");\n        scan(switchStatement.getSelector());\n        printer.write(\") {\").incTab();\n        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {\n            printer.writeln().writeTabs();\n            scan(c);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.decTab().write(\"}\");\n        } else {\n            printer.decTab().writeln().writeTabs().write(\"}\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        printer.write(\"synchronized\");\n        if (synchro.getExpression() != null) {\n            printer.write(\"(\");\n            scan(synchro.getExpression());\n            printer.write(\") \");\n        }\n        scan(synchro.getBlock());\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        printer.write(\"throw \");\n        scan(throwStatement.getThrownExpression());\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        printer.write(\"try \");\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if (tryBlock.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryBlock.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        printer.write(\"try \");\n        if ((tryWithResource.getResources() != null) && (!tryWithResource.getResources().isEmpty())) {\n            printer.write(\"(\");\n            for (spoon.reflect.code.CtLocalVariable<?> r : tryWithResource.getResources()) {\n                scan(r);\n                printer.write(\";\");\n            }\n            printer.removeLastChar();\n            printer.write(\") \");\n        }\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if (tryWithResource.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryWithResource.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        if (wildcardReference.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(wildcardReference);\n        if (printQualified(wildcardReference)) {\n            printer.write(wildcardReference.getQualifiedName());\n        } else {\n            printer.write(wildcardReference.getSimpleName());\n        }\n        if (wildcardReference.getBoundingType() != null) {\n            if (wildcardReference.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(wildcardReference.getBoundingType());\n        }\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (importsContext.isImported(ref) || ((this.env.isAutoImports() && (ref.getPackage() != null)) && ref.getPackage().getSimpleName().equals(\"java.lang\"))) {\n            for (spoon.reflect.visitor.TypeContext typeContext : context.currentThis) {\n                if (typeContext.getSimpleName().equals(ref.getSimpleName()) && (!java.util.Objects.equals(typeContext.getPackage(), ref.getPackage()))) {\n                    return true;\n                }\n                if (typeContext.isNameConflict(ref.getSimpleName())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n        for (spoon.reflect.reference.CtTypeReference<?> bound : reference.getBounds()) {\n            scan(bound);\n            printer.write(\" & \");\n        }\n        printer.removeLastChar();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n            return;\n        }\n        boolean isInner = ref.getDeclaringType() != null;\n        if (isInner) {\n            if ((!context.ignoreEnclosingClass()) && (!ref.isLocalType())) {\n                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();\n                if (!accessType.isAnonymous()) {\n                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    printer.write(\".\");\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                printer.write(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(ref.getSimpleName());\n            }\n        } else {\n            if ((ref.getPackage() != null) && printQualified(ref)) {\n                if (!ref.getPackage().isUnnamedPackage()) {\n                    scan(ref.getPackage());\n                    printer.write(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n        }\n        if (withGenerics && (!context.ignoreGenerics())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {\n                elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        printer.preWriteUnaryOperator(operator.getKind());\n        scan(operator.getOperand());\n        printer.postWriteUnaryOperator(operator.getKind());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {\n        enterCtExpression(variableRead);\n        printer.write(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n        enterCtExpression(variableWrite);\n        printer.write(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        printer.write(\"while (\");\n        scan(whileLoop.getLoopingExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n        elementPrinterHelper.writeComment(expression);\n        printer.write(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        elementPrinterHelper.writeComment(statement);\n        printer.write(statement.getValue());\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return context;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String getPackageDeclaration() {\n        return printPackageInfo(context.currentTopLevel.getPackage());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        spoon.reflect.visitor.PrinterHelper bck = printer;\n        spoon.reflect.visitor.ElementPrinterHelper bck2 = elementPrinterHelper;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        elementPrinterHelper.writeComment(pack);\n        for (spoon.reflect.declaration.CtAnnotation<?> a : pack.getAnnotations()) {\n            a.accept(this);\n        }\n        if (!pack.isUnnamedPackage()) {\n            printer.write((\"package \" + pack.getQualifiedName()) + \";\");\n        }\n        java.lang.String ret = printer.toString();\n        elementPrinterHelper = bck2;\n        printer = bck;\n        return ret;\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public void reset() {\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper.setPrinter(printer);\n        context = new spoon.reflect.visitor.PrintingContext();\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {\n        this.sourceCompilationUnit = sourceCompilationUnit;\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n        java.util.Set<spoon.reflect.reference.CtReference> imports = new java.util.HashSet<>();\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            imports.addAll(computeImports(t));\n        }\n        elementPrinterHelper.writeHeader(types, imports);\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            scan(t);\n            if (!env.isPreserveLineNumbers()) {\n                printer.writeln().writeln().writeTabs();\n            } else {\n                printer.adjustEndPosition(t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {\n        return printer.getLineNumberMapping();\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "UPD",
            "src": "@java.lang.Override\npublic void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n    visitCtTypeParameterReference(typeParameter.getReference());\n}",
            "src_parent": "public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    public static final java.lang.String JAVA_FILE_EXTENSION = \".java\";\n\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION = \"package-info\" + spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION;\n\n    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty(\"line.separator\");\n\n    public static final java.lang.String COMMENT_STAR = \" * \";\n\n    public static final java.lang.String BLOCK_COMMENT_END = \" */\";\n\n    public static final java.lang.String JAVADOC_START = \"/**\";\n\n    public static final java.lang.String INLINE_COMMENT_START = \"// \";\n\n    public static final java.lang.String BLOCK_COMMENT_START = \"/* \";\n\n    public spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();\n\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    private spoon.compiler.Environment env;\n\n    private spoon.reflect.visitor.PrinterHelper printer;\n\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    private spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env = env;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        printer.mapLine(e, sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            context.parenthesedExpression.push(e);\n            printer.write(\"(\");\n        }\n        if (!e.getTypeCasts().isEmpty()) {\n            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {\n                printer.write(\"(\");\n                this.scan(r);\n                printer.write(\") \");\n                printer.write(\"(\");\n                context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(s, sourceCompilationUnit);\n        elementPrinterHelper.writeAnnotations(s);\n        if (s.getLabel() != null) {\n            printer.write(s.getLabel()).write(\" : \");\n        }\n    }\n\n    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        while ((context.parenthesedExpression.size() > 0) && (e == context.parenthesedExpression.peek())) {\n            context.parenthesedExpression.pop();\n            printer.write(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeImports(spoon.reflect.declaration.CtType<?> type) {\n        context.currentTopLevel = type;\n        return importsContext.computeAllImports(context.currentTopLevel);\n    }\n\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (env.isAutoImports()) {\n            importsContext.computeImports(element);\n        }\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e != null) {\n            context.elementStack.push(e);\n            if (env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    printer.adjustStartPosition(e);\n                }\n            }\n            e.accept(this);\n            context.elementStack.pop();\n        }\n        return this;\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.reference.CtReference ref) {\n        if (ref != null) {\n            ref.accept(this);\n        }\n        return this;\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {\n        if (e.getTypeCasts().size() != 0) {\n            return true;\n        }\n        try {\n            if ((e.getParent() instanceof spoon.reflect.code.CtBinaryOperator) || (e.getParent() instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if (e.getParent() instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {\n        elementPrinterHelper.writeAnnotations(annotation);\n        printer.write(\"@\");\n        scan(annotation.getAnnotationType());\n        if (annotation.getValues().size() > 0) {\n            printer.write(\"(\");\n            for (java.util.Map.Entry<java.lang.String, spoon.reflect.code.CtExpression> e : annotation.getValues().entrySet()) {\n                printer.write(e.getKey() + \" = \");\n                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\")\");\n        }\n        printer.writeln().writeTabs();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        visitCtType(annotationType);\n        printer.write((\"@interface \" + annotationType.getSimpleName()) + \" {\").incTab();\n        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        elementPrinterHelper.writeComment(impl);\n        elementPrinterHelper.writeAnnotations(impl);\n        elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        printer.write(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        printer.write(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!context.skipArray()) {\n            printer.write(\"[]\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {\n        enterCtStatement(asserted);\n        printer.write(\"assert \");\n        scan(asserted.getAssertExpression());\n        if (asserted.getExpression() != null) {\n            printer.write(\" : \");\n            scan(asserted.getExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        printer.write(\" = \");\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        printer.write(\" \").writeOperator(operator.getKind()).write(\" \");\n        scan(operator.getRightHandOperand());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {\n        enterCtStatement(block);\n        if (!block.isImplicit()) {\n            printer.write(\"{\");\n        }\n        printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!statement.isImplicit()) {\n                printer.writeln().writeTabs();\n                elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        printer.decTab();\n        printer.adjustEndPosition(block);\n        if (env.isPreserveLineNumbers()) {\n            if (!block.isImplicit()) {\n                printer.writeTabs().write(\"}\");\n            }\n        } else {\n            printer.writeln().writeTabs();\n            if (!block.isImplicit()) {\n                printer.write(\"}\");\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        printer.write(\"break\");\n        if (breakStatement.getTargetLabel() != null) {\n            printer.write(\" \" + breakStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {\n        enterCtStatement(caseStatement);\n        if (caseStatement.getCaseExpression() != null) {\n            printer.write(\"case \");\n            if (caseStatement.getCaseExpression() instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                if (((variable.getType() != null) && (variable.getDeclaringType() != null)) && variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName())) {\n                    printer.write(variable.getSimpleName());\n                } else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            } else {\n                scan(caseStatement.getCaseExpression());\n            }\n        } else {\n            printer.write(\"default\");\n        }\n        printer.write(\" :\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            printer.writeln().writeTabs();\n            elementPrinterHelper.writeStatement(statement);\n        }\n        printer.decTab();\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.write(\" catch (\");\n        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();\n        if (parameter.getMultiTypes().size() > 0) {\n            for (int i = 0; i < parameter.getMultiTypes().size(); i++) {\n                spoon.reflect.reference.CtTypeReference<?> type = parameter.getMultiTypes().get(i);\n                scan(type);\n                if (i < (parameter.getMultiTypes().size() - 1)) {\n                    printer.write(\" | \");\n                }\n            }\n            printer.write(\" \" + parameter.getSimpleName());\n        } else {\n            scan(parameter);\n        }\n        printer.write(\") \");\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        context.pushCurrentThis(ctClass);\n        if (((ctClass.getSimpleName() != null) && (!spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()))) && (!ctClass.isAnonymous())) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                printer.write(\"class \" + ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(\"class \" + ctClass.getSimpleName());\n            }\n            elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            elementPrinterHelper.writeExtendsClause(ctClass);\n            elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        printer.adjustEndPosition(ctClass).decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        visitCtTypeParameterReference(typeParameter.getReference());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();\n        boolean parent;\n        try {\n            parent = (conditional.getParent() instanceof spoon.reflect.code.CtAssignment) || (conditional.getParent() instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            parent = false;\n        }\n        if (parent) {\n            printer.write(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            printer.write(\")\");\n        }\n        printer.write(\" ? \");\n        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();\n        scan(thenExpression);\n        printer.write(\" : \");\n        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();\n        boolean isAssign = false;\n        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            printer.write(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            printer.write(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {\n        elementPrinterHelper.writeComment(constructor);\n        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(constructor);\n        elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (constructor.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        if (constructor.getDeclaringType() != null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                printer.write(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        elementPrinterHelper.writeExecutableParameters(constructor);\n        elementPrinterHelper.writeThrowsClause(constructor);\n        printer.write(\" \");\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        printer.write(\"continue\");\n        if (continueStatement.getTargetLabel() != null) {\n            printer.write(\" \" + continueStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        printer.write(\"do\");\n        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        printer.write(\"while (\");\n        scan(doLoop.getLoopingExpression());\n        printer.write(\" )\");\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        visitCtType(ctEnum);\n        printer.write(\"enum \" + ctEnum.getSimpleName());\n        elementPrinterHelper.writeImplementsClause(ctEnum);\n        context.pushCurrentThis(ctEnum);\n        printer.write(\" {\").incTab().writeln();\n        if (ctEnum.getEnumValues().size() == 0) {\n            printer.writeTabs().write(\";\").writeln();\n        } else {\n            for (spoon.reflect.declaration.CtEnumValue<?> enumValue : ctEnum.getEnumValues()) {\n                scan(enumValue);\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\";\");\n        }\n        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        printer.write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {\n        elementPrinterHelper.writeComment(f);\n        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        printer.write(\" \");\n        printer.write(f.getSimpleName());\n        if (f.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(f.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n        printer.write(enumValue.getSimpleName());\n        if (enumValue.getDefaultExpression() != null) {\n            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));\n            if (constructorCall.getArguments().size() > 0) {\n                printer.write(\"(\");\n                boolean first = true;\n                for (spoon.reflect.code.CtExpression<?> ctexpr : constructorCall.getArguments()) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        printer.write(\",\");\n                    }\n                    scan(ctexpr);\n                }\n                printer.write(\")\");\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {\n        enterCtExpression(f);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (f.getVariable().isStatic() && (f.getTarget() instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression<?> target = f.getTarget();\n            if (target != null) {\n                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField = f.getVariable().isStatic();\n                boolean isImportedField = importsContext.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {\n                    if (target.isImplicit()) {\n                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();\n                        final java.lang.String fieldName = field.getSimpleName();\n                        spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                        if (var != field) {\n                            target.setImplicit(false);\n                        }\n                    }\n                    printer.snapshotLength();\n                    scan(target);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent = targetExp.getParent();\n            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        if ((((((parent instanceof spoon.reflect.code.CtFieldWrite) && targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget())) && (anonymousParent != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable() != null)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();\n            if (thisAccess.isImplicit()) {\n                return;\n            }\n            if ((targetType == null) || ((thisAccess.getParent(spoon.reflect.declaration.CtType.class) != null) && thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel())) {\n                printer.write(\"this\");\n                return;\n            }\n            if (targetType.isAnonymous()) {\n                printer.write(\"this\");\n                return;\n            }\n            if (!context.currentThis.isEmpty()) {\n                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();\n                if (!lastTypeQualifiedName.equals(targetTypeQualifiedName)) {\n                    printer.snapshotLength();\n                    visitCtTypeReferenceWithoutGenerics(targetType);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                    printer.write(\"this\");\n                    return;\n                }\n            }\n            printer.write(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {\n        enterCtExpression(f);\n        if (f.getTarget() != null) {\n            scan(f.getTarget());\n            printer.write(\".\");\n        }\n        printer.write(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n        printer.write(spoon.reflect.code.CtJavaDocTag.JAVADOC_TAG_PREFIX);\n        printer.write(docTag.getType().name().toLowerCase());\n        printer.write(\" \");\n        if (docTag.getType().hasParam()) {\n            printer.write(docTag.getParam()).writeln().writeTabs();\n        }\n        java.lang.String[] tagLines = docTag.getContent().split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n        for (int i = 0; i < tagLines.length; i++) {\n            java.lang.String com = tagLines[i];\n            if ((i > 0) || docTag.getType().hasParam()) {\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n            }\n            if (docTag.getType().hasParam()) {\n                printer.write(\"\\t\\t\");\n            }\n            printer.write(com.trim()).writeln().writeTabs();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!env.isCommentsEnabled()) && (context.elementStack.size() > 1)) {\n            return;\n        }\n        switch (comment.getCommentType()) {\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln().writeTabs();\n                break;\n            case INLINE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.INLINE_COMMENT_START);\n                break;\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_START);\n                break;\n        }\n        java.lang.String content = comment.getContent();\n        switch (comment.getCommentType()) {\n            case INLINE :\n                printer.write(content);\n                break;\n            default :\n                java.lang.String[] lines = content.split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n                for (int i = 0; i < lines.length; i++) {\n                    java.lang.String com = lines[i];\n                    if (comment.getCommentType() == spoon.reflect.code.CtComment.CommentType.BLOCK) {\n                        printer.write(com);\n                        if (lines.length > 1) {\n                            printer.writeln().writeTabs();\n                        }\n                    } else if (com.length() > 0) {\n                        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR + com).writeln().writeTabs();\n                    } else {\n                        printer.write(\" *\" + com).writeln().writeTabs();\n                    }\n                }\n                if (comment instanceof spoon.reflect.code.CtJavaDoc) {\n                    if (!((spoon.reflect.code.CtJavaDoc) (comment)).getTags().isEmpty()) {\n                        printer.write(\" *\").writeln().writeTabs();\n                    }\n                    for (spoon.reflect.code.CtJavaDocTag docTag : ((spoon.reflect.code.CtJavaDoc) (comment)).getTags()) {\n                        scan(docTag);\n                    }\n                }\n                break;\n        }\n        switch (comment.getCommentType()) {\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (annotationFieldAccess.getTarget() != null) {\n                scan(annotationFieldAccess.getTarget());\n                printer.write(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            printer.write(\"()\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        boolean isStatic = reference.getSimpleName().equals(\"class\") || ((!reference.getSimpleName().equals(\"super\")) && reference.isStatic());\n        boolean printType = true;\n        if (reference.isFinal() && reference.isStatic()) {\n            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                printType = false;\n            } else if (context.isInCurrentScope(declTypeRef)) {\n                printType = false;\n            }\n        }\n        if ((isStatic && printType) && (!context.ignoreStaticAccess())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            printer.write(\".\");\n        }\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        printer.write(\"for (\");\n        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();\n        if (st.size() > 0) {\n            scan(st.get(0));\n        }\n        if (st.size() > 1) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().noTypeDecl(true)) {\n                for (int i = 1; i < st.size(); i++) {\n                    printer.write(\", \");\n                    scan(st.get(i));\n                }\n            }\n        }\n        printer.write(\"; \");\n        scan(forLoop.getExpression());\n        printer.write(\";\");\n        if (!forLoop.getForUpdate().isEmpty()) {\n            printer.write(\" \");\n        }\n        for (spoon.reflect.code.CtStatement s : forLoop.getForUpdate()) {\n            scan(s);\n            printer.write(\" , \");\n        }\n        if (forLoop.getForUpdate().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        printer.write(\"for (\");\n        scan(foreach.getVariable());\n        printer.write(\" : \");\n        scan(foreach.getExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        printer.write(\"if (\");\n        scan(ifElement.getCondition());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if (ifElement.getElseStatement() != null) {\n            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition() == null) ? ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition() : ifElement.getThenStatement().getPosition();\n                if (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd()) {\n                    elementPrinterHelper.writeComment(comment);\n                }\n            }\n            printer.write(\"else\");\n            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        visitCtType(intrface);\n        printer.write(\"interface \" + intrface.getSimpleName());\n        if (intrface.getFormalCtTypeParameters() != null) {\n            elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (intrface.getSuperInterfaces().size() > 0) {\n            printer.write(\" extends \");\n            for (spoon.reflect.reference.CtTypeReference<?> ref : intrface.getSuperInterfaces()) {\n                scan(ref);\n                printer.write(\" , \");\n            }\n            printer.removeLastChar();\n        }\n        context.pushCurrentThis(intrface);\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType<?> parentType;\n            try {\n                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType = null;\n            }\n            if (((parentType != null) && (parentType.getQualifiedName() != null)) && parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName())) {\n                printer.write(\"this\");\n            } else {\n                printer.snapshotLength();\n                scan(invocation.getTarget());\n                if (printer.hasNewContent()) {\n                    printer.write(\".\");\n                }\n                printer.write(\"super\");\n            }\n        } else {\n            printer.snapshotLength();\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                if (invocation.getTarget() instanceof spoon.reflect.code.CtTypeAccess) {\n                    _context.ignoreGenerics(true);\n                }\n                scan(invocation.getTarget());\n            }\n            if (printer.hasNewContent()) {\n                printer.write(\".\");\n            }\n            elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (env.isPreserveLineNumbers()) {\n                printer.adjustStartPosition(invocation);\n            }\n            printer.write(invocation.getExecutable().getSimpleName());\n        }\n        printer.write(\"(\");\n        boolean remove = false;\n        for (spoon.reflect.code.CtExpression<?> e : invocation.getArguments()) {\n            scan(e);\n            printer.write(\", \");\n            remove = true;\n        }\n        if (remove) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        exitCtExpression(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {\n        enterCtExpression(literal);\n        if (literal.getValue() == null) {\n            printer.write(\"null\");\n        } else if (literal.getValue() instanceof java.lang.Long) {\n            printer.write(literal.getValue() + \"L\");\n        } else if (literal.getValue() instanceof java.lang.Float) {\n            printer.write(literal.getValue() + \"F\");\n        } else if (literal.getValue() instanceof java.lang.Character) {\n            printer.write(\"'\");\n            boolean mayContainsSpecialCharacter = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacter = stringLength != 1;\n            }\n            printer.writeStringLiteral(new java.lang.String(new char[]{ ((java.lang.Character) (literal.getValue())) }), mayContainsSpecialCharacter);\n            printer.write(\"'\");\n        } else if (literal.getValue() instanceof java.lang.String) {\n            printer.write('\\\"');\n            boolean mayContainsSpecialCharacters = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacters = ((java.lang.String) (literal.getValue())).length() != stringLength;\n            }\n            printer.writeStringLiteral(((java.lang.String) (literal.getValue())), mayContainsSpecialCharacters);\n            printer.write('\\\"');\n        } else if (literal.getValue() instanceof java.lang.Class) {\n            printer.write(((java.lang.Class<?>) (literal.getValue())).getName());\n        } else {\n            printer.write(literal.getValue().toString());\n        }\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {\n        if (!context.noTypeDecl()) {\n            enterCtStatement(localVariable);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(localVariable);\n        }\n        if (!context.noTypeDecl()) {\n            elementPrinterHelper.writeModifiers(localVariable);\n            scan(localVariable.getType());\n            printer.write(\" \");\n        }\n        printer.write(localVariable.getSimpleName());\n        if (localVariable.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(localVariable.getDefaultExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(catchVariable);\n        }\n        elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        printer.write(\" \");\n        printer.write(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {\n        elementPrinterHelper.writeComment(m);\n        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(m);\n        if (m.isDefaultMethod()) {\n            printer.write(\"default \");\n        }\n        elementPrinterHelper.writeFormalTypeParameters(m);\n        if (m.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        printer.write(\" \");\n        printer.write(m.getSimpleName());\n        elementPrinterHelper.writeExecutableParameters(m);\n        elementPrinterHelper.writeThrowsClause(m);\n        if (m.getBody() != null) {\n            printer.write(\" \");\n            scan(m.getBody());\n            if (m.getBody().getPosition() != null) {\n                if (m.getBody().getPosition().getCompilationUnit() == sourceCompilationUnit) {\n                    if (m.getBody().getStatements().isEmpty() || (!(m.getBody().getStatements().get(m.getBody().getStatements().size() - 1) instanceof spoon.reflect.code.CtReturn))) {\n                        printer.putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                } else {\n                    printer.undefineLine();\n                }\n            } else {\n                printer.undefineLine();\n            }\n        } else {\n            printer.write(\";\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n        elementPrinterHelper.writeComment(annotationMethod);\n        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        printer.write(\" \");\n        printer.write(annotationMethod.getSimpleName());\n        printer.write(\"()\");\n        if (annotationMethod.getDefaultExpression() != null) {\n            printer.write(\" default \");\n            scan(annotationMethod.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation = (newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class) == null) && (newArray.getParent(spoon.reflect.declaration.CtAnnotation.class) == null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation = true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();\n            if (ref != null) {\n                printer.write(\"new \");\n            }\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                printer.write(\"[\");\n                if (newArray.getDimensionExpressions().size() > i) {\n                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                printer.write(\"]\");\n                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().size() == 0) {\n            printer.write(\"{ \");\n            java.util.List<spoon.reflect.code.CtExpression<?>> l_elements = newArray.getElements();\n            for (int i = 0; i < l_elements.size(); i++) {\n                spoon.reflect.code.CtExpression e = l_elements.get(i);\n                scan(e);\n                printer.write(\" , \");\n                if ((i + 1) == l_elements.size()) {\n                    printer.removeLastChar();\n                    java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n                    if ((!comments.isEmpty()) && (comments.get(comments.size() - 1).getCommentType() == spoon.reflect.code.CtComment.CommentType.INLINE)) {\n                        printer.writeln();\n                    }\n                }\n            }\n            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            printer.write(\" }\");\n        }\n        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n    }\n\n    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (ctConstructorCall.getTarget() != null) {\n                scan(ctConstructorCall.getTarget());\n                printer.write(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            printer.write(\"new \");\n            if (ctConstructorCall.getActualTypeArguments().size() > 0) {\n                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        printer.write(\"(\");\n        for (spoon.reflect.code.CtCodeElement exp : ctConstructorCall.getArguments()) {\n            scan(exp);\n            printer.write(\", \");\n        }\n        if (ctConstructorCall.getArguments().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n    }\n\n    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (reference == null) {\n            return false;\n        }\n        if (reference.getDeclaringType() == null) {\n            return false;\n        }\n        if (reference.isLocalType()) {\n            return false;\n        }\n        if (reference.getDeclaringType().getActualTypeArguments().size() != 0) {\n            return true;\n        }\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {\n        enterCtExpression(lambda);\n        printer.write(\"(\");\n        if (lambda.getParameters().size() > 0) {\n            for (spoon.reflect.declaration.CtParameter<?> parameter : lambda.getParameters()) {\n                scan(parameter);\n                printer.write(\",\");\n            }\n            printer.removeLastChar();\n        }\n        printer.write(\") -> \");\n        if (lambda.getBody() != null) {\n            scan(lambda.getBody());\n        } else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n        enterCtExpression(expression);\n        scan(expression.getTarget());\n        printer.write(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            printer.write(\"new\");\n        } else {\n            printer.write(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        printer.write(\" \");\n        printer.writeOperator(assignment.getKind());\n        printer.write(\"= \");\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!ctPackage.isUnnamedPackage()) {\n            printer.write((\"package \" + ctPackage.getQualifiedName()) + \";\");\n        } else {\n            printer.write(\"// default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)\\n\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {\n        elementPrinterHelper.writeComment(parameter);\n        elementPrinterHelper.writeAnnotations(parameter);\n        elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());\n            printer.write(\"...\");\n        } else {\n            scan(parameter.getType());\n        }\n        printer.write(\" \");\n        printer.write(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {\n        enterCtStatement(returnStatement);\n        printer.write(\"return \");\n        scan(returnStatement.getReturnedExpression());\n    }\n\n    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {\n        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(type, sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            context.currentTopLevel = type;\n        }\n        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {\n        enterCtStatement(switchStatement);\n        printer.write(\"switch (\");\n        scan(switchStatement.getSelector());\n        printer.write(\") {\").incTab();\n        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {\n            printer.writeln().writeTabs();\n            scan(c);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.decTab().write(\"}\");\n        } else {\n            printer.decTab().writeln().writeTabs().write(\"}\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        printer.write(\"synchronized\");\n        if (synchro.getExpression() != null) {\n            printer.write(\"(\");\n            scan(synchro.getExpression());\n            printer.write(\") \");\n        }\n        scan(synchro.getBlock());\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        printer.write(\"throw \");\n        scan(throwStatement.getThrownExpression());\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        printer.write(\"try \");\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if (tryBlock.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryBlock.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        printer.write(\"try \");\n        if ((tryWithResource.getResources() != null) && (!tryWithResource.getResources().isEmpty())) {\n            printer.write(\"(\");\n            for (spoon.reflect.code.CtLocalVariable<?> r : tryWithResource.getResources()) {\n                scan(r);\n                printer.write(\";\");\n            }\n            printer.removeLastChar();\n            printer.write(\") \");\n        }\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if (tryWithResource.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryWithResource.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n        if (ref.getBoundingType() != null) {\n            if (ref.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(ref.getBoundingType());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        visitCtTypeParameterReference(wildcardReference);\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (importsContext.isImported(ref) || ((this.env.isAutoImports() && (ref.getPackage() != null)) && ref.getPackage().getSimpleName().equals(\"java.lang\"))) {\n            for (spoon.reflect.visitor.TypeContext typeContext : context.currentThis) {\n                if (typeContext.getSimpleName().equals(ref.getSimpleName()) && (!java.util.Objects.equals(typeContext.getPackage(), ref.getPackage()))) {\n                    return true;\n                }\n                if (typeContext.isNameConflict(ref.getSimpleName())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n        for (spoon.reflect.reference.CtTypeReference<?> bound : reference.getBounds()) {\n            scan(bound);\n            printer.write(\" & \");\n        }\n        printer.removeLastChar();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n            return;\n        }\n        boolean isInner = ref.getDeclaringType() != null;\n        if (isInner) {\n            if ((!context.ignoreEnclosingClass()) && (!ref.isLocalType())) {\n                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();\n                if (!accessType.isAnonymous()) {\n                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    printer.write(\".\");\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                printer.write(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(ref.getSimpleName());\n            }\n        } else {\n            if ((ref.getPackage() != null) && printQualified(ref)) {\n                if (!ref.getPackage().isUnnamedPackage()) {\n                    scan(ref.getPackage());\n                    printer.write(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n        }\n        if (withGenerics && (!context.ignoreGenerics())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {\n                elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        printer.preWriteUnaryOperator(operator.getKind());\n        scan(operator.getOperand());\n        printer.postWriteUnaryOperator(operator.getKind());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {\n        enterCtExpression(variableRead);\n        printer.write(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n        enterCtExpression(variableWrite);\n        printer.write(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        printer.write(\"while (\");\n        scan(whileLoop.getLoopingExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n        elementPrinterHelper.writeComment(expression);\n        printer.write(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        elementPrinterHelper.writeComment(statement);\n        printer.write(statement.getValue());\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return context;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String getPackageDeclaration() {\n        return printPackageInfo(context.currentTopLevel.getPackage());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        spoon.reflect.visitor.PrinterHelper bck = printer;\n        spoon.reflect.visitor.ElementPrinterHelper bck2 = elementPrinterHelper;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        elementPrinterHelper.writeComment(pack);\n        for (spoon.reflect.declaration.CtAnnotation<?> a : pack.getAnnotations()) {\n            a.accept(this);\n        }\n        if (!pack.isUnnamedPackage()) {\n            printer.write((\"package \" + pack.getQualifiedName()) + \";\");\n        }\n        java.lang.String ret = printer.toString();\n        elementPrinterHelper = bck2;\n        printer = bck;\n        return ret;\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public void reset() {\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper.setPrinter(printer);\n        context = new spoon.reflect.visitor.PrintingContext();\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {\n        this.sourceCompilationUnit = sourceCompilationUnit;\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n        java.util.Set<spoon.reflect.reference.CtReference> imports = new java.util.HashSet<>();\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            imports.addAll(computeImports(t));\n        }\n        elementPrinterHelper.writeHeader(types, imports);\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            scan(t);\n            if (!env.isPreserveLineNumbers()) {\n                printer.writeln().writeln().writeTabs();\n            } else {\n                printer.adjustEndPosition(t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {\n        return printer.getLineNumberMapping();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "DEL",
            "src": "visitCtTypeParameterReference(wildcardReference)",
            "src_parent": "{\n    visitCtTypeParameterReference(wildcardReference);\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (wildcardReference.isImplicit()) {\n    return;\n}",
            "src_parent": "{\n    if (wildcardReference.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(wildcardReference);\n    if (printQualified(wildcardReference)) {\n        printer.write(wildcardReference.getQualifiedName());\n    } else {\n        printer.write(wildcardReference.getSimpleName());\n    }\n    if (wildcardReference.getBoundingType() != null) {\n        if (wildcardReference.isUpper()) {\n            printer.write(\" extends \");\n        } else {\n            printer.write(\" super \");\n        }\n        scan(wildcardReference.getBoundingType());\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "elementPrinterHelper.writeAnnotations(wildcardReference)",
            "src_parent": "{\n    if (wildcardReference.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(wildcardReference);\n    if (printQualified(wildcardReference)) {\n        printer.write(wildcardReference.getQualifiedName());\n    } else {\n        printer.write(wildcardReference.getSimpleName());\n    }\n    if (wildcardReference.getBoundingType() != null) {\n        if (wildcardReference.isUpper()) {\n            printer.write(\" extends \");\n        } else {\n            printer.write(\" super \");\n        }\n        scan(wildcardReference.getBoundingType());\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (printQualified(wildcardReference)) {\n    printer.write(wildcardReference.getQualifiedName());\n} else {\n    printer.write(wildcardReference.getSimpleName());\n}",
            "src_parent": "{\n    if (wildcardReference.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(wildcardReference);\n    if (printQualified(wildcardReference)) {\n        printer.write(wildcardReference.getQualifiedName());\n    } else {\n        printer.write(wildcardReference.getSimpleName());\n    }\n    if (wildcardReference.getBoundingType() != null) {\n        if (wildcardReference.isUpper()) {\n            printer.write(\" extends \");\n        } else {\n            printer.write(\" super \");\n        }\n        scan(wildcardReference.getBoundingType());\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "null",
            "dst_parent": "null",
            "dst_parent_type": "null",
            "dst_type": "null",
            "operator": "INS",
            "src": "if (wildcardReference.getBoundingType() != null) {\n    if (wildcardReference.isUpper()) {\n        printer.write(\" extends \");\n    } else {\n        printer.write(\" super \");\n    }\n    scan(wildcardReference.getBoundingType());\n}",
            "src_parent": "{\n    if (wildcardReference.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(wildcardReference);\n    if (printQualified(wildcardReference)) {\n        printer.write(wildcardReference.getQualifiedName());\n    } else {\n        printer.write(wildcardReference.getSimpleName());\n    }\n    if (wildcardReference.getBoundingType() != null) {\n        if (wildcardReference.isUpper()) {\n            printer.write(\" extends \");\n        } else {\n            printer.write(\" super \");\n        }\n        scan(wildcardReference.getBoundingType());\n    }\n}",
            "src_parent_type": "Block",
            "src_type": "If"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@java.lang.Override\npublic void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n    if (ref.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(ref);\n    if (printQualified(ref)) {\n        printer.write(ref.getQualifiedName());\n    } else {\n        printer.write(ref.getSimpleName());\n    }\n}",
            "dst_parent": "public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    public static final java.lang.String JAVA_FILE_EXTENSION = \".java\";\n\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION = \"package-info\" + spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION;\n\n    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty(\"line.separator\");\n\n    public static final java.lang.String COMMENT_STAR = \" * \";\n\n    public static final java.lang.String BLOCK_COMMENT_END = \" */\";\n\n    public static final java.lang.String JAVADOC_START = \"/**\";\n\n    public static final java.lang.String INLINE_COMMENT_START = \"// \";\n\n    public static final java.lang.String BLOCK_COMMENT_START = \"/* \";\n\n    public spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();\n\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    private spoon.compiler.Environment env;\n\n    private spoon.reflect.visitor.PrinterHelper printer;\n\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    private spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env = env;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        printer.mapLine(e, sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            context.parenthesedExpression.push(e);\n            printer.write(\"(\");\n        }\n        if (!e.getTypeCasts().isEmpty()) {\n            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {\n                printer.write(\"(\");\n                this.scan(r);\n                printer.write(\") \");\n                printer.write(\"(\");\n                context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(s, sourceCompilationUnit);\n        elementPrinterHelper.writeAnnotations(s);\n        if (s.getLabel() != null) {\n            printer.write(s.getLabel()).write(\" : \");\n        }\n    }\n\n    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        while ((context.parenthesedExpression.size() > 0) && (e == context.parenthesedExpression.peek())) {\n            context.parenthesedExpression.pop();\n            printer.write(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeImports(spoon.reflect.declaration.CtType<?> type) {\n        context.currentTopLevel = type;\n        return importsContext.computeAllImports(context.currentTopLevel);\n    }\n\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (env.isAutoImports()) {\n            importsContext.computeImports(element);\n        }\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e != null) {\n            context.elementStack.push(e);\n            if (env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    printer.adjustStartPosition(e);\n                }\n            }\n            e.accept(this);\n            context.elementStack.pop();\n        }\n        return this;\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.reference.CtReference ref) {\n        if (ref != null) {\n            ref.accept(this);\n        }\n        return this;\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {\n        if (e.getTypeCasts().size() != 0) {\n            return true;\n        }\n        try {\n            if ((e.getParent() instanceof spoon.reflect.code.CtBinaryOperator) || (e.getParent() instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if (e.getParent() instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {\n        elementPrinterHelper.writeAnnotations(annotation);\n        printer.write(\"@\");\n        scan(annotation.getAnnotationType());\n        if (annotation.getValues().size() > 0) {\n            printer.write(\"(\");\n            for (java.util.Map.Entry<java.lang.String, spoon.reflect.code.CtExpression> e : annotation.getValues().entrySet()) {\n                printer.write(e.getKey() + \" = \");\n                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\")\");\n        }\n        printer.writeln().writeTabs();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        visitCtType(annotationType);\n        printer.write((\"@interface \" + annotationType.getSimpleName()) + \" {\").incTab();\n        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        elementPrinterHelper.writeComment(impl);\n        elementPrinterHelper.writeAnnotations(impl);\n        elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        printer.write(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        printer.write(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!context.skipArray()) {\n            printer.write(\"[]\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {\n        enterCtStatement(asserted);\n        printer.write(\"assert \");\n        scan(asserted.getAssertExpression());\n        if (asserted.getExpression() != null) {\n            printer.write(\" : \");\n            scan(asserted.getExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        printer.write(\" = \");\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        printer.write(\" \").writeOperator(operator.getKind()).write(\" \");\n        scan(operator.getRightHandOperand());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {\n        enterCtStatement(block);\n        if (!block.isImplicit()) {\n            printer.write(\"{\");\n        }\n        printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!statement.isImplicit()) {\n                printer.writeln().writeTabs();\n                elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        printer.decTab();\n        printer.adjustEndPosition(block);\n        if (env.isPreserveLineNumbers()) {\n            if (!block.isImplicit()) {\n                printer.writeTabs().write(\"}\");\n            }\n        } else {\n            printer.writeln().writeTabs();\n            if (!block.isImplicit()) {\n                printer.write(\"}\");\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        printer.write(\"break\");\n        if (breakStatement.getTargetLabel() != null) {\n            printer.write(\" \" + breakStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {\n        enterCtStatement(caseStatement);\n        if (caseStatement.getCaseExpression() != null) {\n            printer.write(\"case \");\n            if (caseStatement.getCaseExpression() instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                if (((variable.getType() != null) && (variable.getDeclaringType() != null)) && variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName())) {\n                    printer.write(variable.getSimpleName());\n                } else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            } else {\n                scan(caseStatement.getCaseExpression());\n            }\n        } else {\n            printer.write(\"default\");\n        }\n        printer.write(\" :\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            printer.writeln().writeTabs();\n            elementPrinterHelper.writeStatement(statement);\n        }\n        printer.decTab();\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.write(\" catch (\");\n        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();\n        if (parameter.getMultiTypes().size() > 0) {\n            for (int i = 0; i < parameter.getMultiTypes().size(); i++) {\n                spoon.reflect.reference.CtTypeReference<?> type = parameter.getMultiTypes().get(i);\n                scan(type);\n                if (i < (parameter.getMultiTypes().size() - 1)) {\n                    printer.write(\" | \");\n                }\n            }\n            printer.write(\" \" + parameter.getSimpleName());\n        } else {\n            scan(parameter);\n        }\n        printer.write(\") \");\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        context.pushCurrentThis(ctClass);\n        if (((ctClass.getSimpleName() != null) && (!spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()))) && (!ctClass.isAnonymous())) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                printer.write(\"class \" + ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(\"class \" + ctClass.getSimpleName());\n            }\n            elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            elementPrinterHelper.writeExtendsClause(ctClass);\n            elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        printer.adjustEndPosition(ctClass).decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        spoon.reflect.reference.CtTypeParameterReference ref = typeParameter.getReference();\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n        if (ref.getBoundingType() != null) {\n            if (ref.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(ref.getBoundingType());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();\n        boolean parent;\n        try {\n            parent = (conditional.getParent() instanceof spoon.reflect.code.CtAssignment) || (conditional.getParent() instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            parent = false;\n        }\n        if (parent) {\n            printer.write(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            printer.write(\")\");\n        }\n        printer.write(\" ? \");\n        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();\n        scan(thenExpression);\n        printer.write(\" : \");\n        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();\n        boolean isAssign = false;\n        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            printer.write(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            printer.write(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {\n        elementPrinterHelper.writeComment(constructor);\n        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(constructor);\n        elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (constructor.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        if (constructor.getDeclaringType() != null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                printer.write(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        elementPrinterHelper.writeExecutableParameters(constructor);\n        elementPrinterHelper.writeThrowsClause(constructor);\n        printer.write(\" \");\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        printer.write(\"continue\");\n        if (continueStatement.getTargetLabel() != null) {\n            printer.write(\" \" + continueStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        printer.write(\"do\");\n        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        printer.write(\"while (\");\n        scan(doLoop.getLoopingExpression());\n        printer.write(\" )\");\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        visitCtType(ctEnum);\n        printer.write(\"enum \" + ctEnum.getSimpleName());\n        elementPrinterHelper.writeImplementsClause(ctEnum);\n        context.pushCurrentThis(ctEnum);\n        printer.write(\" {\").incTab().writeln();\n        if (ctEnum.getEnumValues().size() == 0) {\n            printer.writeTabs().write(\";\").writeln();\n        } else {\n            for (spoon.reflect.declaration.CtEnumValue<?> enumValue : ctEnum.getEnumValues()) {\n                scan(enumValue);\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\";\");\n        }\n        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        printer.write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {\n        elementPrinterHelper.writeComment(f);\n        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        printer.write(\" \");\n        printer.write(f.getSimpleName());\n        if (f.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(f.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n        printer.write(enumValue.getSimpleName());\n        if (enumValue.getDefaultExpression() != null) {\n            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));\n            if (constructorCall.getArguments().size() > 0) {\n                printer.write(\"(\");\n                boolean first = true;\n                for (spoon.reflect.code.CtExpression<?> ctexpr : constructorCall.getArguments()) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        printer.write(\",\");\n                    }\n                    scan(ctexpr);\n                }\n                printer.write(\")\");\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {\n        enterCtExpression(f);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (f.getVariable().isStatic() && (f.getTarget() instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression<?> target = f.getTarget();\n            if (target != null) {\n                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField = f.getVariable().isStatic();\n                boolean isImportedField = importsContext.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {\n                    if (target.isImplicit()) {\n                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();\n                        final java.lang.String fieldName = field.getSimpleName();\n                        spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                        if (var != field) {\n                            target.setImplicit(false);\n                        }\n                    }\n                    printer.snapshotLength();\n                    scan(target);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent = targetExp.getParent();\n            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        if ((((((parent instanceof spoon.reflect.code.CtFieldWrite) && targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget())) && (anonymousParent != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable() != null)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();\n            if (thisAccess.isImplicit()) {\n                return;\n            }\n            if ((targetType == null) || ((thisAccess.getParent(spoon.reflect.declaration.CtType.class) != null) && thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel())) {\n                printer.write(\"this\");\n                return;\n            }\n            if (targetType.isAnonymous()) {\n                printer.write(\"this\");\n                return;\n            }\n            if (!context.currentThis.isEmpty()) {\n                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();\n                if (!lastTypeQualifiedName.equals(targetTypeQualifiedName)) {\n                    printer.snapshotLength();\n                    visitCtTypeReferenceWithoutGenerics(targetType);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                    printer.write(\"this\");\n                    return;\n                }\n            }\n            printer.write(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {\n        enterCtExpression(f);\n        if (f.getTarget() != null) {\n            scan(f.getTarget());\n            printer.write(\".\");\n        }\n        printer.write(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n        printer.write(spoon.reflect.code.CtJavaDocTag.JAVADOC_TAG_PREFIX);\n        printer.write(docTag.getType().name().toLowerCase());\n        printer.write(\" \");\n        if (docTag.getType().hasParam()) {\n            printer.write(docTag.getParam()).writeln().writeTabs();\n        }\n        java.lang.String[] tagLines = docTag.getContent().split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n        for (int i = 0; i < tagLines.length; i++) {\n            java.lang.String com = tagLines[i];\n            if ((i > 0) || docTag.getType().hasParam()) {\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n            }\n            if (docTag.getType().hasParam()) {\n                printer.write(\"\\t\\t\");\n            }\n            printer.write(com.trim()).writeln().writeTabs();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!env.isCommentsEnabled()) && (context.elementStack.size() > 1)) {\n            return;\n        }\n        switch (comment.getCommentType()) {\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln().writeTabs();\n                break;\n            case INLINE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.INLINE_COMMENT_START);\n                break;\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_START);\n                break;\n        }\n        java.lang.String content = comment.getContent();\n        switch (comment.getCommentType()) {\n            case INLINE :\n                printer.write(content);\n                break;\n            default :\n                java.lang.String[] lines = content.split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n                for (int i = 0; i < lines.length; i++) {\n                    java.lang.String com = lines[i];\n                    if (comment.getCommentType() == spoon.reflect.code.CtComment.CommentType.BLOCK) {\n                        printer.write(com);\n                        if (lines.length > 1) {\n                            printer.writeln().writeTabs();\n                        }\n                    } else if (com.length() > 0) {\n                        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR + com).writeln().writeTabs();\n                    } else {\n                        printer.write(\" *\" + com).writeln().writeTabs();\n                    }\n                }\n                if (comment instanceof spoon.reflect.code.CtJavaDoc) {\n                    if (!((spoon.reflect.code.CtJavaDoc) (comment)).getTags().isEmpty()) {\n                        printer.write(\" *\").writeln().writeTabs();\n                    }\n                    for (spoon.reflect.code.CtJavaDocTag docTag : ((spoon.reflect.code.CtJavaDoc) (comment)).getTags()) {\n                        scan(docTag);\n                    }\n                }\n                break;\n        }\n        switch (comment.getCommentType()) {\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (annotationFieldAccess.getTarget() != null) {\n                scan(annotationFieldAccess.getTarget());\n                printer.write(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            printer.write(\"()\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        boolean isStatic = reference.getSimpleName().equals(\"class\") || ((!reference.getSimpleName().equals(\"super\")) && reference.isStatic());\n        boolean printType = true;\n        if (reference.isFinal() && reference.isStatic()) {\n            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                printType = false;\n            } else if (context.isInCurrentScope(declTypeRef)) {\n                printType = false;\n            }\n        }\n        if ((isStatic && printType) && (!context.ignoreStaticAccess())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            printer.write(\".\");\n        }\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        printer.write(\"for (\");\n        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();\n        if (st.size() > 0) {\n            scan(st.get(0));\n        }\n        if (st.size() > 1) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().noTypeDecl(true)) {\n                for (int i = 1; i < st.size(); i++) {\n                    printer.write(\", \");\n                    scan(st.get(i));\n                }\n            }\n        }\n        printer.write(\"; \");\n        scan(forLoop.getExpression());\n        printer.write(\";\");\n        if (!forLoop.getForUpdate().isEmpty()) {\n            printer.write(\" \");\n        }\n        for (spoon.reflect.code.CtStatement s : forLoop.getForUpdate()) {\n            scan(s);\n            printer.write(\" , \");\n        }\n        if (forLoop.getForUpdate().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        printer.write(\"for (\");\n        scan(foreach.getVariable());\n        printer.write(\" : \");\n        scan(foreach.getExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        printer.write(\"if (\");\n        scan(ifElement.getCondition());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if (ifElement.getElseStatement() != null) {\n            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition() == null) ? ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition() : ifElement.getThenStatement().getPosition();\n                if (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd()) {\n                    elementPrinterHelper.writeComment(comment);\n                }\n            }\n            printer.write(\"else\");\n            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        visitCtType(intrface);\n        printer.write(\"interface \" + intrface.getSimpleName());\n        if (intrface.getFormalCtTypeParameters() != null) {\n            elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (intrface.getSuperInterfaces().size() > 0) {\n            printer.write(\" extends \");\n            for (spoon.reflect.reference.CtTypeReference<?> ref : intrface.getSuperInterfaces()) {\n                scan(ref);\n                printer.write(\" , \");\n            }\n            printer.removeLastChar();\n        }\n        context.pushCurrentThis(intrface);\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType<?> parentType;\n            try {\n                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType = null;\n            }\n            if (((parentType != null) && (parentType.getQualifiedName() != null)) && parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName())) {\n                printer.write(\"this\");\n            } else {\n                printer.snapshotLength();\n                scan(invocation.getTarget());\n                if (printer.hasNewContent()) {\n                    printer.write(\".\");\n                }\n                printer.write(\"super\");\n            }\n        } else {\n            printer.snapshotLength();\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                if (invocation.getTarget() instanceof spoon.reflect.code.CtTypeAccess) {\n                    _context.ignoreGenerics(true);\n                }\n                scan(invocation.getTarget());\n            }\n            if (printer.hasNewContent()) {\n                printer.write(\".\");\n            }\n            elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (env.isPreserveLineNumbers()) {\n                printer.adjustStartPosition(invocation);\n            }\n            printer.write(invocation.getExecutable().getSimpleName());\n        }\n        printer.write(\"(\");\n        boolean remove = false;\n        for (spoon.reflect.code.CtExpression<?> e : invocation.getArguments()) {\n            scan(e);\n            printer.write(\", \");\n            remove = true;\n        }\n        if (remove) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        exitCtExpression(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {\n        enterCtExpression(literal);\n        if (literal.getValue() == null) {\n            printer.write(\"null\");\n        } else if (literal.getValue() instanceof java.lang.Long) {\n            printer.write(literal.getValue() + \"L\");\n        } else if (literal.getValue() instanceof java.lang.Float) {\n            printer.write(literal.getValue() + \"F\");\n        } else if (literal.getValue() instanceof java.lang.Character) {\n            printer.write(\"'\");\n            boolean mayContainsSpecialCharacter = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacter = stringLength != 1;\n            }\n            printer.writeStringLiteral(new java.lang.String(new char[]{ ((java.lang.Character) (literal.getValue())) }), mayContainsSpecialCharacter);\n            printer.write(\"'\");\n        } else if (literal.getValue() instanceof java.lang.String) {\n            printer.write('\\\"');\n            boolean mayContainsSpecialCharacters = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacters = ((java.lang.String) (literal.getValue())).length() != stringLength;\n            }\n            printer.writeStringLiteral(((java.lang.String) (literal.getValue())), mayContainsSpecialCharacters);\n            printer.write('\\\"');\n        } else if (literal.getValue() instanceof java.lang.Class) {\n            printer.write(((java.lang.Class<?>) (literal.getValue())).getName());\n        } else {\n            printer.write(literal.getValue().toString());\n        }\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {\n        if (!context.noTypeDecl()) {\n            enterCtStatement(localVariable);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(localVariable);\n        }\n        if (!context.noTypeDecl()) {\n            elementPrinterHelper.writeModifiers(localVariable);\n            scan(localVariable.getType());\n            printer.write(\" \");\n        }\n        printer.write(localVariable.getSimpleName());\n        if (localVariable.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(localVariable.getDefaultExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(catchVariable);\n        }\n        elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        printer.write(\" \");\n        printer.write(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {\n        elementPrinterHelper.writeComment(m);\n        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(m);\n        if (m.isDefaultMethod()) {\n            printer.write(\"default \");\n        }\n        elementPrinterHelper.writeFormalTypeParameters(m);\n        if (m.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        printer.write(\" \");\n        printer.write(m.getSimpleName());\n        elementPrinterHelper.writeExecutableParameters(m);\n        elementPrinterHelper.writeThrowsClause(m);\n        if (m.getBody() != null) {\n            printer.write(\" \");\n            scan(m.getBody());\n            if (m.getBody().getPosition() != null) {\n                if (m.getBody().getPosition().getCompilationUnit() == sourceCompilationUnit) {\n                    if (m.getBody().getStatements().isEmpty() || (!(m.getBody().getStatements().get(m.getBody().getStatements().size() - 1) instanceof spoon.reflect.code.CtReturn))) {\n                        printer.putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                } else {\n                    printer.undefineLine();\n                }\n            } else {\n                printer.undefineLine();\n            }\n        } else {\n            printer.write(\";\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n        elementPrinterHelper.writeComment(annotationMethod);\n        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        printer.write(\" \");\n        printer.write(annotationMethod.getSimpleName());\n        printer.write(\"()\");\n        if (annotationMethod.getDefaultExpression() != null) {\n            printer.write(\" default \");\n            scan(annotationMethod.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation = (newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class) == null) && (newArray.getParent(spoon.reflect.declaration.CtAnnotation.class) == null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation = true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();\n            if (ref != null) {\n                printer.write(\"new \");\n            }\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                printer.write(\"[\");\n                if (newArray.getDimensionExpressions().size() > i) {\n                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                printer.write(\"]\");\n                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().size() == 0) {\n            printer.write(\"{ \");\n            java.util.List<spoon.reflect.code.CtExpression<?>> l_elements = newArray.getElements();\n            for (int i = 0; i < l_elements.size(); i++) {\n                spoon.reflect.code.CtExpression e = l_elements.get(i);\n                scan(e);\n                printer.write(\" , \");\n                if ((i + 1) == l_elements.size()) {\n                    printer.removeLastChar();\n                    java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n                    if ((!comments.isEmpty()) && (comments.get(comments.size() - 1).getCommentType() == spoon.reflect.code.CtComment.CommentType.INLINE)) {\n                        printer.writeln();\n                    }\n                }\n            }\n            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            printer.write(\" }\");\n        }\n        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n    }\n\n    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (ctConstructorCall.getTarget() != null) {\n                scan(ctConstructorCall.getTarget());\n                printer.write(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            printer.write(\"new \");\n            if (ctConstructorCall.getActualTypeArguments().size() > 0) {\n                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        printer.write(\"(\");\n        for (spoon.reflect.code.CtCodeElement exp : ctConstructorCall.getArguments()) {\n            scan(exp);\n            printer.write(\", \");\n        }\n        if (ctConstructorCall.getArguments().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n    }\n\n    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (reference == null) {\n            return false;\n        }\n        if (reference.getDeclaringType() == null) {\n            return false;\n        }\n        if (reference.isLocalType()) {\n            return false;\n        }\n        if (reference.getDeclaringType().getActualTypeArguments().size() != 0) {\n            return true;\n        }\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {\n        enterCtExpression(lambda);\n        printer.write(\"(\");\n        if (lambda.getParameters().size() > 0) {\n            for (spoon.reflect.declaration.CtParameter<?> parameter : lambda.getParameters()) {\n                scan(parameter);\n                printer.write(\",\");\n            }\n            printer.removeLastChar();\n        }\n        printer.write(\") -> \");\n        if (lambda.getBody() != null) {\n            scan(lambda.getBody());\n        } else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n        enterCtExpression(expression);\n        scan(expression.getTarget());\n        printer.write(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            printer.write(\"new\");\n        } else {\n            printer.write(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        printer.write(\" \");\n        printer.writeOperator(assignment.getKind());\n        printer.write(\"= \");\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!ctPackage.isUnnamedPackage()) {\n            printer.write((\"package \" + ctPackage.getQualifiedName()) + \";\");\n        } else {\n            printer.write(\"// default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)\\n\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {\n        elementPrinterHelper.writeComment(parameter);\n        elementPrinterHelper.writeAnnotations(parameter);\n        elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());\n            printer.write(\"...\");\n        } else {\n            scan(parameter.getType());\n        }\n        printer.write(\" \");\n        printer.write(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {\n        enterCtStatement(returnStatement);\n        printer.write(\"return \");\n        scan(returnStatement.getReturnedExpression());\n    }\n\n    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {\n        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(type, sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            context.currentTopLevel = type;\n        }\n        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {\n        enterCtStatement(switchStatement);\n        printer.write(\"switch (\");\n        scan(switchStatement.getSelector());\n        printer.write(\") {\").incTab();\n        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {\n            printer.writeln().writeTabs();\n            scan(c);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.decTab().write(\"}\");\n        } else {\n            printer.decTab().writeln().writeTabs().write(\"}\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        printer.write(\"synchronized\");\n        if (synchro.getExpression() != null) {\n            printer.write(\"(\");\n            scan(synchro.getExpression());\n            printer.write(\") \");\n        }\n        scan(synchro.getBlock());\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        printer.write(\"throw \");\n        scan(throwStatement.getThrownExpression());\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        printer.write(\"try \");\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if (tryBlock.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryBlock.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        printer.write(\"try \");\n        if ((tryWithResource.getResources() != null) && (!tryWithResource.getResources().isEmpty())) {\n            printer.write(\"(\");\n            for (spoon.reflect.code.CtLocalVariable<?> r : tryWithResource.getResources()) {\n                scan(r);\n                printer.write(\";\");\n            }\n            printer.removeLastChar();\n            printer.write(\") \");\n        }\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if (tryWithResource.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryWithResource.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        if (wildcardReference.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(wildcardReference);\n        if (printQualified(wildcardReference)) {\n            printer.write(wildcardReference.getQualifiedName());\n        } else {\n            printer.write(wildcardReference.getSimpleName());\n        }\n        if (wildcardReference.getBoundingType() != null) {\n            if (wildcardReference.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(wildcardReference.getBoundingType());\n        }\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (importsContext.isImported(ref) || ((this.env.isAutoImports() && (ref.getPackage() != null)) && ref.getPackage().getSimpleName().equals(\"java.lang\"))) {\n            for (spoon.reflect.visitor.TypeContext typeContext : context.currentThis) {\n                if (typeContext.getSimpleName().equals(ref.getSimpleName()) && (!java.util.Objects.equals(typeContext.getPackage(), ref.getPackage()))) {\n                    return true;\n                }\n                if (typeContext.isNameConflict(ref.getSimpleName())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n        for (spoon.reflect.reference.CtTypeReference<?> bound : reference.getBounds()) {\n            scan(bound);\n            printer.write(\" & \");\n        }\n        printer.removeLastChar();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n            return;\n        }\n        boolean isInner = ref.getDeclaringType() != null;\n        if (isInner) {\n            if ((!context.ignoreEnclosingClass()) && (!ref.isLocalType())) {\n                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();\n                if (!accessType.isAnonymous()) {\n                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    printer.write(\".\");\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                printer.write(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(ref.getSimpleName());\n            }\n        } else {\n            if ((ref.getPackage() != null) && printQualified(ref)) {\n                if (!ref.getPackage().isUnnamedPackage()) {\n                    scan(ref.getPackage());\n                    printer.write(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n        }\n        if (withGenerics && (!context.ignoreGenerics())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {\n                elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        printer.preWriteUnaryOperator(operator.getKind());\n        scan(operator.getOperand());\n        printer.postWriteUnaryOperator(operator.getKind());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {\n        enterCtExpression(variableRead);\n        printer.write(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n        enterCtExpression(variableWrite);\n        printer.write(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        printer.write(\"while (\");\n        scan(whileLoop.getLoopingExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n        elementPrinterHelper.writeComment(expression);\n        printer.write(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        elementPrinterHelper.writeComment(statement);\n        printer.write(statement.getValue());\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return context;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String getPackageDeclaration() {\n        return printPackageInfo(context.currentTopLevel.getPackage());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        spoon.reflect.visitor.PrinterHelper bck = printer;\n        spoon.reflect.visitor.ElementPrinterHelper bck2 = elementPrinterHelper;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        elementPrinterHelper.writeComment(pack);\n        for (spoon.reflect.declaration.CtAnnotation<?> a : pack.getAnnotations()) {\n            a.accept(this);\n        }\n        if (!pack.isUnnamedPackage()) {\n            printer.write((\"package \" + pack.getQualifiedName()) + \";\");\n        }\n        java.lang.String ret = printer.toString();\n        elementPrinterHelper = bck2;\n        printer = bck;\n        return ret;\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public void reset() {\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper.setPrinter(printer);\n        context = new spoon.reflect.visitor.PrintingContext();\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {\n        this.sourceCompilationUnit = sourceCompilationUnit;\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n        java.util.Set<spoon.reflect.reference.CtReference> imports = new java.util.HashSet<>();\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            imports.addAll(computeImports(t));\n        }\n        elementPrinterHelper.writeHeader(types, imports);\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            scan(t);\n            if (!env.isPreserveLineNumbers()) {\n                printer.writeln().writeln().writeTabs();\n            } else {\n                printer.adjustEndPosition(t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {\n        return printer.getLineNumberMapping();\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "MOV",
            "src": "@java.lang.Override\npublic void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n    visitCtTypeParameterReference(typeParameter.getReference());\n}",
            "src_parent": "public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    public static final java.lang.String JAVA_FILE_EXTENSION = \".java\";\n\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION = \"package-info\" + spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION;\n\n    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty(\"line.separator\");\n\n    public static final java.lang.String COMMENT_STAR = \" * \";\n\n    public static final java.lang.String BLOCK_COMMENT_END = \" */\";\n\n    public static final java.lang.String JAVADOC_START = \"/**\";\n\n    public static final java.lang.String INLINE_COMMENT_START = \"// \";\n\n    public static final java.lang.String BLOCK_COMMENT_START = \"/* \";\n\n    public spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();\n\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    private spoon.compiler.Environment env;\n\n    private spoon.reflect.visitor.PrinterHelper printer;\n\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    private spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env = env;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        printer.mapLine(e, sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            context.parenthesedExpression.push(e);\n            printer.write(\"(\");\n        }\n        if (!e.getTypeCasts().isEmpty()) {\n            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {\n                printer.write(\"(\");\n                this.scan(r);\n                printer.write(\") \");\n                printer.write(\"(\");\n                context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(s, sourceCompilationUnit);\n        elementPrinterHelper.writeAnnotations(s);\n        if (s.getLabel() != null) {\n            printer.write(s.getLabel()).write(\" : \");\n        }\n    }\n\n    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        while ((context.parenthesedExpression.size() > 0) && (e == context.parenthesedExpression.peek())) {\n            context.parenthesedExpression.pop();\n            printer.write(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeImports(spoon.reflect.declaration.CtType<?> type) {\n        context.currentTopLevel = type;\n        return importsContext.computeAllImports(context.currentTopLevel);\n    }\n\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (env.isAutoImports()) {\n            importsContext.computeImports(element);\n        }\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e != null) {\n            context.elementStack.push(e);\n            if (env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    printer.adjustStartPosition(e);\n                }\n            }\n            e.accept(this);\n            context.elementStack.pop();\n        }\n        return this;\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.reference.CtReference ref) {\n        if (ref != null) {\n            ref.accept(this);\n        }\n        return this;\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {\n        if (e.getTypeCasts().size() != 0) {\n            return true;\n        }\n        try {\n            if ((e.getParent() instanceof spoon.reflect.code.CtBinaryOperator) || (e.getParent() instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if (e.getParent() instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {\n        elementPrinterHelper.writeAnnotations(annotation);\n        printer.write(\"@\");\n        scan(annotation.getAnnotationType());\n        if (annotation.getValues().size() > 0) {\n            printer.write(\"(\");\n            for (java.util.Map.Entry<java.lang.String, spoon.reflect.code.CtExpression> e : annotation.getValues().entrySet()) {\n                printer.write(e.getKey() + \" = \");\n                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\")\");\n        }\n        printer.writeln().writeTabs();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        visitCtType(annotationType);\n        printer.write((\"@interface \" + annotationType.getSimpleName()) + \" {\").incTab();\n        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        elementPrinterHelper.writeComment(impl);\n        elementPrinterHelper.writeAnnotations(impl);\n        elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        printer.write(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        printer.write(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!context.skipArray()) {\n            printer.write(\"[]\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {\n        enterCtStatement(asserted);\n        printer.write(\"assert \");\n        scan(asserted.getAssertExpression());\n        if (asserted.getExpression() != null) {\n            printer.write(\" : \");\n            scan(asserted.getExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        printer.write(\" = \");\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        printer.write(\" \").writeOperator(operator.getKind()).write(\" \");\n        scan(operator.getRightHandOperand());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {\n        enterCtStatement(block);\n        if (!block.isImplicit()) {\n            printer.write(\"{\");\n        }\n        printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!statement.isImplicit()) {\n                printer.writeln().writeTabs();\n                elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        printer.decTab();\n        printer.adjustEndPosition(block);\n        if (env.isPreserveLineNumbers()) {\n            if (!block.isImplicit()) {\n                printer.writeTabs().write(\"}\");\n            }\n        } else {\n            printer.writeln().writeTabs();\n            if (!block.isImplicit()) {\n                printer.write(\"}\");\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        printer.write(\"break\");\n        if (breakStatement.getTargetLabel() != null) {\n            printer.write(\" \" + breakStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {\n        enterCtStatement(caseStatement);\n        if (caseStatement.getCaseExpression() != null) {\n            printer.write(\"case \");\n            if (caseStatement.getCaseExpression() instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                if (((variable.getType() != null) && (variable.getDeclaringType() != null)) && variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName())) {\n                    printer.write(variable.getSimpleName());\n                } else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            } else {\n                scan(caseStatement.getCaseExpression());\n            }\n        } else {\n            printer.write(\"default\");\n        }\n        printer.write(\" :\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            printer.writeln().writeTabs();\n            elementPrinterHelper.writeStatement(statement);\n        }\n        printer.decTab();\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.write(\" catch (\");\n        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();\n        if (parameter.getMultiTypes().size() > 0) {\n            for (int i = 0; i < parameter.getMultiTypes().size(); i++) {\n                spoon.reflect.reference.CtTypeReference<?> type = parameter.getMultiTypes().get(i);\n                scan(type);\n                if (i < (parameter.getMultiTypes().size() - 1)) {\n                    printer.write(\" | \");\n                }\n            }\n            printer.write(\" \" + parameter.getSimpleName());\n        } else {\n            scan(parameter);\n        }\n        printer.write(\") \");\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        context.pushCurrentThis(ctClass);\n        if (((ctClass.getSimpleName() != null) && (!spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()))) && (!ctClass.isAnonymous())) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                printer.write(\"class \" + ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(\"class \" + ctClass.getSimpleName());\n            }\n            elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            elementPrinterHelper.writeExtendsClause(ctClass);\n            elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        printer.adjustEndPosition(ctClass).decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        visitCtTypeParameterReference(typeParameter.getReference());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();\n        boolean parent;\n        try {\n            parent = (conditional.getParent() instanceof spoon.reflect.code.CtAssignment) || (conditional.getParent() instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            parent = false;\n        }\n        if (parent) {\n            printer.write(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            printer.write(\")\");\n        }\n        printer.write(\" ? \");\n        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();\n        scan(thenExpression);\n        printer.write(\" : \");\n        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();\n        boolean isAssign = false;\n        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            printer.write(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            printer.write(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {\n        elementPrinterHelper.writeComment(constructor);\n        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(constructor);\n        elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (constructor.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        if (constructor.getDeclaringType() != null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                printer.write(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        elementPrinterHelper.writeExecutableParameters(constructor);\n        elementPrinterHelper.writeThrowsClause(constructor);\n        printer.write(\" \");\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        printer.write(\"continue\");\n        if (continueStatement.getTargetLabel() != null) {\n            printer.write(\" \" + continueStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        printer.write(\"do\");\n        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        printer.write(\"while (\");\n        scan(doLoop.getLoopingExpression());\n        printer.write(\" )\");\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        visitCtType(ctEnum);\n        printer.write(\"enum \" + ctEnum.getSimpleName());\n        elementPrinterHelper.writeImplementsClause(ctEnum);\n        context.pushCurrentThis(ctEnum);\n        printer.write(\" {\").incTab().writeln();\n        if (ctEnum.getEnumValues().size() == 0) {\n            printer.writeTabs().write(\";\").writeln();\n        } else {\n            for (spoon.reflect.declaration.CtEnumValue<?> enumValue : ctEnum.getEnumValues()) {\n                scan(enumValue);\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\";\");\n        }\n        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        printer.write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {\n        elementPrinterHelper.writeComment(f);\n        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        printer.write(\" \");\n        printer.write(f.getSimpleName());\n        if (f.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(f.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n        printer.write(enumValue.getSimpleName());\n        if (enumValue.getDefaultExpression() != null) {\n            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));\n            if (constructorCall.getArguments().size() > 0) {\n                printer.write(\"(\");\n                boolean first = true;\n                for (spoon.reflect.code.CtExpression<?> ctexpr : constructorCall.getArguments()) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        printer.write(\",\");\n                    }\n                    scan(ctexpr);\n                }\n                printer.write(\")\");\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {\n        enterCtExpression(f);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (f.getVariable().isStatic() && (f.getTarget() instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression<?> target = f.getTarget();\n            if (target != null) {\n                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField = f.getVariable().isStatic();\n                boolean isImportedField = importsContext.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {\n                    if (target.isImplicit()) {\n                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();\n                        final java.lang.String fieldName = field.getSimpleName();\n                        spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                        if (var != field) {\n                            target.setImplicit(false);\n                        }\n                    }\n                    printer.snapshotLength();\n                    scan(target);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent = targetExp.getParent();\n            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        if ((((((parent instanceof spoon.reflect.code.CtFieldWrite) && targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget())) && (anonymousParent != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable() != null)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();\n            if (thisAccess.isImplicit()) {\n                return;\n            }\n            if ((targetType == null) || ((thisAccess.getParent(spoon.reflect.declaration.CtType.class) != null) && thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel())) {\n                printer.write(\"this\");\n                return;\n            }\n            if (targetType.isAnonymous()) {\n                printer.write(\"this\");\n                return;\n            }\n            if (!context.currentThis.isEmpty()) {\n                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();\n                if (!lastTypeQualifiedName.equals(targetTypeQualifiedName)) {\n                    printer.snapshotLength();\n                    visitCtTypeReferenceWithoutGenerics(targetType);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                    printer.write(\"this\");\n                    return;\n                }\n            }\n            printer.write(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {\n        enterCtExpression(f);\n        if (f.getTarget() != null) {\n            scan(f.getTarget());\n            printer.write(\".\");\n        }\n        printer.write(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n        printer.write(spoon.reflect.code.CtJavaDocTag.JAVADOC_TAG_PREFIX);\n        printer.write(docTag.getType().name().toLowerCase());\n        printer.write(\" \");\n        if (docTag.getType().hasParam()) {\n            printer.write(docTag.getParam()).writeln().writeTabs();\n        }\n        java.lang.String[] tagLines = docTag.getContent().split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n        for (int i = 0; i < tagLines.length; i++) {\n            java.lang.String com = tagLines[i];\n            if ((i > 0) || docTag.getType().hasParam()) {\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n            }\n            if (docTag.getType().hasParam()) {\n                printer.write(\"\\t\\t\");\n            }\n            printer.write(com.trim()).writeln().writeTabs();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!env.isCommentsEnabled()) && (context.elementStack.size() > 1)) {\n            return;\n        }\n        switch (comment.getCommentType()) {\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln().writeTabs();\n                break;\n            case INLINE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.INLINE_COMMENT_START);\n                break;\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_START);\n                break;\n        }\n        java.lang.String content = comment.getContent();\n        switch (comment.getCommentType()) {\n            case INLINE :\n                printer.write(content);\n                break;\n            default :\n                java.lang.String[] lines = content.split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n                for (int i = 0; i < lines.length; i++) {\n                    java.lang.String com = lines[i];\n                    if (comment.getCommentType() == spoon.reflect.code.CtComment.CommentType.BLOCK) {\n                        printer.write(com);\n                        if (lines.length > 1) {\n                            printer.writeln().writeTabs();\n                        }\n                    } else if (com.length() > 0) {\n                        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR + com).writeln().writeTabs();\n                    } else {\n                        printer.write(\" *\" + com).writeln().writeTabs();\n                    }\n                }\n                if (comment instanceof spoon.reflect.code.CtJavaDoc) {\n                    if (!((spoon.reflect.code.CtJavaDoc) (comment)).getTags().isEmpty()) {\n                        printer.write(\" *\").writeln().writeTabs();\n                    }\n                    for (spoon.reflect.code.CtJavaDocTag docTag : ((spoon.reflect.code.CtJavaDoc) (comment)).getTags()) {\n                        scan(docTag);\n                    }\n                }\n                break;\n        }\n        switch (comment.getCommentType()) {\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (annotationFieldAccess.getTarget() != null) {\n                scan(annotationFieldAccess.getTarget());\n                printer.write(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            printer.write(\"()\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        boolean isStatic = reference.getSimpleName().equals(\"class\") || ((!reference.getSimpleName().equals(\"super\")) && reference.isStatic());\n        boolean printType = true;\n        if (reference.isFinal() && reference.isStatic()) {\n            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                printType = false;\n            } else if (context.isInCurrentScope(declTypeRef)) {\n                printType = false;\n            }\n        }\n        if ((isStatic && printType) && (!context.ignoreStaticAccess())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            printer.write(\".\");\n        }\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        printer.write(\"for (\");\n        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();\n        if (st.size() > 0) {\n            scan(st.get(0));\n        }\n        if (st.size() > 1) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().noTypeDecl(true)) {\n                for (int i = 1; i < st.size(); i++) {\n                    printer.write(\", \");\n                    scan(st.get(i));\n                }\n            }\n        }\n        printer.write(\"; \");\n        scan(forLoop.getExpression());\n        printer.write(\";\");\n        if (!forLoop.getForUpdate().isEmpty()) {\n            printer.write(\" \");\n        }\n        for (spoon.reflect.code.CtStatement s : forLoop.getForUpdate()) {\n            scan(s);\n            printer.write(\" , \");\n        }\n        if (forLoop.getForUpdate().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        printer.write(\"for (\");\n        scan(foreach.getVariable());\n        printer.write(\" : \");\n        scan(foreach.getExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        printer.write(\"if (\");\n        scan(ifElement.getCondition());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if (ifElement.getElseStatement() != null) {\n            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition() == null) ? ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition() : ifElement.getThenStatement().getPosition();\n                if (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd()) {\n                    elementPrinterHelper.writeComment(comment);\n                }\n            }\n            printer.write(\"else\");\n            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        visitCtType(intrface);\n        printer.write(\"interface \" + intrface.getSimpleName());\n        if (intrface.getFormalCtTypeParameters() != null) {\n            elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (intrface.getSuperInterfaces().size() > 0) {\n            printer.write(\" extends \");\n            for (spoon.reflect.reference.CtTypeReference<?> ref : intrface.getSuperInterfaces()) {\n                scan(ref);\n                printer.write(\" , \");\n            }\n            printer.removeLastChar();\n        }\n        context.pushCurrentThis(intrface);\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType<?> parentType;\n            try {\n                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType = null;\n            }\n            if (((parentType != null) && (parentType.getQualifiedName() != null)) && parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName())) {\n                printer.write(\"this\");\n            } else {\n                printer.snapshotLength();\n                scan(invocation.getTarget());\n                if (printer.hasNewContent()) {\n                    printer.write(\".\");\n                }\n                printer.write(\"super\");\n            }\n        } else {\n            printer.snapshotLength();\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                if (invocation.getTarget() instanceof spoon.reflect.code.CtTypeAccess) {\n                    _context.ignoreGenerics(true);\n                }\n                scan(invocation.getTarget());\n            }\n            if (printer.hasNewContent()) {\n                printer.write(\".\");\n            }\n            elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (env.isPreserveLineNumbers()) {\n                printer.adjustStartPosition(invocation);\n            }\n            printer.write(invocation.getExecutable().getSimpleName());\n        }\n        printer.write(\"(\");\n        boolean remove = false;\n        for (spoon.reflect.code.CtExpression<?> e : invocation.getArguments()) {\n            scan(e);\n            printer.write(\", \");\n            remove = true;\n        }\n        if (remove) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        exitCtExpression(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {\n        enterCtExpression(literal);\n        if (literal.getValue() == null) {\n            printer.write(\"null\");\n        } else if (literal.getValue() instanceof java.lang.Long) {\n            printer.write(literal.getValue() + \"L\");\n        } else if (literal.getValue() instanceof java.lang.Float) {\n            printer.write(literal.getValue() + \"F\");\n        } else if (literal.getValue() instanceof java.lang.Character) {\n            printer.write(\"'\");\n            boolean mayContainsSpecialCharacter = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacter = stringLength != 1;\n            }\n            printer.writeStringLiteral(new java.lang.String(new char[]{ ((java.lang.Character) (literal.getValue())) }), mayContainsSpecialCharacter);\n            printer.write(\"'\");\n        } else if (literal.getValue() instanceof java.lang.String) {\n            printer.write('\\\"');\n            boolean mayContainsSpecialCharacters = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacters = ((java.lang.String) (literal.getValue())).length() != stringLength;\n            }\n            printer.writeStringLiteral(((java.lang.String) (literal.getValue())), mayContainsSpecialCharacters);\n            printer.write('\\\"');\n        } else if (literal.getValue() instanceof java.lang.Class) {\n            printer.write(((java.lang.Class<?>) (literal.getValue())).getName());\n        } else {\n            printer.write(literal.getValue().toString());\n        }\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {\n        if (!context.noTypeDecl()) {\n            enterCtStatement(localVariable);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(localVariable);\n        }\n        if (!context.noTypeDecl()) {\n            elementPrinterHelper.writeModifiers(localVariable);\n            scan(localVariable.getType());\n            printer.write(\" \");\n        }\n        printer.write(localVariable.getSimpleName());\n        if (localVariable.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(localVariable.getDefaultExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(catchVariable);\n        }\n        elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        printer.write(\" \");\n        printer.write(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {\n        elementPrinterHelper.writeComment(m);\n        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(m);\n        if (m.isDefaultMethod()) {\n            printer.write(\"default \");\n        }\n        elementPrinterHelper.writeFormalTypeParameters(m);\n        if (m.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        printer.write(\" \");\n        printer.write(m.getSimpleName());\n        elementPrinterHelper.writeExecutableParameters(m);\n        elementPrinterHelper.writeThrowsClause(m);\n        if (m.getBody() != null) {\n            printer.write(\" \");\n            scan(m.getBody());\n            if (m.getBody().getPosition() != null) {\n                if (m.getBody().getPosition().getCompilationUnit() == sourceCompilationUnit) {\n                    if (m.getBody().getStatements().isEmpty() || (!(m.getBody().getStatements().get(m.getBody().getStatements().size() - 1) instanceof spoon.reflect.code.CtReturn))) {\n                        printer.putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                } else {\n                    printer.undefineLine();\n                }\n            } else {\n                printer.undefineLine();\n            }\n        } else {\n            printer.write(\";\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n        elementPrinterHelper.writeComment(annotationMethod);\n        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        printer.write(\" \");\n        printer.write(annotationMethod.getSimpleName());\n        printer.write(\"()\");\n        if (annotationMethod.getDefaultExpression() != null) {\n            printer.write(\" default \");\n            scan(annotationMethod.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation = (newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class) == null) && (newArray.getParent(spoon.reflect.declaration.CtAnnotation.class) == null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation = true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();\n            if (ref != null) {\n                printer.write(\"new \");\n            }\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                printer.write(\"[\");\n                if (newArray.getDimensionExpressions().size() > i) {\n                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                printer.write(\"]\");\n                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().size() == 0) {\n            printer.write(\"{ \");\n            java.util.List<spoon.reflect.code.CtExpression<?>> l_elements = newArray.getElements();\n            for (int i = 0; i < l_elements.size(); i++) {\n                spoon.reflect.code.CtExpression e = l_elements.get(i);\n                scan(e);\n                printer.write(\" , \");\n                if ((i + 1) == l_elements.size()) {\n                    printer.removeLastChar();\n                    java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n                    if ((!comments.isEmpty()) && (comments.get(comments.size() - 1).getCommentType() == spoon.reflect.code.CtComment.CommentType.INLINE)) {\n                        printer.writeln();\n                    }\n                }\n            }\n            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            printer.write(\" }\");\n        }\n        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n    }\n\n    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (ctConstructorCall.getTarget() != null) {\n                scan(ctConstructorCall.getTarget());\n                printer.write(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            printer.write(\"new \");\n            if (ctConstructorCall.getActualTypeArguments().size() > 0) {\n                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        printer.write(\"(\");\n        for (spoon.reflect.code.CtCodeElement exp : ctConstructorCall.getArguments()) {\n            scan(exp);\n            printer.write(\", \");\n        }\n        if (ctConstructorCall.getArguments().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n    }\n\n    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (reference == null) {\n            return false;\n        }\n        if (reference.getDeclaringType() == null) {\n            return false;\n        }\n        if (reference.isLocalType()) {\n            return false;\n        }\n        if (reference.getDeclaringType().getActualTypeArguments().size() != 0) {\n            return true;\n        }\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {\n        enterCtExpression(lambda);\n        printer.write(\"(\");\n        if (lambda.getParameters().size() > 0) {\n            for (spoon.reflect.declaration.CtParameter<?> parameter : lambda.getParameters()) {\n                scan(parameter);\n                printer.write(\",\");\n            }\n            printer.removeLastChar();\n        }\n        printer.write(\") -> \");\n        if (lambda.getBody() != null) {\n            scan(lambda.getBody());\n        } else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n        enterCtExpression(expression);\n        scan(expression.getTarget());\n        printer.write(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            printer.write(\"new\");\n        } else {\n            printer.write(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        printer.write(\" \");\n        printer.writeOperator(assignment.getKind());\n        printer.write(\"= \");\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!ctPackage.isUnnamedPackage()) {\n            printer.write((\"package \" + ctPackage.getQualifiedName()) + \";\");\n        } else {\n            printer.write(\"// default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)\\n\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {\n        elementPrinterHelper.writeComment(parameter);\n        elementPrinterHelper.writeAnnotations(parameter);\n        elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());\n            printer.write(\"...\");\n        } else {\n            scan(parameter.getType());\n        }\n        printer.write(\" \");\n        printer.write(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {\n        enterCtStatement(returnStatement);\n        printer.write(\"return \");\n        scan(returnStatement.getReturnedExpression());\n    }\n\n    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {\n        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(type, sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            context.currentTopLevel = type;\n        }\n        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {\n        enterCtStatement(switchStatement);\n        printer.write(\"switch (\");\n        scan(switchStatement.getSelector());\n        printer.write(\") {\").incTab();\n        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {\n            printer.writeln().writeTabs();\n            scan(c);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.decTab().write(\"}\");\n        } else {\n            printer.decTab().writeln().writeTabs().write(\"}\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        printer.write(\"synchronized\");\n        if (synchro.getExpression() != null) {\n            printer.write(\"(\");\n            scan(synchro.getExpression());\n            printer.write(\") \");\n        }\n        scan(synchro.getBlock());\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        printer.write(\"throw \");\n        scan(throwStatement.getThrownExpression());\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        printer.write(\"try \");\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if (tryBlock.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryBlock.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        printer.write(\"try \");\n        if ((tryWithResource.getResources() != null) && (!tryWithResource.getResources().isEmpty())) {\n            printer.write(\"(\");\n            for (spoon.reflect.code.CtLocalVariable<?> r : tryWithResource.getResources()) {\n                scan(r);\n                printer.write(\";\");\n            }\n            printer.removeLastChar();\n            printer.write(\") \");\n        }\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if (tryWithResource.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryWithResource.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n        if (ref.getBoundingType() != null) {\n            if (ref.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(ref.getBoundingType());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        visitCtTypeParameterReference(wildcardReference);\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (importsContext.isImported(ref) || ((this.env.isAutoImports() && (ref.getPackage() != null)) && ref.getPackage().getSimpleName().equals(\"java.lang\"))) {\n            for (spoon.reflect.visitor.TypeContext typeContext : context.currentThis) {\n                if (typeContext.getSimpleName().equals(ref.getSimpleName()) && (!java.util.Objects.equals(typeContext.getPackage(), ref.getPackage()))) {\n                    return true;\n                }\n                if (typeContext.isNameConflict(ref.getSimpleName())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n        for (spoon.reflect.reference.CtTypeReference<?> bound : reference.getBounds()) {\n            scan(bound);\n            printer.write(\" & \");\n        }\n        printer.removeLastChar();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n            return;\n        }\n        boolean isInner = ref.getDeclaringType() != null;\n        if (isInner) {\n            if ((!context.ignoreEnclosingClass()) && (!ref.isLocalType())) {\n                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();\n                if (!accessType.isAnonymous()) {\n                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    printer.write(\".\");\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                printer.write(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(ref.getSimpleName());\n            }\n        } else {\n            if ((ref.getPackage() != null) && printQualified(ref)) {\n                if (!ref.getPackage().isUnnamedPackage()) {\n                    scan(ref.getPackage());\n                    printer.write(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n        }\n        if (withGenerics && (!context.ignoreGenerics())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {\n                elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        printer.preWriteUnaryOperator(operator.getKind());\n        scan(operator.getOperand());\n        printer.postWriteUnaryOperator(operator.getKind());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {\n        enterCtExpression(variableRead);\n        printer.write(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n        enterCtExpression(variableWrite);\n        printer.write(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        printer.write(\"while (\");\n        scan(whileLoop.getLoopingExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n        elementPrinterHelper.writeComment(expression);\n        printer.write(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        elementPrinterHelper.writeComment(statement);\n        printer.write(statement.getValue());\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return context;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String getPackageDeclaration() {\n        return printPackageInfo(context.currentTopLevel.getPackage());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        spoon.reflect.visitor.PrinterHelper bck = printer;\n        spoon.reflect.visitor.ElementPrinterHelper bck2 = elementPrinterHelper;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        elementPrinterHelper.writeComment(pack);\n        for (spoon.reflect.declaration.CtAnnotation<?> a : pack.getAnnotations()) {\n            a.accept(this);\n        }\n        if (!pack.isUnnamedPackage()) {\n            printer.write((\"package \" + pack.getQualifiedName()) + \";\");\n        }\n        java.lang.String ret = printer.toString();\n        elementPrinterHelper = bck2;\n        printer = bck;\n        return ret;\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public void reset() {\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper.setPrinter(printer);\n        context = new spoon.reflect.visitor.PrintingContext();\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {\n        this.sourceCompilationUnit = sourceCompilationUnit;\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n        java.util.Set<spoon.reflect.reference.CtReference> imports = new java.util.HashSet<>();\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            imports.addAll(computeImports(t));\n        }\n        elementPrinterHelper.writeHeader(types, imports);\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            scan(t);\n            if (!env.isPreserveLineNumbers()) {\n                printer.writeln().writeln().writeTabs();\n            } else {\n                printer.adjustEndPosition(t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {\n        return printer.getLineNumberMapping();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "true",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Method",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "@java.lang.Override\npublic void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n    spoon.reflect.reference.CtTypeParameterReference ref = typeParameter.getReference();\n    if (ref.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(ref);\n    if (printQualified(ref)) {\n        printer.write(ref.getQualifiedName());\n    } else {\n        printer.write(ref.getSimpleName());\n    }\n    if (ref.getBoundingType() != null) {\n        if (ref.isUpper()) {\n            printer.write(\" extends \");\n        } else {\n            printer.write(\" super \");\n        }\n        scan(ref.getBoundingType());\n    }\n}",
            "dst_parent": "public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    public static final java.lang.String JAVA_FILE_EXTENSION = \".java\";\n\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION = \"package-info\" + spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION;\n\n    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty(\"line.separator\");\n\n    public static final java.lang.String COMMENT_STAR = \" * \";\n\n    public static final java.lang.String BLOCK_COMMENT_END = \" */\";\n\n    public static final java.lang.String JAVADOC_START = \"/**\";\n\n    public static final java.lang.String INLINE_COMMENT_START = \"// \";\n\n    public static final java.lang.String BLOCK_COMMENT_START = \"/* \";\n\n    public spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();\n\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    private spoon.compiler.Environment env;\n\n    private spoon.reflect.visitor.PrinterHelper printer;\n\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    private spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env = env;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        printer.mapLine(e, sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            context.parenthesedExpression.push(e);\n            printer.write(\"(\");\n        }\n        if (!e.getTypeCasts().isEmpty()) {\n            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {\n                printer.write(\"(\");\n                this.scan(r);\n                printer.write(\") \");\n                printer.write(\"(\");\n                context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(s, sourceCompilationUnit);\n        elementPrinterHelper.writeAnnotations(s);\n        if (s.getLabel() != null) {\n            printer.write(s.getLabel()).write(\" : \");\n        }\n    }\n\n    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        while ((context.parenthesedExpression.size() > 0) && (e == context.parenthesedExpression.peek())) {\n            context.parenthesedExpression.pop();\n            printer.write(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeImports(spoon.reflect.declaration.CtType<?> type) {\n        context.currentTopLevel = type;\n        return importsContext.computeAllImports(context.currentTopLevel);\n    }\n\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (env.isAutoImports()) {\n            importsContext.computeImports(element);\n        }\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e != null) {\n            context.elementStack.push(e);\n            if (env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    printer.adjustStartPosition(e);\n                }\n            }\n            e.accept(this);\n            context.elementStack.pop();\n        }\n        return this;\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.reference.CtReference ref) {\n        if (ref != null) {\n            ref.accept(this);\n        }\n        return this;\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {\n        if (e.getTypeCasts().size() != 0) {\n            return true;\n        }\n        try {\n            if ((e.getParent() instanceof spoon.reflect.code.CtBinaryOperator) || (e.getParent() instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if (e.getParent() instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {\n        elementPrinterHelper.writeAnnotations(annotation);\n        printer.write(\"@\");\n        scan(annotation.getAnnotationType());\n        if (annotation.getValues().size() > 0) {\n            printer.write(\"(\");\n            for (java.util.Map.Entry<java.lang.String, spoon.reflect.code.CtExpression> e : annotation.getValues().entrySet()) {\n                printer.write(e.getKey() + \" = \");\n                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\")\");\n        }\n        printer.writeln().writeTabs();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        visitCtType(annotationType);\n        printer.write((\"@interface \" + annotationType.getSimpleName()) + \" {\").incTab();\n        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        elementPrinterHelper.writeComment(impl);\n        elementPrinterHelper.writeAnnotations(impl);\n        elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        printer.write(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        printer.write(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!context.skipArray()) {\n            printer.write(\"[]\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {\n        enterCtStatement(asserted);\n        printer.write(\"assert \");\n        scan(asserted.getAssertExpression());\n        if (asserted.getExpression() != null) {\n            printer.write(\" : \");\n            scan(asserted.getExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        printer.write(\" = \");\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        printer.write(\" \").writeOperator(operator.getKind()).write(\" \");\n        scan(operator.getRightHandOperand());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {\n        enterCtStatement(block);\n        if (!block.isImplicit()) {\n            printer.write(\"{\");\n        }\n        printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!statement.isImplicit()) {\n                printer.writeln().writeTabs();\n                elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        printer.decTab();\n        printer.adjustEndPosition(block);\n        if (env.isPreserveLineNumbers()) {\n            if (!block.isImplicit()) {\n                printer.writeTabs().write(\"}\");\n            }\n        } else {\n            printer.writeln().writeTabs();\n            if (!block.isImplicit()) {\n                printer.write(\"}\");\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        printer.write(\"break\");\n        if (breakStatement.getTargetLabel() != null) {\n            printer.write(\" \" + breakStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {\n        enterCtStatement(caseStatement);\n        if (caseStatement.getCaseExpression() != null) {\n            printer.write(\"case \");\n            if (caseStatement.getCaseExpression() instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                if (((variable.getType() != null) && (variable.getDeclaringType() != null)) && variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName())) {\n                    printer.write(variable.getSimpleName());\n                } else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            } else {\n                scan(caseStatement.getCaseExpression());\n            }\n        } else {\n            printer.write(\"default\");\n        }\n        printer.write(\" :\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            printer.writeln().writeTabs();\n            elementPrinterHelper.writeStatement(statement);\n        }\n        printer.decTab();\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.write(\" catch (\");\n        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();\n        if (parameter.getMultiTypes().size() > 0) {\n            for (int i = 0; i < parameter.getMultiTypes().size(); i++) {\n                spoon.reflect.reference.CtTypeReference<?> type = parameter.getMultiTypes().get(i);\n                scan(type);\n                if (i < (parameter.getMultiTypes().size() - 1)) {\n                    printer.write(\" | \");\n                }\n            }\n            printer.write(\" \" + parameter.getSimpleName());\n        } else {\n            scan(parameter);\n        }\n        printer.write(\") \");\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        context.pushCurrentThis(ctClass);\n        if (((ctClass.getSimpleName() != null) && (!spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()))) && (!ctClass.isAnonymous())) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                printer.write(\"class \" + ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(\"class \" + ctClass.getSimpleName());\n            }\n            elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            elementPrinterHelper.writeExtendsClause(ctClass);\n            elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        printer.adjustEndPosition(ctClass).decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        spoon.reflect.reference.CtTypeParameterReference ref = typeParameter.getReference();\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n        if (ref.getBoundingType() != null) {\n            if (ref.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(ref.getBoundingType());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();\n        boolean parent;\n        try {\n            parent = (conditional.getParent() instanceof spoon.reflect.code.CtAssignment) || (conditional.getParent() instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            parent = false;\n        }\n        if (parent) {\n            printer.write(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            printer.write(\")\");\n        }\n        printer.write(\" ? \");\n        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();\n        scan(thenExpression);\n        printer.write(\" : \");\n        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();\n        boolean isAssign = false;\n        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            printer.write(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            printer.write(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {\n        elementPrinterHelper.writeComment(constructor);\n        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(constructor);\n        elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (constructor.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        if (constructor.getDeclaringType() != null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                printer.write(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        elementPrinterHelper.writeExecutableParameters(constructor);\n        elementPrinterHelper.writeThrowsClause(constructor);\n        printer.write(\" \");\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        printer.write(\"continue\");\n        if (continueStatement.getTargetLabel() != null) {\n            printer.write(\" \" + continueStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        printer.write(\"do\");\n        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        printer.write(\"while (\");\n        scan(doLoop.getLoopingExpression());\n        printer.write(\" )\");\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        visitCtType(ctEnum);\n        printer.write(\"enum \" + ctEnum.getSimpleName());\n        elementPrinterHelper.writeImplementsClause(ctEnum);\n        context.pushCurrentThis(ctEnum);\n        printer.write(\" {\").incTab().writeln();\n        if (ctEnum.getEnumValues().size() == 0) {\n            printer.writeTabs().write(\";\").writeln();\n        } else {\n            for (spoon.reflect.declaration.CtEnumValue<?> enumValue : ctEnum.getEnumValues()) {\n                scan(enumValue);\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\";\");\n        }\n        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        printer.write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {\n        elementPrinterHelper.writeComment(f);\n        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        printer.write(\" \");\n        printer.write(f.getSimpleName());\n        if (f.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(f.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n        printer.write(enumValue.getSimpleName());\n        if (enumValue.getDefaultExpression() != null) {\n            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));\n            if (constructorCall.getArguments().size() > 0) {\n                printer.write(\"(\");\n                boolean first = true;\n                for (spoon.reflect.code.CtExpression<?> ctexpr : constructorCall.getArguments()) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        printer.write(\",\");\n                    }\n                    scan(ctexpr);\n                }\n                printer.write(\")\");\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {\n        enterCtExpression(f);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (f.getVariable().isStatic() && (f.getTarget() instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression<?> target = f.getTarget();\n            if (target != null) {\n                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField = f.getVariable().isStatic();\n                boolean isImportedField = importsContext.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {\n                    if (target.isImplicit()) {\n                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();\n                        final java.lang.String fieldName = field.getSimpleName();\n                        spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                        if (var != field) {\n                            target.setImplicit(false);\n                        }\n                    }\n                    printer.snapshotLength();\n                    scan(target);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent = targetExp.getParent();\n            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        if ((((((parent instanceof spoon.reflect.code.CtFieldWrite) && targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget())) && (anonymousParent != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable() != null)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();\n            if (thisAccess.isImplicit()) {\n                return;\n            }\n            if ((targetType == null) || ((thisAccess.getParent(spoon.reflect.declaration.CtType.class) != null) && thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel())) {\n                printer.write(\"this\");\n                return;\n            }\n            if (targetType.isAnonymous()) {\n                printer.write(\"this\");\n                return;\n            }\n            if (!context.currentThis.isEmpty()) {\n                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();\n                if (!lastTypeQualifiedName.equals(targetTypeQualifiedName)) {\n                    printer.snapshotLength();\n                    visitCtTypeReferenceWithoutGenerics(targetType);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                    printer.write(\"this\");\n                    return;\n                }\n            }\n            printer.write(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {\n        enterCtExpression(f);\n        if (f.getTarget() != null) {\n            scan(f.getTarget());\n            printer.write(\".\");\n        }\n        printer.write(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n        printer.write(spoon.reflect.code.CtJavaDocTag.JAVADOC_TAG_PREFIX);\n        printer.write(docTag.getType().name().toLowerCase());\n        printer.write(\" \");\n        if (docTag.getType().hasParam()) {\n            printer.write(docTag.getParam()).writeln().writeTabs();\n        }\n        java.lang.String[] tagLines = docTag.getContent().split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n        for (int i = 0; i < tagLines.length; i++) {\n            java.lang.String com = tagLines[i];\n            if ((i > 0) || docTag.getType().hasParam()) {\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n            }\n            if (docTag.getType().hasParam()) {\n                printer.write(\"\\t\\t\");\n            }\n            printer.write(com.trim()).writeln().writeTabs();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!env.isCommentsEnabled()) && (context.elementStack.size() > 1)) {\n            return;\n        }\n        switch (comment.getCommentType()) {\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln().writeTabs();\n                break;\n            case INLINE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.INLINE_COMMENT_START);\n                break;\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_START);\n                break;\n        }\n        java.lang.String content = comment.getContent();\n        switch (comment.getCommentType()) {\n            case INLINE :\n                printer.write(content);\n                break;\n            default :\n                java.lang.String[] lines = content.split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n                for (int i = 0; i < lines.length; i++) {\n                    java.lang.String com = lines[i];\n                    if (comment.getCommentType() == spoon.reflect.code.CtComment.CommentType.BLOCK) {\n                        printer.write(com);\n                        if (lines.length > 1) {\n                            printer.writeln().writeTabs();\n                        }\n                    } else if (com.length() > 0) {\n                        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR + com).writeln().writeTabs();\n                    } else {\n                        printer.write(\" *\" + com).writeln().writeTabs();\n                    }\n                }\n                if (comment instanceof spoon.reflect.code.CtJavaDoc) {\n                    if (!((spoon.reflect.code.CtJavaDoc) (comment)).getTags().isEmpty()) {\n                        printer.write(\" *\").writeln().writeTabs();\n                    }\n                    for (spoon.reflect.code.CtJavaDocTag docTag : ((spoon.reflect.code.CtJavaDoc) (comment)).getTags()) {\n                        scan(docTag);\n                    }\n                }\n                break;\n        }\n        switch (comment.getCommentType()) {\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (annotationFieldAccess.getTarget() != null) {\n                scan(annotationFieldAccess.getTarget());\n                printer.write(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            printer.write(\"()\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        boolean isStatic = reference.getSimpleName().equals(\"class\") || ((!reference.getSimpleName().equals(\"super\")) && reference.isStatic());\n        boolean printType = true;\n        if (reference.isFinal() && reference.isStatic()) {\n            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                printType = false;\n            } else if (context.isInCurrentScope(declTypeRef)) {\n                printType = false;\n            }\n        }\n        if ((isStatic && printType) && (!context.ignoreStaticAccess())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            printer.write(\".\");\n        }\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        printer.write(\"for (\");\n        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();\n        if (st.size() > 0) {\n            scan(st.get(0));\n        }\n        if (st.size() > 1) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().noTypeDecl(true)) {\n                for (int i = 1; i < st.size(); i++) {\n                    printer.write(\", \");\n                    scan(st.get(i));\n                }\n            }\n        }\n        printer.write(\"; \");\n        scan(forLoop.getExpression());\n        printer.write(\";\");\n        if (!forLoop.getForUpdate().isEmpty()) {\n            printer.write(\" \");\n        }\n        for (spoon.reflect.code.CtStatement s : forLoop.getForUpdate()) {\n            scan(s);\n            printer.write(\" , \");\n        }\n        if (forLoop.getForUpdate().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        printer.write(\"for (\");\n        scan(foreach.getVariable());\n        printer.write(\" : \");\n        scan(foreach.getExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        printer.write(\"if (\");\n        scan(ifElement.getCondition());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if (ifElement.getElseStatement() != null) {\n            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition() == null) ? ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition() : ifElement.getThenStatement().getPosition();\n                if (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd()) {\n                    elementPrinterHelper.writeComment(comment);\n                }\n            }\n            printer.write(\"else\");\n            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        visitCtType(intrface);\n        printer.write(\"interface \" + intrface.getSimpleName());\n        if (intrface.getFormalCtTypeParameters() != null) {\n            elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (intrface.getSuperInterfaces().size() > 0) {\n            printer.write(\" extends \");\n            for (spoon.reflect.reference.CtTypeReference<?> ref : intrface.getSuperInterfaces()) {\n                scan(ref);\n                printer.write(\" , \");\n            }\n            printer.removeLastChar();\n        }\n        context.pushCurrentThis(intrface);\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType<?> parentType;\n            try {\n                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType = null;\n            }\n            if (((parentType != null) && (parentType.getQualifiedName() != null)) && parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName())) {\n                printer.write(\"this\");\n            } else {\n                printer.snapshotLength();\n                scan(invocation.getTarget());\n                if (printer.hasNewContent()) {\n                    printer.write(\".\");\n                }\n                printer.write(\"super\");\n            }\n        } else {\n            printer.snapshotLength();\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                if (invocation.getTarget() instanceof spoon.reflect.code.CtTypeAccess) {\n                    _context.ignoreGenerics(true);\n                }\n                scan(invocation.getTarget());\n            }\n            if (printer.hasNewContent()) {\n                printer.write(\".\");\n            }\n            elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (env.isPreserveLineNumbers()) {\n                printer.adjustStartPosition(invocation);\n            }\n            printer.write(invocation.getExecutable().getSimpleName());\n        }\n        printer.write(\"(\");\n        boolean remove = false;\n        for (spoon.reflect.code.CtExpression<?> e : invocation.getArguments()) {\n            scan(e);\n            printer.write(\", \");\n            remove = true;\n        }\n        if (remove) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        exitCtExpression(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {\n        enterCtExpression(literal);\n        if (literal.getValue() == null) {\n            printer.write(\"null\");\n        } else if (literal.getValue() instanceof java.lang.Long) {\n            printer.write(literal.getValue() + \"L\");\n        } else if (literal.getValue() instanceof java.lang.Float) {\n            printer.write(literal.getValue() + \"F\");\n        } else if (literal.getValue() instanceof java.lang.Character) {\n            printer.write(\"'\");\n            boolean mayContainsSpecialCharacter = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacter = stringLength != 1;\n            }\n            printer.writeStringLiteral(new java.lang.String(new char[]{ ((java.lang.Character) (literal.getValue())) }), mayContainsSpecialCharacter);\n            printer.write(\"'\");\n        } else if (literal.getValue() instanceof java.lang.String) {\n            printer.write('\\\"');\n            boolean mayContainsSpecialCharacters = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacters = ((java.lang.String) (literal.getValue())).length() != stringLength;\n            }\n            printer.writeStringLiteral(((java.lang.String) (literal.getValue())), mayContainsSpecialCharacters);\n            printer.write('\\\"');\n        } else if (literal.getValue() instanceof java.lang.Class) {\n            printer.write(((java.lang.Class<?>) (literal.getValue())).getName());\n        } else {\n            printer.write(literal.getValue().toString());\n        }\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {\n        if (!context.noTypeDecl()) {\n            enterCtStatement(localVariable);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(localVariable);\n        }\n        if (!context.noTypeDecl()) {\n            elementPrinterHelper.writeModifiers(localVariable);\n            scan(localVariable.getType());\n            printer.write(\" \");\n        }\n        printer.write(localVariable.getSimpleName());\n        if (localVariable.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(localVariable.getDefaultExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(catchVariable);\n        }\n        elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        printer.write(\" \");\n        printer.write(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {\n        elementPrinterHelper.writeComment(m);\n        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(m);\n        if (m.isDefaultMethod()) {\n            printer.write(\"default \");\n        }\n        elementPrinterHelper.writeFormalTypeParameters(m);\n        if (m.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        printer.write(\" \");\n        printer.write(m.getSimpleName());\n        elementPrinterHelper.writeExecutableParameters(m);\n        elementPrinterHelper.writeThrowsClause(m);\n        if (m.getBody() != null) {\n            printer.write(\" \");\n            scan(m.getBody());\n            if (m.getBody().getPosition() != null) {\n                if (m.getBody().getPosition().getCompilationUnit() == sourceCompilationUnit) {\n                    if (m.getBody().getStatements().isEmpty() || (!(m.getBody().getStatements().get(m.getBody().getStatements().size() - 1) instanceof spoon.reflect.code.CtReturn))) {\n                        printer.putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                } else {\n                    printer.undefineLine();\n                }\n            } else {\n                printer.undefineLine();\n            }\n        } else {\n            printer.write(\";\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n        elementPrinterHelper.writeComment(annotationMethod);\n        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        printer.write(\" \");\n        printer.write(annotationMethod.getSimpleName());\n        printer.write(\"()\");\n        if (annotationMethod.getDefaultExpression() != null) {\n            printer.write(\" default \");\n            scan(annotationMethod.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation = (newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class) == null) && (newArray.getParent(spoon.reflect.declaration.CtAnnotation.class) == null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation = true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();\n            if (ref != null) {\n                printer.write(\"new \");\n            }\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                printer.write(\"[\");\n                if (newArray.getDimensionExpressions().size() > i) {\n                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                printer.write(\"]\");\n                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().size() == 0) {\n            printer.write(\"{ \");\n            java.util.List<spoon.reflect.code.CtExpression<?>> l_elements = newArray.getElements();\n            for (int i = 0; i < l_elements.size(); i++) {\n                spoon.reflect.code.CtExpression e = l_elements.get(i);\n                scan(e);\n                printer.write(\" , \");\n                if ((i + 1) == l_elements.size()) {\n                    printer.removeLastChar();\n                    java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n                    if ((!comments.isEmpty()) && (comments.get(comments.size() - 1).getCommentType() == spoon.reflect.code.CtComment.CommentType.INLINE)) {\n                        printer.writeln();\n                    }\n                }\n            }\n            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            printer.write(\" }\");\n        }\n        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n    }\n\n    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (ctConstructorCall.getTarget() != null) {\n                scan(ctConstructorCall.getTarget());\n                printer.write(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            printer.write(\"new \");\n            if (ctConstructorCall.getActualTypeArguments().size() > 0) {\n                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        printer.write(\"(\");\n        for (spoon.reflect.code.CtCodeElement exp : ctConstructorCall.getArguments()) {\n            scan(exp);\n            printer.write(\", \");\n        }\n        if (ctConstructorCall.getArguments().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n    }\n\n    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (reference == null) {\n            return false;\n        }\n        if (reference.getDeclaringType() == null) {\n            return false;\n        }\n        if (reference.isLocalType()) {\n            return false;\n        }\n        if (reference.getDeclaringType().getActualTypeArguments().size() != 0) {\n            return true;\n        }\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {\n        enterCtExpression(lambda);\n        printer.write(\"(\");\n        if (lambda.getParameters().size() > 0) {\n            for (spoon.reflect.declaration.CtParameter<?> parameter : lambda.getParameters()) {\n                scan(parameter);\n                printer.write(\",\");\n            }\n            printer.removeLastChar();\n        }\n        printer.write(\") -> \");\n        if (lambda.getBody() != null) {\n            scan(lambda.getBody());\n        } else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n        enterCtExpression(expression);\n        scan(expression.getTarget());\n        printer.write(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            printer.write(\"new\");\n        } else {\n            printer.write(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        printer.write(\" \");\n        printer.writeOperator(assignment.getKind());\n        printer.write(\"= \");\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!ctPackage.isUnnamedPackage()) {\n            printer.write((\"package \" + ctPackage.getQualifiedName()) + \";\");\n        } else {\n            printer.write(\"// default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)\\n\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {\n        elementPrinterHelper.writeComment(parameter);\n        elementPrinterHelper.writeAnnotations(parameter);\n        elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());\n            printer.write(\"...\");\n        } else {\n            scan(parameter.getType());\n        }\n        printer.write(\" \");\n        printer.write(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {\n        enterCtStatement(returnStatement);\n        printer.write(\"return \");\n        scan(returnStatement.getReturnedExpression());\n    }\n\n    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {\n        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(type, sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            context.currentTopLevel = type;\n        }\n        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {\n        enterCtStatement(switchStatement);\n        printer.write(\"switch (\");\n        scan(switchStatement.getSelector());\n        printer.write(\") {\").incTab();\n        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {\n            printer.writeln().writeTabs();\n            scan(c);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.decTab().write(\"}\");\n        } else {\n            printer.decTab().writeln().writeTabs().write(\"}\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        printer.write(\"synchronized\");\n        if (synchro.getExpression() != null) {\n            printer.write(\"(\");\n            scan(synchro.getExpression());\n            printer.write(\") \");\n        }\n        scan(synchro.getBlock());\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        printer.write(\"throw \");\n        scan(throwStatement.getThrownExpression());\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        printer.write(\"try \");\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if (tryBlock.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryBlock.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        printer.write(\"try \");\n        if ((tryWithResource.getResources() != null) && (!tryWithResource.getResources().isEmpty())) {\n            printer.write(\"(\");\n            for (spoon.reflect.code.CtLocalVariable<?> r : tryWithResource.getResources()) {\n                scan(r);\n                printer.write(\";\");\n            }\n            printer.removeLastChar();\n            printer.write(\") \");\n        }\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if (tryWithResource.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryWithResource.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        if (wildcardReference.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(wildcardReference);\n        if (printQualified(wildcardReference)) {\n            printer.write(wildcardReference.getQualifiedName());\n        } else {\n            printer.write(wildcardReference.getSimpleName());\n        }\n        if (wildcardReference.getBoundingType() != null) {\n            if (wildcardReference.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(wildcardReference.getBoundingType());\n        }\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (importsContext.isImported(ref) || ((this.env.isAutoImports() && (ref.getPackage() != null)) && ref.getPackage().getSimpleName().equals(\"java.lang\"))) {\n            for (spoon.reflect.visitor.TypeContext typeContext : context.currentThis) {\n                if (typeContext.getSimpleName().equals(ref.getSimpleName()) && (!java.util.Objects.equals(typeContext.getPackage(), ref.getPackage()))) {\n                    return true;\n                }\n                if (typeContext.isNameConflict(ref.getSimpleName())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n        for (spoon.reflect.reference.CtTypeReference<?> bound : reference.getBounds()) {\n            scan(bound);\n            printer.write(\" & \");\n        }\n        printer.removeLastChar();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n            return;\n        }\n        boolean isInner = ref.getDeclaringType() != null;\n        if (isInner) {\n            if ((!context.ignoreEnclosingClass()) && (!ref.isLocalType())) {\n                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();\n                if (!accessType.isAnonymous()) {\n                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    printer.write(\".\");\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                printer.write(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(ref.getSimpleName());\n            }\n        } else {\n            if ((ref.getPackage() != null) && printQualified(ref)) {\n                if (!ref.getPackage().isUnnamedPackage()) {\n                    scan(ref.getPackage());\n                    printer.write(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n        }\n        if (withGenerics && (!context.ignoreGenerics())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {\n                elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        printer.preWriteUnaryOperator(operator.getKind());\n        scan(operator.getOperand());\n        printer.postWriteUnaryOperator(operator.getKind());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {\n        enterCtExpression(variableRead);\n        printer.write(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n        enterCtExpression(variableWrite);\n        printer.write(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        printer.write(\"while (\");\n        scan(whileLoop.getLoopingExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n        elementPrinterHelper.writeComment(expression);\n        printer.write(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        elementPrinterHelper.writeComment(statement);\n        printer.write(statement.getValue());\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return context;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String getPackageDeclaration() {\n        return printPackageInfo(context.currentTopLevel.getPackage());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        spoon.reflect.visitor.PrinterHelper bck = printer;\n        spoon.reflect.visitor.ElementPrinterHelper bck2 = elementPrinterHelper;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        elementPrinterHelper.writeComment(pack);\n        for (spoon.reflect.declaration.CtAnnotation<?> a : pack.getAnnotations()) {\n            a.accept(this);\n        }\n        if (!pack.isUnnamedPackage()) {\n            printer.write((\"package \" + pack.getQualifiedName()) + \";\");\n        }\n        java.lang.String ret = printer.toString();\n        elementPrinterHelper = bck2;\n        printer = bck;\n        return ret;\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public void reset() {\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper.setPrinter(printer);\n        context = new spoon.reflect.visitor.PrintingContext();\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {\n        this.sourceCompilationUnit = sourceCompilationUnit;\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n        java.util.Set<spoon.reflect.reference.CtReference> imports = new java.util.HashSet<>();\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            imports.addAll(computeImports(t));\n        }\n        elementPrinterHelper.writeHeader(types, imports);\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            scan(t);\n            if (!env.isPreserveLineNumbers()) {\n                printer.writeln().writeln().writeTabs();\n            } else {\n                printer.adjustEndPosition(t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {\n        return printer.getLineNumberMapping();\n    }\n}",
            "dst_parent_type": "Class",
            "dst_type": "Method",
            "operator": "MOV",
            "src": "@java.lang.Override\npublic void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n    if (ref.isImplicit()) {\n        return;\n    }\n    elementPrinterHelper.writeAnnotations(ref);\n    if (printQualified(ref)) {\n        printer.write(ref.getQualifiedName());\n    } else {\n        printer.write(ref.getSimpleName());\n    }\n    if (ref.getBoundingType() != null) {\n        if (ref.isUpper()) {\n            printer.write(\" extends \");\n        } else {\n            printer.write(\" super \");\n        }\n        scan(ref.getBoundingType());\n    }\n}",
            "src_parent": "public class DefaultJavaPrettyPrinter implements spoon.reflect.visitor.CtVisitor , spoon.reflect.visitor.PrettyPrinter {\n    public static final java.lang.String JAVA_FILE_EXTENSION = \".java\";\n\n    public static final java.lang.String JAVA_PACKAGE_DECLARATION = \"package-info\" + spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVA_FILE_EXTENSION;\n\n    public static final java.lang.String LINE_SEPARATOR = java.lang.System.getProperty(\"line.separator\");\n\n    public static final java.lang.String COMMENT_STAR = \" * \";\n\n    public static final java.lang.String BLOCK_COMMENT_END = \" */\";\n\n    public static final java.lang.String JAVADOC_START = \"/**\";\n\n    public static final java.lang.String INLINE_COMMENT_START = \"// \";\n\n    public static final java.lang.String BLOCK_COMMENT_START = \"/* \";\n\n    public spoon.reflect.visitor.PrintingContext context = new spoon.reflect.visitor.PrintingContext();\n\n    private spoon.reflect.visitor.ImportScanner importsContext;\n\n    private spoon.compiler.Environment env;\n\n    private spoon.reflect.visitor.PrinterHelper printer;\n\n    private spoon.reflect.visitor.ElementPrinterHelper elementPrinterHelper;\n\n    private spoon.reflect.cu.CompilationUnit sourceCompilationUnit;\n\n    public DefaultJavaPrettyPrinter(spoon.compiler.Environment env) {\n        this.env = env;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n    }\n\n    protected void enterCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        }\n        printer.mapLine(e, sourceCompilationUnit);\n        if (shouldSetBracket(e)) {\n            context.parenthesedExpression.push(e);\n            printer.write(\"(\");\n        }\n        if (!e.getTypeCasts().isEmpty()) {\n            for (spoon.reflect.reference.CtTypeReference<?> r : e.getTypeCasts()) {\n                printer.write(\"(\");\n                this.scan(r);\n                printer.write(\") \");\n                printer.write(\"(\");\n                context.parenthesedExpression.push(e);\n            }\n        }\n    }\n\n    protected void enterCtStatement(spoon.reflect.code.CtStatement s) {\n        elementPrinterHelper.writeComment(s, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(s, sourceCompilationUnit);\n        elementPrinterHelper.writeAnnotations(s);\n        if (s.getLabel() != null) {\n            printer.write(s.getLabel()).write(\" : \");\n        }\n    }\n\n    protected void exitCtExpression(spoon.reflect.code.CtExpression<?> e) {\n        while ((context.parenthesedExpression.size() > 0) && (e == context.parenthesedExpression.peek())) {\n            context.parenthesedExpression.pop();\n            printer.write(\")\");\n        } \n        if (!(e instanceof spoon.reflect.code.CtStatement)) {\n            elementPrinterHelper.writeComment(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        }\n    }\n\n    public java.util.Collection<spoon.reflect.reference.CtReference> computeImports(spoon.reflect.declaration.CtType<?> type) {\n        context.currentTopLevel = type;\n        return importsContext.computeAllImports(context.currentTopLevel);\n    }\n\n    public void computeImports(spoon.reflect.declaration.CtElement element) {\n        if (env.isAutoImports()) {\n            importsContext.computeImports(element);\n        }\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.declaration.CtElement e) {\n        if (e != null) {\n            context.elementStack.push(e);\n            if (env.isPreserveLineNumbers()) {\n                if (!(e instanceof spoon.reflect.declaration.CtNamedElement)) {\n                    printer.adjustStartPosition(e);\n                }\n            }\n            e.accept(this);\n            context.elementStack.pop();\n        }\n        return this;\n    }\n\n    public spoon.reflect.visitor.DefaultJavaPrettyPrinter scan(spoon.reflect.reference.CtReference ref) {\n        if (ref != null) {\n            ref.accept(this);\n        }\n        return this;\n    }\n\n    private boolean shouldSetBracket(spoon.reflect.code.CtExpression<?> e) {\n        if (e.getTypeCasts().size() != 0) {\n            return true;\n        }\n        try {\n            if ((e.getParent() instanceof spoon.reflect.code.CtBinaryOperator) || (e.getParent() instanceof spoon.reflect.code.CtUnaryOperator)) {\n                return ((((e instanceof spoon.reflect.code.CtTargetedExpression) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator)) || (e instanceof spoon.reflect.code.CtBinaryOperator);\n            }\n            if (e.getParent() instanceof spoon.reflect.code.CtTargetedExpression) {\n                return (((e instanceof spoon.reflect.code.CtBinaryOperator) || (e instanceof spoon.reflect.code.CtAssignment)) || (e instanceof spoon.reflect.code.CtConditional)) || (e instanceof spoon.reflect.code.CtUnaryOperator);\n            }\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public java.lang.String toString() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotation(spoon.reflect.declaration.CtAnnotation<A> annotation) {\n        elementPrinterHelper.writeAnnotations(annotation);\n        printer.write(\"@\");\n        scan(annotation.getAnnotationType());\n        if (annotation.getValues().size() > 0) {\n            printer.write(\"(\");\n            for (java.util.Map.Entry<java.lang.String, spoon.reflect.code.CtExpression> e : annotation.getValues().entrySet()) {\n                printer.write(e.getKey() + \" = \");\n                elementPrinterHelper.writeAnnotationElement(annotation.getFactory(), e.getValue());\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\")\");\n        }\n        printer.writeln().writeTabs();\n    }\n\n    @java.lang.Override\n    public <A extends java.lang.annotation.Annotation> void visitCtAnnotationType(spoon.reflect.declaration.CtAnnotationType<A> annotationType) {\n        visitCtType(annotationType);\n        printer.write((\"@interface \" + annotationType.getSimpleName()) + \" {\").incTab();\n        elementPrinterHelper.writeElementList(annotationType.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n    }\n\n    @java.lang.Override\n    public void visitCtAnonymousExecutable(spoon.reflect.declaration.CtAnonymousExecutable impl) {\n        elementPrinterHelper.writeComment(impl);\n        elementPrinterHelper.writeAnnotations(impl);\n        elementPrinterHelper.writeModifiers(impl);\n        scan(impl.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayRead(spoon.reflect.code.CtArrayRead<T> arrayRead) {\n        printCtArrayAccess(arrayRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayWrite(spoon.reflect.code.CtArrayWrite<T> arrayWrite) {\n        printCtArrayAccess(arrayWrite);\n    }\n\n    private <T, E extends spoon.reflect.code.CtExpression<?>> void printCtArrayAccess(spoon.reflect.code.CtArrayAccess<T, E> arrayAccess) {\n        enterCtExpression(arrayAccess);\n        scan(arrayAccess.getTarget());\n        printer.write(\"[\");\n        scan(arrayAccess.getIndexExpression());\n        printer.write(\"]\");\n        exitCtExpression(arrayAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtArrayTypeReference(spoon.reflect.reference.CtArrayTypeReference<T> reference) {\n        if (reference.isImplicit()) {\n            return;\n        }\n        scan(reference.getComponentType());\n        if (!context.skipArray()) {\n            printer.write(\"[]\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAssert(spoon.reflect.code.CtAssert<T> asserted) {\n        enterCtStatement(asserted);\n        printer.write(\"assert \");\n        scan(asserted.getAssertExpression());\n        if (asserted.getExpression() != null) {\n            printer.write(\" : \");\n            scan(asserted.getExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtAssignment(spoon.reflect.code.CtAssignment<T, A> assignement) {\n        enterCtStatement(assignement);\n        enterCtExpression(assignement);\n        scan(assignement.getAssigned());\n        printer.write(\" = \");\n        scan(assignement.getAssignment());\n        exitCtExpression(assignement);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtBinaryOperator(spoon.reflect.code.CtBinaryOperator<T> operator) {\n        enterCtExpression(operator);\n        scan(operator.getLeftHandOperand());\n        printer.write(\" \").writeOperator(operator.getKind()).write(\" \");\n        scan(operator.getRightHandOperand());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <R> void visitCtBlock(spoon.reflect.code.CtBlock<R> block) {\n        enterCtStatement(block);\n        if (!block.isImplicit()) {\n            printer.write(\"{\");\n        }\n        printer.incTab();\n        for (spoon.reflect.code.CtStatement statement : block.getStatements()) {\n            if (!statement.isImplicit()) {\n                printer.writeln().writeTabs();\n                elementPrinterHelper.writeStatement(statement);\n            }\n        }\n        printer.decTab();\n        printer.adjustEndPosition(block);\n        if (env.isPreserveLineNumbers()) {\n            if (!block.isImplicit()) {\n                printer.writeTabs().write(\"}\");\n            }\n        } else {\n            printer.writeln().writeTabs();\n            if (!block.isImplicit()) {\n                printer.write(\"}\");\n            }\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtBreak(spoon.reflect.code.CtBreak breakStatement) {\n        enterCtStatement(breakStatement);\n        printer.write(\"break\");\n        if (breakStatement.getTargetLabel() != null) {\n            printer.write(\" \" + breakStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <E> void visitCtCase(spoon.reflect.code.CtCase<E> caseStatement) {\n        enterCtStatement(caseStatement);\n        if (caseStatement.getCaseExpression() != null) {\n            printer.write(\"case \");\n            if (caseStatement.getCaseExpression() instanceof spoon.reflect.code.CtFieldAccess) {\n                final spoon.reflect.reference.CtFieldReference variable = ((spoon.reflect.code.CtFieldAccess) (caseStatement.getCaseExpression())).getVariable();\n                if (((variable.getType() != null) && (variable.getDeclaringType() != null)) && variable.getType().getQualifiedName().equals(variable.getDeclaringType().getQualifiedName())) {\n                    printer.write(variable.getSimpleName());\n                } else {\n                    scan(caseStatement.getCaseExpression());\n                }\n            } else {\n                scan(caseStatement.getCaseExpression());\n            }\n        } else {\n            printer.write(\"default\");\n        }\n        printer.write(\" :\").incTab();\n        for (spoon.reflect.code.CtStatement statement : caseStatement.getStatements()) {\n            printer.writeln().writeTabs();\n            elementPrinterHelper.writeStatement(statement);\n        }\n        printer.decTab();\n    }\n\n    @java.lang.Override\n    public void visitCtCatch(spoon.reflect.code.CtCatch catchBlock) {\n        elementPrinterHelper.writeComment(catchBlock, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.write(\" catch (\");\n        spoon.reflect.code.CtCatchVariable<? extends java.lang.Throwable> parameter = catchBlock.getParameter();\n        if (parameter.getMultiTypes().size() > 0) {\n            for (int i = 0; i < parameter.getMultiTypes().size(); i++) {\n                spoon.reflect.reference.CtTypeReference<?> type = parameter.getMultiTypes().get(i);\n                scan(type);\n                if (i < (parameter.getMultiTypes().size() - 1)) {\n                    printer.write(\" | \");\n                }\n            }\n            printer.write(\" \" + parameter.getSimpleName());\n        } else {\n            scan(parameter);\n        }\n        printer.write(\") \");\n        scan(catchBlock.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtClass(spoon.reflect.declaration.CtClass<T> ctClass) {\n        context.pushCurrentThis(ctClass);\n        if (((ctClass.getSimpleName() != null) && (!spoon.reflect.declaration.CtType.NAME_UNKNOWN.equals(ctClass.getSimpleName()))) && (!ctClass.isAnonymous())) {\n            visitCtType(ctClass);\n            if (ctClass.isLocalType()) {\n                printer.write(\"class \" + ctClass.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(\"class \" + ctClass.getSimpleName());\n            }\n            elementPrinterHelper.writeFormalTypeParameters(ctClass);\n            elementPrinterHelper.writeExtendsClause(ctClass);\n            elementPrinterHelper.writeImplementsClause(ctClass);\n        }\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(ctClass.getTypeMembers());\n        printer.adjustEndPosition(ctClass).decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameter(spoon.reflect.declaration.CtTypeParameter typeParameter) {\n        visitCtTypeParameterReference(typeParameter.getReference());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConditional(spoon.reflect.code.CtConditional<T> conditional) {\n        enterCtExpression(conditional);\n        spoon.reflect.code.CtExpression<java.lang.Boolean> condition = conditional.getCondition();\n        boolean parent;\n        try {\n            parent = (conditional.getParent() instanceof spoon.reflect.code.CtAssignment) || (conditional.getParent() instanceof spoon.reflect.declaration.CtVariable);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException ex) {\n            parent = false;\n        }\n        if (parent) {\n            printer.write(\"(\");\n        }\n        scan(condition);\n        if (parent) {\n            printer.write(\")\");\n        }\n        printer.write(\" ? \");\n        spoon.reflect.code.CtExpression<T> thenExpression = conditional.getThenExpression();\n        scan(thenExpression);\n        printer.write(\" : \");\n        spoon.reflect.code.CtExpression<T> elseExpression = conditional.getElseExpression();\n        boolean isAssign = false;\n        if (isAssign = elseExpression instanceof spoon.reflect.code.CtAssignment) {\n            printer.write(\"(\");\n        }\n        scan(elseExpression);\n        if (isAssign) {\n            printer.write(\")\");\n        }\n        exitCtExpression(conditional);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructor(spoon.reflect.declaration.CtConstructor<T> constructor) {\n        elementPrinterHelper.writeComment(constructor);\n        elementPrinterHelper.visitCtNamedElement(constructor, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(constructor);\n        elementPrinterHelper.writeFormalTypeParameters(constructor);\n        if (constructor.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        if (constructor.getDeclaringType() != null) {\n            if (constructor.getDeclaringType().isLocalType()) {\n                printer.write(constructor.getDeclaringType().getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(constructor.getDeclaringType().getSimpleName());\n            }\n        }\n        elementPrinterHelper.writeExecutableParameters(constructor);\n        elementPrinterHelper.writeThrowsClause(constructor);\n        printer.write(\" \");\n        scan(constructor.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtContinue(spoon.reflect.code.CtContinue continueStatement) {\n        enterCtStatement(continueStatement);\n        printer.write(\"continue\");\n        if (continueStatement.getTargetLabel() != null) {\n            printer.write(\" \" + continueStatement.getTargetLabel());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtDo(spoon.reflect.code.CtDo doLoop) {\n        enterCtStatement(doLoop);\n        printer.write(\"do\");\n        elementPrinterHelper.writeIfOrLoopBlock(doLoop.getBody());\n        printer.write(\"while (\");\n        scan(doLoop.getLoopingExpression());\n        printer.write(\" )\");\n    }\n\n    @java.lang.Override\n    public <T extends java.lang.Enum<?>> void visitCtEnum(spoon.reflect.declaration.CtEnum<T> ctEnum) {\n        visitCtType(ctEnum);\n        printer.write(\"enum \" + ctEnum.getSimpleName());\n        elementPrinterHelper.writeImplementsClause(ctEnum);\n        context.pushCurrentThis(ctEnum);\n        printer.write(\" {\").incTab().writeln();\n        if (ctEnum.getEnumValues().size() == 0) {\n            printer.writeTabs().write(\";\").writeln();\n        } else {\n            for (spoon.reflect.declaration.CtEnumValue<?> enumValue : ctEnum.getEnumValues()) {\n                scan(enumValue);\n                printer.write(\", \");\n            }\n            printer.removeLastChar();\n            printer.write(\";\");\n        }\n        elementPrinterHelper.writeElementList(ctEnum.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtExecutableReference(spoon.reflect.reference.CtExecutableReference<T> reference) {\n        printer.write(reference.getSignature());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtField(spoon.reflect.declaration.CtField<T> f) {\n        elementPrinterHelper.writeComment(f);\n        elementPrinterHelper.visitCtNamedElement(f, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(f);\n        scan(f.getType());\n        printer.write(\" \");\n        printer.write(f.getSimpleName());\n        if (f.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(f.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    public <T> void visitCtEnumValue(spoon.reflect.declaration.CtEnumValue<T> enumValue) {\n        elementPrinterHelper.visitCtNamedElement(enumValue, sourceCompilationUnit);\n        printer.write(enumValue.getSimpleName());\n        if (enumValue.getDefaultExpression() != null) {\n            spoon.reflect.code.CtConstructorCall<?> constructorCall = ((spoon.reflect.code.CtConstructorCall<?>) (enumValue.getDefaultExpression()));\n            if (constructorCall.getArguments().size() > 0) {\n                printer.write(\"(\");\n                boolean first = true;\n                for (spoon.reflect.code.CtExpression<?> ctexpr : constructorCall.getArguments()) {\n                    if (first) {\n                        first = false;\n                    } else {\n                        printer.write(\",\");\n                    }\n                    scan(ctexpr);\n                }\n                printer.write(\")\");\n            }\n            if (constructorCall instanceof spoon.reflect.code.CtNewClass) {\n                scan(((spoon.reflect.code.CtNewClass<?>) (constructorCall)).getAnonymousClass());\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldRead(spoon.reflect.code.CtFieldRead<T> fieldRead) {\n        printCtFieldAccess(fieldRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldWrite(spoon.reflect.code.CtFieldWrite<T> fieldWrite) {\n        printCtFieldAccess(fieldWrite);\n    }\n\n    private <T> void printCtFieldAccess(spoon.reflect.code.CtFieldAccess<T> f) {\n        enterCtExpression(f);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (f.getVariable().isStatic() && (f.getTarget() instanceof spoon.reflect.code.CtTypeAccess)) {\n                _context.ignoreGenerics(true);\n            }\n            spoon.reflect.code.CtExpression<?> target = f.getTarget();\n            if (target != null) {\n                boolean isInitializeStaticFinalField = isInitializeStaticFinalField(f.getTarget());\n                boolean isStaticField = f.getVariable().isStatic();\n                boolean isImportedField = importsContext.isImported(f.getVariable());\n                if ((!isInitializeStaticFinalField) && (!(isStaticField && isImportedField))) {\n                    if (target.isImplicit()) {\n                        final spoon.reflect.declaration.CtField<?> field = f.getVariable().getFieldDeclaration();\n                        final java.lang.String fieldName = field.getSimpleName();\n                        spoon.reflect.declaration.CtVariable<?> var = f.getVariable().map(new spoon.reflect.visitor.filter.PotentialVariableDeclarationFunction(fieldName)).first();\n                        if (var != field) {\n                            target.setImplicit(false);\n                        }\n                    }\n                    printer.snapshotLength();\n                    scan(target);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                }\n                _context.ignoreStaticAccess(true);\n            }\n            scan(f.getVariable());\n        }\n        exitCtExpression(f);\n    }\n\n    private <T> boolean isInitializeStaticFinalField(spoon.reflect.code.CtExpression<T> targetExp) {\n        final spoon.reflect.declaration.CtElement parent;\n        final spoon.reflect.declaration.CtAnonymousExecutable anonymousParent;\n        try {\n            parent = targetExp.getParent();\n            anonymousParent = targetExp.getParent(spoon.reflect.declaration.CtAnonymousExecutable.class);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            return false;\n        }\n        if ((((((parent instanceof spoon.reflect.code.CtFieldWrite) && targetExp.equals(((spoon.reflect.code.CtFieldWrite) (parent)).getTarget())) && (anonymousParent != null)) && (((spoon.reflect.code.CtFieldWrite) (parent)).getVariable() != null)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.STATIC)) && ((spoon.reflect.code.CtFieldWrite) (parent)).getVariable().getModifiers().contains(spoon.reflect.declaration.ModifierKind.FINAL)) {\n            return true;\n        }\n        return false;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtThisAccess(spoon.reflect.code.CtThisAccess<T> thisAccess) {\n        try {\n            enterCtExpression(thisAccess);\n            spoon.reflect.code.CtTypeAccess target = ((spoon.reflect.code.CtTypeAccess) (thisAccess.getTarget()));\n            spoon.reflect.reference.CtTypeReference targetType = target.getAccessedType();\n            if (thisAccess.isImplicit()) {\n                return;\n            }\n            if ((targetType == null) || ((thisAccess.getParent(spoon.reflect.declaration.CtType.class) != null) && thisAccess.getParent(spoon.reflect.declaration.CtType.class).isTopLevel())) {\n                printer.write(\"this\");\n                return;\n            }\n            if (targetType.isAnonymous()) {\n                printer.write(\"this\");\n                return;\n            }\n            if (!context.currentThis.isEmpty()) {\n                spoon.reflect.declaration.CtType lastType = context.currentThis.peekFirst().type;\n                java.lang.String lastTypeQualifiedName = lastType.getQualifiedName();\n                java.lang.String targetTypeQualifiedName = targetType.getQualifiedName();\n                if (!lastTypeQualifiedName.equals(targetTypeQualifiedName)) {\n                    printer.snapshotLength();\n                    visitCtTypeReferenceWithoutGenerics(targetType);\n                    if (printer.hasNewContent()) {\n                        printer.write(\".\");\n                    }\n                    printer.write(\"this\");\n                    return;\n                }\n            }\n            printer.write(\"this\");\n        } finally {\n            exitCtExpression(thisAccess);\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtSuperAccess(spoon.reflect.code.CtSuperAccess<T> f) {\n        enterCtExpression(f);\n        if (f.getTarget() != null) {\n            scan(f.getTarget());\n            printer.write(\".\");\n        }\n        printer.write(\"super\");\n        exitCtExpression(f);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDoc(spoon.reflect.code.CtJavaDoc comment) {\n        visitCtComment(comment);\n    }\n\n    @java.lang.Override\n    public void visitCtJavaDocTag(spoon.reflect.code.CtJavaDocTag docTag) {\n        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n        printer.write(spoon.reflect.code.CtJavaDocTag.JAVADOC_TAG_PREFIX);\n        printer.write(docTag.getType().name().toLowerCase());\n        printer.write(\" \");\n        if (docTag.getType().hasParam()) {\n            printer.write(docTag.getParam()).writeln().writeTabs();\n        }\n        java.lang.String[] tagLines = docTag.getContent().split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n        for (int i = 0; i < tagLines.length; i++) {\n            java.lang.String com = tagLines[i];\n            if ((i > 0) || docTag.getType().hasParam()) {\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR);\n            }\n            if (docTag.getType().hasParam()) {\n                printer.write(\"\\t\\t\");\n            }\n            printer.write(com.trim()).writeln().writeTabs();\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtComment(spoon.reflect.code.CtComment comment) {\n        if ((!env.isCommentsEnabled()) && (context.elementStack.size() > 1)) {\n            return;\n        }\n        switch (comment.getCommentType()) {\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln();\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.JAVADOC_START).writeln().writeTabs();\n                break;\n            case INLINE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.INLINE_COMMENT_START);\n                break;\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_START);\n                break;\n        }\n        java.lang.String content = comment.getContent();\n        switch (comment.getCommentType()) {\n            case INLINE :\n                printer.write(content);\n                break;\n            default :\n                java.lang.String[] lines = content.split(spoon.reflect.visitor.DefaultJavaPrettyPrinter.LINE_SEPARATOR);\n                for (int i = 0; i < lines.length; i++) {\n                    java.lang.String com = lines[i];\n                    if (comment.getCommentType() == spoon.reflect.code.CtComment.CommentType.BLOCK) {\n                        printer.write(com);\n                        if (lines.length > 1) {\n                            printer.writeln().writeTabs();\n                        }\n                    } else if (com.length() > 0) {\n                        printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.COMMENT_STAR + com).writeln().writeTabs();\n                    } else {\n                        printer.write(\" *\" + com).writeln().writeTabs();\n                    }\n                }\n                if (comment instanceof spoon.reflect.code.CtJavaDoc) {\n                    if (!((spoon.reflect.code.CtJavaDoc) (comment)).getTags().isEmpty()) {\n                        printer.write(\" *\").writeln().writeTabs();\n                    }\n                    for (spoon.reflect.code.CtJavaDocTag docTag : ((spoon.reflect.code.CtJavaDoc) (comment)).getTags()) {\n                        scan(docTag);\n                    }\n                }\n                break;\n        }\n        switch (comment.getCommentType()) {\n            case BLOCK :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case FILE :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n            case JAVADOC :\n                printer.write(spoon.reflect.visitor.DefaultJavaPrettyPrinter.BLOCK_COMMENT_END);\n                break;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationFieldAccess(spoon.reflect.code.CtAnnotationFieldAccess<T> annotationFieldAccess) {\n        enterCtExpression(annotationFieldAccess);\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (annotationFieldAccess.getTarget() != null) {\n                scan(annotationFieldAccess.getTarget());\n                printer.write(\".\");\n                _context.ignoreStaticAccess(true);\n            }\n            _context.ignoreGenerics(true);\n            scan(annotationFieldAccess.getVariable());\n            printer.write(\"()\");\n        }\n        exitCtExpression(annotationFieldAccess);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtFieldReference(spoon.reflect.reference.CtFieldReference<T> reference) {\n        boolean isStatic = reference.getSimpleName().equals(\"class\") || ((!reference.getSimpleName().equals(\"super\")) && reference.isStatic());\n        boolean printType = true;\n        if (reference.isFinal() && reference.isStatic()) {\n            spoon.reflect.reference.CtTypeReference<?> declTypeRef = reference.getDeclaringType();\n            if (declTypeRef.isAnonymous()) {\n                printType = false;\n            } else if (context.isInCurrentScope(declTypeRef)) {\n                printType = false;\n            }\n        }\n        if ((isStatic && printType) && (!context.ignoreStaticAccess())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(true)) {\n                scan(reference.getDeclaringType());\n            }\n            printer.write(\".\");\n        }\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public void visitCtFor(spoon.reflect.code.CtFor forLoop) {\n        enterCtStatement(forLoop);\n        printer.write(\"for (\");\n        java.util.List<spoon.reflect.code.CtStatement> st = forLoop.getForInit();\n        if (st.size() > 0) {\n            scan(st.get(0));\n        }\n        if (st.size() > 1) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().noTypeDecl(true)) {\n                for (int i = 1; i < st.size(); i++) {\n                    printer.write(\", \");\n                    scan(st.get(i));\n                }\n            }\n        }\n        printer.write(\"; \");\n        scan(forLoop.getExpression());\n        printer.write(\";\");\n        if (!forLoop.getForUpdate().isEmpty()) {\n            printer.write(\" \");\n        }\n        for (spoon.reflect.code.CtStatement s : forLoop.getForUpdate()) {\n            scan(s);\n            printer.write(\" , \");\n        }\n        if (forLoop.getForUpdate().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(forLoop.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtForEach(spoon.reflect.code.CtForEach foreach) {\n        enterCtStatement(foreach);\n        printer.write(\"for (\");\n        scan(foreach.getVariable());\n        printer.write(\" : \");\n        scan(foreach.getExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(foreach.getBody());\n    }\n\n    @java.lang.Override\n    public void visitCtIf(spoon.reflect.code.CtIf ifElement) {\n        enterCtStatement(ifElement);\n        printer.write(\"if (\");\n        scan(ifElement.getCondition());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(ifElement.getThenStatement());\n        if (ifElement.getElseStatement() != null) {\n            java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(ifElement, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            for (spoon.reflect.code.CtComment comment : comments) {\n                spoon.reflect.cu.SourcePosition thenPosition = (ifElement.getThenStatement().getPosition() == null) ? ((spoon.reflect.code.CtBlock) (ifElement.getThenStatement())).getStatement(0).getPosition() : ifElement.getThenStatement().getPosition();\n                if (comment.getPosition().getSourceStart() > thenPosition.getSourceEnd()) {\n                    elementPrinterHelper.writeComment(comment);\n                }\n            }\n            printer.write(\"else\");\n            elementPrinterHelper.writeIfOrLoopBlock(ifElement.getElseStatement());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInterface(spoon.reflect.declaration.CtInterface<T> intrface) {\n        visitCtType(intrface);\n        printer.write(\"interface \" + intrface.getSimpleName());\n        if (intrface.getFormalCtTypeParameters() != null) {\n            elementPrinterHelper.writeFormalTypeParameters(intrface);\n        }\n        if (intrface.getSuperInterfaces().size() > 0) {\n            printer.write(\" extends \");\n            for (spoon.reflect.reference.CtTypeReference<?> ref : intrface.getSuperInterfaces()) {\n                scan(ref);\n                printer.write(\" , \");\n            }\n            printer.removeLastChar();\n        }\n        context.pushCurrentThis(intrface);\n        printer.write(\" {\").incTab();\n        elementPrinterHelper.writeElementList(intrface.getTypeMembers());\n        printer.decTab().writeTabs().write(\"}\");\n        context.popCurrentThis();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtInvocation(spoon.reflect.code.CtInvocation<T> invocation) {\n        enterCtStatement(invocation);\n        enterCtExpression(invocation);\n        if (invocation.getExecutable().isConstructor()) {\n            elementPrinterHelper.writeActualTypeArguments(invocation.getExecutable());\n            spoon.reflect.declaration.CtType<?> parentType;\n            try {\n                parentType = invocation.getParent(spoon.reflect.declaration.CtType.class);\n            } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n                parentType = null;\n            }\n            if (((parentType != null) && (parentType.getQualifiedName() != null)) && parentType.getQualifiedName().equals(invocation.getExecutable().getDeclaringType().getQualifiedName())) {\n                printer.write(\"this\");\n            } else {\n                printer.snapshotLength();\n                scan(invocation.getTarget());\n                if (printer.hasNewContent()) {\n                    printer.write(\".\");\n                }\n                printer.write(\"super\");\n            }\n        } else {\n            printer.snapshotLength();\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                if (invocation.getTarget() instanceof spoon.reflect.code.CtTypeAccess) {\n                    _context.ignoreGenerics(true);\n                }\n                scan(invocation.getTarget());\n            }\n            if (printer.hasNewContent()) {\n                printer.write(\".\");\n            }\n            elementPrinterHelper.writeActualTypeArguments(invocation);\n            if (env.isPreserveLineNumbers()) {\n                printer.adjustStartPosition(invocation);\n            }\n            printer.write(invocation.getExecutable().getSimpleName());\n        }\n        printer.write(\"(\");\n        boolean remove = false;\n        for (spoon.reflect.code.CtExpression<?> e : invocation.getArguments()) {\n            scan(e);\n            printer.write(\", \");\n            remove = true;\n        }\n        if (remove) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n        exitCtExpression(invocation);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLiteral(spoon.reflect.code.CtLiteral<T> literal) {\n        enterCtExpression(literal);\n        if (literal.getValue() == null) {\n            printer.write(\"null\");\n        } else if (literal.getValue() instanceof java.lang.Long) {\n            printer.write(literal.getValue() + \"L\");\n        } else if (literal.getValue() instanceof java.lang.Float) {\n            printer.write(literal.getValue() + \"F\");\n        } else if (literal.getValue() instanceof java.lang.Character) {\n            printer.write(\"'\");\n            boolean mayContainsSpecialCharacter = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacter = stringLength != 1;\n            }\n            printer.writeStringLiteral(new java.lang.String(new char[]{ ((java.lang.Character) (literal.getValue())) }), mayContainsSpecialCharacter);\n            printer.write(\"'\");\n        } else if (literal.getValue() instanceof java.lang.String) {\n            printer.write('\\\"');\n            boolean mayContainsSpecialCharacters = true;\n            spoon.reflect.cu.SourcePosition position = literal.getPosition();\n            if (position != null) {\n                int stringLength = (position.getSourceEnd() - position.getSourceStart()) - 1;\n                mayContainsSpecialCharacters = ((java.lang.String) (literal.getValue())).length() != stringLength;\n            }\n            printer.writeStringLiteral(((java.lang.String) (literal.getValue())), mayContainsSpecialCharacters);\n            printer.write('\\\"');\n        } else if (literal.getValue() instanceof java.lang.Class) {\n            printer.write(((java.lang.Class<?>) (literal.getValue())).getName());\n        } else {\n            printer.write(literal.getValue().toString());\n        }\n        exitCtExpression(literal);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariable(spoon.reflect.code.CtLocalVariable<T> localVariable) {\n        if (!context.noTypeDecl()) {\n            enterCtStatement(localVariable);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(localVariable);\n        }\n        if (!context.noTypeDecl()) {\n            elementPrinterHelper.writeModifiers(localVariable);\n            scan(localVariable.getType());\n            printer.write(\" \");\n        }\n        printer.write(localVariable.getSimpleName());\n        if (localVariable.getDefaultExpression() != null) {\n            printer.write(\" = \");\n            scan(localVariable.getDefaultExpression());\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLocalVariableReference(spoon.reflect.reference.CtLocalVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariable(spoon.reflect.code.CtCatchVariable<T> catchVariable) {\n        if (env.isPreserveLineNumbers()) {\n            printer.adjustStartPosition(catchVariable);\n        }\n        elementPrinterHelper.writeModifiers(catchVariable);\n        scan(catchVariable.getType());\n        printer.write(\" \");\n        printer.write(catchVariable.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCatchVariableReference(spoon.reflect.reference.CtCatchVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtMethod(spoon.reflect.declaration.CtMethod<T> m) {\n        elementPrinterHelper.writeComment(m);\n        elementPrinterHelper.visitCtNamedElement(m, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(m);\n        if (m.isDefaultMethod()) {\n            printer.write(\"default \");\n        }\n        elementPrinterHelper.writeFormalTypeParameters(m);\n        if (m.getFormalCtTypeParameters().size() > 0) {\n            printer.write(' ');\n        }\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreGenerics(false)) {\n            scan(m.getType());\n        }\n        printer.write(\" \");\n        printer.write(m.getSimpleName());\n        elementPrinterHelper.writeExecutableParameters(m);\n        elementPrinterHelper.writeThrowsClause(m);\n        if (m.getBody() != null) {\n            printer.write(\" \");\n            scan(m.getBody());\n            if (m.getBody().getPosition() != null) {\n                if (m.getBody().getPosition().getCompilationUnit() == sourceCompilationUnit) {\n                    if (m.getBody().getStatements().isEmpty() || (!(m.getBody().getStatements().get(m.getBody().getStatements().size() - 1) instanceof spoon.reflect.code.CtReturn))) {\n                        printer.putLineNumberMapping(m.getBody().getPosition().getEndLine());\n                    }\n                } else {\n                    printer.undefineLine();\n                }\n            } else {\n                printer.undefineLine();\n            }\n        } else {\n            printer.write(\";\");\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtAnnotationMethod(spoon.reflect.declaration.CtAnnotationMethod<T> annotationMethod) {\n        elementPrinterHelper.writeComment(annotationMethod);\n        elementPrinterHelper.visitCtNamedElement(annotationMethod, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(annotationMethod);\n        scan(annotationMethod.getType());\n        printer.write(\" \");\n        printer.write(annotationMethod.getSimpleName());\n        printer.write(\"()\");\n        if (annotationMethod.getDefaultExpression() != null) {\n            printer.write(\" default \");\n            scan(annotationMethod.getDefaultExpression());\n        }\n        printer.write(\";\");\n    }\n\n    @java.lang.Override\n    @java.lang.SuppressWarnings(\"rawtypes\")\n    public <T> void visitCtNewArray(spoon.reflect.code.CtNewArray<T> newArray) {\n        enterCtExpression(newArray);\n        boolean isNotInAnnotation;\n        try {\n            isNotInAnnotation = (newArray.getParent(spoon.reflect.declaration.CtAnnotationType.class) == null) && (newArray.getParent(spoon.reflect.declaration.CtAnnotation.class) == null);\n        } catch (spoon.reflect.declaration.ParentNotInitializedException e) {\n            isNotInAnnotation = true;\n        }\n        if (isNotInAnnotation) {\n            spoon.reflect.reference.CtTypeReference<?> ref = newArray.getType();\n            if (ref != null) {\n                printer.write(\"new \");\n            }\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().skipArray(true)) {\n                scan(ref);\n            }\n            for (int i = 0; ref instanceof spoon.reflect.reference.CtArrayTypeReference; i++) {\n                printer.write(\"[\");\n                if (newArray.getDimensionExpressions().size() > i) {\n                    spoon.reflect.code.CtExpression<java.lang.Integer> e = newArray.getDimensionExpressions().get(i);\n                    scan(e);\n                }\n                printer.write(\"]\");\n                ref = ((spoon.reflect.reference.CtArrayTypeReference) (ref)).getComponentType();\n            }\n        }\n        if (newArray.getDimensionExpressions().size() == 0) {\n            printer.write(\"{ \");\n            java.util.List<spoon.reflect.code.CtExpression<?>> l_elements = newArray.getElements();\n            for (int i = 0; i < l_elements.size(); i++) {\n                spoon.reflect.code.CtExpression e = l_elements.get(i);\n                scan(e);\n                printer.write(\" , \");\n                if ((i + 1) == l_elements.size()) {\n                    printer.removeLastChar();\n                    java.util.List<spoon.reflect.code.CtComment> comments = elementPrinterHelper.getComments(e, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n                    if ((!comments.isEmpty()) && (comments.get(comments.size() - 1).getCommentType() == spoon.reflect.code.CtComment.CommentType.INLINE)) {\n                        printer.writeln();\n                    }\n                }\n            }\n            elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.INSIDE);\n            printer.write(\" }\");\n        }\n        elementPrinterHelper.writeComment(newArray, spoon.reflect.visitor.printer.CommentOffset.AFTER);\n        exitCtExpression(newArray);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        enterCtStatement(ctConstructorCall);\n        enterCtExpression(ctConstructorCall);\n        printConstructorCall(ctConstructorCall);\n        exitCtExpression(ctConstructorCall);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtNewClass(spoon.reflect.code.CtNewClass<T> newClass) {\n        enterCtStatement(newClass);\n        enterCtExpression(newClass);\n        printConstructorCall(newClass);\n        scan(newClass.getAnonymousClass());\n        exitCtExpression(newClass);\n    }\n\n    private <T> void printConstructorCall(spoon.reflect.code.CtConstructorCall<T> ctConstructorCall) {\n        try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n            if (ctConstructorCall.getTarget() != null) {\n                scan(ctConstructorCall.getTarget());\n                printer.write(\".\");\n                _context.ignoreEnclosingClass(true);\n            }\n            if (hasDeclaringTypeWithGenerics(ctConstructorCall.getType())) {\n                _context.ignoreEnclosingClass(true);\n            }\n            printer.write(\"new \");\n            if (ctConstructorCall.getActualTypeArguments().size() > 0) {\n                elementPrinterHelper.writeActualTypeArguments(ctConstructorCall);\n            }\n            scan(ctConstructorCall.getType());\n        }\n        printer.write(\"(\");\n        for (spoon.reflect.code.CtCodeElement exp : ctConstructorCall.getArguments()) {\n            scan(exp);\n            printer.write(\", \");\n        }\n        if (ctConstructorCall.getArguments().size() > 0) {\n            printer.removeLastChar();\n        }\n        printer.write(\")\");\n    }\n\n    private <T> boolean hasDeclaringTypeWithGenerics(spoon.reflect.reference.CtTypeReference<T> reference) {\n        if (reference == null) {\n            return false;\n        }\n        if (reference.getDeclaringType() == null) {\n            return false;\n        }\n        if (reference.isLocalType()) {\n            return false;\n        }\n        if (reference.getDeclaringType().getActualTypeArguments().size() != 0) {\n            return true;\n        }\n        return hasDeclaringTypeWithGenerics(reference.getDeclaringType());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtLambda(spoon.reflect.code.CtLambda<T> lambda) {\n        enterCtExpression(lambda);\n        printer.write(\"(\");\n        if (lambda.getParameters().size() > 0) {\n            for (spoon.reflect.declaration.CtParameter<?> parameter : lambda.getParameters()) {\n                scan(parameter);\n                printer.write(\",\");\n            }\n            printer.removeLastChar();\n        }\n        printer.write(\") -> \");\n        if (lambda.getBody() != null) {\n            scan(lambda.getBody());\n        } else {\n            scan(lambda.getExpression());\n        }\n        exitCtExpression(lambda);\n    }\n\n    @java.lang.Override\n    public <T, E extends spoon.reflect.code.CtExpression<?>> void visitCtExecutableReferenceExpression(spoon.reflect.code.CtExecutableReferenceExpression<T, E> expression) {\n        enterCtExpression(expression);\n        scan(expression.getTarget());\n        printer.write(\"::\");\n        if (expression.getExecutable().isConstructor()) {\n            printer.write(\"new\");\n        } else {\n            printer.write(expression.getExecutable().getSimpleName());\n        }\n        exitCtExpression(expression);\n    }\n\n    @java.lang.Override\n    public <T, A extends T> void visitCtOperatorAssignment(spoon.reflect.code.CtOperatorAssignment<T, A> assignment) {\n        enterCtStatement(assignment);\n        enterCtExpression(assignment);\n        scan(assignment.getAssigned());\n        printer.write(\" \");\n        printer.writeOperator(assignment.getKind());\n        printer.write(\"= \");\n        scan(assignment.getAssignment());\n        exitCtExpression(assignment);\n    }\n\n    @java.lang.Override\n    public void visitCtPackage(spoon.reflect.declaration.CtPackage ctPackage) {\n        if (!ctPackage.isUnnamedPackage()) {\n            printer.write((\"package \" + ctPackage.getQualifiedName()) + \";\");\n        } else {\n            printer.write(\"// default package (CtPackage.TOP_LEVEL_PACKAGE_NAME in Spoon= unnamed package)\\n\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtPackageReference(spoon.reflect.reference.CtPackageReference reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameter(spoon.reflect.declaration.CtParameter<T> parameter) {\n        elementPrinterHelper.writeComment(parameter);\n        elementPrinterHelper.writeAnnotations(parameter);\n        elementPrinterHelper.writeModifiers(parameter);\n        if (parameter.isVarArgs()) {\n            scan(((spoon.reflect.reference.CtArrayTypeReference<T>) (parameter.getType())).getComponentType());\n            printer.write(\"...\");\n        } else {\n            scan(parameter.getType());\n        }\n        printer.write(\" \");\n        printer.write(parameter.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtParameterReference(spoon.reflect.reference.CtParameterReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public <R> void visitCtReturn(spoon.reflect.code.CtReturn<R> returnStatement) {\n        enterCtStatement(returnStatement);\n        printer.write(\"return \");\n        scan(returnStatement.getReturnedExpression());\n    }\n\n    private <T> void visitCtType(spoon.reflect.declaration.CtType<T> type) {\n        elementPrinterHelper.writeComment(type, spoon.reflect.visitor.printer.CommentOffset.BEFORE);\n        printer.mapLine(type, sourceCompilationUnit);\n        if (type.isTopLevel()) {\n            context.currentTopLevel = type;\n        }\n        elementPrinterHelper.visitCtNamedElement(type, sourceCompilationUnit);\n        elementPrinterHelper.writeModifiers(type);\n    }\n\n    @java.lang.Override\n    public void visitCtStatementList(spoon.reflect.code.CtStatementList statements) {\n        for (spoon.reflect.code.CtStatement s : statements.getStatements()) {\n            scan(s);\n        }\n    }\n\n    @java.lang.Override\n    public <E> void visitCtSwitch(spoon.reflect.code.CtSwitch<E> switchStatement) {\n        enterCtStatement(switchStatement);\n        printer.write(\"switch (\");\n        scan(switchStatement.getSelector());\n        printer.write(\") {\").incTab();\n        for (spoon.reflect.code.CtCase<?> c : switchStatement.getCases()) {\n            printer.writeln().writeTabs();\n            scan(c);\n        }\n        if (env.isPreserveLineNumbers()) {\n            printer.decTab().write(\"}\");\n        } else {\n            printer.decTab().writeln().writeTabs().write(\"}\");\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtSynchronized(spoon.reflect.code.CtSynchronized synchro) {\n        enterCtStatement(synchro);\n        printer.write(\"synchronized\");\n        if (synchro.getExpression() != null) {\n            printer.write(\"(\");\n            scan(synchro.getExpression());\n            printer.write(\") \");\n        }\n        scan(synchro.getBlock());\n    }\n\n    @java.lang.Override\n    public void visitCtThrow(spoon.reflect.code.CtThrow throwStatement) {\n        enterCtStatement(throwStatement);\n        printer.write(\"throw \");\n        scan(throwStatement.getThrownExpression());\n    }\n\n    @java.lang.Override\n    public void visitCtTry(spoon.reflect.code.CtTry tryBlock) {\n        enterCtStatement(tryBlock);\n        printer.write(\"try \");\n        scan(tryBlock.getBody());\n        for (spoon.reflect.code.CtCatch c : tryBlock.getCatchers()) {\n            scan(c);\n        }\n        if (tryBlock.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryBlock.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTryWithResource(spoon.reflect.code.CtTryWithResource tryWithResource) {\n        enterCtStatement(tryWithResource);\n        printer.write(\"try \");\n        if ((tryWithResource.getResources() != null) && (!tryWithResource.getResources().isEmpty())) {\n            printer.write(\"(\");\n            for (spoon.reflect.code.CtLocalVariable<?> r : tryWithResource.getResources()) {\n                scan(r);\n                printer.write(\";\");\n            }\n            printer.removeLastChar();\n            printer.write(\") \");\n        }\n        scan(tryWithResource.getBody());\n        for (spoon.reflect.code.CtCatch c : tryWithResource.getCatchers()) {\n            scan(c);\n        }\n        if (tryWithResource.getFinalizer() != null) {\n            printer.write(\" finally \");\n            scan(tryWithResource.getFinalizer());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtTypeParameterReference(spoon.reflect.reference.CtTypeParameterReference ref) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        elementPrinterHelper.writeAnnotations(ref);\n        if (printQualified(ref)) {\n            printer.write(ref.getQualifiedName());\n        } else {\n            printer.write(ref.getSimpleName());\n        }\n        if (ref.getBoundingType() != null) {\n            if (ref.isUpper()) {\n                printer.write(\" extends \");\n            } else {\n                printer.write(\" super \");\n            }\n            scan(ref.getBoundingType());\n        }\n    }\n\n    @java.lang.Override\n    public void visitCtWildcardReference(spoon.reflect.reference.CtWildcardReference wildcardReference) {\n        visitCtTypeParameterReference(wildcardReference);\n    }\n\n    private boolean printQualified(spoon.reflect.reference.CtTypeReference<?> ref) {\n        if (importsContext.isImported(ref) || ((this.env.isAutoImports() && (ref.getPackage() != null)) && ref.getPackage().getSimpleName().equals(\"java.lang\"))) {\n            for (spoon.reflect.visitor.TypeContext typeContext : context.currentThis) {\n                if (typeContext.getSimpleName().equals(ref.getSimpleName()) && (!java.util.Objects.equals(typeContext.getPackage(), ref.getPackage()))) {\n                    return true;\n                }\n                if (typeContext.isNameConflict(ref.getSimpleName())) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtIntersectionTypeReference(spoon.reflect.reference.CtIntersectionTypeReference<T> reference) {\n        for (spoon.reflect.reference.CtTypeReference<?> bound : reference.getBounds()) {\n            scan(bound);\n            printer.write(\" & \");\n        }\n        printer.removeLastChar();\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<T> ref) {\n        visitCtTypeReference(ref, true);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtTypeAccess(spoon.reflect.code.CtTypeAccess<T> typeAccess) {\n        if (typeAccess.isImplicit()) {\n            return;\n        }\n        enterCtExpression(typeAccess);\n        scan(typeAccess.getAccessedType());\n        exitCtExpression(typeAccess);\n    }\n\n    private void visitCtTypeReferenceWithoutGenerics(spoon.reflect.reference.CtTypeReference<?> ref) {\n        visitCtTypeReference(ref, false);\n    }\n\n    private void visitCtTypeReference(spoon.reflect.reference.CtTypeReference<?> ref, boolean withGenerics) {\n        if (ref.isImplicit()) {\n            return;\n        }\n        if (ref.isPrimitive()) {\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n            return;\n        }\n        boolean isInner = ref.getDeclaringType() != null;\n        if (isInner) {\n            if ((!context.ignoreEnclosingClass()) && (!ref.isLocalType())) {\n                spoon.reflect.reference.CtTypeReference<?> accessType = ref.getAccessType();\n                if (!accessType.isAnonymous()) {\n                    try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify()) {\n                        if (!withGenerics) {\n                            _context.ignoreGenerics(true);\n                        }\n                        scan(accessType);\n                    }\n                    printer.write(\".\");\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            if (ref.isLocalType()) {\n                printer.write(ref.getSimpleName().replaceAll(\"^[0-9]*\", \"\"));\n            } else {\n                printer.write(ref.getSimpleName());\n            }\n        } else {\n            if ((ref.getPackage() != null) && printQualified(ref)) {\n                if (!ref.getPackage().isUnnamedPackage()) {\n                    scan(ref.getPackage());\n                    printer.write(spoon.reflect.declaration.CtPackage.PACKAGE_SEPARATOR);\n                }\n            }\n            elementPrinterHelper.writeAnnotations(ref);\n            printer.write(ref.getSimpleName());\n        }\n        if (withGenerics && (!context.ignoreGenerics())) {\n            try (final spoon.reflect.visitor.PrintingContext.Writable _context = context.modify().ignoreEnclosingClass(false)) {\n                elementPrinterHelper.writeActualTypeArguments(ref);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnaryOperator(spoon.reflect.code.CtUnaryOperator<T> operator) {\n        enterCtStatement(operator);\n        enterCtExpression(operator);\n        printer.preWriteUnaryOperator(operator.getKind());\n        scan(operator.getOperand());\n        printer.postWriteUnaryOperator(operator.getKind());\n        exitCtExpression(operator);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableRead(spoon.reflect.code.CtVariableRead<T> variableRead) {\n        enterCtExpression(variableRead);\n        printer.write(variableRead.getVariable().getSimpleName());\n        exitCtExpression(variableRead);\n    }\n\n    @java.lang.Override\n    public <T> void visitCtVariableWrite(spoon.reflect.code.CtVariableWrite<T> variableWrite) {\n        enterCtExpression(variableWrite);\n        printer.write(variableWrite.getVariable().getSimpleName());\n        exitCtExpression(variableWrite);\n    }\n\n    public void visitCtWhile(spoon.reflect.code.CtWhile whileLoop) {\n        enterCtStatement(whileLoop);\n        printer.write(\"while (\");\n        scan(whileLoop.getLoopingExpression());\n        printer.write(\")\");\n        elementPrinterHelper.writeIfOrLoopBlock(whileLoop.getBody());\n    }\n\n    @java.lang.Override\n    public <T> void visitCtCodeSnippetExpression(spoon.reflect.code.CtCodeSnippetExpression<T> expression) {\n        elementPrinterHelper.writeComment(expression);\n        printer.write(expression.getValue());\n    }\n\n    @java.lang.Override\n    public void visitCtCodeSnippetStatement(spoon.reflect.code.CtCodeSnippetStatement statement) {\n        elementPrinterHelper.writeComment(statement);\n        printer.write(statement.getValue());\n    }\n\n    public spoon.reflect.visitor.ElementPrinterHelper getElementPrinterHelper() {\n        return elementPrinterHelper;\n    }\n\n    public spoon.reflect.visitor.PrintingContext getContext() {\n        return context;\n    }\n\n    @java.lang.Override\n    public <T> void visitCtUnboundVariableReference(spoon.reflect.reference.CtUnboundVariableReference<T> reference) {\n        printer.write(reference.getSimpleName());\n    }\n\n    @java.lang.Override\n    public java.lang.String getPackageDeclaration() {\n        return printPackageInfo(context.currentTopLevel.getPackage());\n    }\n\n    @java.lang.Override\n    public java.lang.String printPackageInfo(spoon.reflect.declaration.CtPackage pack) {\n        spoon.reflect.visitor.PrinterHelper bck = printer;\n        spoon.reflect.visitor.ElementPrinterHelper bck2 = elementPrinterHelper;\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper = new spoon.reflect.visitor.ElementPrinterHelper(printer, this, env);\n        elementPrinterHelper.writeComment(pack);\n        for (spoon.reflect.declaration.CtAnnotation<?> a : pack.getAnnotations()) {\n            a.accept(this);\n        }\n        if (!pack.isUnnamedPackage()) {\n            printer.write((\"package \" + pack.getQualifiedName()) + \";\");\n        }\n        java.lang.String ret = printer.toString();\n        elementPrinterHelper = bck2;\n        printer = bck;\n        return ret;\n    }\n\n    @java.lang.Override\n    public java.lang.String getResult() {\n        return printer.toString();\n    }\n\n    @java.lang.Override\n    public void reset() {\n        printer = new spoon.reflect.visitor.PrinterHelper(env);\n        elementPrinterHelper.setPrinter(printer);\n        context = new spoon.reflect.visitor.PrintingContext();\n    }\n\n    @java.lang.Override\n    public void calculate(spoon.reflect.cu.CompilationUnit sourceCompilationUnit, java.util.List<spoon.reflect.declaration.CtType<?>> types) {\n        this.sourceCompilationUnit = sourceCompilationUnit;\n        if (env.isAutoImports()) {\n            this.importsContext = new spoon.reflect.visitor.ImportScannerImpl();\n        } else {\n            this.importsContext = new spoon.reflect.visitor.MinimalImportScanner();\n        }\n        java.util.Set<spoon.reflect.reference.CtReference> imports = new java.util.HashSet<>();\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            imports.addAll(computeImports(t));\n        }\n        elementPrinterHelper.writeHeader(types, imports);\n        for (spoon.reflect.declaration.CtType<?> t : types) {\n            scan(t);\n            if (!env.isPreserveLineNumbers()) {\n                printer.writeln().writeln().writeTabs();\n            } else {\n                printer.adjustEndPosition(t);\n            }\n        }\n    }\n\n    @java.lang.Override\n    public java.util.Map<java.lang.Integer, java.lang.Integer> getLineNumberMapping() {\n        return printer.getLineNumberMapping();\n    }\n}",
            "src_parent_type": "Class",
            "src_type": "Method"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "true",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "typeParameter.getReference()",
            "dst_parent": "spoon.reflect.reference.CtTypeParameterReference ref = typeParameter.getReference()",
            "dst_parent_type": "LocalVariable",
            "dst_type": "Invocation",
            "operator": "MOV",
            "src": "typeParameter.getReference()",
            "src_parent": "visitCtTypeParameterReference(typeParameter.getReference())",
            "src_parent_type": "Invocation",
            "src_type": "Invocation"
          }
        },
        {
          "FEATURES_METHOD_INVOCATION": {},
          "FEATURES_TYPEACCESS": {},
          "FEATURES_VARS": {},
          "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
          "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
          "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
          "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
          "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Method",
          "S15_HAS_OBJECTIVE_METHOD_CALL": "false",
          "S16_HAS_Invocations_Prone_Exception": "false",
          "S18_In_Synchronized_Method": "false",
          "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
          "S1_LOCAL_VAR_NOT_USED": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
          "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
          "S3_TYPE_OF_FAULTY_STATEMENT": "Invocation",
          "S4_Field_NOT_ASSIGNED": "false",
          "S4_Field_NOT_USED": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
          "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
          "S6_METHOD_THROWS_EXCEPTION": "false",
          "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
          "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
          "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
          "ast_info": {
            "dst": "wildcardReference",
            "dst_parent": "wildcardReference.getQualifiedName()",
            "dst_parent_type": "Invocation",
            "dst_type": "VariableRead",
            "operator": "MOV",
            "src": "wildcardReference",
            "src_parent": "visitCtTypeParameterReference(wildcardReference)",
            "src_parent_type": "Invocation",
            "src_type": "VariableRead"
          }
        }
      ],
      "file_name": "DefaultJavaPrettyPrinter"
    }
  ],
  "id": "bears_59"
}